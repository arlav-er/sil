set define off
set pagesize 0
set linesize 10000
set sqlblanklines on




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_ACCESSO.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_ACCESSO IS

procedure REGISTRA_ACCESSO (JSESSIONID in TS_ACCESSO_UTENTE.STRJSESSIONID%type, pCDNUTENTE in TS_ACCESSO_UTENTE.CDNUTENTE%TYPE,IP in TS_ACCESSO_UTENTE.STRIP%type,STRSISTEMAOP in TS_ACCESSO_UTENTE.STRSISTEMAOP%type,BROWSER in TS_ACCESSO_UTENTE.STRBROWSER%type,HOSTNAME in TS_ACCESSO_UTENTE.STRHOSTNAME%type);

PROCEDURE DEREGISTRA_ACCESSO (JSESSIONID in TS_ACCESSO_UTENTE.STRJSESSIONID%type);

function maxMinutiConnesso ( pHostName in varchar2) return number;

function generaHtmlMinutiNorm ( currentTimestamp in date,pMaxMinutiConnessi in number ) return varchar2;

procedure clearTableAccessoUtente( pHOSTNAME in varchar2 );

procedure REGISTRA_ACCESSO_CONVENZIONATO (p_CDNUTENTE in TS_ACCESSO_CONVENZIONATO.CDNUTENTE%TYPE, p_STRNUMEROPRATICA in TS_ACCESSO_CONVENZIONATO.STRNUMEROPRATICA%type);

function SET_NUMTENTATIVI_ACCESSO (p_CDNUTENTE in ts_utente.cdnut%TYPE) return varchar2;

END PG_ACCESSO;
/
CREATE OR REPLACE PACKAGE BODY PG_ACCESSO IS

procedure REGISTRA_ACCESSO (JSESSIONID in TS_ACCESSO_UTENTE.STRJSESSIONID%type, pCDNUTENTE in TS_ACCESSO_UTENTE.CDNUTENTE%TYPE,IP in TS_ACCESSO_UTENTE.STRIP%type,STRSISTEMAOP in TS_ACCESSO_UTENTE.STRSISTEMAOP%type,BROWSER in TS_ACCESSO_UTENTE.STRBROWSER%type,HOSTNAME in TS_ACCESSO_UTENTE.STRHOSTNAME%type) IS
begin
    INSERT INTO TS_ACCESSO_UTENTE
               ( TS_ACCESSO_UTENTE.STRJSESSIONID, TS_ACCESSO_UTENTE.CDNUTENTE, TS_ACCESSO_UTENTE.STRIP, TS_ACCESSO_UTENTE.STRSISTEMAOP, TS_ACCESSO_UTENTE.STRBROWSER, TS_ACCESSO_UTENTE.DTMINIZIOSESSIONE, TS_ACCESSO_UTENTE.STRHOSTNAME )
              VALUES
              ( JSESSIONID, pCDNUTENTE, IP, STRSISTEMAOP, BROWSER, SYSDATE, HOSTNAME );
    exception
         when DUP_VAL_ON_INDEX then
             UPDATE TS_ACCESSO_UTENTE SET TS_ACCESSO_UTENTE.DTMINIZIOSESSIONE  = SYSDATE, CDNUTENTE = pCDNUTENTE WHERE TS_ACCESSO_UTENTE.STRJSESSIONID = JSESSIONID;
end;

PROCEDURE DEREGISTRA_ACCESSO (JSESSIONID in TS_ACCESSO_UTENTE.STRJSESSIONID%type) IS

p_cdnutente TS_ACCESSO_UTENTE.Cdnutente%type;

BEGIN
   BEGIN         
     select au.cdnutente 
     into p_cdnutente
     from TS_ACCESSO_UTENTE au
     WHERE au.STRJSESSIONID = JSESSIONID;

     UPDATE TS_ACCESSO_UTENTE SET TS_ACCESSO_UTENTE.DTMFINESESSIONE  = SYSDATE WHERE TS_ACCESSO_UTENTE.STRJSESSIONID = JSESSIONID;
   
     update ts_utente set FLGLOGGED = 'N' where CDNUT = p_cdnutente;
   EXCEPTION
        when NO_DATA_FOUND then 
        null;
   END;
END;


function maxMinutiConnesso ( pHostName in varchar2) return number is
    maxMinutiConnessi number;

begin

    select (sysdate - min(dtminiziosessione))*24*60
         into maxMinutiConnessi
    from TS_ACCESSO_UTENTE
    where dtmfinesessione is null
        and strhostname=pHostName;

    return maxMinutiConnessi;

end;



function generaHtmlMinutiNorm ( currentTimestamp in date,pMaxMinutiConnessi in number  ) return varchar2 is
     minuti number;
     minutiNormalizzati number;
begin

    minuti:=(sysdate - currentTimestamp)*24*60;
    minutiNormalizzati:= ceil(minuti/ pMaxMinutiConnessi * 100 );

    return '<img src="../../img/pix_rosso.gif" height="5" width="'  || minutiNormalizzati  || '"> ' ||  round(minuti) || ' min.';

end;

procedure clearTableAccessoUtente( pHOSTNAME in varchar2 ) is

begin
    delete from TS_ACCESSO_UTENTE
         where STRHOSTNAME = pHOSTNAME and DTMFINESESSIONE is null;
end;


procedure REGISTRA_ACCESSO_CONVENZIONATO (p_CDNUTENTE in TS_ACCESSO_CONVENZIONATO.CDNUTENTE%TYPE, p_STRNUMEROPRATICA in TS_ACCESSO_CONVENZIONATO.STRNUMEROPRATICA%type) IS
begin
    INSERT INTO TS_ACCESSO_CONVENZIONATO
                  (PRGACCESSOCONV,
                 CDNUTENTE,
                 DTMACCESSO,
                 STRNUMEROPRATICA)
                VALUES
                (S_TS_ACCESSO_CONVENZIONATO.Nextval, 
                p_CDNUTENTE,
                sysdate,
                p_STRNUMEROPRATICA);  
                
    update ts_utente 
    set flglogged = 'S'
    where cdnut = p_CDNUTENTE;
                
end;

function SET_NUMTENTATIVI_ACCESSO (p_CDNUTENTE in ts_utente.cdnut%TYPE)  return varchar2 IS

queryWhere varchar2(255);
checkUtente varchar2(255);

p_numsecondiwait ts_generale.numsecondiwait%type;
p_nummaxtentativi ts_generale.nummaxtentativi%type;
p_datultimoaccesso ts_utente.datultimoaccesso%type;
p_numtentativi ts_utente.numtentativi%type;
p_tentativiRimasti number;
p_secondi number;
p_flglogged ts_utente.flglogged%type;
p_flgutconvenzione ts_utente.flgutconvenzione%type;

begin
   checkUtente := '';
   select g.numsecondiwait, g.nummaxtentativi
   into p_numsecondiwait, p_nummaxtentativi
   from ts_generale g;
   
   select t.datultimoaccesso, nvl(t.numtentativi,0), t.flglogged, t.flgutconvenzione
   into p_datultimoaccesso, p_numtentativi, p_flglogged, p_flgutconvenzione
   from ts_utente t
   where t.cdnut = p_CDNUTENTE;
   
   if (p_flgutconvenzione = 'S') then 
     if (p_flglogged = 'S') then
         checkUtente := 'Accesso già eseguito da un altro browser';
     elsif (p_numTentativi = p_nummaxtentativi) then       
         select (sysdate - p_datultimoaccesso)*24*60*60 into p_secondi from dual;
         if (p_secondi < p_numsecondiwait) then
            checkUtente := 'Hai superato il numero massimo di tentativi. Il tuo account è bloccato per i prossimi '|| ROUND(p_numsecondiwait-p_secondi)||' secondi';
         else 
            queryWhere :=  ' WHERE CDNUT = ' || p_CDNUTENTE;

            PG_LOG.doLog('U', 'TS_UTENTE', p_CDNUTENTE, queryWhere);

            update ts_utente 
            set numtentativi = 0,
            DATULTIMOACCESSO = sysdate            
            where CDNUT = p_CDNUTENTE;   
         
            p_tentativiRimasti := p_nummaxtentativi - 1;
            checkUtente :=  '' || p_tentativiRimasti || ' tentativi a disposizione';
         end if;                                                      
     elsif (p_numTentativi < p_nummaxtentativi) then
         queryWhere :=  ' WHERE CDNUT = ' || p_CDNUTENTE;

         PG_LOG.doLog('U', 'TS_UTENTE', p_CDNUTENTE, queryWhere);

         update ts_utente 
         set numtentativi = p_numTentativi+1,
         DATULTIMOACCESSO = sysdate         
         where CDNUT = p_CDNUTENTE;
         
         p_tentativiRimasti := p_nummaxtentativi - (p_numTentativi+1);
         if (p_tentativiRimasti = 1) then 
             checkUtente := 'Ultimo tentativo a disposizione';
         elsif (p_tentativiRimasti = 0) then 
             checkUtente := 'Hai superato il numero massimo di tentativi. Il tuo account è bloccato per i prossimi '||p_numsecondiwait||' secondi';
         else 
             checkUtente :=  '' || p_tentativiRimasti || ' tentativi a disposizione';
         end if;         
     end if;
   else 
     if (p_numTentativi = p_nummaxtentativi) then       
         select (sysdate - p_datultimoaccesso)*24*60*60 into p_secondi from dual;
         if (p_secondi < p_numsecondiwait) then
            checkUtente := 'Hai superato il numero massimo di tentativi. Il tuo account è bloccato per i prossimi '|| ROUND(p_numsecondiwait-p_secondi)||' secondi';
         else 
            queryWhere :=  ' WHERE CDNUT = ' || p_CDNUTENTE;

            PG_LOG.doLog('U', 'TS_UTENTE', p_CDNUTENTE, queryWhere);

            update ts_utente 
            set numtentativi = 0,
            DATULTIMOACCESSO = sysdate            
            where CDNUT = p_CDNUTENTE;   
         
            p_tentativiRimasti := p_nummaxtentativi - 1;
            checkUtente :=  '' || p_tentativiRimasti || ' tentativi a disposizione';
         end if;                                                      
     elsif (p_numTentativi < p_nummaxtentativi) then
         queryWhere :=  ' WHERE CDNUT = ' || p_CDNUTENTE;

         PG_LOG.doLog('U', 'TS_UTENTE', p_CDNUTENTE, queryWhere);

         update ts_utente 
         set numtentativi = p_numTentativi+1,
         DATULTIMOACCESSO = sysdate         
         where CDNUT = p_CDNUTENTE;
         
         p_tentativiRimasti := p_nummaxtentativi - (p_numTentativi+1);
         if (p_tentativiRimasti = 1) then 
             checkUtente := 'Ultimo tentativo a disposizione';
         elsif (p_tentativiRimasti = 0) then 
             checkUtente := 'Hai superato il numero massimo di tentativi. Il tuo account è bloccato per i prossimi '||p_numsecondiwait||' secondi';
         else 
             checkUtente :=  '' || p_tentativiRimasti || ' tentativi a disposizione';
         end if;         
     end if;  
   end if;  
   return checkUtente;
                   
end;


END PG_ACCESSO;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_ACCORPA_LAVORATORE.sql
************************************************************************************** */


create or replace package PG_ACCORPA_LAVORATORE is

  -- Author  : GIULIANI DAVIDE
  -- Created : 23/06/2005 16.10.33
  -- Purpose :

    FUNCTION accorpaLavoratore ( PlavDaAccorpare varchar2,
                                 PlavInCuiAccorpare varchar2,
                                 PutenteMod varchar2,
                                 encrypterKey varchar2
                                ) RETURN VARCHAR2;

    FUNCTION Accorpamentogestionerose( lavDaAccorpare    AN_LAVORATORE.CDNLAVORATORE%TYPE,
                                       lavInCuiAccorpare AN_LAVORATORE.CDNLAVORATORE%TYPE,
                                     cdnUtMod TS_UTENTE.CDNUT%TYPE
                                     ) RETURN number;
     FUNCTION accorpa_iscrizione (
      plav             VARCHAR2,
      inprgaltraiscr   or_colloquio.prgaltraiscr%TYPE,                           --L'iscrizione che ERA dell'accorpato
      prgaltraiscrto   or_colloquio.prgaltraiscr%TYPE,                   --L'iscrizione corrispondente dell'accorpante
      putentemod       VARCHAR2
   )
      RETURN NUMBER;

/* Abilita le stampe DBMS_OUTPUT */
isdebug BOOLEAN := false;

end PG_ACCORPA_LAVORATORE;
 
/
CREATE OR REPLACE PACKAGE BODY PG_ACCORPA_LAVORATORE
IS
   /******************************************************************************
   18/06/2014 MAURO
     modifiche per gestione SAP
     Esce con -6
     La tabella è SP_LAVORATORE
   *******************************************************************************/
   
   /******************************************************************************
   10/06/2010 ALESSANDRO PEGORARO
     modifiche per gestione accorpamento CIG
     le tabelle relative alle cig vengono accorpate prima delle altre
     se fallisce, esce con -3
     -CI_CORSO
     -CI_CORSO_CATALOGO
     -CI_CORSO_ORIENTER
     -OR_COLLOQUIO
     -OR_PERCORSO_CONCORDATO
     -AM_ALTRA_ISCR
   *******************************************************************************/

   /******************************************************************************
   08/02/2008 MAURO
     modifiche per nuovi MODULI COLLOCAMENTO MIRATO
     - AM_CM_ISCR_STORICO

   * Per le modifiche inerenti alle Rose e Graduatorie:
   * - CM_CANC_GRAD

   *******************************************************************************/

   /******************************************************************************
   21/03/2007 MAURO
     modifiche per nuovi MODULI COLLOCAMENTO MIRATO
     - CM_RICH_COMPUTO
     - CM_LAV_CARICO
     - CM_LAV_REDDITO
     - CM_ASS_LAV_SERVIZIO
     - PR_DISPO_L68
     - CM_CONV_DETTAGLIO
     - CM_PI_LAV_RISERVA

   * Le modifiche inerenti a:
   * - Iscrizioni a liste speciali
   *
   * sono già previste facendo la delete in AM_CM_ISCR
   *
   * Le modifiche inerenti a:
   * - le Adesioni alle richieste numeriche
   * - gli Avviamenti a selezione
   * - le Rose e Graduatorie
   *
   * sono già previste nella procedura Accorpamentogestionerose()
   *******************************************************************************/

   /******************************************************************************
   30/10/2006 DONATO
     modifiche per nuovi MODULI
     vengono effettuati aggiornamenti sul CDNLAVORATORE sulle seguenti tabelle
     1) CM_DIAGNOSI_FUNZIONALE
     2) AS_AVV_SELEZIONE
     3) AS_VALORE_ISEE
     4) DO_NOMINATIVO
     5) DO_LAV_STORIA_ROSA
     6) AS_STORIA_STATO_OCC
   *******************************************************************************/

   /*  Alessandro Pegoraro
   Registra l'accorpamento. Chiamata prima delle cancellazioni per
   tenere traccia dell'operazione. Inserisce in AN_LAVORATORE_ACCORPA e torna il PRG del record inserito
   o torna -1 in caso di errore.
   NO autonomous transaction perchè in caso di errore non va inserito nulla
   */
   FUNCTION log_accorpamento (plavdaaccorpare VARCHAR2, plavincuiaccorpare VARCHAR2, putentemod VARCHAR2)
      RETURN NUMBER
   IS
      codfiscaccorpato an_lavoratore.strcodicefiscale%TYPE;
      codfiscaccorpante an_lavoratore.strcodicefiscale%TYPE;
      strupd         VARCHAR2 (2000);
      tmp_prg_acc    an_lavoratore_accorpa.prglavoratoreaccorpa%TYPE;
   BEGIN
      SELECT strcodicefiscale
        INTO codfiscaccorpato
        FROM an_lavoratore
       WHERE cdnlavoratore = plavdaaccorpare;

      SELECT strcodicefiscale
        INTO codfiscaccorpante
        FROM an_lavoratore
       WHERE cdnlavoratore = plavincuiaccorpare;

      SELECT s_an_lavoratore_accorpa.NEXTVAL INTO tmp_prg_acc FROM DUAL;

      strupd :=
         (
          'INSERT INTO AN_LAVORATORE_ACCORPA (CDNLAVORATORE, CDNLAVORATOREACCORPATO, CDNUTINS, DTMINS, PRGLAVORATOREACCORPA, STRCODICEFISCALE, STRCODICEFISCALEACCORPATO) VALUES ('
          || plavincuiaccorpare || ',' || plavdaaccorpare || ',' || putentemod || ',sysdate, ' || tmp_prg_acc ||
          ' ,''' || codfiscaccorpante || ''',''' || codfiscaccorpato || ''' )');
      DBMS_OUTPUT.put_line (strupd);

      EXECUTE IMMEDIATE strupd;

      RETURN tmp_prg_acc;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN -1;
      WHEN OTHERS
      THEN
         RETURN -1;
   END;

   FUNCTION log_accorpamento_accordo (plav an_lavoratore_accorpa.prglavoratoreaccorpa%TYPE,
      prgacc ci_accordo_accorpa.prgaccordo%TYPE)
      RETURN NUMBER
   IS
      codfiscaccorpato an_lavoratore.strcodicefiscale%TYPE;
      codfiscaccorpante an_lavoratore.strcodicefiscale%TYPE;
      strupd         VARCHAR2 (2000);
   BEGIN
      strupd :=
         ('INSERT INTO CI_ACCORDO_ACCORPA (PRGACCORDOACCORPA, PRGLAVORATOREACCORPA, PRGACCORDO) VALUES (' ||
          'S_CI_ACCORDO_ACCORPA.nextval,' || plav || ',' || prgacc || ' )');

      IF (isdebug = TRUE)
      THEN
         DBMS_OUTPUT.put_line (strupd);
      END IF;

      EXECUTE IMMEDIATE strupd;

      RETURN 1;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN -1;
      WHEN OTHERS
      THEN
         RETURN -1;
   END;

 procedure putNotificaLavoratore(
      cdnLav AN_LAVORATORE.cdnLavoratore%type,
      Messaggio        in VARCHAR2,
      p_cdnut          IN VARCHAR2 :=null,
      p_data_scadenza  IN VARCHAR2 :=null) IS
 
        dataScadenza AN_EVIDENZA.Datdatascad%type;
        prgTipoev DE_TIPO_EVIDENZA.PRGTIPOEVIDENZA%type;
        cdn_ut  ts_utente.CDNUT%type;
        begin

             if (p_data_scadenza is not null) then
                 dataScadenza := to_date(p_data_scadenza, 'dd/mm/yyyy');
             else
                 dataScadenza:=sysdate+365;
             end if;

             select prgTipoEvidenza
             into Prgtipoev
             from DE_TIPO_EVIDENZA te
             where te.codtipoevidenza='AV';


             if (cdnLav is not null) then
                if (p_cdnut is null) then
                   cdn_ut := to_number('190');
                else
                   cdn_ut := to_number(p_cdnut);
                end if;
                begin
                     insert into AN_EVIDENZA
                     (PRGEVIDENZA, CDNLAVORATORE, DATDATASCAD,
                      STREVIDENZA, PRGTIPOEVIDENZA,
                      CDNUTINS, DTMINS, CDNUTMOD, DTMMOD)
                                values
                       (S_AN_EVIDENZA.nextVal, cdnLav, dataScadenza,
                        Messaggio, Prgtipoev,
                        cdn_ut, sysdate, cdn_ut, sysdate);

                end;
               end if;

             return;
        end putNotificaLavoratore;

   /*
   Alessandro Pegoraro
   Quando si accorpano due lavoratori entrambi con accordo, prima di procedere verifichiamo che gli accordi
   siano sulla stessa catena e che l'accorpante abbia un accordo più giovane.

   La funziona torna il PRG dell'accordo più giovane, o -1 se non sono nella stessa catena
   */
   FUNCTION check_catena_accordi (prgaccfrom am_altra_iscr.prgaccordo%TYPE, prgaccto am_altra_iscr.prgaccordo%TYPE)
      RETURN NUMBER
   IS
      prgacctemp     am_altra_iscr.prgaccordo%TYPE;
   BEGIN
      prgacctemp := prgaccto;

      WHILE prgacctemp IS NOT NULL
      LOOP
         BEGIN
            IF (prgacctemp = prgaccfrom)
            THEN
               IF (isdebug)
               THEN
                  DBMS_OUTPUT.put_line (prgaccfrom || ' è l''accordo più giovane');
               END IF;

               --Sono sulla stessa catena, e l'accordo del accorpato è più giovane --> torno quella
               RETURN prgaccfrom;
            END IF;

            SELECT prgaccordosucc
              INTO prgacctemp
              FROM ci_accordo
             WHERE prgaccordo = prgacctemp;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               EXIT;
         END;
      END LOOP;

      prgacctemp := prgaccfrom;

      WHILE prgacctemp IS NOT NULL
      LOOP
         BEGIN
            IF (prgacctemp = prgaccto)
            THEN
               IF (isdebug)
               THEN
                  DBMS_OUTPUT.put_line (prgaccto || ' è l''accordo più giovane');
               END IF;

               RETURN prgaccto;
            --Sono sulla stessa catena, torno l'accordo del accorpante
            END IF;

            SELECT prgaccordosucc
              INTO prgacctemp
              FROM ci_accordo
             WHERE prgaccordo = prgacctemp;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               EXIT;
         END;
      END LOOP;

      IF (isdebug)
      THEN
         DBMS_OUTPUT.put_line (prgaccto || ' e ' || prgaccfrom || ' non sono sulla stessa catena');
      END IF;

      --NON sono sulla stessa catena
      RETURN -1;
   END;

   /*
   Alessandro Pegoraro - accorpamento corsi CIG
   Si distingue tra corsi del catalogo e corsi orienter; per ogni corso dell'accorpato
   si verifica se lo stesso corso è già presente, eventualmente lo si cancella (inserendo il contatto)
   altrimenti viene semplicemente spostato su un'altra iscrizione CIG
   */
   FUNCTION accorpa_corsi (putentemod VARCHAR2, prgaltraiscrin am_altra_iscr.prgaltraiscr%TYPE,
      prgaltraiscrto am_altra_iscr.prgaltraiscr%TYPE)
      RETURN NUMBER
   IS
      strupdate      VARCHAR2 (2000);
      strwhere       VARCHAR2 (2000);
      tmp_res        NUMBER;
      flg_ex         BOOLEAN;
   BEGIN
      --Prima analizzo i corsi orienter
      FOR corso IN (SELECT codrifpa, codsede, cor.prgcorsoci
                      FROM ci_corso_orienter co JOIN ci_corso cor ON cor.prgcorsoci = co.prgcorsoci
                     WHERE cor.prgaltraiscr = prgaltraiscrin)
      LOOP
         flg_ex := FALSE;

         strupdate := NULL;

         strupdate := 'UPDATE CI_CORSO SET PRGALTRAISCR=' || prgaltraiscrto;

         FOR corsoto IN (SELECT co.*
                           FROM ci_corso_orienter co JOIN ci_corso cor ON cor.prgcorsoci = co.prgcorsoci
                          WHERE cor.prgaltraiscr = prgaltraiscrto)
         LOOP
            --SE IL CORSO c'è GIà UGUALE, LO CANCELLO
            IF (corso.codrifpa = corsoto.codrifpa
                AND corso.codsede = corsoto.codsede
                AND corso.prgcorsoci <> corsoto.prgcorsoci)
            THEN
               strupdate :=
                  strupdate ||
                  ',dtmcancellazione=sysdate,prgcolloquio = NULL,prgpercorso = NULL,cdnUtenteCancellazione=' ||
                  putentemod;
               flg_ex := TRUE;
            END IF;

            IF (flg_ex = TRUE)
            THEN
               EXIT;                                                                  --ho trovato, inutile continuare
            END IF;
         END LOOP;

         strwhere := ' WHERE PRGCORSOCI= ' || corso.prgcorsoci;

         IF (strupdate IS NOT NULL)
         THEN
            pg_log.dolog ('U', 'CI_CORSO', putentemod, strwhere);

            EXECUTE IMMEDIATE (strupdate || strwhere);

            IF (isdebug = TRUE)
            THEN
               DBMS_OUTPUT.put_line (strupdate || strwhere);
            END IF;
         END IF;
      END LOOP;

      strupdate := NULL;

      --Poi analizzo i corsi CATALOGO
      FOR corso IN (SELECT numidproposta, numrecid, cor.prgcorsoci prgcorsoci
                      FROM ci_corso_catalogo co JOIN ci_corso cor ON cor.prgcorsoci = co.prgcorsoci
                     WHERE cor.prgaltraiscr = prgaltraiscrin)
      LOOP
         flg_ex := FALSE;

         strupdate := 'UPDATE CI_CORSO SET PRGALTRAISCR = ' || prgaltraiscrto;

         FOR corsoto IN (SELECT co.*
                           FROM ci_corso_catalogo co JOIN ci_corso cor ON cor.prgcorsoci = co.prgcorsoci
                          WHERE cor.prgaltraiscr = prgaltraiscrto)
         LOOP
            --DBMS_OUTPUT.put_line ('DEB DA:'||corso.prgcorsoci||' a: '||corsoto.prgcorsoci);
            --SE IL CORSO c'è GIà UGUALE, LO CANCELLO
            IF (corso.numidproposta = corsoto.numidproposta
                AND corso.numrecid = corsoto.numrecid
                AND corso.prgcorsoci <> corsoto.prgcorsoci)
            THEN
               strupdate := strupdate || ', dtmcancellazione = sysdate, cdnUtenteCancellazione =' || putentemod;
               -- e cancello anche il contatto
               flg_ex := TRUE;
            END IF;

            IF (flg_ex = TRUE)
            THEN
               EXIT;
            END IF;
         END LOOP;

         strwhere := ' WHERE PRGCORSOCI = ' || corso.prgcorsoci;

         IF (strupdate IS NOT NULL)
         THEN
            IF (isdebug = TRUE)
            THEN
               DBMS_OUTPUT.put_line (strupdate || strwhere);
            END IF;

            pg_log.dolog ('U', 'CI_CORSO', putentemod, strwhere);

            EXECUTE IMMEDIATE (strupdate || strwhere);
         END IF;
      -- tmp_res := removecontatto (corso.prgcorsoci, putentemod);
      END LOOP;

      RETURN 1;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN -3;
   END;

   FUNCTION accorpa_colloqui (plav VARCHAR2, inprgaltraiscr or_colloquio.prgaltraiscr%TYPE, --L'iscrizione che ERA dell'accorpato
      prgaltraiscrto or_colloquio.prgaltraiscr%TYPE,                     --L'iscrizione corrispondente dell'accorpante
                                                    putentemod VARCHAR2)
      RETURN NUMBER
   IS
      checkcoll      NUMBER;
      tmp_res        NUMBER;
      checkcollto    NUMBER;
      checkperc      NUMBER;
      concatcorsi    VARCHAR2 (2000) := NULL;
      targetcoll     or_colloquio.prgcolloquio%TYPE;
      targetcollto   or_colloquio.prgcolloquio%TYPE;
      strupdate      VARCHAR2 (2000) := '';
   BEGIN

      /* CHECK sui colloqui del  primo accordo */
      SELECT COUNT (coll.prgcolloquio)
        INTO checkcoll
        FROM or_colloquio coll
       WHERE coll.cdnlavoratore = plav AND coll.prgaltraiscr = inprgaltraiscr;

      /* CHECK sui colloqui del  secondo accordo */
      SELECT COUNT (coll.prgcolloquio)
        INTO checkcollto
        FROM or_colloquio coll
       WHERE coll.cdnlavoratore = plav AND coll.prgaltraiscr = prgaltraiscrto;

      IF (checkcoll = 0)
      THEN
         IF (isdebug = TRUE)
         THEN
            DBMS_OUTPUT.put_line ('L''accorpato non ha colloqui da spostare');
         END IF;

         RETURN 0;
      END IF;

      IF (checkcollto = 0)
      THEN
         --sposta colloquio da iscr. in a iscr. già esistente. Il CDNLAV è già OK
         strupdate :=
            ('UPDATE OR_COLLOQUIO SET PRGALTRAISCR=' || prgaltraiscrto ||
             ',NUMKLOCOLLOQUIO = NUMKLOCOLLOQUIO+1 WHERE CDNLAVORATORE =' || plav || ' AND PRGALTRAISCR = ' ||
             inprgaltraiscr);

         IF (isdebug)
         THEN
            DBMS_OUTPUT.put_line (strupdate);
         END IF;

         pg_log.dolog ('U', 'OR_COLLOQUIO', putentemod, 'WHERE CDNLAVORATORE =' || plav || ' AND PRGALTRAISCR = ' || inprgaltraiscr);

         EXECUTE IMMEDIATE (strupdate);

         RETURN 1;
      ELSE                                                               --I1  ha il colloquio -> accorpo PIC e azioni
         SELECT prgcolloquio                                               --seleziono il colloquio C2, so già che c'è
           INTO targetcoll
           FROM or_colloquio
          WHERE cdnlavoratore = plav AND prgaltraiscr = inprgaltraiscr;

         SELECT prgcolloquio                                               --seleziono il colloquio C1, so già che c'è
           INTO targetcollto
           FROM or_colloquio
          WHERE cdnlavoratore = plav AND prgaltraiscr = prgaltraiscrto;

         --cerco le PIC nell'accorpante, per vedere se devo annullare quelle dell'accorpato
         SELECT COUNT (1)
           INTO checkperc
           FROM or_percorso_concordato orp JOIN de_esito dee ON dee.codesito = orp.codesito
          WHERE orp.prgcolloquio = targetcollto AND orp.prgazioni = 151 AND orp.codesitorendicont = 'E';

         --se l'accorpato aveva la presa in carico valida O ALTRE AZIONI, le sposto
         FOR percors IN (SELECT prgpercorso, prgazioni
                           FROM or_percorso_concordato orp
                          WHERE orp.prgcolloquio = targetcoll)
         LOOP
            concatcorsi := NULL;

            FOR corsi IN (SELECT prgcorsoci
                            FROM ci_corso cor
                           WHERE cor.prgcolloquio = targetcoll AND cor.prgaltraiscr = inprgaltraiscr)
            LOOP
               IF (concatcorsi IS NULL)
               THEN
                  concatcorsi := corsi.prgcorsoci;
               ELSE
                  concatcorsi := concatcorsi || ',' || corsi.prgcorsoci;
               END IF;
            END LOOP;

            IF (isdebug)
            THEN
               DBMS_OUTPUT.put_line ('xxx' || concatcorsi);
            END IF;

            IF (concatcorsi IS NOT NULL)
            THEN
               strupdate :=
                  ('UPDATE CI_CORSO SET PRGCOLLOQUIO = NULL, PRGPERCORSO = NULL WHERE PRGPERCORSO = ' || percors.
                   prgpercorso);

               IF (isdebug)
               THEN
                  DBMS_OUTPUT.put_line (strupdate);
               END IF;

               pg_log.dolog ('U', 'CI_CORSO', putentemod, ' WHERE PRGPERCORSO = ' || percors.prgpercorso);

               EXECUTE IMMEDIATE (strupdate);
            END IF;

            strupdate := ('UPDATE OR_PERCORSO_CONCORDATO SET PRGCOLLOQUIO =' || targetcollto);

            IF (checkperc != 0 AND percors.prgazioni = 151)
            THEN
               --presa in carico valida trovata
               strupdate := strupdate || ', CODESITO = ''NA'' ';
               --imposto codEsitoRendicont ad ANNULLATO ed elimino la data conclusione
               strupdate := strupdate || ', CODESITORENDICONT = ''A'' ';
               strupdate := strupdate || ', DATEFFETTIVA = null ';
            END IF;

            strupdate := strupdate || '  WHERE PRGPERCORSO = ' || percors.prgpercorso;

            IF (isdebug)
            THEN
               DBMS_OUTPUT.put_line (strupdate);
            END IF;

            pg_log.dolog ('U', 'OR_PERCORSO_CONCORDATO', putentemod, ' WHERE PRGPERCORSO = ' || percors.prgpercorso);

            EXECUTE IMMEDIATE (strupdate);

            IF (concatcorsi IS NOT NULL)
            THEN
               strupdate :=
                  ('UPDATE CI_CORSO SET PRGCOLLOQUIO = ' || targetcollto || ', PRGPERCORSO = ' || percors.prgpercorso
                   || ' WHERE PRGCORSOCI IN ( ' || concatcorsi || ') ');

               IF (isdebug)
               THEN
                  DBMS_OUTPUT.put_line (strupdate);
               END IF;

               pg_log.dolog ('U', 'CI_CORSO', putentemod, ' WHERE PRGPERCORSO = IN ( ' || concatcorsi || ') ');

               EXECUTE IMMEDIATE (strupdate);
            END IF;
         END LOOP;

         pg_log.dolog ('D', 'OR_SCHEDA_COLLOQUIO', putentemod, ' where prgcolloquio =  ' || targetcoll);

         DELETE FROM or_scheda_colloquio
               WHERE prgcolloquio = targetcoll;

         IF (isdebug)
         THEN
            DBMS_OUTPUT.put_line ('DELETE FROM OR_SCHEDA_COLLOQUIO WHERE prgcolloquio =' || targetcoll);
         END IF;

         -- cancellare colloquio C2
         pg_log.dolog ('D', 'OR_COLLOQUIO', putentemod, ' where prgcolloquio =  ' || targetcoll);

         DELETE FROM or_colloquio
               WHERE prgcolloquio = targetcoll;

         IF (isdebug = TRUE)
         THEN
            DBMS_OUTPUT.put_line ('DELETE FROM OR_COLLOQUIO WHERE prgcolloquio =' || targetcoll);
         END IF;
      END IF;

      RETURN 1;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN -4;
   END;

   /*********************************************************************************************
     20/06/2010 ALESSANDRO PEGORARO
     Gestione accorpamento  iscrizione.

     Ho già spostato l'iscrizione sul lav. accorpante, ove ora mi trovo con DUE
     iscrizioni di cui accorpare Percorso, PIC e azioni

    *********************************************************************************************/
   FUNCTION accorpa_iscrizione (plav VARCHAR2, inprgaltraiscr or_colloquio.prgaltraiscr%TYPE, --L'iscrizione che ERA dell'accorpato
      prgaltraiscrto or_colloquio.prgaltraiscr%TYPE,    --L'iscrizione corrispondente dell'accorpante, può essere NULL
                                                    putentemod VARCHAR2)
      RETURN NUMBER
   IS
      checkcoll      NUMBER;
      tmp_res        NUMBER;
      checkcollto    NUMBER;
      checkperc      NUMBER;
      targetcoll     or_colloquio.prgcolloquio%TYPE;
      targetcollto   or_colloquio.prgcolloquio%TYPE;
      targetperc     or_percorso_concordato.prgpercorso%TYPE;
      targetacc      am_altra_iscr.prgaccordo%TYPE;
      targetaccto    am_altra_iscr.prgaccordo%TYPE;
      targetaccgiovane am_altra_iscr.prgaccordo%TYPE;
      strupdate      VARCHAR2 (2000) := '';
   BEGIN
      IF (isdebug)
      THEN
         DBMS_OUTPUT.put_line ('Accorpamento iscrizioni corrispondenti:' || inprgaltraiscr || ' e ' ||
                               prgaltraiscrto);
      END IF;


      --ACCORPAMENTO COLLOQUI
      tmp_res := accorpa_colloqui (plav, inprgaltraiscr, prgaltraiscrto, putentemod);

      IF (tmp_res < 0)
      THEN
         RETURN tmp_res;
      END IF;

      --ACCORPAMENTO CORSI
      tmp_res := accorpa_corsi (putentemod, inprgaltraiscr, prgaltraiscrto);

      IF (tmp_res < 0)
      THEN
         RETURN tmp_res;
      END IF;

      --SELEZIONE ACCORDO PIU GIOVANE
      SELECT COUNT (1)
        INTO checkcoll
        FROM am_altra_iscr cig
       WHERE cig.prgaltraiscr = inprgaltraiscr AND cig.prgaccordo IS NOT NULL;

      SELECT COUNT (1)
        INTO checkcollto
        FROM am_altra_iscr cig
       WHERE cig.prgaltraiscr = prgaltraiscrto AND cig.prgaccordo IS NOT NULL;

      IF (checkcoll > 0)
      THEN
         SELECT prgaccordo
           INTO targetacc
           FROM am_altra_iscr cig
          WHERE cig.prgaltraiscr = inprgaltraiscr AND cig.prgaccordo IS NOT NULL;

         IF (checkcollto > 0)
         THEN
            SELECT prgaccordo
              INTO targetaccto
              FROM am_altra_iscr cig
             WHERE cig.prgaltraiscr = prgaltraiscrto AND cig.prgaccordo IS NOT NULL;

            --cerco il più giovane
            targetaccgiovane := check_catena_accordi (targetacc, targetaccto);

            IF (targetaccgiovane <> -1)
            THEN                                                                          --se sono sulla stessa chain
               pg_log.dolog ('U', 'am_altra_iscr', putentemod, ' where PRGALTRAISCR =  ' || prgaltraiscrto);

               --aggiorno l'iscrizione con l'accordo più recente
               UPDATE am_altra_iscr
                  SET prgaccordo = targetaccgiovane, numkloaltraiscr = numkloaltraiscr + 1
                WHERE prgaltraiscr = prgaltraiscrto;

               IF (isdebug = TRUE)
               THEN
                  DBMS_OUTPUT.put_line ('update am_altra_iscr set prgaccordo = ' || targetaccgiovane ||
                                        ',NUMKLOALTRAISCR = NUMKLOALTRAISCR+1 where PRGALTRAISCR = ' ||
                                        prgaltraiscrto);
               END IF;

               pg_log.dolog ('D', 'AM_ALTRA_ISCR', putentemod, ' WHERE prgaltraiscr =  ' || inprgaltraiscr);

               IF (isdebug = TRUE)
               THEN
                  DBMS_OUTPUT.put_line ('DELETE FROM am_altra_iscr WHERE prgaltraiscr = ' || inprgaltraiscr);
               END IF;

               --Infine cancello l'iscrizione accorpata
               DELETE FROM am_altra_iscr
                     WHERE prgaltraiscr = inprgaltraiscr;
            ELSE                                                               --non sono sulla stessa catena, annullo
               pg_log.dolog ('U', 'am_altra_iscr', putentemod, ' where PRGALTRAISCR =  ' || inprgaltraiscr);

               --annullo l'iscrizione dell'accorpato
               UPDATE am_altra_iscr
                  SET codstato = DECODE (codstato,  'AA', 'AA',  'AD', 'AD',  'AR', 'AR',  'AA'),
                      numkloaltraiscr = numkloaltraiscr + 1
                WHERE prgaltraiscr = inprgaltraiscr;

               IF (isdebug = TRUE)
               THEN
                  DBMS_OUTPUT.
                   put_line (
                             'UPDATE AM_ALTRA_ISCR SET CODSTATO=DECODE(CODSTATO,''AA'',''AA'',''AD'',''AD'',''AR'',''AR'',''AA''), NUMKLOALTRAISCR = NUMKLOALTRAISCR+1
                            WHERE prgaltraiscr = '
                             || inprgaltraiscr);
               END IF;

               RETURN -7;
            END IF;
         ELSE                                                                                    --I1 non ha l'accordo
            pg_log.dolog ('U', 'am_altra_iscr', putentemod, ' where PRGALTRAISCR =  ' || prgaltraiscrto);

            --aggiorno l'accordo
            UPDATE am_altra_iscr
               SET prgaccordo = targetacc, numkloaltraiscr = numkloaltraiscr + 1
             WHERE prgaltraiscr = prgaltraiscrto;

            IF (isdebug = TRUE)
            THEN
               DBMS_OUTPUT.put_line ('UPDATE am_altra_iscr
               SET prgaccordo = ' || targetacc ||
                                     ', numkloaltraiscr = numkloaltraiscr + 1
             WHERE prgaltraiscr =' || prgaltraiscrto);
            END IF;

            pg_log.dolog ('D', 'AM_ALTRA_ISCR', putentemod, ' WHERE prgaltraiscr =  ' || inprgaltraiscr);

            --Infine cancello l'iscrizione accorpata
            DELETE FROM am_altra_iscr
                  WHERE cdnlavoratore = plav AND prgaltraiscr = inprgaltraiscr;

            IF (isdebug = TRUE)
            THEN
               DBMS_OUTPUT.put_line ('DELETE FROM am_altra_iscr
                  WHERE cdnlavoratore = ' || plav || ' AND prgaltraiscr = ' ||
                                     inprgaltraiscr);
            END IF;
         END IF;
      ELSE
         pg_log.dolog ('D', 'AM_ALTRA_ISCR', putentemod, ' WHERE prgaltraiscr =  ' || inprgaltraiscr);

         --Infine cancello l'iscrizione accorpata
         DELETE FROM am_altra_iscr
               WHERE cdnlavoratore = plav AND prgaltraiscr = inprgaltraiscr;

         IF (isdebug)
         THEN
            DBMS_OUTPUT.put_line ('DELETE FROM AM_ALTRA_ISCR WHERE cdnlavoratore = plav AND prgaltraiscr = ' ||
                                  inprgaltraiscr);
         END IF;
      END IF;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN -5;
   END;

   /*
   Alessandro Pegoraro

   chiamato su ogni iscrizione CIG, sposta colloquio e iscrizione, logga
   */
   FUNCTION migraz_semplice (plavdaaccorpare VARCHAR2, plavincuiaccorpare VARCHAR2,
      prgaltraiscrfrom am_altra_iscr.prgaltraiscr%TYPE, prgacc an_lavoratore_accorpa.prglavoratoreaccorpa%TYPE,
      putentemod VARCHAR2)
      RETURN NUMBER
   IS
      strupdate      VARCHAR2 (2000);
      strwhere       VARCHAR2 (1000);
      prgaccordotemp am_altra_iscr.prgaccordo%TYPE := NULL;
      tmp_res        NUMBER;
   BEGIN
      SELECT prgaccordo
        INTO prgaccordotemp
        FROM am_altra_iscr cig
       WHERE prgaltraiscr = prgaltraiscrfrom;

      --SPOSTA COLLOQUIO. Anche se non c'è NO problem perchè specifico il prgaltraiscr
      strupdate :=
         ('UPDATE OR_COLLOQUIO SET CDNLAVORATORE =' || plavincuiaccorpare ||
          ',NUMKLOCOLLOQUIO = NUMKLOCOLLOQUIO+1 WHERE CDNLAVORATORE =' || plavdaaccorpare || ' AND PRGALTRAISCR = '
          || prgaltraiscrfrom);

      IF (isdebug)
      THEN
         DBMS_OUTPUT.put_line (strupdate);
      END IF;

      pg_log.dolog ('U', 'OR_COLLOQUIO', putentemod, 'WHERE CDNLAVORATORE =' || plavdaaccorpare || ' AND PRGALTRAISCR = ' || prgaltraiscrfrom);

      EXECUTE IMMEDIATE (strupdate);

      --SPOSTA ISCRIZIONE
      strupdate :=
         ('UPDATE AM_ALTRA_ISCR SET CDNLAVORATORE =' || plavincuiaccorpare || ',NUMKLOALTRAISCR = NUMKLOALTRAISCR+1');
      strwhere := (' WHERE PRGALTRAISCR =' || prgaltraiscrfrom);

      IF (isdebug)
      THEN
         DBMS_OUTPUT.put_line (strupdate || strwhere);
      END IF;

      pg_log.dolog ('U', 'AM_ALTRA_ISCR', putentemod, strwhere);

      EXECUTE IMMEDIATE (strupdate || strwhere);

      --logga la presenza dell'accordo
      IF (prgaccordotemp IS NOT NULL)
      THEN
         tmp_res := log_accorpamento_accordo (prgacc, prgaccordotemp);

         IF (tmp_res = -1)
         THEN
            RETURN -2;
         END IF;
      END IF;


      IF (isdebug)
      THEN
         DBMS_OUTPUT.put_line ('Completata migrazione semplice');
      END IF;

      RETURN 1;
   END;
   
  /*
   MAURO
   gestione SAP
   */
   FUNCTION check_sap_lavdaaccorpare (plavdaaccorpare VARCHAR2, plavincuiaccorpare VARCHAR2, putentemod VARCHAR2)
      RETURN NUMBER
   IS
        p_prgsplav SP_LAVORATORE.PRGSPLAV%type;
        p_datfineval SP_LAVORATORE.DATFINEVAL%type;
        p_codstato SP_LAVORATORE.CODSTATO%type;
    p_numklosap SP_LAVORATORE.NUMKLOSAP%type;
    checksapattivalavresta NUMBER;
        
        CURSOR saplavcursor
        IS
            SELECT PRGSPLAV, DATFINEVAL, CODSTATO, NUMKLOSAP
            FROM SP_LAVORATORE 
            where CDNLAVORATORE = plavdaaccorpare;      
   BEGIN
   
    SELECT COUNT (SP.PRGSPLAV)
        INTO checksapattivalavresta
        FROM SP_LAVORATORE sp
    WHERE sp.cdnlavoratore = plavincuiaccorpare AND sp.DATFINEVAL is null and sp.CODSTATO in ('01','04');
   
        FOR saplav IN saplavcursor
        LOOP
            p_prgsplav := saplav.PRGSPLAV;
            p_datfineval := saplav.DATFINEVAL;
            p_codstato := saplav.CODSTATO;
      p_numklosap := saplav.NUMKLOSAP;
      
      if (p_datfineval is null and p_codstato in ('01','04')) then
      
        if (checksapattivalavresta = 0) then
          pg_log.dolog ('U', 'SP_LAVORATORE', putentemod, 'WHERE PRGSPLAV = ' || p_prgsplav);
        
          UPDATE SP_LAVORATORE sp
            SET sp.cdnlavoratore = plavincuiaccorpare, sp.cdnutmod = cdnutmod, sp.dtmmod = SYSDATE,
            sp.numklosap = p_numklosap + 1
          WHERE sp.PRGSPLAV = p_prgsplav;
          
        else 
        
          pg_log.dolog ('D', 'SP_LAVORATORE', putentemod, 'WHERE PRGSPLAV = ' || p_prgsplav);
        
          DELETE FROM SP_LAVORATORE where PRGSPLAV = p_prgsplav;
          
        end if;
        
      else
        pg_log.dolog ('D', 'SP_LAVORATORE', putentemod, 'WHERE PRGSPLAV = ' || p_prgsplav);
        
        DELETE FROM SP_LAVORATORE where PRGSPLAV = p_prgsplav;
      
      end if;
            
        END LOOP;       
        
        RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN -7;
   END;

   /*********************************************************************************************
     20/06/2005 DAVIDE
     Funzione che cancella un lavoratore DA ACCORPARE dal DB e i dati ad esso collegati

     OCCHIO !!
     NOTA: QUESTA FUNZIONE NON PUO' ESSERE UTILIZZATA PER CANCELLARE UN LAVORATORE!!

       Il motivo è perchè gli appuntamenti presenti nell'agenda NON vengono cancellati!!
      Questo perchè può esistere il caso di appuntamenti multipli (stesso appuntamento più lavoratori)
      che NON devono essere cancellati. Andrebbe cancellato solo il lavoratore singolo all'interno
      dell'appuntamento. Se invece l'appuntamento non è multiplo allora deve essere eliminato tutto
      l'appuntamento e riallineati gli slot. Dal momento che per l'accorpamento non è necessario
      cancellare l'appuntamento (perchè gli appuntamenti vengono aggiornati), se si decide di utilizzare
      tale funzione per la cancellazione ricordarsi di implementare la cancellazione dell'appuntamento.

    *********************************************************************************************/
   FUNCTION cancellalavoratoreaccorpato (pcdnlavdacancellare VARCHAR2, pcdnutmod NUMBER, encrypterkey VARCHAR2)
      RETURN NUMBER
   IS
      cdnlavdacancellare an_lavoratore.cdnlavoratore%TYPE;
      clausolawhere  VARCHAR2 (50);
   BEGIN
      cdnlavdacancellare := TO_NUMBER (pcdnlavdacancellare);
      clausolawhere := 'WHERE CDNLAVORATORE = ' || pcdnlavdacancellare;

      -- INIZIO MODULI COLLOCAMENTO MIRATO
    pg_log.dolog ('D', 'CM_RICH_COMPUTO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM cm_rich_computo comp
            WHERE comp.cdnlavoratore = cdnlavdacancellare;
      
    pg_log.dolog ('D', 'CM_LAV_CARICO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM cm_lav_carico car
            WHERE car.cdnlavoratore = cdnlavdacancellare;

    pg_log.dolog ('D', 'CM_LAV_REDDITO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM cm_lav_reddito red
            WHERE red.cdnlavoratore = cdnlavdacancellare;

    pg_log.dolog ('D', 'CM_ASS_LAV_SERVIZIO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM cm_ass_lav_servizio ser
            WHERE ser.cdnlavoratore = cdnlavdacancellare;

   -- pg_log.dolog ('D', 'PR_DISPO_L68', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM pr_dispo_l68 dis
            WHERE dis.cdnlavoratore = cdnlavdacancellare;
      
    pg_log.dolog ('U', 'CM_CONV_DETTAGLIO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      UPDATE cm_conv_dettaglio ass
         SET ass.cdnlavoratore = NULL
       WHERE ass.cdnlavoratore = cdnlavdacancellare;

    pg_log.dolog ('U', 'CM_PI_LAV_RISERVA', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      UPDATE cm_pi_lav_riserva pro
         SET pro.cdnlavoratore = NULL, pro.cdnutmod = cdnutmod, pro.dtmmod = SYSDATE,
             pro.numklolavriserva = numklolavriserva + 1
       WHERE pro.cdnlavoratore = cdnlavdacancellare;

      -- FINE MODULI COLLOCAMENTO MIRATO
    pg_log.dolog ('D', 'AM_ART16', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);   
      DELETE FROM am_art16 t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

    pg_log.dolog ('D', 'AM_CM_GRADUATORIA', pcdnutmod, 'WHERE prgcmiscr IN
                     (SELECT t2.prgcmiscr
                        FROM am_cm_iscr t1, am_cm_graduatoria t2
                       WHERE decrypt (t1.cdnlavoratore, '''|| encrypterkey ||''') ='|| cdnlavdacancellare
                             || ' AND t1.prgcmiscr = t2.prgcmiscr)');    
      DELETE FROM am_cm_graduatoria t
            WHERE t.prgcmiscr IN
                     (SELECT t2.prgcmiscr
                        FROM am_cm_iscr t1, am_cm_graduatoria t2
                       WHERE decrypt (t1.cdnlavoratore, encrypterkey) = cdnlavdacancellare
                             AND t1.prgcmiscr = t2.prgcmiscr);

    pg_log.dolog ('D', 'CM_ISCR_ART1', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);   
      DELETE FROM cm_iscr_art1 t
            WHERE t.cdnlavoratore = cdnlavdacancellare;


      DELETE FROM am_cm_iscr_storico sto
            WHERE sto.prgcmiscr IN (SELECT t.prgcmiscr
                                      FROM am_cm_iscr t
                                     WHERE decrypt (t.cdnlavoratore, encrypterkey) = cdnlavdacancellare);

--    pg_log.dolog ('D', 'AM_CM_ISCR', pcdnutmod, 'WHERE decrypt (CDNLAVORATORE, ' || encrypterkey ||') = ' || cdnlavdacancellare);   
      DELETE FROM am_cm_iscr t
            WHERE decrypt (t.cdnlavoratore, encrypterkey) = cdnlavdacancellare;

      DELETE FROM am_dich_sospensione t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

      /*-- PRIMA di cancellare le tabelle del patto cancello le tab 'collegate' --*/
      DELETE FROM md_am_patto_lav_ag_agenda md
            WHERE EXISTS
                     (SELECT s.strchiavetabella3
                        FROM am_patto_lavoratore p, am_lav_patto_scelta s
                       WHERE p.prgpattolavoratore = s.prgpattolavoratore
                             AND p.cdnlavoratore = cdnlavdacancellare
                             AND s.codlsttab = 'AG_LAV'
                             AND s.strchiavetabella2 = md.codcpi
                             AND s.strchiavetabella3 = md.prgappuntamento);

      DELETE FROM md_am_patto_lav_or_perc md
            WHERE EXISTS
                     (SELECT s.strchiavetabella
                        FROM am_patto_lavoratore p, am_lav_patto_scelta s
                       WHERE p.prgpattolavoratore = s.prgpattolavoratore
                             AND p.cdnlavoratore = cdnlavdacancellare
                             AND s.codlsttab = 'OR_PER'
                             AND s.strchiavetabella = md.prgpercorso);

      DELETE FROM md_am_patto_lav_pr_mans md
            WHERE md.cdnlavoratore = cdnlavdacancellare;

      /*-- Cancello il PATTO --*/
    DELETE FROM OR_SCHEDA_SVANTAGGIO ss
            WHERE ss.PRGPATTOLAVORATORE IN (SELECT ss1.prgpattolavoratore
                                             FROM am_patto_lavoratore ss1
                                            WHERE ss1.cdnlavoratore = cdnlavdacancellare);
                      
    pg_log.dolog ('D', 'AM_PROGRAMMA_ENTE', pcdnutmod, 'WHERE PRGPATTOLAVORATORE IN (SELECT pe1.prgpattolavoratore
                                            FROM am_patto_lavoratore pe1
                      WHERE pe1.cdnlavoratore = ' || cdnlavdacancellare||')');   
    DELETE FROM AM_PROGRAMMA_ENTE pe
            WHERE pe.PRGPATTOLAVORATORE IN (SELECT pe1.prgpattolavoratore
                                            FROM am_patto_lavoratore pe1
                      WHERE pe1.cdnlavoratore = cdnlavdacancellare);
                      

      pg_log.dolog ('D', 'OR_SCHEDA_PARTECIPANTE', pcdnutmod, 'WHERE PRGPATTOLAVORATORE IN (SELECT sp1.prgpattolavoratore
                                             FROM am_patto_lavoratore sp1
                                            WHERE sp1.cdnlavoratore = ' || cdnlavdacancellare ||')');
    DELETE FROM OR_SCHEDA_PARTECIPANTE sp
            WHERE sp.PRGPATTOLAVORATORE IN (SELECT sp1.prgpattolavoratore
                                             FROM am_patto_lavoratore sp1
                                            WHERE sp1.cdnlavoratore = cdnlavdacancellare);

      pg_log.dolog ('D', 'AM_LAV_PATTO_SCELTA', pcdnutmod, 'WHERE prgpattolavoratore IN (SELECT t1.prgpattolavoratore
                                             FROM am_patto_lavoratore t1
                                            WHERE t1.cdnlavoratore = ' ||cdnlavdacancellare||')');                      
      DELETE FROM am_lav_patto_scelta t
            WHERE t.prgpattolavoratore IN (SELECT t1.prgpattolavoratore
                                             FROM am_patto_lavoratore t1
                                            WHERE t1.cdnlavoratore = cdnlavdacancellare);
   
   pg_log.dolog ('D', 'AM_PATTO_LAVORATORE', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);   
      DELETE FROM am_patto_lavoratore t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

      /*-- Cancello la DID  --*/
    
      pg_log.dolog ('D', 'AM_DICH_DISP_COLL', pcdnutmod, 'WHERE prgdichdisponibilita IN
                     (SELECT ddc.prgdichdisponibilita
                        FROM am_elenco_anagrafico ea, am_dich_disponibilita dd,
                             am_dich_disp_coll ddc
                       WHERE ea.prgelencoanagrafico = dd.prgelencoanagrafico
                             AND dd.prgdichdisponibilita = ddc.prgdichdisponibilita
                             AND ea.cdnlavoratore = ' || cdnlavdacancellare||')');  
               
      DELETE FROM am_dich_disp_coll t
            WHERE t.prgdichdisponibilita IN
                     (SELECT ddc.prgdichdisponibilita
                        FROM am_elenco_anagrafico ea, am_dich_disponibilita dd,
                             am_dich_disp_coll ddc
                       WHERE ea.prgelencoanagrafico = dd.prgelencoanagrafico
                             AND dd.prgdichdisponibilita = ddc.prgdichdisponibilita
                             AND ea.cdnlavoratore = cdnlavdacancellare);

  /* -- Cancello la DID  annuale */
   pg_log.dolog ('D', 'AM_DID_ANNUALE', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);      
      DELETE FROM AM_DID_ANNUALE dida WHERE DIDA.CDNLAVORATORE = cdnlavdacancellare;

   pg_log.dolog ('D', 'AM_DICH_DISPONIBILITA', pcdnutmod, 'WHERE prgelencoanagrafico IN
                     (SELECT dd.prgelencoanagrafico
                        FROM am_elenco_anagrafico ea, am_dich_disponibilita dd
                       WHERE ea.prgelencoanagrafico = dd.prgelencoanagrafico
                             AND ea.cdnlavoratore = ' || cdnlavdacancellare||')');      
               
      DELETE FROM am_dich_disponibilita t
            WHERE t.prgelencoanagrafico IN
                     (SELECT dd.prgelencoanagrafico
                        FROM am_elenco_anagrafico ea, am_dich_disponibilita dd
                       WHERE ea.prgelencoanagrafico = dd.prgelencoanagrafico
                             AND ea.cdnlavoratore = cdnlavdacancellare);

      /*--  Cancello i contatti e le tabelle collegate  --*/
   pg_log.dolog ('D', 'AC_INDIRIZZO', pcdnutmod, 'WHERE prgrilevazione IN
                     (SELECT i.prgrilevazione
                        FROM ac_indirizzo i, ac_rilevazione_fabbisogno rf, ag_contatto c
                       WHERE c.cdnlavoratore = ' ||cdnlavdacancellare||
                             ' AND c.prgcontatto = rf.prgcontatto
                             AND rf.prgrilevazione = i.prgrilevazione)');
               
      DELETE FROM ac_indirizzo ind
            WHERE ind.prgrilevazione IN
                     (SELECT i.prgrilevazione
                        FROM ac_indirizzo i, ac_rilevazione_fabbisogno rf, ag_contatto c
                       WHERE c.cdnlavoratore = cdnlavdacancellare
                             AND c.prgcontatto = rf.prgcontatto
                             AND rf.prgrilevazione = i.prgrilevazione);
               
               
   pg_log.dolog ('D', 'AC_RILEVAZIONE_FABBISOGNO', pcdnutmod, 'WHERE prgcontatto IN (SELECT rf.prgcontatto
                                      FROM ac_rilevazione_fabbisogno rf, ag_contatto c
                                     WHERE c.cdnlavoratore = '|| cdnlavdacancellare||' AND c.prgcontatto = rf.prgcontatto)');
      DELETE FROM ac_rilevazione_fabbisogno t
            WHERE t.prgcontatto IN (SELECT rf.prgcontatto
                                      FROM ac_rilevazione_fabbisogno rf, ag_contatto c
                                     WHERE c.cdnlavoratore = cdnlavdacancellare AND c.prgcontatto = rf.prgcontatto);

   pg_log.dolog ('D', 'AG_CONTATTO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM ag_contatto t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

      /*  AGENDA
       La tabella AG_LAVORATORE è legata all'agenda. Non posso cancellare
       semplicemente il lavoratore perchè creerei un appuntamento 'valido'
       senza alcun lavoratore al suo interno. Non posso nemmeno cancellare
       tutto l'appuntamento perchè potrebberee esserci altri lavoratori o
       un'azienda (appuntamento multiplo). Poi occorrerebbe porcedere all'allineamnto slot.
       Al momento quindi NON viene gestita la cancellazione dell'appuntamento
       qualora si cancelli un lavoratore attraverso quesata SP.
      */
      -- delete from AG_LAVORATORE t where t.cdnlavoratore = cdnLavDaCancellare;

      /*-- Cancello i DOCUMENTI  --*/
    
      DELETE FROM am_documento_blob t
            WHERE t.prgdocumento IN (SELECT t1.prgdocumento
                                       FROM am_documento t1
                                      WHERE t1.cdnlavoratore = cdnlavdacancellare);

   pg_log.dolog ('D', 'AM_DOCUMENTO_COLL', pcdnutmod, 'WHERE prgdocumento IN (SELECT t1.prgdocumento
                                       FROM am_documento t1
                                      WHERE t1.cdnlavoratore = '||cdnlavdacancellare||')');
      DELETE FROM AM_DOCUMENTO_COLL t
            WHERE t.prgdocumento IN (SELECT t1.prgdocumento
                                       FROM am_documento t1
                                      WHERE t1.cdnlavoratore = cdnlavdacancellare);
                    
   pg_log.dolog ('D', 'AM_DOCUMENTO_ALLEGATO', pcdnutmod, 'WHERE prgdocumentopadre IN (SELECT t1.prgdocumento
                    FROM am_documento t1
                    WHERE t1.cdnlavoratore = '||cdnlavdacancellare||')');                   
  DELETE FROM AM_DOCUMENTO_ALLEGATO t
            WHERE t.prgdocumentopadre IN (SELECT t1.prgdocumento
                    FROM am_documento t1
                    WHERE t1.cdnlavoratore = cdnlavdacancellare);
                    
   pg_log.dolog ('D', 'AM_DOCUMENTO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM am_documento t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

      /*-- Cancello il lavoratore dall'Elenco anagrafico  --*/
   pg_log.dolog ('D', 'AM_ELENCO_ANAGRAFICO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);    
      DELETE FROM am_elenco_anagrafico t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'AM_EX_PERM_SOGG', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare); 
      DELETE FROM am_ex_perm_sogg t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'AM_INDISP_TEMP', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);  
      DELETE FROM am_indisp_temp t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'AM_LISTA_SPETT_ISCR', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare); 
      DELETE FROM am_lista_spett_iscr t
            WHERE t.cdnlavoratore = cdnlavdacancellare;
      
   pg_log.dolog ('D', 'AM_MB_LSU', pcdnutmod, 'WHERE prgmobilitaiscr IN (SELECT t1.prgmobilitaiscr
                                          FROM am_mobilita_iscr t1
                                         WHERE t1.cdnlavoratore = '||cdnlavdacancellare||')');  
      DELETE FROM am_mb_lsu t
            WHERE t.prgmobilitaiscr IN (SELECT t1.prgmobilitaiscr
                                          FROM am_mobilita_iscr t1
                                         WHERE t1.cdnlavoratore = cdnlavdacancellare);
                     
--   pg_log.dolog ('D', 'AM_MOBILITA_ISCR_MANS', pcdnutmod, 'WHERE prgmobilitaiscr IN (SELECT t1.prgmobilitaiscr
 --                                         FROM am_mobilita_iscr t1
 --                                        WHERE t1.cdnlavoratore = '|| cdnlavdacancellare||')'); 
      DELETE FROM am_mobilita_iscr_mans t
            WHERE t.prgmobilitaiscr IN (SELECT t1.prgmobilitaiscr
                                          FROM am_mobilita_iscr t1
                                         WHERE t1.cdnlavoratore = cdnlavdacancellare);

      DELETE FROM AM_MOBILITA_RIS_DETT t
            WHERE t.prgmobilitaiscr IN (SELECT t1.prgmobilitaiscr
                                          FROM am_mobilita_iscr t1
                                         WHERE t1.cdnlavoratore = cdnlavdacancellare);

   pg_log.dolog ('D', 'AM_MOBILITA_ISCR', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);  
      DELETE FROM AM_MOBILITA_ISCR t
            WHERE t.cdnlavoratore = cdnlavdacancellare;
   

      DELETE FROM am_obbligo_istruzione t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'AM_OBBLIGO_FORMATIVO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);  
      DELETE FROM AM_OBBLIGO_FORMATIVO t
            WHERE t.cdnlavoratore = cdnlavdacancellare;
   
   pg_log.dolog ('D', 'AM_PRIVACY', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);  
      DELETE FROM AM_PRIVACY t
            WHERE t.cdnlavoratore = cdnlavdacancellare;
            
   pg_log.dolog ('D', 'AM_CONSENSO_FIRMA', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
	  DELETE FROM AM_CONSENSO_FIRMA t
			WHERE t.cdnlavoratore =  cdnlavdacancellare;

      DELETE FROM AN_EVIDENZA t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'DO_DISPONIBILITA', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);  
      DELETE FROM DO_DISPONIBILITA t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'DO_ESITO_CANDIDATO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);  
      DELETE FROM DO_ESITO_CANDIDATO t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

      /*
      XXX NUOVA GESTIONE:
      DA VALUTARE!!!!!!!
      non viene più eliminata la gestione incrocio
      */
   pg_log.dolog ('D', 'DO_NOMINATIVO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);     
      DELETE FROM DO_NOMINATIVO t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'PR_ABILITAZIONE', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);     
      DELETE FROM PR_ABILITAZIONE t
            WHERE t.cdnlavoratore = cdnlavdacancellare;
   
   pg_log.dolog ('D', 'PR_COMPETENZA', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);     
      DELETE FROM PR_COMPETENZA t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'PR_CREDITO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);      
      DELETE FROM PR_CREDITO t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'PR_INDISPONIBILITA', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM pr_indisponibilita t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'PR_INFO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM PR_INFO t
            WHERE t.cdnlavoratore = cdnlavdacancellare;
   
   pg_log.dolog ('D', 'PR_LINGUA', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM PR_LINGUA t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'PR_NOTA_LAV', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM PR_NOTA_LAV t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'PR_STUDIO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM PR_STUDIO t
            WHERE t.cdnlavoratore = cdnlavdacancellare;
            
   pg_log.dolog ('D', 'PR_CORSO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);		
	  DELETE FROM PR_CORSO t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'PR_VALIDITA', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM PR_VALIDITA t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'PR_VISIBILITA', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM PR_VISIBILITA t
            WHERE t.cdnlavoratore = cdnlavdacancellare;


      DELETE FROM ST_DICH_ATT t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

      /*-- Cancello i COLLOQUI e relativi PERCORSI --*/
   pg_log.dolog ('D', 'OR_PERCORSO_CONCORDATO', pcdnutmod, 'WHERE prgcolloquio IN (SELECT t1.prgcolloquio
                                       FROM or_colloquio t1
                                      WHERE t1.cdnlavoratore = ' ||cdnlavdacancellare||')');    
      DELETE FROM OR_PERCORSO_CONCORDATO t
            WHERE t.prgcolloquio IN (SELECT t1.prgcolloquio
                                       FROM or_colloquio t1
                                      WHERE t1.cdnlavoratore = cdnlavdacancellare);

   pg_log.dolog ('D', 'OR_SCHEDA_COLLOQUIO', pcdnutmod, 'WHERE prgcolloquio IN (SELECT t1.prgcolloquio
                                       FROM or_colloquio t1
                                      WHERE t1.cdnlavoratore = ' ||cdnlavdacancellare||')');  
      DELETE FROM OR_SCHEDA_COLLOQUIO t
            WHERE t.prgcolloquio IN (SELECT t1.prgcolloquio
                                       FROM or_colloquio t1
                                      WHERE t1.cdnlavoratore = cdnlavdacancellare);

   pg_log.dolog ('D', 'OR_SCHEDA_NOF', pcdnutmod, 'WHERE prgcolloquio IN (SELECT t1.prgcolloquio
                                       FROM or_colloquio t1
                                      WHERE t1.cdnlavoratore = ' ||cdnlavdacancellare||')');
      DELETE FROM OR_SCHEDA_NOF t
            WHERE t.prgcolloquio IN (SELECT t1.prgcolloquio
                                       FROM or_colloquio t1
                                      WHERE t1.cdnlavoratore = cdnlavdacancellare);

   pg_log.dolog ('D', 'OR_COLLOQUIO_COLL', pcdnutmod, 'WHERE prgcolloquio IN (SELECT t1.prgcolloquio
                                       FROM or_colloquio t1
                                      WHERE t1.cdnlavoratore = ' ||cdnlavdacancellare||')');
      DELETE FROM OR_COLLOQUIO_COLL t
            WHERE t.prgcolloquio IN (SELECT t1.prgcolloquio
                                       FROM or_colloquio t1
                                      WHERE t1.cdnlavoratore = cdnlavdacancellare);

   pg_log.dolog ('D', 'OR_COLLOQUIO', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM OR_COLLOQUIO t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'PR_ASS_ESP_MOVI', pcdnutmod, 'WHERE prgesplavoro IN
                     (SELECT t2.prgesplavoro
                        FROM pr_mansione t1, pr_esp_lavoro t2
                       WHERE t1.prgmansione = t2.prgmansione AND t1.cdnlavoratore = '||cdnlavdacancellare||')');
      DELETE FROM PR_ASS_ESP_MOVI t
            WHERE t.prgesplavoro IN
                     (SELECT t2.prgesplavoro
                        FROM pr_mansione t1, pr_esp_lavoro t2
                       WHERE t1.prgmansione = t2.prgmansione AND t1.cdnlavoratore = cdnlavdacancellare);

   pg_log.dolog ('D', 'PR_ESP_LAVORO', pcdnutmod, 'WHERE prgmansione IN (SELECT t1.prgmansione
                                      FROM pr_mansione t1
                                     WHERE t1.cdnlavoratore = '||cdnlavdacancellare||')');
      DELETE FROM PR_ESP_LAVORO t
            WHERE t.prgmansione IN (SELECT t1.prgmansione
                                      FROM pr_mansione t1
                                     WHERE t1.cdnlavoratore = cdnlavdacancellare);
   
   pg_log.dolog ('D', 'PR_MOBIL_GEOGR', pcdnutmod, 'WHERE prgmansione IN (SELECT t1.prgmansione
                                      FROM pr_mansione t1
                                     WHERE t1.cdnlavoratore = '||cdnlavdacancellare ||')');
      DELETE FROM PR_MOBIL_GEOGR t
            WHERE t.prgmansione IN (SELECT t1.prgmansione
                                      FROM pr_mansione t1
                                     WHERE t1.cdnlavoratore = cdnlavdacancellare);

   pg_log.dolog ('D', 'PR_MANSIONE', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);
      DELETE FROM PR_MANSIONE t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

      /*-- Cancello le inf storiche relative alla rosa --*/
   pg_log.dolog ('D', 'DO_LAV_STORIA_ROSA', pcdnutmod, 'WHERE cdnlavoratore = '||cdnlavdacancellare||
                  'AND codprovincia = (SELECT g.codprovinciasil
                                          FROM ts_generale g)');    
      DELETE FROM DO_LAV_STORIA_ROSA r
            WHERE r.cdnlavoratore = cdnlavdacancellare
                  AND r.codprovincia = (SELECT g.codprovinciasil
                                          FROM ts_generale g);

      DELETE FROM MD_AM_PATTO_LAV_PR_MANS m
            WHERE m.cdnlavoratore = cdnlavdacancellare;

      /* -- cancello lo stato occupazionale --
         (operazione da fare DOPO la cancellazione dei movimenti)
      */
   pg_log.dolog ('D', 'AM_STATO_OCCUPAZ', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);    
      DELETE FROM AM_STATO_OCCUPAZ t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

      DELETE FROM AN_EVIDENZA t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

   pg_log.dolog ('D', 'AN_LAV_STORIA_INF_COLL', pcdnutmod, 'WHERE prglavstoriainf IN (SELECT t1.prglavstoriainf
                                          FROM an_lav_storia_inf t1
                                         WHERE t1.cdnlavoratore = '||cdnlavdacancellare||')');    
      DELETE FROM AN_LAV_STORIA_INF_COLL t
            WHERE t.prglavstoriainf IN (SELECT t1.prglavstoriainf
                                          FROM an_lav_storia_inf t1
                                         WHERE t1.cdnlavoratore = cdnlavdacancellare);

   pg_log.dolog ('D', 'AN_LAV_STORIA_INF', pcdnutmod, 'WHERE CDNLAVORATORE =' || cdnlavdacancellare);         
    DELETE FROM AN_LAV_STORIA_INF t
            WHERE t.cdnlavoratore = cdnlavdacancellare;

      /*-- Traccio la successiva operazione di delete del lavoratore da accorpare nella tabella di log!! --*/
      pg_log.dolog ('D', 'AN_LAVORATORE', pcdnutmod, clausolawhere);

      /*-- E infine cancello il LAVORATORE !! --*/
      IF (isdebug)
      THEN
         DBMS_OUTPUT.put_line (' DELETE FROM an_lavoratore lav
            WHERE lav.cdnlavoratore = ' || cdnlavdacancellare);
      END IF;

      DELETE FROM an_lavoratore lav
            WHERE lav.cdnlavoratore = cdnlavdacancellare;

      RETURN 0;
   END;

   /*********************************************************************************************
     22/06/2005 DAVIDE
     Funzione che ACCORPA un lavoratore ad un altro. Il Lavoratore "da accorpare" è quello che
     verrà poi cancellato dal DB, mentre quello accorpante è quello che rimane nel DB.

      L'accorpamento al momento avviene in questo modo:
        TUTTI i movimenti (protocollati annullati rettificati etc. ...) del lavoratore da accorpare
        vengono "trsferiti" (con una UPDATE) al lavoratore accorpante.
        TUTTE le rimanenti informazioni del lavoratore da accorpare (stato occupazionale, iscirzione
        all'elenco anagrafico, dati amministrativi etc) vengono cancellati attraverso la funzione
        cancellaLavoratore(_) definita sempre all'interno di questro package.
    *********************************************************************************************/
   FUNCTION accorpalavoratore (plavdaaccorpare VARCHAR2, plavincuiaccorpare VARCHAR2, putentemod VARCHAR2,
      encrypterkey VARCHAR2)
      RETURN VARCHAR2
   IS
      lavdaaccorpare an_lavoratore.cdnlavoratore%TYPE;
      lavincuiaccorpare an_lavoratore.cdnlavoratore%TYPE;
      cdnutmod       ts_utente.cdnut%TYPE;
      retnum         NUMBER;
      prgaccordotemp am_altra_iscr.prgaccordo%TYPE;
      prgaccordotempto am_altra_iscr.prgaccordo%TYPE;
      prgaltraiscrtemp am_altra_iscr.prgaltraiscr%TYPE;
      prgaccorpa     an_lavoratore_accorpa.prglavoratoreaccorpa%TYPE;
      checkcigfrom   NUMBER;
      checkcigto     NUMBER;
      flgsemplice    BOOLEAN := FALSE;
      tmp_res        NUMBER;
      tmp_res_m      NUMBER;
      tmp_res_sap    NUMBER;
      strupdate      VARCHAR2 (2000);
      numcilavoratori NUMBER;
      checkpresa    NUMBER;
      retstring      VARCHAR2 (2000) := '';
    numdeleghe NUMBER;
    numdeleghe_accor NUMBER;
   --stringa da tornare, contenente l'esito + gli accordi
   BEGIN
      lavdaaccorpare := plavdaaccorpare;
      lavincuiaccorpare := plavincuiaccorpare;
      cdnutmod := TO_NUMBER (putentemod);
      --inserimento record in AN_LAVORATORE_ACCORPA
      prgaccorpa := log_accorpamento (lavdaaccorpare, lavincuiaccorpare, putentemod);

      -- VERIFICO SE IL LAVORATORE ACCORPANTE HA UN'ISCRIZIONE CIG
      FOR cig_iscr
         IN (SELECT cig.prgaltraiscr, cig.datinizio, cig.datfine, cig.prgazienda, cig.prgaccordo,
                    cig.codstato
               FROM am_altra_iscr cig
              WHERE cig.cdnlavoratore = lavdaaccorpare AND NVL (cig.codstato, 'NT') NOT IN ('AA', 'AR', 'AN')
                    AND NOT EXISTS
                               (SELECT cig2.prgaltraiscr
                                  FROM am_altra_iscr cig2
                                 WHERE cig2.cdnlavoratore = cig.cdnlavoratore
                                       AND CIG2.DATINIZIO = cig.datinizio
                                       AND CIG2.DATFINE = cig.DATFINE
                                       AND CIG2.PRGAZIENDA = CIG.PRGAZIENDA
                                       AND cig2.prgaltraiscr <> cig.prgaltraiscr))
      LOOP
         --verifica iscrizione  corrispondente
         SELECT COUNT (cig.prgaltraiscr)
           INTO checkcigto
           FROM am_altra_iscr cig
          WHERE cig.cdnlavoratore = lavincuiaccorpare
                AND cig.datinizio = cig_iscr.datinizio
                AND cig.datfine = cig_iscr.datfine
                AND cig.prgazienda = cig_iscr.prgazienda;

         --verifica per 1 a 1 (questa dovrebbe essere inutile)
         SELECT COUNT (cig.prgaltraiscr)
           INTO checkcigfrom
           FROM am_altra_iscr cig
          WHERE cig.cdnlavoratore = lavdaaccorpare
                AND cig.datinizio = cig_iscr.datinizio
                AND cig.datfine = cig_iscr.datfine
                AND cig.prgazienda = cig_iscr.prgazienda;


         IF (checkcigfrom = 1 AND checkcigto = 1)
         THEN
            --So che c'è una sola iscr corrispondente, la seleziono
            SELECT cig.prgaltraiscr, cig.prgaccordo
              INTO prgaltraiscrtemp, prgaccordotempto
              FROM am_altra_iscr cig
             WHERE cig.cdnlavoratore = lavincuiaccorpare
                   AND cig.datinizio = cig_iscr.datinizio
                   AND cig.datfine = cig_iscr.datfine
                   AND cig.prgazienda = cig_iscr.prgazienda;

            --Check stessa catena
            tmp_res := check_catena_accordi (cig_iscr.prgaccordo, prgaccordotempto);

            IF (isdebug)
            THEN
               DBMS_OUTPUT.put_line ('Esito verifica catena: più recente = ' || tmp_res);
            END IF;

            tmp_res_m :=
               migraz_semplice (lavdaaccorpare, lavincuiaccorpare, cig_iscr.prgaltraiscr, prgaccorpa, putentemod);

            IF (tmp_res_m < 0)
            THEN
               RETURN tmp_res_m;
            END IF;

            --Accorpo le iscrizioni SSE gli accordi sono sulla stessa catena di rettifiche E 2 check di prima
            IF (prgaccordotempto IS NULL OR tmp_res = cig_iscr.prgaccordo OR tmp_res = prgaccordotempto)
            THEN
                IF (isdebug)
            THEN
               DBMS_OUTPUT.put_line ('Accorpo Iscrizioni del lavoratore   ' || lavincuiaccorpare);
            END IF;
               tmp_res := accorpa_iscrizione (lavincuiaccorpare, cig_iscr.prgaltraiscr, prgaltraiscrtemp, putentemod);

               IF (tmp_res < 0)
               THEN
                  RETURN tmp_res;
               END IF;
            END IF;
         ELSE                           --Passo all'iscr successiva, questa era annullata O senza corrispondenza 1 a 1
            tmp_res :=
               migraz_semplice (lavdaaccorpare, lavincuiaccorpare, cig_iscr.prgaltraiscr, prgaccorpa, putentemod);

            IF (tmp_res < 0)
            THEN
               RETURN tmp_res;
            END IF;
         END IF;
      END LOOP;


      -- PER OGNI ALTRA ISCRIZIONE
      FOR cig_iscr
         IN (SELECT cig.prgaltraiscr, cig.datinizio, cig.datfine, cig.prgazienda, cig.prgaccordo,
                    cig.codstato
               FROM am_altra_iscr cig
              WHERE cig.cdnlavoratore = lavdaaccorpare
                    AND (NVL (cig.codstato, 'NT') IN ('AA', 'AR', 'AN')
                         OR EXISTS
                               (SELECT cig2.prgaltraiscr
                                  FROM am_altra_iscr cig2
                                 WHERE cig2.cdnlavoratore = cig.cdnlavoratore
                                       AND CIG2.DATINIZIO = cig.datinizio
                                       AND CIG2.DATFINE = cig.DATFINE
                                       AND CIG2.PRGAZIENDA = CIG.PRGAZIENDA
                                       AND cig2.prgaltraiscr <> cig.prgaltraiscr)))
      LOOP
         IF (isdebug)
         THEN
            DBMS_OUTPUT.put_line ('Loop ALTRE iscrizioni CIG = ' || cig_iscr.prgaltraiscr);
         END IF;

         tmp_res_m :=
            migraz_semplice (lavdaaccorpare, lavincuiaccorpare, cig_iscr.prgaltraiscr, prgaccorpa, putentemod);

         IF (tmp_res_m < 0)
         THEN
            RETURN tmp_res_m;
         END IF;
      END LOOP;

      -- Aggiorno gli eventuali lavoratori coinvolti nell'accordo - quadro B --XXX
      SELECT COUNT (clav.prglavoratore)
        INTO numcilavoratori
        FROM ci_lavoratore clav
       WHERE clav.cdnlavoratore = lavdaaccorpare;

      IF (numcilavoratori > 0)
      THEN
         pg_log.dolog ('U', 'CI_LAVORATORE', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare);

         UPDATE ci_lavoratore cl
            SET cl.cdnlavoratore = lavincuiaccorpare, cl.cdnutmod = cdnutmod, cl.dtmmod = SYSDATE,
                cl.numklolavoratore = cl.numklolavoratore + 1
          WHERE cl.cdnlavoratore = lavdaaccorpare;

         IF (isdebug)
         THEN
            DBMS_OUTPUT.put_line ('UPDATE ci_lavoratore cl
            SET cl.cdnlavoratore =' || lavincuiaccorpare ||
                                  ', cl.cdnutmod = cdnutmod, cl.dtmmod = SYSDATE,
                cl.numklolavoratore = cl.numklolavoratore + 1
                WHERE cl.cdnlavoratore =  ' || lavdaaccorpare);
         END IF;
      END IF;

      /* Aggiorno gli eventuali lavoratori coinvolti nell'accordo          CHIEDERE A CICALE
       SELECT COUNT (clav.prglavoratore)
         INTO numcilavoratori
         FROM ci_accordo clav
        WHERE clav.cdnlavoratore = lavdaaccorpare;

       IF (numcilavoratori > 0)
       THEN
          pg_log.dolog ('U', 'ci_accordo', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare);

          UPDATE ci_accordo cl
             SET cl.cdnlavoratore = lavincuiaccorpare, cl.cdnutmod = cdnutmod, cl.dtmmod = SYSDATE,
                 CL.NUMKLOACCORDO = cl.NUMKLOACCORDO + 1
           WHERE cl.cdnlavoratore = lavdaaccorpare;

            IF (isdebug)
             THEN
                DBMS_OUTPUT.put_line ('UPDATE ci_accordo cl
             SET cl.cdnlavoratore ='|| lavincuiaccorpare||', cl.cdnutmod = cdnutmod, cl.dtmmod = SYSDATE,
                 cl.NUMKLOACCORDO = cl.NUMKLOACCORDO + 1
                 WHERE cl.cdnlavoratore =  ' ||lavdaaccorpare);
             END IF;



       END IF;*/

      --TODO: TOGLIERE
      --  DBMS_OUTPUT.put_line ('USCITA TEMPORANEA PER SVILUPPO');
      --  ROLLBACK;
      --  RETURN '-10' || retstring;
      
      
      /* Se il lavoratore che si deve accorpare:
         -Ha una SAP in stato Annullata o Bruciata quest'ultima viene cancellata
         -Ha una SAP in stato Attiva o Perdita di Titolarità comporterà un errore */
      tmp_res_sap := check_sap_lavdaaccorpare (lavdaaccorpare, lavincuiaccorpare, putentemod);

      IF (tmp_res_sap < 0)
      THEN
        RETURN tmp_res_sap;
      END IF;

      -- "Trasferisco" i movimenti da un lavoratore all'altro
    
    pg_log.dolog ('U', 'AM_MOVIMENTO', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare);
      UPDATE am_movimento m
         SET m.cdnlavoratore = lavincuiaccorpare, m.cdnutmod = cdnutmod, m.dtmmod = SYSDATE, m.prgstatooccupaz = NULL,
             m.numklomov = m.numklomov + 1
       WHERE m.cdnlavoratore = lavdaaccorpare;

      --..e quindi i relativi documenti associati ai movimenti
    pg_log.dolog ('U', 'AM_DOCUMENTO', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare||' AND codtipodocumento LIKE ''MV___''');     
      UPDATE am_documento d
         SET d.cdnlavoratore = lavincuiaccorpare, d.cdnutmod = cdnutmod, d.dtmmod = SYSDATE,
             d.numklodocumento = d.numklodocumento + 1
       WHERE d.cdnlavoratore = lavdaaccorpare AND d.codtipodocumento LIKE 'MV___';

      -- "Trasferisco" le dichiarazioni reddituali da un lavoratore all'altro
    pg_log.dolog ('U', 'AM_DICH_LAV', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare);    
      UPDATE am_dich_lav
         SET cdnlavoratore = lavincuiaccorpare, cdnutmod = cdnutmod, dtmmod = SYSDATE,
             numklodichlav = numklodichlav + 1
       WHERE cdnlavoratore = lavdaaccorpare;

      --..e quindi i relativi documenti associati alle dichiarazioni reddituali
    pg_log.dolog ('U', 'AM_DOCUMENTO', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare||' AND codtipodocumento = ''DR02''');   
      UPDATE am_documento d
         SET d.cdnlavoratore = lavincuiaccorpare, d.cdnutmod = cdnutmod, d.dtmmod = SYSDATE,
             d.numklodocumento = d.numklodocumento + 1
       WHERE d.cdnlavoratore = lavdaaccorpare AND d.codtipodocumento = 'DR02';

      -- Aggiorno gli eventuali appuntamenti presi per il lavoratore
      -- accorpato con il lavoratore accorpante
    pg_log.dolog ('U', 'AG_LAVORATORE', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare);        
      UPDATE ag_lavoratore l
         SET l.cdnlavoratore = lavincuiaccorpare
       WHERE l.cdnlavoratore = lavdaaccorpare;
       
       
        --presa atto
       SELECT count(1) INTO checkpresa FROM CA_PRESA_ATTO pt WHERE CDNLAVORATORE = lavdaaccorpare AND PT.CODSTATOPRESAATTO = 'AT';
       
       --sposta quelle annullate e chiuse
         
       UPDATE CA_PRESA_ATTO pa set pa.CDNLAVORATORE = lavincuiaccorpare, pa.NUMKLOPRESAATTO = pa.NUMKLOPRESAATTO +1, pa.cdnutmod = cdnutmod,
             pa.dtmmod = SYSDATE
       WHERE pa.CDNLAVORATORE = lavdaaccorpare AND PA.CODSTATOPRESAATTO IN( 'AN', 'CH', 'AC');
       
       --sposta e annulla per accorpamento
       UPDATE CA_PRESA_ATTO pa set pa.CDNLAVORATORE = lavincuiaccorpare, pa.NUMKLOPRESAATTO = pa.NUMKLOPRESAATTO +1, pa.cdnutmod = cdnutmod,
             pa.dtmmod = SYSDATE, PA.CODSTATOPRESAATTO = 'AC'
       WHERE pa.CDNLAVORATORE = lavdaaccorpare AND PA.CODSTATOPRESAATTO = 'AT';
      
       if (checkpresa >= 1) then
       --INSERT EVIDENZA
       putNotificaLavoratore(
          lavincuiaccorpare,
          'Verificare le prese d''atto a seguito di accorpamento',
          cdnutmod,
          null);
       end if;
      

      -- INIZIO MODULI COLLOCAMENTO MIRATO

      -- Aggiorno eventuali diagnosi funzionali per il lavoratore
      -- accorpato con il lavoratore accorpante
    
    pg_log.dolog ('U', 'CM_DIAGNOSI_FUNZIONALE', cdnutmod, 'WHERE cdnlavoratore = encrypt ('||lavdaaccorpare||','''||encrypterkey||''')');      
      UPDATE CM_DIAGNOSI_FUNZIONALE df
         SET df.cdnlavoratore = encrypt (lavincuiaccorpare, encrypterkey), df.cdnutmod = cdnutmod,
             df.dtmmod = SYSDATE, df.datfine = SYSDATE, df.numklodiagnosifunzionale = df.numklodiagnosifunzionale + 1
       WHERE df.cdnlavoratore = encrypt (lavdaaccorpare, encrypterkey);

      -- Aggiorno eventuali nulla osta per il lavoratore
      -- accorpato con il lavoratore accorpante
    pg_log.dolog ('U', 'CM_NULLA_OSTA', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare);    
      UPDATE CM_NULLA_OSTA n_o
         SET n_o.cdnlavoratore = lavincuiaccorpare, n_o.cdnutmod = cdnutmod, n_o.dtmmod = SYSDATE,
             n_o.numklonullaosta = n_o.numklonullaosta + 1
       WHERE n_o.cdnlavoratore = lavdaaccorpare;

      --..e quindi i relativi documenti associati ai nullaosta
    pg_log.dolog ('U', 'AM_DOCUMENTO', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare|| ' AND codtipodocumento = ''NULOST''');    
      UPDATE AM_DOCUMENTO d
         SET d.cdnlavoratore = lavincuiaccorpare, d.cdnutmod = cdnutmod, d.dtmmod = SYSDATE,
             d.numklodocumento = d.numklodocumento + 1
       WHERE d.cdnlavoratore = lavdaaccorpare AND d.codtipodocumento = 'NULOST';

      -- Aggiorno eventuali verbali di accertamento per il lavoratore
      -- accorpato con il lavoratore accorpante
    pg_log.dolog ('U', 'CM_VERBALE_ACCERT', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare );       
      UPDATE CM_VERBALE_ACCERT verb
         SET verb.cdnlavoratore = lavincuiaccorpare, verb.cdnutmod = cdnutmod, verb.dtmmod = SYSDATE,
             verb.numkloverbaleacc = verb.numkloverbaleacc + 1
       WHERE verb.cdnlavoratore = lavdaaccorpare;

      -- FINE MODULI COLLOCAMENTO MIRATO
      
      --2014/06 PEGORARO - GESTIONE DID da INPS, Elimino CDNLAV accorpato dalla tabella
      PG_LOG.DOLOG('U', 'AM_DID_INPS', cdnutmod, 'WHERE CDNLAVORATORE = '||lavdaaccorpare);
      UPDATE AM_DID_INPS di SET di.CDNLAVORATORE = NULL, di.NUMKLODIDINPS = di.NUMKLODIDINPS + 1, di.DTMMOD=SYSDATE, di.cdnutmod = cdnutmod WHERE CDNLAVORATORE = lavdaaccorpare;
    
    --2016/03 LANDI - GESTIONE DICHIARAZIONE NEET
      PG_LOG.DOLOG('U', 'AM_LAVORATORE_NEET', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare || ' and datcanc is null and datstoricizzazione is null');
      UPDATE AM_LAVORATORE_NEET neet SET neet.CDNLAVORATORE = lavincuiaccorpare, neet.NUMKLOLAVNEET = neet.NUMKLOLAVNEET + 1, 
    neet.datstoricizzazione=SYSDATE, neet.DTMMOD=SYSDATE, neet.cdnutmod = cdnutmod WHERE CDNLAVORATORE = lavdaaccorpare and datcanc is null and datstoricizzazione is null;
    
    PG_LOG.DOLOG('U', 'AM_LAVORATORE_NEET', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare || ' and (datcanc is not null or datstoricizzazione is not null)');
      UPDATE AM_LAVORATORE_NEET neet SET neet.CDNLAVORATORE = lavincuiaccorpare, neet.NUMKLOLAVNEET = neet.NUMKLOLAVNEET + 1, 
    neet.DTMMOD=SYSDATE, neet.cdnutmod = cdnutmod WHERE CDNLAVORATORE = lavdaaccorpare and (datcanc is not null or datstoricizzazione is not null);
    
    --2017/02 LANDI - GESTIONE PROFILING LAVORATORE
    UPDATE AM_LAVORATORE_PROFILO profilo set profilo.CDNLAVORATORE = lavincuiaccorpare, profilo.cdnutmod = cdnutmod, profilo.dtmmod = sysdate,
    profilo.numklolavprofilo = profilo.numklolavprofilo + 1 WHERE profilo.cdnlavoratore = lavdaaccorpare;

    --2017/12 BORRIELLO - gestione accorpamento tabelle conferimento did
    -- Elimino tutti i dati nella tabella AM_CONFERIMENTO_DID
      -- del lavoratore accorpato
    
    pg_log.dolog ('D', 'AM_CONFERIMENTO_DID', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare);
    
      DELETE FROM AM_CONFERIMENTO_DID conf
            WHERE conf.cdnlavoratore = lavdaaccorpare;
    
      -- FINE CONFERIMENTO_DID
    
    -- 2017/12 BORRIELLO - gestione accorpamento deleghe
    --1) solo uno dei due lavoratori ha deleghe e l'altro no -> spostiamo se necessario le deleghe sul lavoratore che rimane
    --2) se entrambi hanno deleghe vince il lavoratore che rimane e le altre deleghe sul lavoratore che viene cancellato vengono cancellate
  
    select count(*)
    into numdeleghe
    from AM_DELEGA 
    where cdnlavoratore = lavdaaccorpare;
    
    select count(*)
    into numdeleghe_accor
    from AM_DELEGA 
    where cdnlavoratore = lavincuiaccorpare;
    
    --caso 2
    if(numdeleghe > 0 and numdeleghe_accor > 0) then
       pg_log.dolog ('D', 'AM_DELEGA', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare);
       DELETE FROM AM_DELEGA dele WHERE dele.cdnlavoratore = lavdaaccorpare;    
    end if;
    
    --caso 1 (sposto le deleghe)
    if(numdeleghe > 0 and numdeleghe_accor <= 0) then
      pg_log.dolog ('U', 'AM_DELEGA', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare);
    
      UPDATE AM_DELEGA delega set delega.CDNLAVORATORE = lavincuiaccorpare, delega.cdnutmod = cdnutmod, delega.dtmmod = sysdate,
      delega.NUMKLODELEGA = delega.NUMKLODELEGA + 1 WHERE delega.cdnlavoratore = lavdaaccorpare;
    end if;
     
     -- FINE DELEGHE
    
    --2019/03 BORRIELLO - gestione accorpamento tabelle profiling GG
    -- Elimino tutti i dati del lavoratore accorpato dalla tabella AM_YG_PROFILING
    
    pg_log.dolog ('D', 'AM_YG_PROFILING', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare);
    
      DELETE FROM AM_YG_PROFILING profgg
            WHERE profgg.cdnlavoratore = lavdaaccorpare;
   
    -- FINE PROFILING_GG
  
   --2019/04BORRIELLO - gestione accorpamento tabelle verifica condizioni neet gg
    -- Elimino tutti i dati del lavoratore accorpato dalla tabella AM_YG_VERIFICA_NEET
    
    pg_log.dolog ('D', 'AM_YG_VERIFICA_NEET', cdnutmod, 'WHERE CDNLAVORATORE = ' || lavdaaccorpare);
    
      DELETE FROM AM_YG_VERIFICA_NEET neetgg
            WHERE neetgg.cdnlavoratore = lavdaaccorpare;
   
    -- FINE AM_YG_VERIFICA_NEET
    
      -- gestione accorpamento tabelle rose/graduatoria
      retnum := accorpamentogestionerose (lavdaaccorpare, lavincuiaccorpare, cdnutmod);

      IF (retnum = 0)
      THEN
         retnum := cancellalavoratoreaccorpato (lavdaaccorpare, cdnutmod, encrypterkey);
      END IF;

      RETURN TO_CHAR (retnum) || retstring;
   END;

   /*************************************************************************************
   * Ai lavoratori presenti nelle rose, grezze o definitive che siano,                  *
   * vengono cambiati i riferimenti solamente se il Lavoratore 2 non è presente in esse *
   * Il lavoratore 1 viene sostituito col lavoratore 2                                  *
   **************************************************************************************/
   FUNCTION accorpamentogestionerose (lavdaaccorpare an_lavoratore.cdnlavoratore%TYPE,
      lavincuiaccorpare an_lavoratore.cdnlavoratore%TYPE, cdnutmod ts_utente.cdnut%TYPE)
      RETURN NUMBER
   IS
      retnum         NUMBER;
      p_prgrosa      do_nominativo.prgrosa%TYPE;
      p_prgincrocio  do_incrocio.prgincrocio%TYPE;
      checknominativo NUMBER;
      checkstoriaocc NUMBER;

      CURSOR roselavdaacccursor
      IS
         SELECT nom.prgrosa
           FROM do_nominativo nom
          WHERE nom.cdnlavoratore = lavdaaccorpare;

      CURSOR rosecanclavdaacccursor
      IS
         SELECT cgrad.prgrosa
           FROM cm_canc_grad cgrad
          WHERE cgrad.cdnlavoratore = lavdaaccorpare;

      CURSOR incrocistoriastatoocccursor
      IS
         SELECT stocc.prgincrocio
           FROM as_storia_stato_occ stocc
          WHERE stocc.cdnlavoratore = lavdaaccorpare;
   BEGIN
      -- Aggiorno l'AVVIAMENTO A SELEZIONE per il lavoratore
      -- accorpato con il lavoratore accorpante
      UPDATE as_avv_selezione avs
         SET avs.cdnlavoratore = lavincuiaccorpare, avs.cdnutmod = cdnutmod, avs.dtmmod = SYSDATE,
             avs.numkloavvselezione = avs.numkloavvselezione + 1
       WHERE avs.cdnlavoratore = lavdaaccorpare;

	 -- Elimino tutti i dati nella tabella AS_VALORE_ISEE_STORICO
      -- del lavoratore accorpato
      DELETE FROM AS_VALORE_ISEE_STORICO viss
            WHERE viss.PRGVALOREISEE IN (
				SELECT vis.PRGVALOREISEE
				 FROM as_valore_isee vis
            WHERE vis.cdnlavoratore = lavdaaccorpare
			);

      -- Elimino tutti i dati nella tabella AS_VALORE_ISEE
      -- del lavoratore accorpato
      DELETE FROM as_valore_isee vis
            WHERE vis.cdnlavoratore = lavdaaccorpare;

      -- Aggiorno l'adesione alla rosa per il lavoratore
      -- accorpato con il lavoratore accorpante
      -- SOLO SE IL LAVORATORE ACCORPANTE PER LA STESSA ROSA/GRADUATORIA
      -- NON è STATO GIà AVVIATO
      -- ciclo sulle rose a cui il lavoratore ha aderito
      FOR rose IN roselavdaacccursor
      LOOP
         p_prgrosa := rose.prgrosa;

         -- VERIFICO CHE IL LAVORATORE ACCORPANTE NON SIA NELLA STESSA ROSA
         SELECT COUNT (dnom.prgnominativo)
           INTO checknominativo
           FROM do_nominativo dnom
          WHERE dnom.prgrosa = p_prgrosa AND dnom.cdnlavoratore = lavincuiaccorpare;

         IF (checknominativo = 0)
         THEN
            -- AGGIORNO L'ADESIONE ALLA ROSA
            UPDATE do_nominativo dn
               SET dn.cdnlavoratore = lavincuiaccorpare, dn.numklonominativo = dn.numklonominativo + 1
             WHERE dn.cdnlavoratore = lavdaaccorpare AND dn.prgrosa = p_prgrosa;

            -- Aggiorno il Riepilogo indicante la situazione del lavoratore per il lavoratore
            -- accorpato con il lavoratore accorpante
            UPDATE do_lav_storia_rosa lsto
               SET lsto.cdnlavoratore = lavincuiaccorpare
             WHERE lsto.cdnlavoratore = lavdaaccorpare AND lsto.prgrosa = p_prgrosa;
         ELSE
            -- ELIMINO IL PUNTEGGIO PER GRADUATORIE ART. 16
            DELETE FROM as_punteggio ap
                  WHERE ap.prgnominativo IN
                           (SELECT do_nominativo.prgnominativo
                              FROM do_nominativo
                             WHERE do_nominativo.cdnlavoratore = lavdaaccorpare AND do_nominativo.prgrosa = p_prgrosa);

            -- ELIMINO L'ADESIONE DEL LAVORATORE ACCORPATO
            DELETE FROM do_nominativo
                  WHERE do_nominativo.cdnlavoratore = lavdaaccorpare AND do_nominativo.prgrosa = p_prgrosa;

            -- ELIMINO IL RIEPILOGO DELLA SITUAZIONE LAVORATIVA DEL LAVORATORE ACCORPATO
            DELETE FROM do_lav_storia_rosa
                  WHERE do_lav_storia_rosa.cdnlavoratore = lavdaaccorpare AND do_lav_storia_rosa.prgrosa = p_prgrosa;
         END IF;
      END LOOP;

      FOR rosecanc IN rosecanclavdaacccursor
      LOOP
         p_prgrosa := rosecanc.prgrosa;

         UPDATE cm_canc_grad cgrad
            SET cgrad.cdnlavoratore = lavincuiaccorpare
          WHERE cgrad.cdnlavoratore = lavdaaccorpare AND cgrad.prgrosa = p_prgrosa;
      END LOOP;

      FOR incrocio IN incrocistoriastatoocccursor
      LOOP
         p_prgincrocio := incrocio.prgincrocio;

         -- VERIFICO CHE PER IL LAVORATORE ACCORPANTE NON C'è lo storico dello stato occupazionale
         SELECT COUNT (assto.prgstoriastatoocc)
           INTO checkstoriaocc
           FROM as_storia_stato_occ assto
          WHERE assto.cdnlavoratore = lavincuiaccorpare AND assto.prgincrocio = p_prgincrocio;

         IF (checkstoriaocc = 0)
         THEN
            -- Aggiorno lo storico dello stato occupazionale  per il lavoratore
            -- accorpato con il lavoratore accorpante
            UPDATE as_storia_stato_occ ssoc
               SET ssoc.cdnlavoratore = lavincuiaccorpare, ssoc.numklostoriastatoocc = ssoc.numklostoriastatoocc + 1
             WHERE ssoc.cdnlavoratore = lavdaaccorpare AND ssoc.prgincrocio = p_prgincrocio;
         ELSE
            -- ELIMINO LA Storicizzazione dello stato occupazionale DEL LAVORATORE ACCORPATO
            DELETE FROM as_storia_stato_occ
                  WHERE as_storia_stato_occ.cdnlavoratore = lavdaaccorpare
                        AND as_storia_stato_occ.prgincrocio = p_prgincrocio;
         END IF;
      END LOOP;

      RETURN 0;
   END;
 
END PG_ACCORPA_LAVORATORE;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_ACCORPAMENTO.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_ACCORPAMENTO IS

    /*
     * Author  : ROLFINI / ANTENUCCI.
     * Created : 20/08/2004 / 3,6,7/09/2004
     * Purpose : Procedure di accorpamento.
     * Version : 1.4  .
     */

    FUNCTION AccorpaUnitaAziende(ut IN TS_UTENTE.CDNUT%TYPE,
                                 prgAz IN AN_AZIENDA.PRGAZIENDA%TYPE,
                                 prgUnitaAccorpante IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
                                 prgUnitaAccorpata  IN AN_UNITA_AZIENDA.PRGUNITA%TYPE)
                                 RETURN NUMBER;

    FUNCTION AccorpaTestateAziende(ut IN TS_UTENTE.CDNUT%TYPE,
                                   prgAziendaAccorpante IN AN_UNITA_AZIENDA.PRGAZIENDA%TYPE,
                                   prgAziendaAccorpata  IN AN_UNITA_AZIENDA.PRGAZIENDA%TYPE)
                                   RETURN NUMBER;

END PG_ACCORPAMENTO;
/

CREATE OR REPLACE PACKAGE BODY PG_ACCORPAMENTO
IS
   /*
    *******************************************************
    * PRIVATE                                             *
    *******************************************************
    */
TYPE am_altra_type IS TABLE OF AM_ALTRA_ISCR.PRGALTRAISCR%TYPE
                             INDEX BY PLS_INTEGER;
   /*
    * Sostituisce tutti i riferimenti a prgUnitaAccorpata
    * con prgUnitaAccorpante nella tabella data.
    */
   PROCEDURE updateRif (nomeTabella IN ALL_TAB_COLS.TABLE_NAME%TYPE, ut IN TS_UTENTE.CDNUT%TYPE,
      campoAzi IN ALL_TAB_COLS.COLUMN_NAME%TYPE, prgAziAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
      prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE, campoUni IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
      prgUniAccorpante IN AN_UNITA_AZIENDA.PRGUNITA%TYPE, prgUniAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
      nomeLock IN ALL_TAB_COLS.COLUMN_NAME%TYPE, adesso IN DATE)
   IS
      query          VARCHAR2 (2048);
      queryWhere     VARCHAR2 (255);
   BEGIN
      queryWhere := ' WHERE ' || campoAzi || '=' || prgAziAccorpata || ' AND   ' || campoUni || '=' || prgUniAccorpata;

      PG_LOG.doLog ('U', nomeTabella, ut, queryWhere);

      query :=
         'UPDATE ' || nomeTabella || ' SET ' || campoAzi || '=' || prgAziAccorpante || ', ' || campoUni || '=' ||
         prgUniAccorpante;

      /*
      IF (nomeTabella = 'CM_PROSPETTO_INF') THEN
         query := query || ', codMonoStatoProspetto = decode(codMonoStatoProspetto,''V'', ''V'', ''N'') ';
         query := query || ', strNote = TRUNC_DESC(strNote || '' - MODIFICATO PER ACCORPAMENTO TESTATA AZIENDA '', 1000, ''...'') ';
      END IF;
      */

      IF nomeLock IS NOT NULL
      THEN
         query := query || ', ' || nomeLock || '=' || nomeLock || '+1 ';
      END IF;

      IF adesso IS NOT NULL
      THEN
         query :=
            query || ', ' || ' cdnUtMod = ' || ut || ', ' || ' dtmMod = TO_DATE(''' || TO_CHAR (adesso,
            'DD/MM/YYYY HH24:MI') || ''', ''DD/MM/YYYY HH24:MI'') ';
      END IF;

      query := query || queryWhere;

      EXECUTE IMMEDIATE query;
     
   END updateRif;

   /*
    * Sostituisce tutti i riferimenti a prgUnitaAccorpata
    * con prgUnitaAccorpante nella tabella dei prospetti informativi.
    */
   PROCEDURE updateRifProspetto (nomeFuzioneChiamante VARCHAR2, nomeTabella IN ALL_TAB_COLS.TABLE_NAME%TYPE,
      ut IN TS_UTENTE.CDNUT%TYPE, campoAzi IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
      prgAziAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE, prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE,
      campoUni IN ALL_TAB_COLS.COLUMN_NAME%TYPE, prgUniAccorpante IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
      prgUniAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE, nomeLock IN ALL_TAB_COLS.COLUMN_NAME%TYPE, adesso IN DATE)
   IS
      query          VARCHAR2 (2048);
      queryWhere     VARCHAR2 (255);
      p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%TYPE;

      -- ACCORPAMENTO TESTATA AZIENDA : SOLO I PROSPETTI DELL'AZIENDA ACCORPATA CON LE STESSE CARATTERISTICHE
      -- DELL'AZIENDA ACCORPANTE VENGONO POSTI NELLO STATO DI ANNULLATO
      CURSOR prospetti
      IS
         SELECT p1.prgprospettoinf
           FROM cm_prospetto_inf p1, cm_prospetto_inf p2
          WHERE p1.PRGAZIENDA = prgAziAccorpata
                AND p2.PRGAZIENDA = prgAziAccorpante
                AND p1.DATPROSPETTO = p2.DATPROSPETTO
                AND p1.NUMANNORIFPROSPETTO = p2.NUMANNORIFPROSPETTO
                AND p1.CODMONOCATEGORIA = p2.CODMONOCATEGORIA
                AND p1.CODMONOSTATOPROSPETTO IN ('A', 'S', 'U')
                AND p1.CODMONOSTATOPROSPETTO = p2.CODMONOSTATOPROSPETTO
                AND p1.CODPROVINCIA = p2.CODPROVINCIA;

      CURSOR prospNoCollid
      IS
         SELECT prgprospettoinf
           FROM cm_prospetto_inf
          WHERE prgazienda = prgAziAccorpata
                AND prgprospettoinf NOT IN
                       (SELECT p1.prgprospettoinf
                          FROM cm_prospetto_inf p1, cm_prospetto_inf p2
                         WHERE p1.PRGAZIENDA = prgAziAccorpata
                               AND p2.PRGAZIENDA = prgAziAccorpante
                               AND p1.DATPROSPETTO = p2.DATPROSPETTO
                               AND p1.NUMANNORIFPROSPETTO = p2.NUMANNORIFPROSPETTO
                               AND p1.CODMONOCATEGORIA = p2.CODMONOCATEGORIA
                               AND p1.CODMONOSTATOPROSPETTO IN ('A', 'S', 'U')
                               AND p1.CODMONOSTATOPROSPETTO = p2.CODMONOSTATOPROSPETTO
                               AND p1.CODPROVINCIA = p2.CODPROVINCIA);
   BEGIN
      IF (UPPER (nomeFuzioneChiamante) = UPPER ('AccorpaTestateAziende'))
      THEN
         IF (nomeTabella = 'CM_PROSPETTO_INF')
         THEN
            FOR rich IN prospetti
            LOOP
               p_prgProspettoInf := rich.prgprospettoinf;
               queryWhere := ' where prgprospettoinf = ' || p_prgProspettoInf;
               PG_LOG.doLog ('U', 'CM_PROSPETTO_INF', ut, queryWhere);

               IF (p_prgProspettoInf > 0)
               THEN
                  UPDATE am_documento
                     SET codstatoAtto = 'AN', numklodocumento = numklodocumento + 1, cdnUtMod = ut,
                         dtmMod = TO_DATE (adesso, 'DD/MM/YYYY HH24:MI')
                   WHERE prgdocumento IN
                            (SELECT doc.prgdocumento
                               FROM am_documento_coll coll
                                    INNER JOIN cm_prospetto_inf p
                                       ON (p.PRGPROSPETTOINF = TO_NUMBER (coll.STRCHIAVETABELLA))
                                    INNER JOIN am_documento doc
                                       ON (doc.prgdocumento = coll.PRGDOCUMENTO)
                              WHERE doc.codtipodocumento = 'PINF' AND p.prgprospettoinf = p_prgProspettoInf);

                  UPDATE cm_prospetto_inf
                     SET prgAzienda = prgAziAccorpante, prgunita = prgUniAccorpante, codMonoStatoProspetto = 'N',
                         cdnUtMod = ut, dtmMod = TO_DATE (adesso, 'DD/MM/YYYY HH24:MI'),
                         numkloprospettoinf = numkloprospettoinf + 1,
                         strNote = pg_utils.TRUNC_DESC (strNote || ' - MODIFICATO PER ACCORPAMENTO TESTATA AZIENDA ', 1000, '...')
                   WHERE prgprospettoinf = p_prgProspettoInf;
               END IF;
            END LOOP;

            FOR rich IN prospNoCollid
            LOOP
               p_prgProspettoInf := rich.prgprospettoinf;
               queryWhere := ' where prgprospettoinf = ' || p_prgProspettoInf;
               PG_LOG.doLog ('U', 'CM_PROSPETTO_INF', ut, queryWhere);

               IF (p_prgProspettoInf > 0)
               THEN
                  UPDATE cm_prospetto_inf
                     SET prgAzienda = prgAziAccorpante, prgunita = prgUniAccorpante, cdnUtMod = ut,
                         dtmMod = TO_DATE (adesso, 'DD/MM/YYYY HH24:MI'), numkloprospettoinf = numkloprospettoinf + 1,
                         strNote = pg_utils.TRUNC_DESC (strNote || ' - MODIFICATO PER ACCORPAMENTO TESTATA AZIENDA ', 1000, '...')
                   WHERE prgprospettoinf = p_prgProspettoInf;
               END IF;
            END LOOP;
         END IF;
      ELSE
         queryWhere :=
            ' WHERE ' || campoAzi || '=' || prgAziAccorpata || ' AND   ' || campoUni || '=' || prgUniAccorpata;

         PG_LOG.doLog ('U', nomeTabella, ut, queryWhere);

         query :=
            'UPDATE ' || nomeTabella || ' SET ' || campoAzi || '=' || prgAziAccorpante || ', ' || campoUni || '=' ||
            prgUniAccorpante;

         IF (nomeTabella = 'CM_PROSPETTO_INF')
         THEN
            -- if (upper(nomeFuzioneChiamante) = upper('AccorpaTestateAziende')) then
            -- query := query || ', codMonoStatoProspetto = decode(codMonoStatoProspetto,''V'', ''V'', ''N'') ';
            --query := query || ', strNote = pg_utils.TRUNC_DESC(strNote || '' - MODIFICATO PER ACCORPAMENTO TESTATA AZIENDA '', 1000, ''...'') ';
            --elsif
            IF (UPPER (nomeFuzioneChiamante) = UPPER ('AccorpaUnitaAziende'))
            THEN
               query := query || ', strNote = strNote || '' - MODIFICATO PER ACCORPAMENTO UNITA; AZIENDA '' ';
            END IF;
         END IF;

         IF nomeLock IS NOT NULL
         THEN
            query := query || ', ' || nomeLock || '=' || nomeLock || '+1 ';
         END IF;

         IF adesso IS NOT NULL
         THEN
            query :=
               query || ', ' || ' cdnUtMod = ' || ut || ', ' || ' dtmMod = TO_DATE(''' || TO_CHAR (adesso,
               'DD/MM/YYYY HH24:MI') || ''', ''DD/MM/YYYY HH24:MI'') ';
         END IF;

         query := query || queryWhere;

         EXECUTE IMMEDIATE query;
      END IF;
   END updateRifProspetto;


   /*
    * Cancella tutti i riferimenti a prgAziendaAccorpata
    * nella tabella data
    */
   PROCEDURE deleteRifTestataXLav (nomeTabella IN ALL_TAB_COLS.TABLE_NAME%TYPE,
      prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE, cdnLavoratore IN AN_LAVORATORE.CDNLAVORATORE%TYPE,
      ut IN TS_UTENTE.CDNUT%TYPE)
   IS
      query          VARCHAR2 (2048);
      queryWhere     VARCHAR2 (255);
   BEGIN
      queryWhere := ' WHERE PRGAZIENDA = ' || prgAziAccorpata || ' AND CDNLAVORATORE = ' || cdnLavoratore;

      PG_LOG.doLog ('D', nomeTabella, ut, queryWhere);

      query := 'DELETE FROM ' || nomeTabella || queryWhere;

      EXECUTE IMMEDIATE query;
   END deleteRifTestataXLav;


   /*
    * Sostituisce tutti i riferimenti a prgAziendaAccorpata
    * con prgAziendaAccorpante nella tabella data (RIFERITA AD UN LAVORATORE).
    */
   PROCEDURE updateRifTestataXLav (nomeTabella IN ALL_TAB_COLS.TABLE_NAME%TYPE, ut IN TS_UTENTE.CDNUT%TYPE,
      campoAzi IN ALL_TAB_COLS.COLUMN_NAME%TYPE, prgAziAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
      prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE, cdnLavoratore IN AN_LAVORATORE.CDNLAVORATORE%TYPE,
      nomeLock IN ALL_TAB_COLS.COLUMN_NAME%TYPE, adesso IN DATE)
   IS
      query          VARCHAR2 (2048);
      queryWhere     VARCHAR2 (255);
   BEGIN
      queryWhere := ' WHERE ' || campoAzi || '=' || prgAziAccorpata || ' AND CDNLAVORATORE = ' || cdnLavoratore;

      PG_LOG.doLog ('U', nomeTabella, ut, queryWhere);

      query := 'UPDATE ' || nomeTabella || ' SET ' || campoAzi || '=' || prgAziAccorpante || ', ';

      IF nomeLock IS NOT NULL
      THEN
         query := query || nomeLock || '=' || nomeLock || '+1 ' || ', ';
      END IF;

      query :=
         query || '    cdnUtMod = ' || ut || ', ' || '    dtmMod = TO_DATE(''' || TO_CHAR (adesso,
         'DD/MM/YYYY HH24:MI') || ''', ''DD/MM/YYYY HH24:MI'') ' || queryWhere;

      EXECUTE IMMEDIATE query;
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
         IF (nomeTabella = 'PR_INDISPONIBILITA')
         THEN
            deleteRifTestataXLav ('PR_INDISPONIBILITA', prgAziAccorpata, cdnLavoratore, ut);
         END IF;
      WHEN OTHERS
      THEN
         RAISE;
   END updateRifTestataXLav;


   /*
    * Sostituisce tutti i riferimenti a prgAziendaAccorpata
    * con prgAziendaAccorpante nella tabella data.
    */
   PROCEDURE updateRifTestata (nomeTabella IN ALL_TAB_COLS.TABLE_NAME%TYPE, ut IN TS_UTENTE.CDNUT%TYPE,
      campoAzi IN ALL_TAB_COLS.COLUMN_NAME%TYPE, prgAziAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
      prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE, nomeLock IN ALL_TAB_COLS.COLUMN_NAME%TYPE, adesso IN DATE)
   IS
      query          VARCHAR2 (2048);
      queryWhere     VARCHAR2 (255);
   BEGIN
      queryWhere := ' WHERE ' || campoAzi || '=' || prgAziAccorpata;

      PG_LOG.doLog ('U', nomeTabella, ut, queryWhere);

      query := 'UPDATE ' || nomeTabella || ' SET ' || campoAzi || '=' || prgAziAccorpante || ', ';

      IF nomeLock IS NOT NULL
      THEN
         query := query || nomeLock || '=' || nomeLock || '+1 ' || ', ';
      END IF;

      query :=
         query || '    cdnUtMod = ' || ut || ', ' || '    dtmMod = TO_DATE(''' || TO_CHAR (adesso,
         'DD/MM/YYYY HH24:MI') || ''', ''DD/MM/YYYY HH24:MI'') ' || queryWhere;

      EXECUTE IMMEDIATE query;
   END updateRifTestata;


   /*
    * Cancella tutti i riferimenti a prgUnitaAccorpata
    * nella tabella data
    */
   PROCEDURE deleteRif (nomeTabella IN ALL_TAB_COLS.TABLE_NAME%TYPE, prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE,
      prgUniAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE, ut IN TS_UTENTE.CDNUT%TYPE)
   IS
      query          VARCHAR2 (1024);
      queryWhere     VARCHAR2 (255);
   BEGIN
      queryWhere := ' WHERE PRGAZIENDA = ' || prgAziAccorpata || ' AND   PRGUNITA   = ' || prgUniAccorpata;

      PG_LOG.doLog ('D', nomeTabella, ut, queryWhere);

      query := 'DELETE FROM ' || nomeTabella || queryWhere;

      EXECUTE IMMEDIATE query;
   END deleteRif;


   PROCEDURE allineaSedeLegale (ut IN TS_UTENTE.CDNUT%TYPE, prgAz IN AN_AZIENDA.PRGAZIENDA%TYPE,
      prgUnitaAccorpante IN AN_UNITA_AZIENDA.PRGUNITA%TYPE, prgUnitaAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
      adesso IN DATE)
   IS
      sedeAccorpante CHAR (1) := 'N';
      sedeAccorpata  CHAR (1) := 'N';
   BEGIN
      -- vedo se l'accorpante è sede
      SELECT NVL (FLGSEDE, 'N')
        INTO sedeAccorpante
        FROM AN_UNITA_AZIENDA
       WHERE PRGAZIENDA = prgAz AND PRGUNITA = prgUnitaAccorpante;

      -- vedo se l'accorpata è sede
      SELECT NVL (FLGSEDE, 'N')
        INTO sedeAccorpata
        FROM AN_UNITA_AZIENDA
       WHERE PRGAZIENDA = prgAz AND PRGUNITA = prgUnitaAccorpata;

      /* CASISTICHE:
       *   accorpata='S', accorpante='S':  impossibile
       *   accorpata='N', accorpante='N': tutto ok, non faccio niente
       *   accorpata='N', accorpante='S': l'indicazione della sede è preservata, non faccio niente
       *   accorpata='S', accorpante='N': sposto la sede legale nell'accorpante
       */
      IF ( (sedeAccorpata = 'S') AND (sedeAccorpante = 'N'))
      THEN                                                                           -- sposto la sede nell'accorpante
         PG_LOG.doLog ('U', 'AN_UNITA_AZIENDA', ut, ' WHERE PRGAZIENDA = ' || prgAz || ' AND   PRGUNITA   = ' || prgUnitaAccorpata);

         UPDATE AN_UNITA_AZIENDA
            SET FLGSEDE = 'N', NUMKLOUNITAAZIENDA = NUMKLOUNITAAZIENDA + 1, CDNUTMOD = ut,
                DTMMOD = TO_DATE (adesso, 'DD/MM/YYYY HH24:MI')
          WHERE PRGAZIENDA = prgAz AND PRGUNITA = prgUnitaAccorpata;

         PG_LOG.doLog ('U', 'AN_UNITA_AZIENDA', ut, ' WHERE PRGAZIENDA = ' || prgAz || ' AND   PRGUNITA   = ' || prgUnitaAccorpante);

         UPDATE AN_UNITA_AZIENDA
            SET FLGSEDE = 'S', NUMKLOUNITAAZIENDA = NUMKLOUNITAAZIENDA + 1, CDNUTMOD = ut,
                DTMMOD = TO_DATE (adesso, 'DD/MM/YYYY HH24:MI')
          WHERE PRGAZIENDA = prgAz AND PRGUNITA = prgUnitaAccorpante;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END allineaSedeLegale;

   /*
     * Aggiorna la AN_UA_STORIA_INF per riflettere le modifiche ALL'UNITA' dovute a un accorpamento
     * GG 14/9/04
     * Invalidata a causa della specifica che "devono essere
     * cancellati i record che fanno riferimento all'unità".
    PROCEDURE updateStoriaUnita(ut IN TS_UTENTE.CDNUT%TYPE,
                                prgAziAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
                                prgAziAccorpata  IN AN_AZIENDA.PRGAZIENDA%TYPE,
                                prgUniAccorpante IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
                                prgUniAccorpata  IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
                                adesso IN DATE)
    IS
    BEGIN
         *
         * In una sola mossa:
         *  a) effettuo la chiusura della data
         *  b) assegno tutti i record storici dell'unita' accorpata all'accorpante
         *
        UPDATE AN_UA_STORIA_INF
        SET DATFINE = NVL(DATFINE, adesso),
            prgAzienda = prgAziAccorpante,
            prgUnita   = prgUniAccorpante,
            NUMKLOUASTORIAINF = NUMKLOUASTORIAINF + 1,
            cdnUtMod = ut,
            dtmMod = TO_DATE(TO_CHAR(adesso,'DD/MM/YYYY'),'DD/MM/YYYY')
        WHERE prgAzienda = prgAziAccorpata
        AND   prgUnita   = prgUniAccorpata;
    END updateStoriaUnita;
    */


   /*
    * Aggiorna la AN_AZ_STORIA_INF per riflettere le modifiche alla TESTATA dovute a un accorpamento
    * GG 14/9/04
    * Invalidata a causa della specifica che "devono essere
    * cancellati i record che fanno riferimento all'unità".
   PROCEDURE updateStoriaTestata(ut IN TS_UTENTE.CDNUT%TYPE,
                                   prgAziAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
                                   prgAziAccorpata  IN AN_AZIENDA.PRGAZIENDA%TYPE,
                                   adesso IN DATE)
   IS
   BEGIN
        *
        * In una sola mossa:
        *  a) effettuo la chiusura della data
        *  b) assegno tutti i record storici della testata accorpata all'accorpante
        *
       UPDATE AN_AZ_STORIA_INF
       SET DATFINE = NVL(DATFINE, adesso),
           prgAzienda = prgAziAccorpante,
           NUMKLOAZSTORIAINF = NUMKLOAZSTORIAINF + 1,
           cdnUtMod = ut,
           dtmMod = TO_DATE(TO_CHAR(adesso,'DD/MM/YYYY'),'DD/MM/YYYY')
       WHERE PRGAZIENDA = prgAziAccorpata;
   END updateStoriaTestata;
   */


   /*
    * Cancella la AN_UA_STORIA_INF dopo l'accorpamento.
    */
   PROCEDURE deleteStoriaUnita (ut IN TS_UTENTE.CDNUT%TYPE, prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE,
      prgUniAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE)
   IS
   BEGIN
      PG_LOG.doLog ('D', 'AN_UA_STORIA_INF', ut, ' WHERE PRGAZIENDA = ' || prgAziAccorpata || ' AND   PRGUNITA   = ' || prgUniAccorpata);

      DELETE FROM AN_UA_STORIA_INF
            WHERE PRGAZIENDA = prgAziAccorpata AND PRGUNITA = prgUniAccorpata;
   END deleteStoriaUnita;


   /*
    * Cancella la AN_AZ_STORIA_INF dopo l'accorpamento.
    */
   PROCEDURE deleteStoriaTestata (ut IN TS_UTENTE.CDNUT%TYPE, prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE)
   IS
   BEGIN
      PG_LOG.doLog ('D', 'AN_AZ_STORIA_INF', ut, ' WHERE PRGAZIENDA = ' || prgAziAccorpata);

      DELETE FROM AN_AZ_STORIA_INF
            WHERE PRGAZIENDA = prgAziAccorpata;
   END deleteStoriaTestata;

   /*
   Il constraint 'doppio' sulla CI_LAVORATORE impone di sbiancarne i riferimenti alle accorpate prima di
   eseguire l'aggiornamento della CI_REL_ACCORDO_UNIT_AZ. Prima di annullare salvo in array i valori
   e li ripristino. La funzione torna -3 in caso di qualunque errore
   */
   FUNCTION sposta_cig_az (ut IN TS_UTENTE.CDNUT%TYPE, prgAziendaAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
      prgAziendaAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE, prgUnitaAccorpante IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
      prgUnitaAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE, adesso IN DATE, debug_only IN BOOLEAN := FALSE)
      RETURN NUMBER
   IS
      TYPE ci_lav_type IS TABLE OF CI_LAVORATORE.PRGLAVORATORE%TYPE
                             INDEX BY PLS_INTEGER;

      cursore_saved  ci_lav_type;
      cur_count      PLS_INTEGER;
      strupdate      VARCHAR2 (2000);
   -- cur_count_rev   PLS_INTEGER;
   BEGIN
      cur_count := 0;

      /* conto e salvo */
      FOR to_save IN (SELECT PRGLAVORATORE
                        FROM CI_LAVORATORE
                       WHERE PRGAZIENDA = prgAziendaAccorpata AND PRGUNITA = prgUnitaAccorpata)
      /* Tolgo i riferimenti salvati, per poter aggiornare CI_REL_ACCORDO_UNIT_AZ . Poteva essere una query unica, ma così è più leggibile ci piace la simmetria*/
      LOOP
         cursore_saved (cur_count) := to_save.PRGLAVORATORE;
         cur_count := cur_count + 1;
         strupdate := ('UPDATE CI_LAVORATORE SET NUMKLOLAVORATORE=NUMKLOLAVORATORE+1, prgazienda = null, prgunita=null WHERE PRGLAVORATORE = ' || to_save.PRGLAVORATORE);

         IF (debug_only)
         THEN
            DBMS_OUTPUT.put_line (strupdate);
         ELSE
            EXECUTE IMMEDIATE (strupdate);
         END IF;
      END LOOP;

      IF (debug_only)
      THEN
         NULL;
      ELSE
         /* chiamo sposta rif sulla CI_REL */
         updateRif ('CI_REL_ACCORDO_UNIT_AZ', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, NULL, NULL);
      END IF;

      /* Ripristino dalla tabella di appoggio */
      FOR cur_count_rev IN REVERSE 0 .. cur_count - 1
      LOOP
         strupdate :=
            ('UPDATE CI_LAVORATORE SET  NUMKLOLAVORATORE=NUMKLOLAVORATORE+1, PRGAZIENDA = ' || prgAziendaAccorpante || ' ,PRGUNITA= ' ||
             prgUnitaAccorpante || ' WHERE PRGLAVORATORE = ' || cursore_saved (cur_count_rev));

         IF (debug_only)
         THEN
            DBMS_OUTPUT.put_line (strupdate);
         ELSE
            EXECUTE IMMEDIATE (strupdate);
         END IF;
      END LOOP;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         DBMS_OUTPUT.PUT_LINE('ERR'||sqlerrm);
         RETURN -2;
   END;


    PROCEDURE AccorpaIscrizionirecall(ut IN TS_UTENTE.CDNUT%TYPE, saved_tab am_altra_type, cur_count IN PLS_INTEGER, days_of_tolerance IN INTEGER := 0, isdebug IN BOOLEAN := true )
    IS
      check_iscr INTEGER;
      ret_val   INTEGER;
      am_altra_row AM_ALTRA_ISCR%rowtype;
      prgaltrato        AM_ALTRA_ISCR.PRGALTRAISCR%type;
      data_inizio_start DATE;
      data_inizio_end DATE;
      data_fine_start DATE;
      data_fine_end DATE;
      
      tgtaz     AN_AZIENDA.PRGAZIENDA%TYPE;
      
      strcodfisc AN_AZIENDA.STRCODICEFISCALE%TYPE;
      ragsoc    AN_AZIENDA.STRRAGIONESOCIALE%TYPE;
    BEGIN
   
     FOR cur_count_rev IN REVERSE 0 .. cur_count - 1
      LOOP
      
            SELECT * into am_altra_row FROM AM_ALTRA_ISCR WHERE PRGALTRAISCR = saved_tab(cur_count_rev);
            data_inizio_start := am_altra_row.datinizio - days_of_tolerance;
            data_inizio_end  := am_altra_row.datinizio + days_of_tolerance;
            data_fine_start   := am_altra_row.datfine - days_of_tolerance;
            data_fine_end := am_altra_row.datfine + days_of_tolerance;
            check_iscr := 0;
            
            SELECT count(1) INTO check_iscr from AM_ALTRA_ISCR WHERE PRGAZIENDA = am_altra_row.PRGAZIENDA  AND
            PRGACCORDO is NOT null AND CDNLAVORATORE = am_altra_row.CDNLAVORATORE AND datinizio >= data_inizio_start AND datinizio <= data_inizio_end AND
            datfine >= data_fine_start AND datfine <= data_fine_end;
           
            if (check_iscr = 1) then
               
             SELECT PRGALTRAISCR,PRGAZIENDA INTO prgaltrato, tgtaz from AM_ALTRA_ISCR WHERE PRGAZIENDA = am_altra_row.PRGAZIENDA AND
                PRGACCORDO is NOT null AND CDNLAVORATORE = am_altra_row.CDNLAVORATORE AND datinizio >= data_inizio_start AND datinizio <= data_inizio_end AND
                datfine >= data_fine_start AND datfine <= data_fine_end;
             
             SELECT STRCODICEFISCALE , STRRAGIONESOCIALE INTO strcodfisc, ragsoc FROM AN_AZIENDA WHERE PRGAZIENDA = tgtaz;
             
             if (isdebug) then
                     DBMS_OUTPUT.PUT_LINE('Lancio accorpamento iscrizione '||am_altra_row.PRGALTRAISCR || ' verso '||prgaltrato);
                end if;
                /* Mal che vada torna -5 */
                ret_val := PG_ACCORPA_LAVORATORE.ACCORPA_ISCRIZIONE(am_altra_row.CDNLAVORATORE, am_altra_row.PRGALTRAISCR, prgaltrato, ut);
                if (ret_val >=0) then
                 
                 UPDATE AM_ALTRA_ISCR SET STRNOTA = STRNOTA || '- Accorpata iscrizione manuale a seguito di accorpamento testate con 
                    l''azienda: '||ragsoc||' ('||strcodfisc||') in data '||TO_CHAR(sysdate,'dd/mm/yyyy'), NUMKLOALTRAISCR = NUMKLOALTRAISCR+1 WHERE PRGALTRAISCR = prgaltrato;
                end if;
              if (isdebug) then
                     DBMS_OUTPUT.PUT_LINE('Iscrizione '||am_altra_row.PRGALTRAISCR || ' accorpata. Esito: '||ret_val);
                end if;
           elsif (isdebug) then
                DBMS_OUTPUT.PUT_LINE('Iscrizione corrispondente non trovata/troppe. Count= '||check_iscr);
           end if;
                      
            
      END LOOP;
      EXCEPTION
      WHEN OTHERS then
        DBMS_OUTPUT.PUT_LINE('ERR'||sqlerrm);
        
    END AccorpaIscrizionirecall;
   /*
    * Sposta tutti i riferimenti all'unita' verso una nuova unita'.
    */
   FUNCTION spostaRiferimenti (ut IN TS_UTENTE.CDNUT%TYPE, prgAziendaAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
      prgAziendaAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE, prgUnitaAccorpante IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
      prgUnitaAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE, adesso IN DATE)
      RETURN NUMBER
   IS
     
      cur_count      PLS_INTEGER;
      tmp_count     PLS_INTEGER;
      cursore_saved  am_altra_type;
      cig_ret_val    NUMBER;
      checkRegione   DE_PROVINCIA.CODREGIONE%TYPE;
   BEGIN
      updateRif ('AG_AGENDA', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOAGENDA', adesso);
      updateRif ('AG_CONTATTO', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOCONTATTO', adesso);
      /*
       * MAURO (26/03/2007): INIZIO GESTIONE NUOVI MODULI COLLOCAMENTO MIRATO
       */
      updateRif ('CM_CONVENZIONE', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOCONV', adesso);
      updateRif ('CM_RICH_COMPUTO', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLORICHCOMPUTO', adesso);
      updateRif ('CM_NULLA_OSTA', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLONULLAOSTA', adesso);
      updateRif ('CM_NULLA_OSTA', ut, 'prgAziendaUtiliz', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnitaUtiliz', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLONULLAOSTA', adesso);

      updateRifTestata ('CM_RICH_COMP_TERR', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'NUMKLOCOMPTERR', adesso);
      updateRifTestata ('CM_RICH_ESONERO', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'NUMKLOESONERO', adesso);
      updateRifTestata ('CM_RICH_GRADUALITA', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'NUMKLOGRADUALITA', adesso);
      updateRif ('CM_UNITA_SOSPENSIONE', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, NULL, NULL);
      updateRifTestata ('CM_RICH_SOSPENSIONE', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'NUMKLOSOSPENSIONE', adesso);

      /*
       * DONATO 04/04/2008
       * spostata all'interno delle procedure di accorpamento per diversificare il comportamento
       * nel caso di accorpamento unita oppure testata
       */
      --updateRif('CM_PROSPETTO_INF', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOPROSPETTOINF', adesso);
      /*
       * MAURO (26/03/2007): FINE GESTIONE NUOVI MODULI COLLOCAMENTO MIRATO
       */
      updateRif ('AM_DOCUMENTO', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLODOCUMENTO', adesso);
      updateRif ('AM_DOMANDA_REGISTRO_COM', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLODOMANDAREGCOMM', adesso);

      updateRif ('AM_MOBILITA_ISCR', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOMOBISCR', adesso);
      updateRif ('AM_MOVIMENTO_MISSIONE', ut, 'prgAziendaUtiliz', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnitaUtiliz', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOMIS', adesso);
      updateRif ('AM_MOVIMENTO', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOMOV', adesso);
      updateRif ('AM_MOVIMENTO', ut, 'prgAziendaUtiliz', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnitaUtiliz', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOMOV', adesso);

      updateRif ('AM_MOVIMENTO', ut, 'prgAziendaDist', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnitaDist', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOMOV', adesso);

      updateRif ('AM_UA_AUTORIZZAZIONE', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOAUTORIZ', adesso);
      updateRif ('AM_UA_PATTO', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOPATTOUNITAAZIENDALE', adesso);
      updateRif ('DO_RICHIESTA_AZ', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLORICHIESTAAZ', adesso);
      updateRif ('DO_LAV_STORIA_ROSA', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, NULL, NULL);

      /* ALESSANDRO PEGORARO
      26/01/2011 */
       /* Gestione constraint bidirezionale CI_REL_AZIENDA, DEBUG_ONLY a FALSE*/
      cig_ret_val :=
         sposta_cig_az (ut, prgAziendaAccorpante, prgAziendaAccorpata, prgUnitaAccorpante, prgUnitaAccorpata, adesso, false);


        
      IF (cig_ret_val < 0)
      THEN
         RETURN cig_ret_val;
      END IF;
      
      cur_count:=0;
      
      /* CHE CASIN -> trovo iscrizioni senza accordo UNICHE dell'accorpato, che verranno integrate con quelle dell'azienda accorpante */
      FOR moved_iscr IN (SELECT * from am_altra_iscr where PRGAZIENDA = prgAziendaAccorpata AND  PRGUNITA = prgUnitaAccorpata AND PRGACCORDO IS NULL)
      loop
        
        SELECT COUNT(1) INTO tmp_count from am_altra_iscr where PRGAZIENDA = prgAziendaAccorpata AND  PRGUNITA = prgUnitaAccorpata AND PRGACCORDO IS NULL
        AND PRGALTRAISCR <> moved_iscr.PRGALTRAISCR;
        /* Se è unica la aggiungo al set da spostare */
        
        if (tmp_count = 0) then
            cursore_saved(cur_count) := moved_iscr.PRGALTRAISCR;
            cur_count := cur_count + 1;
        end if;
      end loop;
      
      /*GESTIONE AM_ALTRA_ISCR per accorpamento CIG */
      updateRif ('AM_ALTRA_ISCR', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOALTRAISCR', adesso);
         
      -- VERIFICO REGIONE
       SELECT NVL ( (SELECT NVL (num, 0)
                       FROM ts_config_loc loc JOIN ts_generale ts ON ts.codprovinciasil = LOC.STRCODRIF
                      WHERE codtipoconfig = 'OR_CIG'), 0)
         INTO checkRegione
         FROM DUAL;
           
         /* Precondizione per acc.iscrizioni: non è accorpamento unità E siamo in RER */
         if (prgAziendaAccorpante<>prgAziendaAccorpata AND checkregione = 1) then
             DBMS_OUTPUT.PUT_LINE('Lancio accorpamento iscrizioni,count='||cur_count);
            /* Passo tutte le iscrizioni rilevate, uniche E con PRGACCORDO NULL*/
            accorpaiscrizionirecall(ut, cursore_saved, cur_count, 10);
         else 
            DBMS_OUTPUT.PUT_LINE('NON Lancio accorpamento iscrizioni,prgAziendaAccorpata='||prgAziendaAccorpata||' prgAziendaAccorpante:  '||prgAziendaAccorpante);
         end if;
        /* Fine parte CIG */

      /*
       * (punto "da verificare"):
       * Nel caso l'unita' di destinazione appartenga alla STESSA AZIENDA,
       *   cancello tali riferimenti.
       * altrimenti
       *   aggiorno alcune tabelle in piu'.
       */
      IF prgAziendaAccorpante = prgAziendaAccorpata
      THEN
         --deleteRif('AN_AZ_REFERENTE',       prgAziendaAccorpata, prgUnitaAccorpata, ut);
         deleteRif ('AN_AZI_AUTORIZZAZIONE', prgAziendaAccorpata, prgUnitaAccorpata, ut);
      ELSE
         --updateRif('AN_AZ_REFERENTE',       ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, null,     adesso);
         updateRif ('AN_AZI_AUTORIZZAZIONE', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLO', adesso);
      END IF;

      /* Punto verificato
       * Ireferenti vanno sempre aggiunti "in coda"
      */
      updateRif ('AN_AZ_REFERENTE', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, NULL, adesso);
      RETURN 0;
      
   END spostaRiferimenti;


   /*
    * Sposta tutti i riferimenti alla testata verso una nuova testata.
    */
   PROCEDURE spostaRiferimentiTestata (ut IN TS_UTENTE.CDNUT%TYPE, prgAziendaAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
      prgAziendaAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE, adesso IN DATE)
   IS
      CURSOR rifTestata
      IS
         SELECT CDNLAVORATORE
           FROM PR_INDISPONIBILITA
          WHERE PRGAZIENDA = prgAziendaAccorpata;
   BEGIN
      FOR rifTestataRow IN rifTestata
      LOOP
         updateRifTestataXLav ('PR_INDISPONIBILITA', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, rifTestataRow.CDNLAVORATORE, NULL, adesso);
      END LOOP;
   END spostaRiferimentiTestata;


   /*
    * Aggiorna il campo HISTORY dell'AziendaAccorpante con i dati dell'AziendaAccorpata.
 * Regola: HistoryNuovo := HistoryNuovo(corrente) + RagSocVecchia + HistoryVecchia
    */
   PROCEDURE updateHistory (ut IN TS_UTENTE.CDNUT%TYPE, prgAziendaAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
      prgAziendaAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE, adesso IN DATE)
   IS
      ragsocVec      AN_AZIENDA.STRRAGIONESOCIALE%TYPE;
      hisVec         AN_AZIENDA.STRHISTORY%TYPE;
      SEPARATORE     VARCHAR2 (2) := CHR (10) || CHR (13);
   BEGIN
      -- Recupero i dati dell'azienda che verrà cancellata
      SELECT STRRAGIONESOCIALE, STRHISTORY
        INTO ragsocVec, hisVec
        FROM AN_AZIENDA
       WHERE PRGAZIENDA = prgAziendaAccorpata;

      -- Aggiorno HISTORY dell'azienda accorpante con la regola:
      --   HistoryNuovo := HistoryNuovo(corrente) + RagSocVecchia + HistoryVecchia
      -- PS: il SEPARATORE viene messo solo se necessario;
      --     la SUBSTR serve per evitare errori di 'inserted value too large for column'.
      UPDATE AN_AZIENDA
         SET STRHISTORY = SUBSTR (STRHISTORY || DECODE (STRHISTORY, NULL, NULL, SEPARATORE) || 'In data ' || TO_CHAR (adesso, 'DD/MM/YYYY') || ' accorpata azienda ' || ragsocVec || DECODE (hisVec, NULL, NULL, SEPARATORE) || hisVec, 1, 2000),
             NUMKLOAZIENDA = NUMKLOAZIENDA + 1, CDNUTMOD = ut, DTMMOD = TO_DATE (adesso, 'DD/MM/YYYY HH24:MI')
       WHERE PRGAZIENDA = prgAziendaAccorpante;
   END updateHistory;



   /*
    *******************************************************
    * PUBLIC                                              *
    *******************************************************
    */

   FUNCTION AccorpaUnitaAziende (ut IN TS_UTENTE.CDNUT%TYPE, prgAz IN AN_AZIENDA.PRGAZIENDA%TYPE,
      prgUnitaAccorpante IN AN_UNITA_AZIENDA.PRGUNITA%TYPE, prgUnitaAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE)
      RETURN NUMBER
   IS
      checkCig       NUMBER;
      checkRet       NUMBER;
      adesso         DATE := SYSDATE;
      checkRegione   DE_PROVINCIA.CODREGIONE%TYPE;
      codcomaccnte DE_COMUNE.CODCOM%TYPE;
      codcomaccta   DE_COMUNE.CODCOM%TYPE;
   BEGIN
      -- VERIFICO CHE L'AZIENDA DA ACCORPARE NON SIA COINVOLTA IN ALCUNA ISCRIZIONE CIG NON MANUALE
       SELECT COUNT (CIG.PRGALTRAISCR)
         INTO checkCig
         FROM AM_ALTRA_ISCR CIG
        WHERE CIG.PRGAZIENDA = prgAz AND CIG.PRGUNITA = prgUnitaAccorpata AND CIG.prgACCORDO IS NOT NULL;

       -- VERIFICO COMUNI
       SELECT UNIT.CODCOM
         INTO codcomaccnte
         FROM AN_UNITA_AZIENDA unit
         WHERE UNIT.PRGAZIENDA = prgAz AND UNIT.PRGUNITA = prgUnitaAccorpante;
         
         SELECT UNIT.CODCOM
         INTO codcomaccta
         FROM AN_UNITA_AZIENDA unit
         WHERE UNIT.PRGAZIENDA = prgAz AND UNIT.PRGUNITA = prgUnitaAccorpata;

       --SE Regione = ER e c'è iscr.CIG -> BLOCCO
       IF ( (checkCig != 0) AND ( codcomaccnte <> codcomaccta ))
       THEN
          RETURN -2;
       END IF;

      -- Faccio il controllo e l'allineamento su eventuali sede legali coinvolte
      allineaSedeLegale (ut, prgAz, prgUnitaAccorpante, prgUnitaAccorpata, adesso);

      -- non più: udateStoriaUnita(), ora uso la deleteStoriaUnita

      -- Cambio tutte le entita' che riferiscono all'unita' corrente (li redireziono sulla nuova unita')
      checkRet := spostaRiferimenti (ut, prgAz, prgAz, prgUnitaAccorpante, prgUnitaAccorpata, adesso);

      IF (checkRet < 0)
      THEN
         RETURN checkRet;
      END IF;

      -- cambio i riferimenti all'interno del prospetto
      updateRifProspetto ('AccorpaUnitaAziende', 'CM_PROSPETTO_INF', ut, 'prgAzienda', prgAz, prgAz, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOPROSPETTOINF', adesso);

      -- Cancello lo Storico dell'Unita'
      deleteStoriaUnita (ut, prgAz, prgUnitaAccorpata);

      -- Cancello l'unità accorpata.
      deleteRif ('AN_UNITA_AZIENDA', prgAz, prgUnitaAccorpata, ut);

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END AccorpaUnitaAziende;


   FUNCTION AccorpaTestateAziende (ut IN TS_UTENTE.CDNUT%TYPE,
      prgAziendaAccorpante IN AN_UNITA_AZIENDA.PRGAZIENDA%TYPE,
      prgAziendaAccorpata IN AN_UNITA_AZIENDA.PRGAZIENDA%TYPE)
      RETURN NUMBER
   IS
      prgUnitaAccorpante AN_UNITA_AZIENDA.PRGUNITA%TYPE;
      prgUnitaAccorpata AN_UNITA_AZIENDA.PRGUNITA%TYPE;
      checkCig       NUMBER;
      checkRet       NUMBER;
      checkRegione   NUMBER;

      CURSOR unitaAziendaCursor
      IS
         SELECT *
           FROM AN_UNITA_AZIENDA
          WHERE PRGAZIENDA = prgAziendaAccorpata;

      adesso         DATE := SYSDATE;
   BEGIN
      -- VERIFICO CHE L'AZIENDA DA ACCORPARE NON SIA COINVOLTA IN ALCUNA ISCRIZIONE CIG NON MANUALE
        SELECT COUNT (CIG.PRGALTRAISCR)
          INTO checkCig
          FROM AM_ALTRA_ISCR CIG
         WHERE CIG.PRGAZIENDA = prgAziendaAccorpata AND CIG.PRGACCORDO is NOT NULL;

/*
        -- VERIFICO REGIONE  -> CICALE SIC FACERE DIXIT
        --Donato: se id facere dixit, ut bella intestina vitaret
        --select  pr.codregione INTO checkRegione from ts_generale ts join de_provincia pr on pr.codprovincia = ts.codprovinciasil;
        SELECT NVL ( (SELECT NVL (num, 0)
                        FROM ts_config_loc loc JOIN ts_generale ts ON ts.codprovinciasil = LOC.STRCODRIF
                       WHERE codtipoconfig = 'OR_CIG'),
                    0)
          INTO checkRegione
          FROM DUAL;
*/
        IF ( (checkCig != 0))
        THEN
           RETURN -2;
        END IF;


      -- non più: updateStoriaTestata()

      -- 1 Per tutte le unita' locali legate alla azienda AZ2,
      FOR unita2row IN unitaAziendaCursor
      LOOP
         -- 1.a Creo una nuova unita' IN AZ1 usando le info correnti IN unita2row
         -- Nota1: prendo un codice usando la stessa query "SELECT_AN_UNITA_AZIENDA_SEQUENCE"
         -- Nota2: reimposto a 'no' la flag di sede legale! AZ1 ne ha gia' una!
         -- Nota3: imposto "ut" come inserimento e modifica e imposto NUMKLOUNITAAZIENDA a NULL

         prgUnitaAccorpata := unita2row.PRGUNITA;

         SELECT MAX (PRGUNITA) || DECODE (MAX (PRGUNITA), NULL, 0) + 1
           INTO prgUnitaAccorpante
           FROM AN_UNITA_AZIENDA
          WHERE PRGAZIENDA = prgAziendaAccorpante;

         INSERT INTO AN_UNITA_AZIENDA (PRGAZIENDA, PRGUNITA, STRINDIRIZZO, FLGSEDE, STRREA, STRLOCALITA, CODCOM,
                        STRCAP, FLGMEZZIPUB, CODAZSTATO, STRRESPONSABILE, STRREFERENTE, STRTEL, STRFAX, STREMAIL,
                        CODATECO, DATINIZIO, DATFINE, STRNOTE, CDNUTINS, DTMINS, CDNUTMOD, DTMMOD, NUMKLOUNITAAZIENDA,
                        STRNUMEROINPS, STRNUMREGISTROCOMMITT, DATREGISTROCOMMIT, STRRIFERIMENTOSARE, STRREPARTOINPS)
              VALUES (prgAziendaAccorpante, prgUnitaAccorpante, unita2row.STRINDIRIZZO, 'N', unita2row.STRREA,
                      unita2row.STRLOCALITA, unita2row.CODCOM, unita2row.STRCAP, unita2row.FLGMEZZIPUB,
                      unita2row.CODAZSTATO, unita2row.STRRESPONSABILE, unita2row.STRREFERENTE, unita2row.STRTEL,
                      unita2row.STRFAX, unita2row.STREMAIL, unita2row.CODATECO, unita2row.DATINIZIO,
                      unita2row.DATFINE, unita2row.STRNOTE, ut, adesso, ut, adesso, NULL, unita2row.STRNUMEROINPS,
                      unita2row.STRNUMREGISTROCOMMITT, unita2row.DATREGISTROCOMMIT, unita2row.STRRIFERIMENTOSARE,
                      unita2row.STRREPARTOINPS);

         -- 1.b Modifico lo Storico dell'Unita'
         -- non più: udateStoriaUnita(ut, prgAziendaAccorpante, prgAziendaAccorpata, prgUnitaAccorpante, prgUnitaAccorpata, adesso);

         -- 1.c Cambio tutte le entita' che riferiscono all'unita' corrente (li redireziono sulla nuova unita')
         checkRet :=
            spostaRiferimenti (ut, prgAziendaAccorpante, prgAziendaAccorpata, prgUnitaAccorpante, prgUnitaAccorpata,
            adesso);

         IF (checkRet < 0)
         THEN
            RETURN checkRet;
         END IF;



         -- 1.1.1 cambio i riferimenti all'interno del prospetto
         updateRifProspetto ('AccorpaTestateAziende', 'CM_PROSPETTO_INF', ut, 'prgAzienda', prgAziendaAccorpante, prgAziendaAccorpata, 'prgUnita', prgUnitaAccorpante, prgUnitaAccorpata, 'NUMKLOPROSPETTOINF', adesso);


         -- 1.d Cancello lo Storico dell'Unita'
         deleteStoriaUnita (ut, prgAziendaAccorpata, prgUnitaAccorpata);

         -- 1.e Rimuovo l'unita' accorpata.
         deleteRif ('AN_UNITA_AZIENDA', prgAziendaAccorpata, prgUnitaAccorpata, ut);
      END LOOP;

      -- 1.1 Cambio i riferimenti alla TESTATA dell'azienda (non alla sola unità)
      spostaRiferimentiTestata (ut, prgAziendaAccorpante, prgAziendaAccorpata, adesso);


      -- 1.2 Accodo al campo HISTORY di AZ1 la ragione sociale di AZ2.
      updateHistory (ut, prgAziendaAccorpante, prgAziendaAccorpata, adesso);

      -- 2.0 Cancello lo Storico della Testata
      deleteStoriaTestata (ut, prgAziendaAccorpata);

      -- 2.1 Rimuovo la Testata dell'azienda AZ2
      PG_LOG.doLog ('D', 'AN_AZIENDA', ut, ' WHERE PRGAZIENDA = ' || prgAziendaAccorpata);

      DELETE FROM AN_AZIENDA
            WHERE PRGAZIENDA = prgAziendaAccorpata;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         DBMS_OUTPUT.PUT_LINE(sqlerrm);
         RAISE;
   END AccorpaTestateAziende;
END PG_ACCORPAMENTO;
/






/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_AGENDA.sql
************************************************************************************** */


create or replace package PG_AGENDA AS

function giornoDistGGLavDaDataCpi (
    in_date in date,
    in_numerogiornilavdadata in integer,
    in_cpi in de_cpi.codcpi%type) RETURN date;

function ao_effettuaControlliCoerenza (
    
    in_codProvincia in de_provincia.codProvincia%type,
    in_prgSlot in ag_slot.prgSlot%type,
    in_codCpi in de_cpi.codCpi%type,
    in_cdnLavoratore in an_lavoratore.cdnlavoratore%type,
    in_codComDomLav in de_comune.codCom%type,
    in_codComResLav in de_comune.codCom%type,
    in_codComNasLav in de_comune.codCom%type,
    in_cittadinanzaLav in de_comune.codCom%type,
    in_lavoratoreAzienda in varchar2,
	in_codiceRichiesta in varchar2,
    ErrCodeOut OUT varchar2
    
  ) return number;

function ao_registraAppuntamento (
  
    in_codCpi in de_cpi.codCpi%type,
    in_prgSlot in ag_slot.prgSlot%type,
    in_cdnlavoratore in an_lavoratore.cdnlavoratore%type,
    in_prgAzienda in an_unita_azienda.prgazienda%type,
    in_prgUnita in an_unita_azienda.prgunita%type,
    in_strEmail in ag_agenda.stremailrif%type,
    in_strCell in ag_agenda.strtelmobilerif%type,
	in_doCommit in varchar2,
    
    out_strDescrizioneCpi OUT varchar2,
    out_strIndirizzoCpi OUT varchar2,
    out_strIndirizzoStampaCpi OUT varchar2,
    out_strTelCpi OUT varchar2,
    
    out_strIsSpiServizioDisp OUT varchar2,
    out_prgSpiServizio OUT an_spi.prgSpi%type,
    out_strNomeSpiServizio OUT varchar2,
    out_strCognomeSpiServizio OUT varchar2,
    out_strTelSpiServizio OUT varchar2,
    out_strSiglaSpiServizio OUT varchar2,
    
    out_strIsSpiSlotDisp OUT varchar2,
    out_prgSpiSlot OUT an_spi.prgSpi%type,
    out_strNomeSpiSlot OUT varchar2,
    out_strCognomeSpiSlot OUT varchar2,
    out_strTelSpiSlot OUT varchar2,
    out_strSiglaSpiSlot OUT varchar2,
    
    out_strAmbiente OUT varchar2,
	
	out_prgAppuntamento OUT ag_agenda.prgAppuntamento%TYPE,
    
    ErrCodeOut OUT varchar2
    
  ) RETURN NUMBER;

function ao_findSlot (
  
			in_codiceRichiesta in varchar2,
      in_codProvincia in de_provincia.codProvincia%type,
			in_prgSlot in ag_slot.prgSlot%type,
			in_codCpi in de_cpi.codCpi%type,
			in_dataDa in varchar2,
			in_dataA in varchar2,
      in_mattinoPomeriggio in varchar2,
      in_lavoratoreAzienda in varchar2,
			out_prgSlot OUT ag_slot.prgSlot%type,
      out_strDataApp OUT varchar2,
      out_strOraApp OUT varchar2,
      out_strDurataApp OUT varchar2,
      out_codservizio OUT varchar2,
      out_descservizio OUT varchar2,
      ErrCodeOut OUT varchar2
      
  ) RETURN NUMBER;
	
function pdAppuntamentoDidOnline(
			in_cdnlavoratore in an_lavoratore.cdnlavoratore%type,
			in_cpilavoratore in de_cpi.codcpi%type,
      out_strNomeLav OUT varchar2,
      out_strCognome OUT varchar2,
      out_strCellLav OUT varchar2,
      out_strEmailLav OUT varchar2,
      out_strDescrizioneCpi OUT varchar2,
      out_strIndirizzoCpi OUT varchar2,
      out_strTelCpi OUT varchar2,
      out_strDataApp OUT varchar2,
      out_strOraApp OUT varchar2,
      out_strDurataApp OUT varchar2,
      out_strCanSendSms OUT varchar2,
      out_strCanSendEmail OUT varchar2,
      out_strIsSpiDisponibile OUT varchar2,
      out_strNomeSpi OUT varchar2,
      out_strCognomeSpi OUT varchar2,
      out_strTelSpi OUT varchar2,
      ErrCodeOut OUT varchar2) RETURN NUMBER;

function pdAppuntamentoDaSlot(str_prgParSlot in varchar2,
			      str_codParCpi in varchar2,
			      str_prgParAzienda in varchar2,
			      str_prgParUnita in varchar2,
			      str_cdnParLavoratore in varchar2,
			      str_cdnParUtente in varchar2,
				  str_flgParLegaPatto in varchar2,
				  str_doCommit in varchar2,
			      prgParAppuntamento OUT varchar2,
			      codParCpiAppunt OUT varchar2,
			      ErrCodeOut OUT varchar2) RETURN NUMBER;
--
function pdAllineamentoSlot(codParCpi in AG_SLOT.codCpi%TYPE,
			    prgParAppuntamento in AG_AGENDA.prgAppuntamento%TYPE,
			    nParAllineaAppuntamento in integer,
			    codParVecchioStato in DE_STATO_APPUNTAMENTO.CODSTATOAPPUNTAMENTO%TYPE,
			    cdnParUtente in AG_SLOT.CDNUTINS%TYPE,
				flagCancella in integer,
			    ErrCodeOut OUT NUMBER) RETURN NUMBER;
--
function pdInserisciSlotDaSettimana(dataParInizioStr in varchar2,
			    	    dataParFineStr in varchar2,
			    	    codParSettimana in DE_SETTIMANA_TIPO.PRGSETTIPO%TYPE,
			    	    codParCpi in DE_SETTIMANA_TIPO.CODCPI%TYPE,
			    	    codParStatoSlot in AG_SLOT.CODSTATOSLOT%TYPE DEFAULT 'C',
			    	    cdnParUtente in AG_SLOT.CDNUTINS%TYPE,
			    	    ErrCodeOut OUT NUMBER) RETURN NUMBER;
--
function pdCancellaAppuntamento(codParCpi in AG_SLOT.codCpi%TYPE,
			    	prgParAppuntamento in AG_AGENDA.prgAppuntamento%TYPE,
			    	cdnParUtente in AG_SLOT.CDNUTMOD%TYPE,
			    	ErrCodeOut OUT NUMBER) RETURN NUMBER;
--
function pdCancellaSlotMassiva(codParCpi in AG_SLOT.codCpi%TYPE,
			       dataParInizioStr in varchar2,
			       dataParFineStr in varchar2,
			       codParServizio in AG_SLOT.CODSERVIZIO%TYPE,
			       prgSpiOperatore in AG_SPI_SLOT.PRGSPI%TYPE,
				   cdnParUtente in AG_SLOT.CDNUTINS%TYPE,
			       ErrCodeOut OUT NUMBER) RETURN NUMBER;
--
function pdFirstLavApp(p_codCpi in AG_AGENDA.CODCPI%type, p_prgAppuntamento in AG_AGENDA.PRGAPPUNTAMENTO%type) RETURN varchar2;
--
FUNCTION pdAppErr(p_codCpi in AG_AGENDA.CODCPI%type,
		 		  p_prgAppuntamento in AG_AGENDA.PRGAPPUNTAMENTO%type) RETURN varchar2;
--
FUNCTION pdSlotErr(p_codCpi in AG_SLOT.CODCPI%type,
		 		  p_prgSlot in AG_SLOT.PRGSLOT%type) RETURN varchar2;
--
function pdInsMultiploSlot(p_dataInizio in varchar2,
			    	    	p_dataFine in varchar2,
							p_prgSpi in varchar2,
							p_codServizio in varchar2,
							p_prgAmbiente in varchar2,
							p_numAzienda in varchar2,
							p_numLavoratori in varchar2,
							p_flgPubblico in varchar2,
							p_oraInizio in varchar2,
							p_oraFine in varchar2,
							p_numMinuti in varchar2,
							p_numQta in varchar2,
							p_codStatoSlot in varchar2,
			    	        p_codCpi in varchar2,
			    	        p_cdnUtente in varchar2,
			    	        strCodeOut OUT varchar2) RETURN NUMBER;
--

function ao_aggiornaAppuntamentoIdCoap (
  
    in_prgAppuntamento in ag_agenda.prgAppuntamento%TYPE,
    in_strIdCoap in ag_agenda.STRIDCOAP%type,
	cdnParUtente in ag_agenda.CDNUTMOD%type,
	in_doCommit in varchar2,
        
    ErrCodeOut OUT varchar2
    
  ) RETURN NUMBER;
--

end PG_AGENDA;
--
/

CREATE OR REPLACE PACKAGE BODY PG_AGENDA AS
  
  /**********************************************
  * RICERCA GIORNO DISTANTE N GIORNI LAVORATIVI *
  * A PARTIRE DA UNA DATA E UN DETERMINATO CPI  *
  **********************************************/
  
  function giornoDistGGLavDaDataCpi (
    in_date in date,
    in_numerogiornilavdadata in integer,
    in_cpi in de_cpi.codcpi%type) RETURN date IS
    
    currentdate date;
    isgiornononlavorativo integer := 0;
    numerogiornilavorativi integer := 0;
    
  BEGIN
    
    currentdate := trunc(in_date);
    
    LOOP
      
      EXIT WHEN numerogiornilavorativi >= in_numerogiornilavdadata;
      
      -----------------------------------
      -- INCREMENTA IL GIORNO CORRENTE --
      -----------------------------------
      
      currentdate := currentdate + 1;
      
      ----------------------------------------
      -- VERIFICA GIORNO NON LAVORATIVO     --
      -- 0 = lavorativo, 1 = non lavorativo --
      ----------------------------------------
      
      select count(*) into isgiornononlavorativo
      from ag_giornonl
      where 
      
        (codcpi = in_cpi)
      
      and (
      
        ( -- caso 1 (giorno nell'anno corrente)
          (numgg is not null and nummm is not null and numaaaa is not null) and
          TO_CHAR(currentdate,'dd', 'nls_date_language = english') = numgg and TO_CHAR(currentdate,'MM', 'nls_date_language = english') = nummm and TO_CHAR(currentdate,'yyyy', 'nls_date_language = english') = numaaaa and
          currentdate between datinizioval and datfineval
        )
        or
        ( -- caso 2 (giorno di ogni anno)
          (numgg is not null and nummm is not null and numaaaa is null) and
          TO_CHAR(currentdate,'dd', 'nls_date_language = english') = numgg and TO_CHAR(currentdate,'MM', 'nls_date_language = english') = nummm and
          currentdate between datinizioval and datfineval
        )
        or
        ( -- caso 3 (numero giorno della settimana di ogni anno, 6 sabato, 7 domenica)
          (numgsett is not null) and
          TO_CHAR(currentdate,'D', 'nls_date_language = english') = numgsett and
          currentdate between datinizioval and datfineval
        )
      );
      
      IF (isgiornononlavorativo = 0) THEN
        numerogiornilavorativi := numerogiornilavorativi + 1;
      END IF;
      
    END LOOP;
    
    return currentdate;
  
  EXCEPTION
  
    WHEN others THEN
      
      return null;
      
  END giornoDistGGLavDaDataCpi;
  
  /******************************************
  * APPUNTAMENTO ONLINE                 *
  ******************************************/
  
  function ao_effettuaControlliCoerenza (
    
    in_codProvincia in de_provincia.codProvincia%type,
    in_prgSlot in ag_slot.prgSlot%type,
    in_codCpi in de_cpi.codCpi%type,
    in_cdnLavoratore in an_lavoratore.cdnlavoratore%type,
    in_codComDomLav in de_comune.codCom%type,
    in_codComResLav in de_comune.codCom%type,
    in_codComNasLav in de_comune.codCom%type,
    in_cittadinanzaLav in de_comune.codCom%type,
    in_lavoratoreAzienda in varchar2,
	in_codiceRichiesta in varchar2,
    ErrCodeOut OUT varchar2
    
  ) return number is
    
    p_codregione_lav de_regione.codregione%type;
    p_codregione_sil de_regione.codregione%type;
    p_codprovincia_lav de_provincia.codprovincia%type;
    p_codcpidom_lav de_cpi.codcpi%type;
    p_codprovincia_sil de_provincia.codprovincia%type;
	pcodregione_sil ts_generale.codregionesil%type;
	p_flgpoloreg ts_generale.flgpoloreg%type;
	codregioneprov de_provincia.codregione%type;
	codregionecpi de_provincia.codregione%type;
    
    p_record_slot_tmp ag_slot%rowtype;
    p_record_cpi_tmp de_cpi%rowtype;
    
    p_codcom_tmp de_comune.codcom%type;
    p_codcittadinanza_tmp de_cittadinanza.codcittadinanza%type;
	
	p_competenza ts_config_loc.strValore%type;
        
  begin
  
   -- verifiche di coerenza
	BEGIN
      select codprovinciasil, codregionesil, nvl(flgpoloreg, 'N') as flgpoloreg
      into p_codprovincia_sil, pcodregione_sil, p_flgpoloreg
      from ts_generale;
    EXCEPTION
      when no_data_found then
        return -7;
    END;
	
	IF (p_flgpoloreg <> 'N') THEN
		select codregione
		into codregioneprov
		from de_provincia
		where codprovincia = in_codProvincia;
	END IF;
    
	IF (p_flgpoloreg = 'N') THEN
		IF (in_codProvincia != p_codprovincia_sil) THEN
		  -- provincia indicata diversa da provincia sil
		  return -8;
		END IF;
	ELSE
		IF (codregioneprov != pcodregione_sil) THEN
			-- provincia indicata non appartenente alla regione polo regionale
		  return -8;
		END IF;
	END IF;
   
	BEGIN
      select *
      into p_record_cpi_tmp
      from de_cpi
      where codCpi = in_codCpi;
    EXCEPTION
      when no_data_found then
        -- cpi non trovato
        return -3;
    END;
    
	IF (p_flgpoloreg = 'N') THEN
		IF (p_record_cpi_tmp.codProvincia != in_codProvincia) THEN
		  -- coerenza cpi-provincia
		  return -4;
		END IF;
	ELSE
		select de_provincia.codregione
		into codregionecpi
		from de_cpi
		inner join de_provincia on (de_cpi.codProvincia = de_provincia.codProvincia)
		where de_cpi.codCpi = in_codCpi;
		
		IF (codregionecpi != codregioneprov) THEN
		  -- coerenza cpi-regione
		  return -4;
		END IF;
	END IF;
	
    IF (in_prgSlot IS NOT NULL) THEN
      BEGIN
        select *
        into p_record_slot_tmp
        from ag_slot
        where prgSlot = in_prgSlot
          and codCpi = in_codCpi;
      EXCEPTION
        when no_data_found then
          -- coerenza slot-cpi
          return -2;
      END;
    END IF;
    
    IF (in_lavoratoreAzienda IS NOT NULL and in_lavoratoreAzienda = 'L') THEN
      
      IF (in_codComDomLav IS NOT NULL) THEN
        BEGIN
          SELECT codcom
          into p_codcom_tmp
          FROM DE_COMUNE
          WHERE codcom = in_codComDomLav
          AND trunc(datinizioval) <= trunc(SYSDATE)
          AND trunc(datfineval) >= trunc(SYSDATE);
        EXCEPTION
          when no_data_found THEN
            return -9;
        END;
      END IF;
      
      IF (in_codComResLav IS NOT NULL) THEN
        BEGIN
          SELECT codcom
          into p_codcom_tmp
          FROM DE_COMUNE
          WHERE codcom = in_codComResLav
          AND trunc(datinizioval) <= trunc(SYSDATE)
          AND trunc(datfineval) >= trunc(SYSDATE);
        EXCEPTION
          when no_data_found THEN
            return -10;
        END;
      END IF;
    
      IF (in_codComNasLav IS NOT NULL) THEN
        BEGIN
          SELECT codcom
          into p_codcom_tmp
          FROM DE_COMUNE
          WHERE codcom = in_codComNasLav;
        EXCEPTION
          when no_data_found THEN
            return -11;
        END;
      END IF;
      
      IF (in_cittadinanzaLav IS NOT NULL) THEN
        BEGIN
          SELECT codcittadinanza
          into p_codcittadinanza_tmp
          FROM DE_CITTADINANZA
          WHERE codcittadinanza = in_cittadinanzaLav
          AND trunc(datinizioval) <= trunc(SYSDATE)
          AND trunc(datfineval) >= trunc(SYSDATE);
        EXCEPTION
          when no_data_found THEN
            return -12;
        END;
      END IF;
      
      BEGIN
        select 
          prov.codregione, 
          (
            select prov_sil.codregione
            from de_provincia prov_sil
            where prov_sil.codprovincia = (select codprovinciasil from ts_generale)
          ),
          com.codprovincia,
          com.codcpi
        into p_codregione_lav, p_codregione_sil, p_codprovincia_lav, p_codcpidom_lav
        from de_comune com
        inner join de_provincia prov on prov.codprovincia = com.codprovincia
        where com.codCom = in_codComDomLav;
      EXCEPTION
        when no_data_found THEN
          -- regione lavoratore non trovata
          return -5;
      END;
      
      IF (p_codregione_lav = p_codregione_sil) THEN
	  
		begin
			select strValore
			into p_competenza
			from ts_config_loc
			where codtipoconfig = in_codiceRichiesta 
			and num = 7 and strcodrif = p_codprovincia_sil;
		exception
			when others then
				p_competenza := 'COMP';
		end;
	  
        IF (p_competenza != 'NO_COMP') THEN
			IF (p_codprovincia_lav != in_codProvincia OR p_codcpidom_lav != p_record_cpi_tmp.codCpi) THEN
			  -- nel caso di domicilio nella regione il CPI
			  -- e la Provincia di riferimento devono essere
			  -- coerenti con il comune di domicilio
			  return -6;
			END IF;
		END IF;
        
      END IF;
      
    END IF;
    
    return 0;
    
  exception 
  
    when others then
      ErrCodeOut := sqlerrm;
      return -1;
      
  end ao_effettuaControlliCoerenza;
  
  function ao_registraAppuntamento (
  
    in_codCpi in de_cpi.codCpi%type,
    in_prgSlot in ag_slot.prgSlot%type,
    in_cdnlavoratore in an_lavoratore.cdnlavoratore%type,
    in_prgAzienda in an_unita_azienda.prgazienda%type,
    in_prgUnita in an_unita_azienda.prgunita%type,
    in_strEmail in ag_agenda.stremailrif%type,
    in_strCell in ag_agenda.strtelmobilerif%type,
	in_doCommit in varchar2,
    
    out_strDescrizioneCpi OUT varchar2,
    out_strIndirizzoCpi OUT varchar2,
    out_strIndirizzoStampaCpi OUT varchar2,
    out_strTelCpi OUT varchar2,
    
    out_strIsSpiServizioDisp OUT varchar2,
    out_prgSpiServizio OUT an_spi.prgSpi%type,
    out_strNomeSpiServizio OUT varchar2,
    out_strCognomeSpiServizio OUT varchar2,
    out_strTelSpiServizio OUT varchar2,
    out_strSiglaSpiServizio OUT varchar2,
    
    out_strIsSpiSlotDisp OUT varchar2,
    out_prgSpiSlot OUT an_spi.prgSpi%type,
    out_strNomeSpiSlot OUT varchar2,
    out_strCognomeSpiSlot OUT varchar2,
    out_strTelSpiSlot OUT varchar2,
    out_strSiglaSpiSlot OUT varchar2,
    
    out_strAmbiente OUT varchar2,
	
	out_prgAppuntamento OUT ag_agenda.prgAppuntamento%type,
    
    ErrCodeOut OUT varchar2
    
  ) RETURN NUMBER IS
  
    p_servizio_prgspi an_spi.prgspi%type;
  
    p_record_slot ag_slot%rowtype;
    p_slot_prgspi an_spi.prgspi%type;
    p_slot_numerolavprenotati_new number;
    p_slot_numkloslot_new ag_slot.numkloslot%type;
    p_slot_codstatoslot_new ag_slot.codstatoslot%type;
    
    p_agenda_codcpi_new ag_agenda.codcpi%type;
    p_agenda_prgappuntamento_new ag_agenda.prgappuntamento%type;
    p_agenda_codstatoappuntamento ag_agenda.codstatoappuntamento%type := 2; -- Concordato
    p_agenda_utenteins ag_agenda.cdnutins%type := 150; /* utente servizi portale */
    p_agenda_prgtipoprenotazione ag_agenda.prgtipoprenotazione%type := 4; -- Online
	p_agenda_numklo ag_agenda.numkloagenda%type;
	
    p_record_lavoratore an_lavoratore%rowtype;
    
    p_esito_presa_appuntamento number;
    p_out_prg_appuntamento ag_agenda.prgappuntamento%type;
    p_out_cpi_appuntamento de_cpi.codCpi%type;
    p_out_ErrCodeOut varchar2(2048);
    
  BEGIN
  
    ----------------------
    -- RICERCA DATI CPI --
    ----------------------
    
    BEGIN
    
      select strdescrizione, strindirizzo, strtel, strIndirizzoStampa
      into out_strDescrizioneCpi, out_strIndirizzoCpi, out_strTelCpi, out_strIndirizzoStampaCpi
      from de_cpi cpi
      where cpi.codcpi = in_codCpi;
      
    EXCEPTION
      when NO_DATA_FOUND then
        -- cpi non trovato
        return -2;
    END;
    
    ------------------
    -- RICERCA SLOT --
    ------------------
    
    BEGIN
      
      select * 
      into p_record_slot
      from ag_slot
      where prgSlot = in_prgSlot;
      
    EXCEPTION
      when NO_DATA_FOUND then
        -- lo slot indicato in input non è stato trovato
        return -3;
    END;
    
    -------------------------------------------------
    -- RICERCA OPERATORE CPI ASSOCIATO AL SERVIZIO --
    -------------------------------------------------

     BEGIN
      select prgspi
      into p_servizio_prgspi
      from (
        select prgspi
        from ag_assegnazione
        where codcpi = p_record_slot.codcpi
        and codservizio = p_record_slot.codservizio
        order by dtmins desc
      ) where rownum < 2;
    EXCEPTION
      when NO_DATA_FOUND then
        p_servizio_prgspi := null;
        out_prgSpiServizio := null;
        out_strNomeSpiServizio := '';
        out_strCognomeSpiServizio := '';
        out_strTelSpiServizio := '';
        out_strIsSpiServizioDisp := 'N';
        out_strSiglaSpiServizio := '';
    END;

    -- lettura dettagli operatore associato al servizio, se disponibile
    IF (p_servizio_prgspi is not null) THEN
      BEGIN
          select strnome, strcognome, strteloperatore, strsiglaoperatore, prgSpi
          into out_strNomeSpiServizio, out_strCognomeSpiServizio, out_strTelSpiServizio, out_strSiglaSpiServizio, out_prgSpiServizio
          from an_spi
          where prgspi = p_servizio_prgspi;
          out_strIsSpiServizioDisp := 'S';
      EXCEPTION
        when NO_DATA_FOUND then
          out_prgSpiServizio := null;
          out_strNomeSpiServizio := '';
          out_strCognomeSpiServizio := '';
          out_strTelSpiServizio := '';
          out_strIsSpiServizioDisp := 'N';
          out_strSiglaSpiServizio := '';
      END;
    END IF;
    
    -------------------------------------------
    -- RICERCA OPERATORE ASSOCIATO ALLO SLOT --
    -------------------------------------------

    BEGIN
      select prgspi 
      into p_slot_prgspi
      from ag_spi_slot
      where codcpi = p_record_slot.codcpi
      and prgslot = p_record_slot.prgslot;
    EXCEPTION
      when NO_DATA_FOUND then
        p_slot_prgspi := null; -- operatore non trovato!
        out_prgSpiSlot := null;
        out_strNomeSpiSlot := '';
        out_strCognomeSpiSlot := '';
        out_strTelSpiSlot := '';
        out_strIsSpiSlotDisp := 'N';
        out_strSiglaSpiSlot := '';
    END;

    -- leggi dettagli operatore associato allo slot, se disponibile
    IF (p_slot_prgspi is not null) THEN
      BEGIN
        select strnome, strcognome, strteloperatore, strsiglaoperatore, prgSpi
        into out_strNomeSpiSlot, out_strCognomeSpiSlot, out_strTelSpiSlot, out_strSiglaSpiSlot, out_prgSpiSlot
        from an_spi
        where prgspi = p_slot_prgspi;
        out_strIsSpiSlotDisp := 'S';
      EXCEPTION
      when NO_DATA_FOUND then
        out_prgSpiSlot := null;
        out_strNomeSpiSlot := '';
        out_strCognomeSpiSlot := '';
        out_strTelSpiSlot := '';
        out_strIsSpiSlotDisp := 'N';
        out_strSiglaSpiSlot := '';
      END;

    END IF;
    
    ------------------------
    -- RICERCA LAVORATORE --
    ------------------------
    
    IF (in_cdnlavoratore IS NOT NULL) THEN
    
      BEGIN
        select *
        into p_record_lavoratore
        from an_lavoratore
        where cdnlavoratore = in_cdnlavoratore;
      EXCEPTION
        when others then
          -- lavoratore non trovato
          return -4;
      END;
    
    END IF;
    
    ---------------------
    -- RICERCA AZIENDA --
    ---------------------
    
    -- return -5 azienda non trovata
    
    ----------------------------------------------
    -- INSERIMENTO APPUNTAMENTO (se necessario) --
    ----------------------------------------------
    
    BEGIN
      
      p_esito_presa_appuntamento := pdAppuntamentoDaSlot (
                p_record_slot.prgslot,
                in_codCpi,
                in_prgAzienda,
                in_prgUnita,
                in_cdnlavoratore,
                p_agenda_utenteins,
                null,
				in_doCommit,
                p_out_prg_appuntamento,
                p_out_cpi_appuntamento,
                p_out_ErrCodeOut);
      
    IF (p_esito_presa_appuntamento != 0) THEN
        ErrCodeOut := 'pdAppuntamentoDaSlot codErrore: ' || p_esito_presa_appuntamento || '; descErrore ' || p_out_ErrCodeOut;
        IF (p_esito_presa_appuntamento = -1 AND instr(lower(p_out_ErrCodeOut), 'concorrenza') != 0 ) THEN
          --concorrenza
          return -98;
        ELSE
          return -7;
        END IF; 
      END IF;
      
	  out_prgAppuntamento := p_out_prg_appuntamento;
      -- tipo prenotazione: online
	  select numkloagenda
	  into p_agenda_numklo
	  from ag_agenda
	  where prgappuntamento = p_out_prg_appuntamento;
	  
      update ag_agenda
      set prgtipoprenotazione = p_agenda_prgtipoprenotazione,
          numkloagenda = p_agenda_numklo + 1
      where prgappuntamento = p_out_prg_appuntamento;
      
    EXCEPTION
    
      when others then
        -- errore inserimento appuntamento
        ErrCodeOut := sqlerrm;
        return -6;
    
    END;
    
    IF (p_record_slot.prgambiente IS NOT NULL) THEN
      BEGIN
        select strDescrizione
        into out_strAmbiente
        from de_ambiente
        where prgAmbiente = p_record_slot.prgambiente;
      EXCEPTION
        when no_data_found then
          -- ambiente non trovato
          return -9;
      END;
    END IF;
    
    return 0;
    
  EXCEPTION
    
    when others then
      -- errori non gestiti
      -- dbms_output.put_line('ErrCodeOut: ' || sqlerrm);
      ErrCodeOut := sqlerrm;
      return -1;
  
  END ao_registraAppuntamento;
  
  function ao_findSlot (
      
      in_codiceRichiesta in varchar2,
      in_codProvincia in de_provincia.codProvincia%type,
      in_prgSlot in ag_slot.prgSlot%type,
      in_codCpi in de_cpi.codCpi%type,
      in_dataDa in varchar2,
      in_dataA in varchar2,
      in_mattinoPomeriggio in varchar2,
      in_lavoratoreAzienda in varchar2,
      out_prgSlot OUT ag_slot.prgSlot%type,
      out_strDataApp OUT varchar2,
      out_strOraApp OUT varchar2,
      out_strDurataApp OUT varchar2,
      out_codservizio OUT varchar2,
      out_descservizio OUT varchar2,
      ErrCodeOut OUT varchar2
      
  ) RETURN NUMBER IS
    
    p_codServizio ts_config_loc.strValore%type;
    p_orario ts_config_loc.strValore%type;
    p_orario_inizio varchar2(8);
    p_orario_fine varchar2(8);
    p_giorni_da_oggi number;
    
    p_record_slot ag_slot%rowtype;
    p_primogiornolavutile date;
    p_data_da date;
    p_data_a date;
    
    p_slot_dtmdataora date;
    
    p_flgprenotabile de_stato_slot.flgprenotabile%type;
    
    CURSOR c_ricerca_slot_cursor (
      c_codServizio ts_config_loc.strValore%type,
      c_codCpi de_cpi.codCpi%type,
      c_prgSlot ag_slot.prgSlot%type,
      c_primogiornolavutile date,
      c_data_da date,
      c_data_a date,
      c_mattinoPomeriggio varchar2,
      c_orario_inizio varchar2,
      c_orario_fine varchar2,
      c_lavoratoreAzienda varchar2
    ) IS
    
      select * 
      from (
        select slot.*
        from ag_slot slot
        inner join de_stato_slot stato on slot.codstatoslot = stato.codstatoslot
    inner join ag_spi_slot spi on (spi.codcpi = slot.codcpi and spi.prgslot = slot.prgslot)
        where slot.codservizio = c_codServizio
          and slot.codcpi = c_codCpi
          and (
            -- [prgSlot nullo] -> si utilizzano i parametri di ricerca
            (c_prgSlot is null and 
              (
                trunc(slot.dtmdataora) >= trunc(c_primogiornolavutile)
                and (p_data_da is null or trunc(slot.dtmdataora) >= trunc(c_data_da))
                and (p_data_a is null or trunc(slot.dtmdataora) <= trunc(c_data_a))
                and (
                  (c_mattinoPomeriggio is null)
                  or
                  (
                    slot.dtmdataora >= TO_DATE(TO_CHAR(slot.dtmdataora, 'DD/MM/YYYY', 'nls_date_language = english') || ' ' || c_orario_inizio, 'DD/MM/YYYY hh24:mi:ss')
                    and
                    slot.dtmdataora <= TO_DATE(TO_CHAR(slot.dtmdataora, 'DD/MM/YYYY', 'nls_date_language = english') || ' ' || c_orario_fine, 'DD/MM/YYYY hh24:mi:ss')
                  )
                )
              )
            ) or 
            -- [prgSlot non nullo] -> si usa quello per la ricerca
            (c_prgSlot is not null and slot.prgSlot = c_prgSlot)
          )
          and (
            (c_lavoratoreAzienda = 'L' and NVL(slot.numlavprenotati, 0) < slot.numlavoratori)
            or
            (c_lavoratoreAzienda = 'A' and NVL(slot.numaziendeprenotate, 0) < slot.numaziende)
          )
          and stato.flgprenotabile = 'S'
          and NVL(slot.flgpubblico,'N') = 'S'
        order by slot.dtmdataora asc
      );
    
   BEGIN
    
    out_prgSlot := null;
    ErrCodeOut := null;
    
    ----------------------------------------
    --Modificato da Giacomo Pandini 29/08/2016
    
    -- recupero codice servizio
    
    BEGIN
    select ts_config_loc.strValore, de_servizio.strdescrizione
    into out_codservizio, out_descservizio 
    from ag_slot slot 
        left join ts_config_loc on slot.codservizio = ts_config_loc.strValore
        left join de_servizio on slot.codservizio = de_servizio.codservizio
    where slot.prgslot = in_prgSlot 
        and ts_config_loc.codtipoconfig = in_codiceRichiesta
        and ts_config_loc.num = 0
        and ts_config_loc.strcodrif = (select codprovinciasil from ts_generale);
    EXCEPTION
     when no_data_found then
        -- codServizio non trovato
        return -2;
    END;
    
    IF (out_codservizio IS NULL) THEN
      -- servizio non trovato
        return -8;
    END IF;

    -------------------------------------------
    
    -- parametri orario mattina/pomeriggio
    
    IF (in_mattinoPomeriggio is not null) THEN
      
      BEGIN
        select strValore
        into p_orario
        from ts_config_loc
        where codtipoconfig = in_codiceRichiesta 
          and num = decode(in_mattinoPomeriggio, 'M', 1, 'P', 2)
          and strcodrif = (select codprovinciasil from ts_generale);
      EXCEPTION
       when no_data_found then
        -- mattina/pomeriggio non trovato
        return -3;
      END;
      
      p_orario_inizio := SUBSTR(p_orario, 0, INSTR(p_orario, '; ') - 1);
      p_orario_fine := SUBSTR(p_orario, INSTR(p_orario, '; ') + 2, 8);
      
    END IF;
    
    -- parametri data da/a      
    
    IF (in_dataDa IS NOT NULL) THEN
      p_data_da := TO_DATE(in_dataDa, 'DD/MM/YYYY');
    ELSE
      p_data_da := null;
    END IF;
    
    IF (in_dataA IS NOT NULL) THEN
      p_data_a := TO_DATE(in_dataA, 'DD/MM/YYYY');
    ELSE
      p_data_a := null;
    END IF;
    
    -- giorni da oggi
    
    BEGIN
      select to_number(strValore)
      into p_giorni_da_oggi
      from ts_config_loc
      where codtipoconfig = in_codiceRichiesta 
        and num = 3
        and strcodrif = (select codprovinciasil from ts_generale);
    EXCEPTION
      when no_data_found then
        -- mattina/pomeriggio non trovato
        return -4;
    END;
    
    select PG_AGENDA.giornoDistGGLavDaDataCpi(
      sysdate,
      p_giorni_da_oggi,
      in_codCpi)
    into p_primogiornolavutile
    from dual;
        
    -- esistenza / prenotabilità dello slot indicato
    
    IF (in_prgSlot IS NOT NULL) THEN
      BEGIN
        select flgprenotabile
        into p_flgprenotabile
        from ag_slot slot
        inner join de_stato_slot stato on slot.codstatoslot = stato.codstatoslot
        where slot.prgslot = in_prgSlot;
      EXCEPTION
        when no_data_found then
          -- slot non trovato
          return -6;
      END;
      IF (p_flgprenotabile != 'S') THEN
        -- slot non prenotabile
        return -7;
      END IF;
    END IF;
    
    -- ricerca dello slot
        
    OPEN c_ricerca_slot_cursor(
      out_codservizio,
      in_codCpi,
      in_prgSlot,
      p_primogiornolavutile,
      p_data_da,
      p_data_a,
      in_mattinoPomeriggio,
      p_orario_inizio,
      p_orario_fine,
      in_lavoratoreAzienda
    );    
    LOOP
      FETCH c_ricerca_slot_cursor INTO p_record_slot;
      EXIT WHEN c_ricerca_slot_cursor%NOTFOUND;
      out_prgSlot := p_record_slot.prgSlot;
      p_slot_dtmdataora := p_record_slot.dtmdataora;
      EXIT;
    END LOOP;
    CLOSE c_ricerca_slot_cursor;
    
    IF (out_prgSlot IS NULL) THEN
      -- nessuno slot trovato
      return -5;
    END IF;

    -------------------------------------------
        
    --dbms_output.put_line('p_codServizio: ' || p_codServizio);
    --dbms_output.put_line('p_orario: ' || p_orario);
    --dbms_output.put_line('p_orario_inizio: ' || p_orario_inizio);
    --dbms_output.put_line('p_orario_fine: ' || p_orario_fine);
    --dbms_output.put_line('p_giorni_da_oggi: ' || p_giorni_da_oggi);
    --dbms_output.put_line('p_primogiornolavutile: ' || p_primogiornolavutile);
    --dbms_output.put_line('p_data_da: ' || TO_CHAR(p_data_da, 'DD/MM/YYYY hh24:mi:ss'));
    --dbms_output.put_line('p_data_a: ' || TO_CHAR(p_data_a, 'DD/MM/YYYY hh24:mi:ss'));
    --dbms_output.put_line('p_record_slot.prgslot: ' || out_prgSlot);
    --dbms_output.put_line('p_record_slot.dtmdataora: ' || TO_CHAR(p_slot_dtmdataora, 'DD/MM/YYYY hh24:mi:ss'));
    
    out_strDataApp := TO_CHAR(p_record_slot.dtmdataora,'DD/MM/YYYY', 'nls_date_language = english');
    out_strOraApp := TO_CHAR(p_record_slot.dtmdataora,'hh24:mi', 'nls_date_language = english');
    out_strDurataApp := p_record_slot.numminuti;
    
    return 0;
    
  EXCEPTION
    
      when others then
      
        --dbms_output.put_line('ErrCodeOut: ' || sqlerrm);
        ErrCodeOut := sqlerrm;
        
        return -1;
  
  END ao_findSlot;
  
  /******************************************
  * APPUNTAMENTO DID ONLINE                 *
  ******************************************/
  function pdAppuntamentoDidOnline(
      in_cdnlavoratore in an_lavoratore.cdnlavoratore%type,
      in_cpilavoratore in de_cpi.codcpi%type,
      out_strNomeLav OUT varchar2,
      out_strCognome OUT varchar2,
      out_strCellLav OUT varchar2,
      out_strEmailLav OUT varchar2,
      out_strDescrizioneCpi OUT varchar2,
      out_strIndirizzoCpi OUT varchar2,
      out_strTelCpi OUT varchar2,
      out_strDataApp OUT varchar2,
      out_strOraApp OUT varchar2,
      out_strDurataApp OUT varchar2,
      out_strCanSendSms OUT varchar2,
      out_strCanSendEmail OUT varchar2,
      out_strIsSpiDisponibile OUT varchar2,
      out_strNomeSpi OUT varchar2,
      out_strCognomeSpi OUT varchar2,
      out_strTelSpi OUT varchar2,
      ErrCodeOut OUT varchar2) RETURN NUMBER IS

    -- numero giorni da oggi e codice servizio
    tsconfigloc_codtipoconfig ts_config_loc.codtipoconfig%type := 'APP_DIDO';
    tsconfigloc_numerogiornidaoggi ts_config_loc.num%type;
    tsconfigloc_codservizio ts_config_loc.strvalore%type;

    -- lavoratore
    record_lavoratore an_lavoratore%rowtype;

    -- record slot e operatore
    record_slot ag_slot%rowtype;
    slot_prgspi an_spi.prgspi%type;
    slot_numkloslot_new ag_slot.numkloslot%type;
    slot_codstatoslot_new ag_slot.codstatoslot%type;
    slot_numerolavprenotati_new ag_slot.numlavprenotati%type;
    operatore_prgspi an_spi.prgspi%type;

    -- ag_agenda prgappuntamento next value
    agenda_primogiornolavutile date;
    agenda_prgappuntamento_new ag_agenda.prgappuntamento%type;
    agenda_codcpi_new ag_agenda.codcpi%type;
    agenda_utenteins ag_agenda.cdnutins%type := 150; /* utente servizi portale */
    agenda_codstatoappuntamento ag_agenda.codstatoappuntamento%type := 2; -- Concordato
    agenda_prgtipoprenotazione ag_agenda.prgtipoprenotazione%type := 4; -- Online

    -- cpi
    strDescrizioneCpi de_cpi.strdescrizione%type;
    strIndirizzoCpi de_cpi.strindirizzo%type;
    strTelCpi de_cpi.strtel%type;

  BEGIN
    
    ------------------------
    -- RICERCA LAVORATORE --
    ------------------------

    select * into record_lavoratore
    from an_lavoratore
    where cdnlavoratore = in_cdnlavoratore;
    
    out_strNomeLav := record_lavoratore.strnome;
    out_strCognome := record_lavoratore.strcognome;
    out_strCellLav := record_lavoratore.strcell;
    out_strEmailLav := record_lavoratore.stremail;
    
    IF ((NVL(record_lavoratore.flginviosms,'N') = 'S')
      and record_lavoratore.strcell is not null) THEN
      out_strCanSendSms := 'S';
    ELSE
      out_strCanSendSms := 'N';
    END IF;

    IF (record_lavoratore.stremail is not null) THEN
      out_strCanSendEmail := 'S';
    ELSE
      out_strCanSendEmail := 'N';
    END IF;
    
    ----------------------
    -- RICERCA DATI CPI --
    ----------------------
    
    select strdescrizione, strindirizzo, strtel
    into strDescrizioneCpi,strIndirizzoCpi,strTelCpi
    from de_cpi cpi
    where cpi.codcpi = in_cpilavoratore;
    
    out_strDescrizioneCpi := strDescrizioneCpi;
    out_strIndirizzoCpi := strIndirizzoCpi;
    out_strTelCpi := strTelCpi;
    
    -------------------------------
    -- COSTANTI PER RICERCA SLOT --
    -------------------------------
    
    BEGIN
      select num, strvalore
      into tsconfigloc_numerogiornidaoggi, tsconfigloc_codservizio
      from ts_config_loc tl
      where tl.codtipoconfig = tsconfigloc_codtipoconfig
      and strcodrif = (select ts_generale.codprovinciasil from ts_generale);
    EXCEPTION
      when NO_DATA_FOUND then
        return -6;
        --RAISE_APPLICATION_ERROR(-20007,'Record non presente');
    END;
    
    select PG_AGENDA.giornoDistGGLavDaDataCpi(sysdate,tsconfigloc_numerogiornidaoggi,in_cpilavoratore) 
    into agenda_primogiornolavutile
    from dual;
    
    -------------------------------------------------
    -- RICERCA OPERATORE CPI ASSOCIATO AL SERVIZIO --
    -------------------------------------------------
    
    -- ricerca operatore associato al servizio
     BEGIN
      select prgspi
      into operatore_prgspi
      from (
        select prgspi
        from ag_assegnazione
        where codcpi = in_cpilavoratore
        and codservizio = tsconfigloc_codservizio
        order by dtmins desc
      ) where rownum < 2;
    EXCEPTION
      when NO_DATA_FOUND then 
        operatore_prgspi := null;
        out_strNomeSpi := '';
        out_strCognomeSpi := '';
        out_strTelSpi := '';
        out_strIsSpiDisponibile := 'N';
    END;
    
    -- lettura dettagli operatore associato al servizio
    IF (operatore_prgspi is not null) THEN
      BEGIN
          select strnome, strcognome, strteloperatore 
          into out_strNomeSpi, out_strCognomeSpi, out_strTelSpi
          from an_spi
          where prgspi = operatore_prgspi;
          out_strIsSpiDisponibile := 'S';
      EXCEPTION
        when NO_DATA_FOUND then 
          out_strNomeSpi := '';
          out_strCognomeSpi := '';
          out_strTelSpi := '';
          out_strIsSpiDisponibile := 'N';
      END;
    END IF;
    
    -----------------------------------
    -- RICERCA DEL PRIMO SLOT LIBERO --
    -----------------------------------

    BEGIN
      -- ricerca del record slot (se non se ne trova almeno uno viene lanciata un'eccezione)
      select * into record_slot
      from (
        select
        *
        from ag_slot
        where codservizio = tsconfigloc_codservizio -- input
        and trunc(dtmdataora) >= trunc(agenda_primogiornolavutile) -- input (sysdate + N working days)
        and codcpi = in_cpilavoratore
        and (codstatoslot = 'C' or codstatoslot = 'P') -- implicit
        and NVL(numlavprenotati,0) < numlavoratori -- implicit
        and NVL(flgpubblico,'N') = 'S' -- implicit
        order by dtmdataora asc
      ) where rownum <= 1;
    EXCEPTION
    when NO_DATA_FOUND then
      -- nessun slot
      return -2;
      --RAISE_APPLICATION_ERROR(-20002,'Nessuno SLOT disponibile');
    END;

    -------------------------------------------
    -- RICERCA OPERATORE ASSOCIATO ALLO SLOT --
    -------------------------------------------

    -- ricerca operatore associato allo slot
    BEGIN
      select prgspi into slot_prgspi
      from ag_spi_slot
      where codcpi = record_slot.codcpi
      and prgslot = record_slot.prgslot;
    EXCEPTION
      when NO_DATA_FOUND then 
        slot_prgspi := null; -- operatore non trovato!
    END;
        
    -- leggi dettagli operatore associato allo slot, se disponibile
    -- (sovrascrive i dati dell'operatore associato al servizio)
    IF (slot_prgspi is not null) THEN
      BEGIN
        select strnome, strcognome, strteloperatore 
        into out_strNomeSpi, out_strCognomeSpi, out_strTelSpi
        from an_spi
        where prgspi = slot_prgspi;
        out_strIsSpiDisponibile := 'S';
      EXCEPTION
      when NO_DATA_FOUND then 
        -- do nothing, potrebbero già esserci le info 
        -- dell'operatore associato al servizio
        null;
      END;
      
    END IF;

    ----------------------------------------------
    -- INSERIMENTO APPUNTAMENTO (se necessario) --
    ----------------------------------------------

    IF (record_slot.codcpiappuntamento is not null AND
      record_slot.prgappuntamento is not null) THEN

      -- appuntamento già esistente e associabile a un lavoratore
      agenda_codcpi_new := record_slot.codcpiappuntamento;
      agenda_prgappuntamento_new := record_slot.prgappuntamento;

    ELSE

    -- appuntamento non esistente, da creare utilizzando info dello slot trovato
    agenda_codcpi_new := record_slot.codcpi;

    -- nuovo prgappuntamento ricavato da sequence
    select S_AG_AGENDA.nextval into agenda_prgappuntamento_new from dual;

    -- inserimento
    BEGIN
    insert into ag_agenda (
      codcpi,
      prgappuntamento,
      dtmdataora,
      numminuti,
      codservizio,
      prgspi,
      prgambiente,
      txtnote,
      prgtipoprenotazione,
      strtelrif,
      stremailrif,
      strtelmobilerif,
      cdnutmod,
      dtmmod,
      cdnutins,
      dtmins,
      codstatoappuntamento
    ) values (
      agenda_codcpi_new,
      agenda_prgappuntamento_new,
      record_slot.dtmdataora,
      record_slot.numminuti,
      record_slot.codservizio,
      slot_prgspi,
      record_slot.prgambiente,
      record_slot.strnote,
      agenda_prgtipoprenotazione,
      NVL(record_lavoratore.strtelres,record_lavoratore.strteldom),
      record_lavoratore.stremail,
      record_lavoratore.strcell,
      agenda_utenteins,
      sysdate,
      agenda_utenteins,
      sysdate,
      agenda_codstatoappuntamento
    );
    EXCEPTION
      when OTHERS then
      return -3;
    END;
    
    END IF;

    -- a questo punto le informazioni di interesse
    -- per l'appuntamento a si trovano nelle variabili:
    -->> agenda_codcpi_new
    -->> agenda_prgappuntamento_new

    -- associazione lavoratore / appuntamento
    BEGIN
    insert into ag_lavoratore (
      cdnlavoratore,
      codcpi,
      prgappuntamento
    ) values (
      record_lavoratore.cdnlavoratore,
      agenda_codcpi_new,
      agenda_prgappuntamento_new
    );
    EXCEPTION
    when OTHERS then
      -- si cattura il caso in cui un lavoratore
      -- sia già associato ad un determinato appuntamento
      return -4;
      --RAISE_APPLICATION_ERROR(-20003,'Il lavoratore è già associato a questo appuntamento');
    END;

    -- aggiornamento del numero lavoratori associati allo slot
    slot_numerolavprenotati_new := NVL(record_slot.numlavprenotati,0) + 1;

    -- aggiornamento dello stato dello slot
    slot_numkloslot_new := record_slot.numkloslot + 1;
    IF (slot_numerolavprenotati_new = record_slot.numlavoratori) then
    slot_codstatoslot_new := 'T'; --  Totalmente prenotato
    ELSE
    slot_codstatoslot_new := 'P'; -- Parzialmente prenotato
    END IF;

    BEGIN
    update ag_slot set
    codstatoslot = slot_codstatoslot_new,
    dtmmod = sysdate,
    cdnutmod = agenda_utenteins,
    numlavprenotati = slot_numerolavprenotati_new,
    numkloslot = slot_numkloslot_new, -- optimistic lock
    codcpiappuntamento = agenda_codcpi_new,
    prgappuntamento = agenda_prgappuntamento_new
    where prgslot = record_slot.prgslot
    and codcpi = record_slot.codcpi;
    EXCEPTION
    when OTHERS then
      return -5;
    END;
    
    out_strDataApp := TO_CHAR(record_slot.dtmdataora,'DD/MM/YYYY', 'nls_date_language = english');
    out_strOraApp := TO_CHAR(record_slot.dtmdataora,'hh24:mi', 'nls_date_language = english');
    out_strDurataApp := record_slot.numminuti;

    return 0;

  EXCEPTION

    when others then

    out_strNomeLav := '';
    out_strCognome := '';
    out_strCellLav := '';
    out_strEmailLav := '';
    out_strDescrizioneCpi := '';
    out_strIndirizzoCpi := '';
    out_strTelCpi := '';
    out_strDataApp := '';
    out_strOraApp := '';
    out_strDurataApp := '';
    out_strCanSendSms := '';
    out_strCanSendEmail := '';

    ErrCodeOut := sqlerrm;

    return -1;

  END pdAppuntamentoDidOnline;


  /******************************************
  * APPUNTAMENTO DA SLOT                    *
  ******************************************/
  --LA FUNZIONE PERMETTE DI INSERIRE UN APPUNTAMENTO DA SLOT E VENGONO GESTITI
  --I SEGUENTI CASI:INSERIMENTO FATTO DA UN'OPERATORE, DA UN'AZIENDA O DA UN LAVORATORE.
  --IL RISULTATO DI QUESTA STORED E' UN EVENTUALE INSERIMENTO NELLA TABELLA AG_AGENDA,
  --L'AGGIORNAMENTO DELLA TABELLA AG_SLOT E UN EVENTUALE INSERIMENTO NELLA TABELLA AG_LAVORATORE.
  FUNCTION pdAppuntamentoDaSlot(str_prgParSlot in varchar2,
              str_codParCpi in varchar2,
              str_prgParAzienda in varchar2,
              str_prgParUnita in varchar2,
              str_cdnParLavoratore in varchar2,
              str_cdnParUtente in varchar2,
			str_flgParLegaPatto in varchar2,
			str_doCommit in varchar2,
              prgParAppuntamento OUT varchar2,
              codParCpiAppunt OUT varchar2,
              ErrCodeOut OUT varchar2) RETURN NUMBER IS


  prgParSlot AG_SLOT.prgSlot%type;
    codParCpi  AG_SLOT.codCpi%TYPE;
    prgParAzienda AG_AGENDA.prgAzienda%TYPE;
    prgParUnita AG_AGENDA.prgUnita%TYPE;
    cdnParLavoratore AG_Lavoratore.cdnLavoratore%TYPE;
    cdnParUtente AG_SLOT.CDNUTINS%TYPE;
   flgParLegaPatto varchar2(10);


  CURSOR cursorSlot  IS SELECT *
        FROM AG_SLOT
        WHERE AG_SLOT.PRGSLOT = prgParSlot AND AG_SLOT.CODCPI = codParCpi;
  rec_slot           cursorSlot%ROWTYPE;
  codVarStatoSlot     AG_SLOT.CODSTATOSLOT%TYPE;
  nVarStatoOK       integer := 0;
  nVarAziendePren     AG_SLOT.NUMAZIENDEPRENOTATE%TYPE := 0;
  nVarLavoratoriPren     AG_SLOT.NUMLAVPRENOTATI%TYPE := 0;
  nVarAziendePrenSlot   AG_SLOT.NUMAZIENDEPRENOTATE%TYPE;
  nVarLavoratoriPrenSlot  AG_SLOT.NUMLAVPRENOTATI%TYPE;
  nVarMaxAziende      AG_SLOT.NUMAZIENDE%TYPE;
  nVarMaxLavoratori    AG_SLOT.NUMLAVORATORI%TYPE;
  CURSOR cursorSpi  IS SELECT *
        FROM AG_SPI_SLOT
        WHERE AG_SPI_SLOT.PRGSLOT = prgParSlot AND AG_SPI_SLOT.CODCPI = codParCpi;
  recSpi            cursorSpi%ROWTYPE;
  nVarSpi          AG_AGENDA.PRGSPI%TYPE;
  nVarNumKloSlot      AG_SLOT.NUMKLOSLOT%TYPE;
  nVarNumKloApp      AG_AGENDA.NUMKLOAGENDA%TYPE;
  bVarUpdatePrgAppunt      BOOLEAN := FALSE;
  bVarAziendaAppunt    BOOLEAN := FALSE;
  bVarLavoratoreAppunt  BOOLEAN := FALSE;
  prgVarAppCurr      AG_AGENDA.PRGAPPUNTAMENTO%TYPE;
  bVarNumMaxRaggiunto    BOOLEAN:=FALSE;
  nVarStatoConcordato    integer:=2;
  strVarTelRif      AG_AGENDA.STRTELRIF%TYPE:=null;
  strVarTelMobile      AG_AGENDA.STRTELMOBILERIF%TYPE:=null;
  strVarEmail        AG_AGENDA.STREMAILRIF%TYPE:=null;
  nVarPrgPattoLav      AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE%TYPE;
  nContLavPattoAttivo    integer;
  str_where        varchar2(2000);
  BEGIN
    -- Inizializzazione parametri
    prgParSlot := str_prgParSlot;
      codParCpi := str_codParCpi;
      prgParAzienda := str_prgParAzienda;
      prgParUnita := str_prgParUnita;
      cdnParLavoratore := str_cdnParLavoratore;
      cdnParUtente := str_cdnParUtente;
     flgParLegaPatto := str_flgParLegaPatto;
    --

    IF (prgParAzienda is not null AND prgParUnita is not null) THEN
      --IN QUESTO CASO E' L'AZIENDA CHE PRENOTA L'APPUNTAMENTO DA SLOT
      bVarAziendaAppunt := TRUE;
      SELECT STRTEL, STREMAIL
      INTO strVarTelRif, strVarEmail
      FROM AN_UNITA_AZIENDA
      WHERE PRGAZIENDA = prgParAzienda AND PRGUNITA = prgParUnita;
    ELSE
      IF (cdnParLavoratore is not null) THEN
        --IN QUESTO CASO E' IL LAVORATORE CHE PRENOTA L'APPUNTAMENTO DA SLOT
        bVarLavoratoreAppunt := TRUE;
        SELECT CASE
                  WHEN STRTELRES is not null THEN STRTELRES
               WHEN STRTELDOM is not null THEN STRTELDOM
             END,
        STRCELL, STREMAIL
        INTO strVarTelRif, strVarTelMobile, strVarEmail
        FROM AN_LAVORATORE
        WHERE CDNLAVORATORE = cdnParLavoratore;
      END IF;
    END IF;
    IF (bVarAziendaAppunt = FALSE AND bVarLavoratoreAppunt = FALSE) THEN
    --IN QUESTO CASO SIA L'AZIENDA CHE IL LAVORATORE NON VENGONO SPECIFICATI NELLA RICHIESTA
      RETURN 1;
    ELSE
      IF (NOT cursorSlot%ISOPEN) THEN
        OPEN cursorSlot;
      END IF;
      FETCH cursorSlot INTO rec_slot;
      IF (cursorSlot%ROWCOUNT > 0) THEN
        nVarNumKloSlot := rec_slot.NUMKLOSLOT + 1;
        IF (rec_slot.NUMAZIENDEPRENOTATE is not null) THEN
          nVarAziendePrenSlot := rec_slot.NUMAZIENDEPRENOTATE;
        ELSE
          nVarAziendePrenSlot := 0;
        END IF;
        IF (rec_slot.NUMLAVPRENOTATI is not null) THEN
          nVarLavoratoriPrenSlot := rec_slot.NUMLAVPRENOTATI;
        ELSE
          nVarLavoratoriPrenSlot := 0;
        END IF;
        IF (rec_slot.NUMAZIENDE is not null) THEN
          nVarMaxAziende := rec_slot.NUMAZIENDE;
        ELSE
          nVarMaxAziende := 0;
        END IF;
        IF (rec_slot.NUMLAVORATORI is not null) THEN
            nVarMaxLavoratori := rec_slot.NUMLAVORATORI;
        ELSE
          nVarMaxLavoratori := 0;
        END IF;
        IF (rec_slot.CODSTATOSLOT = 'C') THEN
          --stato possibile di partenza dello slot scelto per inserire una prenotazione
          IF (bVarAziendaAppunt = TRUE) THEN
            IF (nVarMaxAziende - nVarAziendePrenSlot = 0) THEN
            --PRENOTAZIONE AZIENDA NON AMMISSIBILE (RAGGIUNTO IL NUM MAX)
              RETURN 5;
            ELSE
              nVarStatoOK := 1;
              nVarAziendePren := nVarAziendePrenSlot + 1;
              nVarLavoratoriPren := nVarLavoratoriPrenSlot;
              IF ((nVarMaxAziende - nVarAziendePrenSlot) +
                  (nVarMaxLavoratori - nVarLavoratoriPrenSlot)) > 1 THEN
                codVarStatoSlot := 'P';
                --slot multiplo
                bVarUpdatePrgAppunt := TRUE;
              ELSE
                IF (nVarMaxAziende - nVarAziendePrenSlot <= 1 AND
                    nVarMaxLavoratori - nVarLavoratoriPrenSlot <= 1) THEN
                  codVarStatoSlot := 'T';
                END IF;
              END IF;
            END IF;
          ELSE
            IF (bVarLavoratoreAppunt = TRUE) THEN
              IF (nVarMaxLavoratori - nVarLavoratoriPrenSlot = 0) THEN
              --PRENOTAZIONE LAVORATORE NON AMMISSIBILE (RAGGIUNTO IL NUM MAX)
                  RETURN 6;
              ELSE
                nVarStatoOK := 1;
                nVarAziendePren := nVarAziendePrenSlot;
                nVarLavoratoriPren := nVarLavoratoriPrenSlot + 1;
                IF ((nVarMaxAziende - nVarAziendePrenSlot) +
                          (nVarMaxLavoratori - nVarLavoratoriPrenSlot)) > 1 THEN
                      codVarStatoSlot := 'P';
                  --slot multiplo
                  bVarUpdatePrgAppunt := TRUE;
                ELSE
                  IF (nVarMaxLavoratori - nVarLavoratoriPrenSlot <= 1 AND
                      nVarMaxAziende - nVarAziendePrenSlot <= 1) THEN
                    codVarStatoSlot := 'T';
                  END IF;
                END IF;
              END IF;
            END IF;
          END IF;
        ELSE
          IF (rec_slot.CODSTATOSLOT = 'P') THEN
            --stato possibile di partenza dello slot scelto per inserire una prenotazione
            IF (bVarAziendaAppunt = TRUE) THEN
              IF (nVarMaxAziende - nVarAziendePrenSlot = 0) THEN
              --PRENOTAZIONE AZIENDA NON AMMISSIBILE (RAGGIUNTO IL NUM MAX)
                RETURN 5;
              ELSE
                nVarStatoOK := 2;
                nVarAziendePren := nVarAziendePrenSlot + 1;
                nVarLavoratoriPren := nVarLavoratoriPrenSlot;
                IF ((nVarMaxAziende - nVarAziendePrenSlot) +
                          (nVarMaxLavoratori - nVarLavoratoriPrenSlot)) > 1 THEN
                  --SLOT MULTIPLO
                     codVarStatoSlot := 'P';
                  --bVarUpdatePrgAppunt := TRUE;
                ELSE
                  IF ((rec_slot.CODCPIAPPUNTAMENTO is not null)
                      AND (rec_slot.PRGAPPUNTAMENTO is not null)
                      AND (nVarMaxAziende - nVarAziendePrenSlot <= 1)
                      AND (nVarMaxLavoratori - nVarLavoratoriPrenSlot <= 1)) THEN
                        codVarStatoSlot := 'T';
                  END IF;
                END IF;
              END IF;
            ELSE
              IF (bVarLavoratoreAppunt = TRUE) THEN
                IF (nVarMaxLavoratori - nVarLavoratoriPrenSlot = 0) THEN
                --PRENOTAZIONE LAVORATORE NON AMMISSIBILE (RAGGIUNTO IL NUM MAX)
                  RETURN 6;
                ELSE
                  nVarStatoOK := 2;
                  nVarLavoratoriPren := nVarLavoratoriPrenSlot + 1;
                  nVarAziendePren := nVarAziendePrenSlot;
                  IF ((nVarMaxAziende - nVarAziendePrenSlot) +
                          (nVarMaxLavoratori - nVarLavoratoriPrenSlot)) > 1 THEN
                       --SLOT MULTIPLO
                       codVarStatoSlot := 'P';
                  ELSE
                    IF ((rec_slot.CODCPIAPPUNTAMENTO is not null)
                        AND (rec_slot.PRGAPPUNTAMENTO is not null)
                        AND (nVarMaxLavoratori - nVarLavoratoriPrenSlot <= 1)
                        AND (nVarMaxAziende - nVarAziendePrenSlot <= 1)) THEN
                          codVarStatoSlot := 'T';
                    END IF;
                  END IF;
                END IF;
              END IF;
            END IF;
            prgParAppuntamento := rec_slot.PRGAPPUNTAMENTO;
              codParCpiAppunt := rec_slot.CODCPIAPPUNTAMENTO;
          END IF;
        END IF;
        IF (nVarStatoOK <> 0) THEN
             --IL VALORE INIZIALE DELLO STATO DELLO SLOT ERA AMMISSIBILE
          IF (NOT cursorSpi%ISOPEN) THEN
            OPEN cursorSpi;
          END IF;
          FETCH cursorSpi INTO recSpi;
          IF (cursorSpi%ROWCOUNT > 0) THEN
            nVarSpi := recSpi.PRGSPI;
            IF (nVarStatoOK = 1) THEN
              select S_AG_AGENDA.nextval into prgParAppuntamento from dual;
              IF bVarAziendaAppunt = TRUE THEN
                --STATO INIZIALE DELLO SLOT C (COMPLETO)
                --E L'APPUNTAMENTO DA SLOT E' STATO FATTO DA UN'AZIENDA
                IF (bVarUpdatePrgAppunt = TRUE) THEN
                --SLOT MULTIPLO
                     INSERT INTO AG_AGENDA (CODCPI,
                           PRGAPPUNTAMENTO,
                          DTMDATAORA,
                          NUMMINUTI,
                          CODSERVIZIO,
                          PRGSPI,
                          PRGAMBIENTE,
                          TXTNOTE,
                          CDNUTMOD,
                          DTMMOD,
                          CDNUTINS,
                          DTMINS,
                          CODSTATOAPPUNTAMENTO,
                          PRGAZIENDA,
                          PRGUNITA)
                    VALUES (codParCpi,
                      prgParAppuntamento,
                      rec_slot.DTMDATAORA,
                      rec_slot.NUMMINUTI,
                      rec_slot.CODSERVIZIO,
                      nVarSpi,
                      rec_slot.PRGAMBIENTE,
                      rec_slot.STRNOTE,
                      cdnParUtente,
                      sysdate,
                      cdnParUtente,
                      sysdate,
                      nVarStatoConcordato,
                      prgParAzienda,
                      prgParUnita);
                ELSE
                  INSERT INTO AG_AGENDA (CODCPI,
                           PRGAPPUNTAMENTO,
                          DTMDATAORA,
                          NUMMINUTI,
                          CODSERVIZIO,
                          PRGSPI,
                          PRGAMBIENTE,
                          TXTNOTE,
                        STRTELRIF,
                        STREMAILRIF,
                          CDNUTMOD,
                          DTMMOD,
                          CDNUTINS,
                          DTMINS,
                          CODSTATOAPPUNTAMENTO,
                          PRGAZIENDA,
                          PRGUNITA)
                    VALUES (codParCpi,
                      prgParAppuntamento,
                      rec_slot.DTMDATAORA,
                      rec_slot.NUMMINUTI,
                      rec_slot.CODSERVIZIO,
                      nVarSpi,
                      rec_slot.PRGAMBIENTE,
                      rec_slot.STRNOTE,
                      strVarTelRif,
                      strVarEmail,
                      cdnParUtente,
                      sysdate,
                      cdnParUtente,
                      sysdate,
                      nVarStatoConcordato,
                      prgParAzienda,
                      prgParUnita);
                END IF;
                select S_AG_AGENDA.currVal into prgVarAppCurr from dual;
              ELSE
                --LO STATO INIZIALE DELLO SLOT C (COMPLETO) E OPERAZIONE RICHIESTA
                --DA UN OPERATORE O LAVORATORE
                IF (bVarUpdatePrgAppunt = TRUE) THEN
                  INSERT INTO AG_AGENDA (CODCPI,
                             PRGAPPUNTAMENTO,
                             DTMDATAORA,
                             NUMMINUTI,
                             CODSERVIZIO,
                             PRGSPI,
                             PRGAMBIENTE,
                             TXTNOTE,
                             CDNUTMOD,
                             DTMMOD,
                             CDNUTINS,
                             DTMINS,
                             CODSTATOAPPUNTAMENTO)
                  VALUES (codParCpi,
                    prgParAppuntamento,
                    rec_slot.DTMDATAORA,
                    rec_slot.NUMMINUTI,
                    rec_slot.CODSERVIZIO,
                    nVarSpi,
                    rec_slot.PRGAMBIENTE,
                    rec_slot.STRNOTE,
                    cdnParUtente,
                    sysdate,
                    cdnParUtente,
                    sysdate,
                    nVarStatoConcordato);
                ELSE
                  INSERT INTO AG_AGENDA (CODCPI,
                             PRGAPPUNTAMENTO,
                             DTMDATAORA,
                             NUMMINUTI,
                             CODSERVIZIO,
                             PRGSPI,
                             PRGAMBIENTE,
                             TXTNOTE,
                           STRTELRIF,
                           STREMAILRIF,
                           STRTELMOBILERIF,
                             CDNUTMOD,
                             DTMMOD,
                             CDNUTINS,
                             DTMINS,
                             CODSTATOAPPUNTAMENTO)
                  VALUES (codParCpi,
                    prgParAppuntamento,
                    rec_slot.DTMDATAORA,
                    rec_slot.NUMMINUTI,
                    rec_slot.CODSERVIZIO,
                    nVarSpi,
                    rec_slot.PRGAMBIENTE,
                    rec_slot.STRNOTE,
                    strVarTelRif,
                    strVarEmail,
                    strVarTelMobile,
                    cdnParUtente,
                    sysdate,
                    cdnParUtente,
                    sysdate,
                    nVarStatoConcordato);
                END IF;
                select S_AG_AGENDA.currVal into prgVarAppCurr from dual;
                --APPUNTAMENTO DA SLOT RICHIESTO DA UN LAVORATORE
                INSERT INTO AG_LAVORATORE (CDNLAVORATORE,
                    CODCPI,
                           PRGAPPUNTAMENTO)
                VALUES (cdnParLavoratore,
                  codParCpi,
                  prgVarAppCurr);
              END IF;
              --lega appuntamento al patto se flgParLegaPatto is not null
              IF (flgParLegaPatto is not null) THEN
                 select count(*)
                 into nContLavPattoAttivo
                 from am_patto_lavoratore
                 where cdnlavoratore = cdnParLavoratore and
                      codcpi = codParCpi and
                   datfine is null;
                 IF (nContLavPattoAttivo = 1) THEN
                     select prgpattolavoratore
                  into nVarPrgPattoLav
                  from am_patto_lavoratore
                  where cdnlavoratore = cdnParLavoratore and
                        codcpi = codParCpi and
                     datfine is null;
                     INSERT INTO AM_LAV_PATTO_SCELTA (PRGLAVPATTOSCELTA,
                                        PRGPATTOLAVORATORE,
                                      CODLSTTAB,
                                   STRCHIAVETABELLA,
                                   STRCHIAVETABELLA2,
                                   STRCHIAVETABELLA3)
                  VALUES (S_AM_LAV_PATTO_SCELTA.nextval,
                        nVarPrgPattoLav,
                      'AG_LAV',
                      cdnParLavoratore,
                      codParCpi,
                        prgVarAppCurr);
                 END IF;
              END IF;
              codParCpiAppunt := codParCpi;
            ELSE  --else IF (nVarStatoOK = 1) THEN
              IF (nVarStatoOK = 2) THEN
                --STATO SLOT P
                IF bVarLavoratoreAppunt = TRUE THEN
                  INSERT INTO AG_LAVORATORE (CDNLAVORATORE,
                    CODCPI,
                           PRGAPPUNTAMENTO)
                  VALUES (cdnParLavoratore,
                    codParCpi,
                    prgParAppuntamento);
                END IF;
                IF(bVarAziendaAppunt=TRUE) THEN
                  select ag_agenda.NUMKLOAGENDA into nVarNumKloApp
                  from ag_agenda
                  where ag_agenda.CODCPI=codParCpiAppunt and ag_agenda.PRGAPPUNTAMENTO=prgParAppuntamento;
                  UPDATE ag_agenda
                  SET NUMKLOAGENDA=nVarNumKloApp+1,
                    PRGAZIENDA=prgParAzienda,
                    PRGUNITA=prgParUnita,
                    DTMMOD=sysdate,
                    CDNUTMOD=cdnParUtente
                  WHERE
                     PRGAPPUNTAMENTO=prgParAppuntamento and CODCPI=codParCpi;
                END IF;
              END IF;
            END IF;  --end if IF (nVarStatoOK = 1) THEN
            IF (bVarUpdatePrgAppunt = TRUE) THEN
              --SLOT MULTIPLO E STATO INIZIALE SLOT C (COMPLETO)
              -- Log dell'Update su AG_SLOT
              str_where := ' WHERE AG_SLOT.PRGSLOT = ' || prgParSlot ||
                       'AND AG_SLOT.CODCPI = ''' || codParCpi || ''' ';
              PG_LOG.DOLOG('U', 'AG_SLOT', cdnParUtente, str_where);
              --
              UPDATE AG_SLOT SET NUMLAVPRENOTATI = nVarLavoratoriPren,
                NUMAZIENDEPRENOTATE = nVarAziendePren,
                CODSTATOSLOT = codVarStatoSlot,
                CODCPIAPPUNTAMENTO = codParCpi,
                PRGAPPUNTAMENTO = prgParAppuntamento,
                CDNUTMOD = cdnParUtente,
                DTMMOD = sysdate,
                NUMKLOSLOT = nVarNumKloSlot
              WHERE AG_SLOT.PRGSLOT = prgParSlot AND AG_SLOT.CODCPI = codParCpi;
            ELSE
              -- Log dell'Update su AG_SLOT
              str_where := ' WHERE AG_SLOT.PRGSLOT = ' || prgParSlot ||
                       'AND AG_SLOT.CODCPI = ''' || codParCpi || ''' ';
              PG_LOG.DOLOG('U', 'AG_SLOT', cdnParUtente, str_where);
              --
              UPDATE AG_SLOT SET NUMLAVPRENOTATI = nVarLavoratoriPren,
                NUMAZIENDEPRENOTATE = nVarAziendePren,
                CODSTATOSLOT = codVarStatoSlot,
                CDNUTMOD = cdnParUtente,
                DTMMOD = sysdate,
                NUMKLOSLOT = nVarNumKloSlot
              WHERE AG_SLOT.PRGSLOT = prgParSlot AND AG_SLOT.CODCPI = codParCpi;
              --OPERAZIONE COMPLETATE OK
            END IF;
			
			IF (str_doCommit = 'true') then
				COMMIT;
			END IF;
            return 0;
          ELSE  --else IF (cursorSpi%ROWCOUNT > 0) THEN
            --ERRORE ACCESSO AL RECORD SPI(GESTIONE MESSAGGIO DI RITORNO)
            RETURN 2;
          END IF;  --end if IF (cursorSpi%ROWCOUNT > 0) THEN
        ELSE  --else IF (nVarStatoOK <> 0) THEN
          --STATO SLOT INIZIALE NON AMMISSIBILE (GESTIONE MESSAGGIO DI RITORNO)
          RETURN 3;
        END IF;  --end if IF (nVarStatoOK <> 0) THEN
      ELSE  --else IF (cursorSlot%ROWCOUNT > 0) THEN
        --ERRORE ACCESSO AL RECORD SLOT(GESTIONE MESSAGGIO DI RITORNO)
        RETURN 4;
      END IF; --end if IF (cursorSlot%ROWCOUNT > 0) THEN
    END IF;
    exception
    when others then
       --ErrCodeOut:=sqlcode;
       --dbms_output.put_line('errore'||sqlcode ||' '||sqlerrm);
       ErrCodeOut := sqlerrm;
	   if (str_doCommit = 'true') then
		  rollback;
	   end if;
       return -1;
  END pdAppuntamentoDaSlot;
  -- ******************************************
  -- pdAllineamentoSlot
  -- ******************************************
  function pdAllineamentoSlot(codParCpi in AG_SLOT.codCpi%TYPE,
                prgParAppuntamento in AG_AGENDA.prgAppuntamento%TYPE,
                nParAllineaAppuntamento in integer,
                codParVecchioStato in DE_STATO_APPUNTAMENTO.CODSTATOAPPUNTAMENTO%TYPE,
                cdnParUtente in AG_SLOT.CDNUTINS%TYPE,
            flagCancella in integer,
                  ErrCodeOut OUT NUMBER) RETURN NUMBER IS
  lcount        integer;
  lcountLav      integer;
  codVarStatoCurr   AG_AGENDA.CODSTATOAPPUNTAMENTO%TYPE;
  flagVarStatoCurr   DE_STATO_APPUNTAMENTO.FLGATTIVO%TYPE;
  flagVarStatoOld   DE_STATO_APPUNTAMENTO.FLGATTIVO%TYPE;
  bVarSlegaApp    BOOLEAN:=FALSE;
  dtmVarDataOra    AG_SLOT.DTMDATAORA%TYPE;
  nVarNumMinuti    AG_SLOT.NUMMINUTI%TYPE;
  codVarServizio    AG_SLOT.CODSERVIZIO%TYPE;
  prgVarAmbiente    AG_SLOT.PRGAMBIENTE%TYPE;
  prgVarSlot      AG_SLOT.PRGSLOT%TYPE;
  codVarCpiSlot    AG_SLOT.CODCPI%TYPE;
  nVarCountSlotInt  integer;
  nVarNumAziende    AG_SLOT.NUMAZIENDE%TYPE;
  nVarNumLavoratori  AG_SLOT.NUMLAVORATORI%TYPE;
  nVarNumAziendePren  AG_SLOT.NUMAZIENDEPRENOTATE%TYPE;
  nVarNumLavPren    AG_SLOT.NUMLAVPRENOTATI%TYPE;
  codVarStatoSlot    AG_SLOT.CODSTATOSLOT%TYPE;
  codVarNewStatoSlot  AG_SLOT.CODSTATOSLOT%TYPE:=null;
  dtmVarDataOraSlot   AG_SLOT.DTMDATAORA%TYPE;
  dataFineApp      DATE;
  dataFineSlot    DATE;
  numVarMinutiSlot  AG_SLOT.NUMMINUTI%TYPE;
  nVarNumKloSlot    AG_SLOT.NUMKLOSLOT%TYPE;
  prgVarSpi      AG_SPI_SLOT.PRGSPI%TYPE;
  nVarNumKloAgenda  AG_AGENDA.NUMKLOAGENDA%TYPE;
  dtmVarDataOraApp   AG_AGENDA.DTMDATAORA%TYPE;
    numVarMinutiApp    AG_AGENDA.NUMMINUTI%TYPE;
    codVarServizioApp  AG_AGENDA.CODSERVIZIO%TYPE;
     prgVarAmbienteApp  AG_AGENDA.PRGAMBIENTE%TYPE;
     prgVarSpiApp    AG_AGENDA.PRGSPI%TYPE;
     prgVarAziendaApp  AG_AGENDA.PRGAZIENDA%TYPE;
     prgVarUnitaApp    AG_AGENDA.PRGUNITA%TYPE;
  -- Cursore SLOT riferito all'appuntamento
  CURSOR cursorSlot  IS SELECT AG_SLOT.DTMDATAORA,
                   AG_SLOT.NUMMINUTI,
                   AG_SLOT.CODSERVIZIO,
                   AG_SLOT.PRGAMBIENTE,
                   AG_SLOT.NUMAZIENDE,
                   AG_SLOT.NUMLAVORATORI,
                   AG_SLOT.NUMAZIENDEPRENOTATE,
                   AG_SLOT.NUMLAVPRENOTATI,
                   AG_SLOT.CODSTATOSLOT,
                      AG_SLOT.NUMKLOSLOT,
                   AG_SPI_SLOT.PRGSPI,
              AG_SLOT.PRGSLOT, AG_SLOT.CODCPI
           FROM AG_SLOT
           INNER JOIN AG_SPI_SLOT ON (AG_SLOT.PRGSLOT = AG_SPI_SLOT.PRGSLOT AND AG_SLOT.CODCPI = AG_SPI_SLOT.CODCPI)
           WHERE AG_SLOT.CODCPIAPPUNTAMENTO = codParCpi AND AG_SLOT.PRGAPPUNTAMENTO = prgParAppuntamento;
  rec_slot     cursorSlot%ROWTYPE;
  -- Cursore sovrapposizioni temporali+operatore per SLOT con STATO='C'
  CURSOR cursorSlotTemp1  IS SELECT AG_SLOT.PRGSLOT,
                  AG_SLOT.CODCPI,
                        AG_SLOT.DTMDATAORA,
            AG_SLOT.NUMMINUTI,
            AG_SLOT.NUMKLOSLOT,
            AG_SLOT.CODSTATOSLOT
        FROM AG_SLOT,AG_AGENDA,AG_SPI_SLOT
        WHERE AG_SLOT.CODCPI = AG_SPI_SLOT.CODCPI AND
              AG_SLOT.PRGSLOT = AG_SPI_SLOT.PRGSLOT AND
            TRUNC(AG_SLOT.DTMDATAORA) = TRUNC(AG_AGENDA.DTMDATAORA) AND
              AG_SLOT.CODSTATOSLOT = 'C' AND
              AG_SPI_SLOT.PRGSPI = AG_AGENDA.PRGSPI AND
              AG_SLOT.CODCPIAPPUNTAMENTO is null AND
              AG_SLOT.PRGAPPUNTAMENTO is null AND
              AG_AGENDA.CODCPI = codParCpi AND
              AG_AGENDA.PRGAPPUNTAMENTO = prgParAppuntamento;
  rec_slotTemp1    cursorSlotTemp1%ROWTYPE;
  -- Cursore sovrapposizioni temporali+operatore per SLOT con STATO='AA' oppure STATO='T'
  CURSOR cursorSlotTemp2  IS SELECT AG_SLOT.PRGSLOT,
                  AG_SLOT.CODCPI,
                        AG_SLOT.DTMDATAORA,
            AG_SLOT.NUMMINUTI,
            AG_SPI_SLOT.PRGSPI,
            AG_SLOT.NUMKLOSLOT,
            AG_SLOT.CODSTATOSLOT
        FROM AG_SLOT,AG_AGENDA,AG_SPI_SLOT
        WHERE AG_SLOT.CODCPI = AG_SPI_SLOT.CODCPI AND
              AG_SLOT.PRGSLOT = AG_SPI_SLOT.PRGSLOT AND
              TRUNC(AG_SLOT.DTMDATAORA) = TRUNC(AG_AGENDA.DTMDATAORA) AND
            (AG_SLOT.CODSTATOSLOT = 'AA' OR AG_SLOT.CODSTATOSLOT = 'T') AND
              AG_SPI_SLOT.PRGSPI = AG_AGENDA.PRGSPI AND
              AG_SLOT.CODCPIAPPUNTAMENTO is null AND
              AG_SLOT.PRGAPPUNTAMENTO is null AND
              AG_AGENDA.CODCPI = codParCpi AND
            NVL(AG_SLOT.NUMAZIENDE,0) + NVL(AG_SLOT.NUMLAVORATORI,0) <= 1 AND
              AG_AGENDA.PRGAPPUNTAMENTO = prgParAppuntamento;
  rec_slotTemp2    cursorSlotTemp2%ROWTYPE;
  BEGIN
    IF (NOT cursorSlot%ISOPEN) THEN
      OPEN cursorSlot;
    END IF;
    FETCH cursorSlot INTO rec_slot;
    lcount := cursorSlot%ROWCOUNT;
    IF (lcount > 0) THEN
        prgVarSlot := rec_slot.PRGSLOT;
      codVarCpiSlot := rec_slot.CODCPI;
        dtmVarDataOra := rec_slot.DTMDATAORA;
      nVarNumMinuti := rec_slot.NUMMINUTI;
          codVarServizio := rec_slot.CODSERVIZIO;
          prgVarAmbiente := rec_slot.PRGAMBIENTE;
          nVarNumAziende := rec_slot.NUMAZIENDE;
          IF (nVarNumAziende is null) THEN
            nVarNumAziende := 0;
          END IF;
          nVarNumLavoratori := rec_slot.NUMLAVORATORI;
          IF (nVarNumLavoratori is null) THEN
            nVarNumLavoratori := 0;
          END IF;
          nVarNumAziendePren := rec_slot.NUMAZIENDEPRENOTATE;
          IF (nVarNumAziendePren is null) THEN
            nVarNumAziendePren := 0;
          END IF;
          nVarNumLavPren := rec_slot.NUMLAVPRENOTATI;
          IF (nVarNumLavPren is null) THEN
            nVarNumLavPren := 0;
          END IF;
          codVarStatoSlot := rec_slot.CODSTATOSLOT;
          nVarNumKloSlot := rec_slot.NUMKLOSLOT;
          prgVarSpi := rec_slot.PRGSPI;
    END IF;
    SELECT count(*)
    INTO lcountLav
          FROM AG_LAVORATORE
    WHERE AG_LAVORATORE.CODCPI = codParCpi
          AND AG_LAVORATORE.PRGAPPUNTAMENTO = prgParAppuntamento;
    SELECT AG_AGENDA.NUMKLOAGENDA,
           AG_AGENDA.CODSTATOAPPUNTAMENTO,
           DE_STATO_APPUNTAMENTO.FLGATTIVO,
           AG_AGENDA.DTMDATAORA,
           AG_AGENDA.NUMMINUTI,
           AG_AGENDA.CODSERVIZIO,
           AG_AGENDA.PRGAMBIENTE,
           AG_AGENDA.PRGSPI,
           AG_AGENDA.PRGAZIENDA,
           AG_AGENDA.PRGUNITA
    INTO nVarNumKloAgenda,
         codVarStatoCurr,
         flagVarStatoCurr,
         dtmVarDataOraApp,
         numVarMinutiApp,
         codVarServizioApp,
         prgVarAmbienteApp,
         prgVarSpiApp,
         prgVarAziendaApp,
         prgVarUnitaApp
    FROM AG_AGENDA
    INNER JOIN DE_STATO_APPUNTAMENTO ON (AG_AGENDA.CODSTATOAPPUNTAMENTO = DE_STATO_APPUNTAMENTO.CODSTATOAPPUNTAMENTO)
    WHERE AG_AGENDA.CODCPI = codParCpi AND AG_AGENDA.PRGAPPUNTAMENTO = prgParAppuntamento;
    dataFineApp := dtmVarDataOraApp + (1/(24*60)*numVarMinutiApp);
    IF (lcount > 0) THEN
    --caso 1:appuntamento ha un riferimento allo slot
      IF NOT (dtmVarDataOra = dtmVarDataOraApp
        AND nVarNumMinuti = numVarMinutiApp
        AND codVarServizio = codVarServizioApp
        AND prgVarAmbiente = prgVarAmbienteApp
        AND prgVarSpi = prgVarSpiApp) THEN
        IF (nParAllineaAppuntamento is not null) THEN
          IF (nParAllineaAppuntamento = 1) THEN
          --Allinea Appuntamento
            nVarNumKloAgenda := nVarNumKloAgenda + 1;
            UPDATE AG_AGENDA
              SET DTMDATAORA = dtmVarDataOra,
                  NUMMINUTI = nVarNumMinuti,
                  CODSERVIZIO = codVarServizio,
                  PRGAMBIENTE = prgVarAmbiente,
                  PRGSPI = prgVarSpi,
                  CDNUTMOD = cdnParUtente,
                  DTMMOD = sysdate,
                  NUMKLOAGENDA = nVarNumKloAgenda
              WHERE AG_AGENDA.CODCPI = codParCpi
                    AND AG_AGENDA.PRGAPPUNTAMENTO = prgParAppuntamento;
          ELSE
          --Slega Appuntamento da slot
            bVarSlegaApp := TRUE;
          END IF;
        END IF;
      END IF;
      IF (prgVarAziendaApp is not null
          AND prgVarUnitaApp is not null
          AND nVarNumAziende <> 1) THEN
            IF (nParAllineaAppuntamento is not null) THEN
              IF (nParAllineaAppuntamento = 1) THEN
                nVarNumKloAgenda := nVarNumKloAgenda + 1;
            UPDATE AG_AGENDA
              SET PRGAZIENDA = null,
                  PRGUNITA = null,
                  CDNUTMOD = cdnParUtente,
                  DTMMOD = sysdate,
                  NUMKLOAGENDA = nVarNumKloAgenda
              WHERE AG_AGENDA.CODCPI = codParCpi
                    AND AG_AGENDA.PRGAPPUNTAMENTO = prgParAppuntamento;
          ELSE
              --Slega Appuntamento da slot
            bVarSlegaApp := TRUE;
              END IF;
        END IF;
      END IF;
      IF (lcountLav > nVarNumLavoratori) THEN
      --Slega Appuntamento da slot
        bVarSlegaApp := TRUE;
      END IF;
      IF (bVarSlegaApp = TRUE) THEN
      --SLEGA APPUNTAMENTO DA SLOT
        nVarNumKloSlot := nVarNumKloSlot + 1;
        UPDATE AG_SLOT
          SET CODCPIAPPUNTAMENTO = null,
              PRGAPPUNTAMENTO = null,
              CODSTATOSLOT = 'A',
              CDNUTMOD = cdnParUtente,
              DTMMOD = sysdate,
              NUMKLOSLOT = nVarNumKloSlot
          WHERE AG_SLOT.CODCPI = codVarCpiSlot
                AND AG_SLOT.PRGSLOT = prgVarSlot;
          --WHERE AG_SLOT.CODCPIAPPUNTAMENTO = codParCpi
          --      AND AG_SLOT.PRGAPPUNTAMENTO = prgParAppuntamento;
      ELSE
      --ESISTE ANCORA LA CHIAVE DELL'APPUNTAMENTO DOPO LE AZIONI PRECEDENTI
        -- aggiunto il 17/06/2004 da Stefy
        IF (prgVarAziendaApp is not null AND prgVarUnitaApp is not null
            AND nVarNumAziende=1 AND nVarNumAziendePren=0) THEN
          nVarNumAziendePren := 1;
        END IF;
        IF (prgVarAziendaApp is null AND prgVarUnitaApp is null
            AND nVarNumAziende=1 AND nVarNumAziendePren=1) THEN
          nVarNumAziendePren := 0;
        END IF;
        --
        IF (nVarNumAziendePren = nVarNumAziende AND
            lcountLav = nVarNumLavoratori) THEN
            IF (codVarStatoSlot = 'C' OR codVarStatoSlot = 'P') THEN
          codVarNewStatoSlot := 'T';
            END IF;
        END IF;
        -- Modificato il 17/06/2004 da Stefy
        IF ((nVarNumAziendePren >= 0 AND  nVarNumAziendePren < nVarNumAziende)
                  OR (nVarNumLavPren >= 0 AND lcountLav < nVarNumLavoratori)) THEN
            IF (codVarStatoSlot = 'C' OR codVarStatoSlot = 'P'  or  codVarStatoSlot = 'T') THEN
          codVarNewStatoSlot := 'P';
            END IF;
        END IF;
        --
        IF (nVarNumAziendePren <= 0 AND lcountLav <= 0) THEN
            IF (codVarStatoSlot = 'C' OR codVarStatoSlot = 'P') THEN
          codVarNewStatoSlot := 'C';
            END IF;
        END IF;
        IF (codVarNewStatoSlot is not null) THEN
          nVarNumKloSlot := nVarNumKloSlot + 1;
          UPDATE AG_SLOT
            SET CODSTATOSLOT = codVarNewStatoSlot,
                NUMLAVPRENOTATI = lcountLav,
                NUMAZIENDEPRENOTATE =
                  CASE
                    WHEN prgVarAziendaApp is null THEN 0
                    WHEN prgVarAziendaApp is not null THEN 1
                  END,
                CDNUTMOD = cdnParUtente,
                DTMMOD = sysdate,
                NUMKLOSLOT = nVarNumKloSlot
            WHERE AG_SLOT.CODCPIAPPUNTAMENTO = codParCpi
                  AND AG_SLOT.PRGAPPUNTAMENTO = prgParAppuntamento;
        END IF;
      END IF;
      -- **********************************************************
      -- ESEGUO I CONTROLLI SUI PASSAGGI DI STATO DELL'APPUNTAMENTO
      -- **********************************************************
      SELECT DE_STATO_APPUNTAMENTO.FLGATTIVO
      INTO flagVarStatoOld
      FROM DE_STATO_APPUNTAMENTO
      WHERE DE_STATO_APPUNTAMENTO.CODSTATOAPPUNTAMENTO = codParVecchioStato;
      --PASSAGGIO FLGATTIVO N--->N  Non comporta nessun controllo o azione
      --PASSAGGIO FLGATTIVO N--->S OPPURE S --->S
      IF((UPPER(flagVarStatoCurr)='S') AND (UPPER(flagVarStatoOld)='N' OR UPPER(flagVarStatoOld)='S')) THEN
         FOR rec_slotTemp1 IN cursorSlotTemp1 LOOP
            dtmVarDataOraSlot := rec_slotTemp1.DTMDATAORA;
          numVarMinutiSlot := rec_slotTemp1.NUMMINUTI;
          --controllo della sovrapposizione temporale
          dataFineSlot := dtmVarDataOraSlot + (1/(24*60)*numVarMinutiSlot);
          /*IF (dtmVarDataOraSlot > dtmVarDataOraApp AND
              dtmVarDataOraSlot < dataFineApp) OR
              (dataFineSlot > dtmVarDataOraApp AND
              dataFineSlot < dataFineApp) THEN*/
          if(
            ((dtmVarDataOraSlot <= dtmVarDataOraApp) AND (dtmVarDataOraApp < dataFineSlot) AND (dataFineSlot <= dataFineApp)) OR
              ((dtmVarDataOraApp <= dtmVarDataOraSlot) AND (dtmVarDataOraSlot < dataFineApp) AND (dataFineApp <= dataFineSlot))
            ) THEN
            UPDATE AG_SLOT
            SET CODSTATOSLOT = 'AA',
                CDNUTMOD = cdnParUtente,
                DTMMOD = sysdate,
                NUMKLOSLOT = rec_slotTemp1.NUMKLOSLOT + 1
            WHERE AG_SLOT.PRGSLOT =  rec_slotTemp1.PRGSLOT AND AG_SLOT.CODCPI = rec_slotTemp1.CODCPI;
          END IF;
        END LOOP;

      END IF;
      --PASSAGGIO FLGATTIVO S--->N
      IF (UPPER(flagVarStatoOld)='S' AND UPPER(flagVarStatoCurr)='N') THEN
         -- Metto il relativo slot in stato di "Annullato" (A)
         nVarNumKloSlot := nVarNumKloSlot + 1;
        UPDATE AG_SLOT
          SET CODCPIAPPUNTAMENTO = null,
              PRGAPPUNTAMENTO = null,
              CODSTATOSLOT = 'A',
            NUMAZIENDEPRENOTATE=0,
            NUMLAVPRENOTATI=0,
              CDNUTMOD = cdnParUtente,
              DTMMOD = sysdate,
              NUMKLOSLOT = nVarNumKloSlot
          WHERE AG_SLOT.CODCPI = codVarCpiSlot
                AND AG_SLOT.PRGSLOT = prgVarSlot;
         -- Ripristino tutti gli slot con sovrapposizione temporale con quello "annullato"
         FOR rec_slotTemp2 IN cursorSlotTemp2 LOOP
          dtmVarDataOraSlot := rec_slotTemp2.DTMDATAORA;
          numVarMinutiSlot := rec_slotTemp2.NUMMINUTI;
          --controllo inclusione temporale (Slot contenuto nell'appuntamento)
          dataFineSlot := dtmVarDataOraSlot + (1/(24*60)*numVarMinutiSlot);
          IF (dtmVarDataOraSlot >= dtmVarDataOraApp AND
              dataFineSlot <= dataFineApp) THEN
            -- Libero lo slot in esame solo se non ci sono appuntamenti
            /* Aggiunto il controllo sull'appuntamento in esame alla count
               Data: 25/08/2004 - Stefy */
            -- Modifica count: 16/11/2005 - Stefy
            select count(*)
            into nVarCountSlotInt
            from ag_agenda, de_stato_appuntamento
            where ag_agenda.CODSTATOAPPUNTAMENTO=de_stato_appuntamento.CODSTATOAPPUNTAMENTO AND
                ag_agenda.CODCPI = rec_slotTemp2.CODCPI AND
                ag_agenda.PRGSPI = rec_slotTemp2.PRGSPI AND
                (
                 ((dtmVarDataOraSlot<=ag_agenda.DTMDATAORA) AND (ag_agenda.DTMDATAORA<dataFineSlot) AND (dataFineSlot<=(ag_agenda.DTMDATAORA + (1/(24*60)*ag_agenda.NUMMINUTI))) ) OR
                 ((ag_agenda.DTMDATAORA<=dtmVarDataOraSlot) AND (dtmVarDataOraSlot < (ag_agenda.DTMDATAORA + (1/(24*60)*ag_agenda.NUMMINUTI))) AND ((ag_agenda.DTMDATAORA + (1/(24*60)*ag_agenda.NUMMINUTI))<=dataFineSlot) )
                ) AND (de_stato_appuntamento.FLGATTIVO = 'S')
                AND (ag_agenda.CODCPI=codParCpi and ag_agenda.PRGAPPUNTAMENTO<>prgParAppuntamento);
            IF(nVarCountSlotInt=0) THEN
              UPDATE AG_SLOT
              SET CODSTATOSLOT = 'C',
                NUMLAVPRENOTATI = 0,
                NUMAZIENDEPRENOTATE = 0,
                  CDNUTMOD = cdnParUtente,
                  DTMMOD = sysdate,
                  NUMKLOSLOT = rec_slotTemp2.NUMKLOSLOT + 1
              WHERE AG_SLOT.PRGSLOT =  rec_slotTemp2.PRGSLOT AND AG_SLOT.CODCPI = rec_slotTemp2.CODCPI;
            END IF; --END IF(nVarCountSlotInt=0)
          END IF;-- END IF (dtmVarDataOraSlot >= dtmVarDataOraApp AND dataFineSlot <= dataFineApp)
        END LOOP;
      END IF;
    ELSE
    --caso 2:appuntamento non ha un riferimento allo slot
      SELECT DE_STATO_APPUNTAMENTO.FLGATTIVO
      INTO flagVarStatoOld
      FROM DE_STATO_APPUNTAMENTO
      WHERE DE_STATO_APPUNTAMENTO.CODSTATOAPPUNTAMENTO = codParVecchioStato;
      --SE VENGO DALLA STORED CANCELLAZIONE (PDCANCELLAAPPUNTAMENTO) ALLORA
      --IMPOSTO STATO CORRENTE A N
      IF (flagCancella = 1) THEN
         flagVarStatoCurr := 'N';
      END IF;
      -- CASO 1: FLGATTIVO='S'
      IF (UPPER(flagVarStatoCurr) = 'S') THEN

           FOR rec_slotTemp1 IN cursorSlotTemp1 LOOP
              dtmVarDataOraSlot := rec_slotTemp1.DTMDATAORA;
            numVarMinutiSlot := rec_slotTemp1.NUMMINUTI;
            --controllo della sovrapposizione temporale
            dataFineSlot := dtmVarDataOraSlot + (1/(24*60)*numVarMinutiSlot);
            /*IF (dtmVarDataOraSlot > dtmVarDataOraApp AND
                dtmVarDataOraSlot < dataFineApp) OR
                (dataFineSlot > dtmVarDataOraApp AND
                dataFineSlot < dataFineApp) THEN*/
            if(
              ((dtmVarDataOraSlot <= dtmVarDataOraApp) AND (dtmVarDataOraApp < dataFineSlot) AND (dataFineSlot <= dataFineApp)) OR
              ((dtmVarDataOraApp <= dtmVarDataOraSlot) AND (dtmVarDataOraSlot < dataFineApp) AND (dataFineApp <= dataFineSlot))
              ) THEN
              UPDATE AG_SLOT
              SET CODSTATOSLOT = 'AA',
                  CDNUTMOD = cdnParUtente,
                  DTMMOD = sysdate,
                  NUMKLOSLOT = rec_slotTemp1.NUMKLOSLOT + 1
              WHERE AG_SLOT.PRGSLOT =  rec_slotTemp1.PRGSLOT AND
                          AG_SLOT.CODCPI = rec_slotTemp1.CODCPI;
            END IF;
          END LOOP;

      END IF;
      -- CASO 2: FLGATTIVO='N'
      IF (UPPER(flagVarStatoCurr)='N') THEN
           FOR rec_slotTemp2 IN cursorSlotTemp2 LOOP
            dtmVarDataOraSlot := rec_slotTemp2.DTMDATAORA;
            numVarMinutiSlot := rec_slotTemp2.NUMMINUTI;
            --controllo inclusione temporale
            dataFineSlot := dtmVarDataOraSlot + (1/(24*60)*numVarMinutiSlot);
            IF (dtmVarDataOraSlot >= dtmVarDataOraApp AND
                dataFineSlot <= dataFineApp) THEN
              /* Aggiunto il controllo sull'appuntamento in esame alla count
               Data: 25/08/2004 - Stefy */
               -- Modifica count: 16/11/2005 - Stefy
              select count(*)
              into nVarCountSlotInt
              from ag_agenda, de_stato_appuntamento
              where ag_agenda.CODSTATOAPPUNTAMENTO=de_stato_appuntamento.CODSTATOAPPUNTAMENTO AND
                  ag_agenda.CODCPI = rec_slotTemp2.CODCPI AND
                  ag_agenda.PRGSPI = rec_slotTemp2.PRGSPI AND
                  (
                      ((dtmVarDataOraSlot<=ag_agenda.DTMDATAORA) AND (ag_agenda.DTMDATAORA<dataFineSlot) AND (dataFineSlot<=(ag_agenda.DTMDATAORA + (1/(24*60)*ag_agenda.NUMMINUTI))) ) OR
                      ((ag_agenda.DTMDATAORA<=dtmVarDataOraSlot) AND (dtmVarDataOraSlot < (ag_agenda.DTMDATAORA + (1/(24*60)*ag_agenda.NUMMINUTI))) AND ((ag_agenda.DTMDATAORA + (1/(24*60)*ag_agenda.NUMMINUTI))<=dataFineSlot) )
                  ) AND (de_stato_appuntamento.FLGATTIVO = 'S')
                  and (ag_agenda.CODCPI=codParCpi and ag_agenda.PRGAPPUNTAMENTO<>prgParAppuntamento);
              IF (nVarCountSlotInt = 0) THEN
                UPDATE AG_SLOT
                SET CODSTATOSLOT = 'C',
                  NUMLAVPRENOTATI = 0,
                  NUMAZIENDEPRENOTATE = 0,
                    CDNUTMOD = cdnParUtente,
                    DTMMOD = sysdate,
                    NUMKLOSLOT = rec_slotTemp2.NUMKLOSLOT + 1
                WHERE AG_SLOT.PRGSLOT =  rec_slotTemp2.PRGSLOT AND
                            AG_SLOT.CODCPI = rec_slotTemp2.CODCPI;
              END IF;
            END IF;
          END LOOP;
        END IF;

    END IF;
    --NEL CASO IN CUI LA STORED VIENE CHIAMATA DALLA PDCANCELLAAPPUNTAMENTO
    --NON DEVE ESSERE COMMITTATA (PARAMETRO FLAGCANCELLA = 1)
    IF (flagCancella is null) THEN
       COMMIT;
    END IF;
    RETURN 0;
    exception
    when others then
      ErrCodeOut:=sqlcode;
    dbms_output.put_line('errore'||sqlcode ||' '||sqlerrm);
    rollback;
    return -1;
  END pdAllineamentoSlot;
  --
  /*****************************************
  *   Inserimento SLOT da SETTIMANA TIPO   *
  *****************************************/
  function pdInserisciSlotDaSettimana(dataParInizioStr in varchar2,
                      dataParFineStr in varchar2,
                        codParSettimana in DE_SETTIMANA_TIPO.PRGSETTIPO%TYPE,
                        codParCpi in DE_SETTIMANA_TIPO.CODCPI%TYPE,
                        codParStatoSlot in AG_SLOT.CODSTATOSLOT%TYPE DEFAULT 'C',
                        cdnParUtente in AG_SLOT.CDNUTINS%TYPE,
                        ErrCodeOut OUT NUMBER) RETURN NUMBER IS
  dtVarInizioVal    DATE;
  dtVarFineVal    DATE;
  dataParInizio     DATE;
  dataParFine    DATE;
  dayofw      NUMBER := 0;
  lcount      number(38) := 0;
  CURSOR cursorSlotTipo  IS SELECT *
           FROM AG_SLOT_TIPO
           WHERE AG_SLOT_TIPO.CODCPI = codParCpi AND AG_SLOT_TIPO.PRGSETTIPO = codParSettimana;
  rec_slotTipo     cursorSlotTipo%ROWTYPE;
  nVarQtaSlot    integer;
  dtVarDataOraSlot  AG_SLOT.DTMDATAORA%TYPE;
  nVarDalleOre     AG_SLOT_TIPO.STRORADALLE%TYPE;
  nVarNumMinuti           AG_SLOT_TIPO.NUMMINUTI%TYPE;
  nVarGiornoSlot    AG_SLOT_TIPO.NUMGIORNOSETT%TYPE;
  nVarGiornoDataCurr  AG_SLOT_TIPO.NUMGIORNOSETT%TYPE;
  dataVarInizio     DATE;
  nDiffGiorni    integer;
  nVarCodDestinatario   AG_SLOT_TIPO.CODDESTINATARIO%TYPE;
  nVarAziendePren   AG_SLOT.NUMAZIENDE%TYPE;
  nVarLavoratoriPren   AG_SLOT.NUMLAVORATORI%TYPE;
  prgVarSlotCurr    AG_SLOT.PRGSLOT%TYPE;
  nVarGiornoNonLav  integer;
  nVarMeseNonLav    integer;
  nVarAnnoNonLav    integer;
  lcountGiorniNonLav   integer;
  bSlotDisgiuntoOp  BOOLEAN := TRUE;
  bSlotDisgiuntoServ  BOOLEAN := TRUE;
  lcountOp      number(38) := 0;
  lcountServ      number(38) := 0;
  sParametroTerritorio varchar2(100);
  nDiffGiorniTerritorio integer;
  BEGIN
    /* patch Alessandro Pegoraro by Orioli Stefania - dataparan0ia */
    /*
    select to_char(to_date('10/02/2010','dd/mm/yyyy'),'d', 'nls_date_language = english') into dayofw from dual;
    if (dayofw=3) then
      nDiffGiorniTerritorio := 0;
    elsif (dayofw=4) then
      nDiffGiorniTerritorio := 1;
    else
      RETURN 1;
    end if;
    */
    /*SELECT VALUE
    INTO sParametroTerritorio
    FROM NLS_SESSION_PARAMETERS
    where UPPER(PARAMETER) = 'NLS_TERRITORY';
    IF (UPPER(TRIM(sParametroTerritorio)) = 'AMERICA') THEN
       nDiffGiorniTerritorio := 1;
    ELSE
       nDiffGiorniTerritorio := 0;
    END IF;*/
    
    -- 03/08/2017 bugfix da forum Oracle
    -- nDiffGiorniTerritorio -> non serve
    
    dataParInizio := to_date(dataParInizioStr,'DD/MM/YYYY');
    dataParFine := to_date(dataParFineStr,'DD/MM/YYYY');
    SELECT TRUNC(DATINIZIOVAL),
           TRUNC(DATFINEVAL)
    INTO dtVarInizioVal,
         dtVarFineVal
    FROM DE_SETTIMANA_TIPO
    WHERE CODCPI = codParCpi AND
                PRGSETTIPO = codParSettimana;
    IF ((dataParInizio < dtVarInizioVal) OR (dataParFine > dtVarFineVal)) THEN
        --DATA INIZIO VALIDITA O DATA FINE VALIDITA SETTIMANA TIPO NON AMMISSIBILI
        --CON I PARAMETRI INPUT DELLA STORED
          RETURN 1;
        ELSE
          SELECT COUNT(*)
          INTO lcount
          FROM VW_AG_SLOT_TIPO_ERR
          WHERE CODCPI = codParCpi AND
                PRGSETTIPO = codParSettimana;
          IF (lcount > 0) THEN
          --SETTIMANA TIPO INCOMPLETA O INCONSISTENTE
            RETURN 2;
          ELSE
            --CONTROLLO SE ESISTE UNO SLOT NEL PERIODO SCELTO CHE SI SOVRAPPONE PER OPERATORE O PER SERVIZIO
            --SOSTITUIRE CON INNER JOIN AG_SLOT_TIP0 PER OTTIMIZZARE LE PRESTAZIONI
        FOR rec_slotTipo IN cursorSlotTipo LOOP
              SELECT COUNT(*)
              INTO lcountServ
              FROM AG_SLOT
              WHERE AG_SLOT.CODCPI = codParCpi AND
                TRUNC(AG_SLOT.DTMDATAORA) BETWEEN
              dataParInizio AND dataParFine AND
              AG_SLOT.CODSERVIZIO = rec_slotTipo.CODSERVIZIO;
          SELECT COUNT(*)
              INTO lcountOp
              FROM AG_SLOT
              LEFT JOIN AG_SPI_SLOT ON (AG_SLOT.PRGSLOT = AG_SPI_SLOT.PRGSLOT AND
                                   AG_SLOT.CODCPI = AG_SPI_SLOT.CODCPI)
          WHERE AG_SLOT.CODCPI = codParCpi AND
                TRUNC(AG_SLOT.DTMDATAORA) BETWEEN
              dataParInizio AND dataParFine AND
              AG_SPI_SLOT.PRGSPI = rec_slotTipo.PRGSPI;
          IF (lcountOp > 0) THEN
            bSlotDisgiuntoOp := FALSE;
          END IF;
          IF (lcountServ > 0) THEN
            bSlotDisgiuntoServ := FALSE;
          END IF;
        END LOOP;
        IF (bSlotDisgiuntoOp = FALSE and bSlotDisgiuntoServ = FALSE) THEN
           RETURN 3;
        ELSE
          IF (bSlotDisgiuntoOp = FALSE) THEN
             RETURN 4;
          ELSE
            IF (bSlotDisgiuntoServ = FALSE) THEN
               RETURN 5;
            ELSE
              --CONTROLLI SUPERATI, INSERIMENTO IN AG_SLOT DALLA SETTIMANA TIPO
              --dataVarInizio := dataParInizio;
                  FOR rec_slotTipo IN cursorSlotTipo LOOP
                    nVarCodDestinatario := rec_slotTipo.CODDESTINATARIO;
                    IF (nVarCodDestinatario = 'L') THEN
                      nVarAziendePren := 0;
                  nVarLavoratoriPren := 1;
                     ELSE
                       IF (nVarCodDestinatario = 'A') THEN
                         nVarAziendePren := 1;
                  nVarLavoratoriPren := 0;
                  ELSE
                    IF (nVarCodDestinatario = 'E') THEN
                      nVarAziendePren := 1;
                      nVarLavoratoriPren := 1;
                    END IF;
                  END IF;
                     END IF;
                    nVarQtaSlot := rec_slotTipo.NUMQTA;
                    nVarNumMinuti := rec_slotTipo.NUMMINUTI;
                    nVarGiornoSlot := rec_slotTipo.NUMGIORNOSETT;
                    /*
                    nVarGiornoDataCurr :=  to_number(to_char(dataParInizio,'d', 'nls_date_language = english'));
                    nVarGiornoDataCurr := nVarGiornoDataCurr - nDiffGiorniTerritorio;
                IF (nVarGiornoDataCurr = 0) THEN
                   nVarGiornoDataCurr := 7;
                END IF;
                */
                    -- 03/08/2017 Stefy bugfix da Forum Oracle 
                    nVarGiornoDataCurr := 1 + TRUNC(dataParInizio) - TRUNC(dataParInizio, 'IW');
                    
                IF (nVarGiornoSlot = nVarGiornoDataCurr) THEN
                  dataVarInizio := dataParInizio;
                ELSE
                  IF (nVarGiornoSlot > nVarGiornoDataCurr) THEN
                    nDiffGiorni := nVarGiornoSlot - nVarGiornoDataCurr;
                  ELSE
                    nDiffGiorni := nVarGiornoDataCurr - nVarGiornoSlot;
                    nDiffGiorni := 7 - nDiffGiorni;
                  END IF;
                  dataVarInizio := dataParInizio + nDiffGiorni;
                END IF;
                WHILE dataVarInizio <= dataParFine LOOP
                  nVarDalleOre := rec_slotTipo.STRORADALLE;
                  --BISOGNA CONTROLLARE SE dataVarInizio E' UN GIORNO N.L.
                  nVarGiornoNonLav := to_number(to_char(dataVarInizio,'dd', 'nls_date_language = english'));
                  nVarMeseNonLav := to_number(to_char(dataVarInizio,'mm', 'nls_date_language = english'));
                  nVarAnnoNonLav := to_number(to_char(dataVarInizio,'yyyy', 'nls_date_language = english'));
                  SELECT count(*)
                  INTO lcountGiorniNonLav
                  FROM AG_GIORNONL
                  WHERE (
                       (NUMGG = nVarGiornoNonLav) AND
                         (NUMMM = nVarMeseNonLav) AND
                         (NUMAAAA = nVarAnnoNonLav OR NUMAAAA is null) AND
                         (DATINIZIOVAL <= trunc(dataVarInizio)
                       AND DATFINEVAL >= trunc(dataVarInizio)
                       ) AND
                       (CODCPI = codParCpi OR CODCPI is null)
                      ) OR (
                        (NUMGSETT = nVarGiornoSlot) and
                      (CODCPI = codParCpi or CODCPI is null) and
                      (datInizioVal<=dataVarInizio and datFineVal>=dataVarInizio)
                      );
                  IF (lcountGiorniNonLav = 0) THEN
                  --GIORNO LAVORATIVO
                    dtVarDataOraSlot := to_date(to_char(dataVarInizio,'dd/mm/yyyy', 'nls_date_language = english') || nVarDalleOre, 'dd/mm/yyyyhh24:mi');
                    FOR i in 1..nVarQtaSlot LOOP
--					  IF TRIM(TO_CHAR(dtVarDataOraSlot, 'DY', 'nls_date_language = english' ) ) NOT IN ('SAT', 'SUN') THEN
					  IF TRIM(TO_CHAR(dtVarDataOraSlot, 'DY', 'nls_date_language = english' ) ) NOT IN ('SUN') THEN
                      INSERT INTO AG_SLOT (PRGSLOT,
                                      CODCPI,
                                      DTMDATAORA,
                                      NUMMINUTI,
                                      CODSERVIZIO,
                                     PRGAMBIENTE,
                                      FLGPUBBLICO,
                                      NUMAZIENDE,
                                      NUMLAVORATORI,
                                      CODSTATOSLOT,
                                      CDNUTINS,
                                      DTMINS,
                                      CDNUTMOD,
                                      DTMMOD)
                      VALUES (S_AG_SLOT.nextval,
                        codParCpi,
                        dtVarDataOraSlot,
                        rec_slotTipo.NUMMINUTI,
                        rec_slotTipo.CODSERVIZIO,
                        rec_slotTipo.PRGAMBIENTE,
                        rec_slotTipo.FLGPUBBLICO,
                        nVarAziendePren,
                        nVarLavoratoriPren,
                        codParStatoSlot,
                        cdnParUtente,
                        sysdate,
                        cdnParUtente,
                        sysdate);
                      select S_AG_SLOT.currVal into prgVarSlotCurr from dual;
                      INSERT INTO AG_SPI_SLOT (PRGSPI,PRGSLOT,CODCPI)
                        VALUES (rec_slotTipo.PRGSPI,prgVarSlotCurr,codParCpi);
                      dtVarDataOraSlot := dtVarDataOraSlot + (1/(24*60)*nVarNumMinuti);
					  end if;
                    END LOOP;
                  END IF;
                  dataVarInizio := dataVarInizio + 7;
                END LOOP;
              END LOOP;
              COMMIT;
              RETURN 0;
                END IF;
          END IF;
        END IF;
          END IF;
        END IF;
       exception
    when others then
      ErrCodeOut:=sqlcode;
    dbms_output.put_line('errore'||sqlcode ||' '||sqlerrm);
    rollback;
    return -1;
  END pdInserisciSlotDaSettimana;
  --
  /***********************************
  * CANCELLAZIONE DI UN APPUNTAMENTO *
  ***********************************/
  function pdCancellaAppuntamento(codParCpi in AG_SLOT.codCpi%TYPE,
              prgParAppuntamento in AG_AGENDA.prgAppuntamento%TYPE,
              cdnParUtente in AG_SLOT.CDNUTMOD%TYPE,
               ErrCodeOut OUT NUMBER) RETURN NUMBER IS
  CURSOR cursorLav  IS SELECT *
        FROM AG_LAVORATORE,AM_LAV_PATTO_SCELTA
        WHERE AM_LAV_PATTO_SCELTA.CODLSTTAB = 'AG_LAV' AND
              AM_LAV_PATTO_SCELTA.STRCHIAVETABELLA = AG_LAVORATORE.CDNLAVORATORE AND
              AM_LAV_PATTO_SCELTA.STRCHIAVETABELLA2 = AG_LAVORATORE.CODCPI AND
              AM_LAV_PATTO_SCELTA.STRCHIAVETABELLA3 = AG_LAVORATORE.PRGAPPUNTAMENTO AND
              AG_LAVORATORE.CODCPI = codParCpi AND
              AG_LAVORATORE.PRGAPPUNTAMENTO = prgParAppuntamento;
  rec_lav     cursorLav%ROWTYPE;
  CURSOR cursorSlot  IS SELECT AG_SLOT.PRGSLOT,
                         AG_SLOT.CODCPI,
                          AG_SLOT.DTMDATAORA,
                  AG_SLOT.NUMMINUTI,
                  AG_SLOT.NUMKLOSLOT,
                  AG_SLOT.CODSTATOSLOT
        FROM AG_SLOT,AG_AGENDA,AG_SPI_SLOT
        WHERE AG_SLOT.CODCPI = AG_SPI_SLOT.CODCPI AND
              AG_SLOT.PRGSLOT = AG_SPI_SLOT.PRGSLOT AND
              TO_DATE(AG_SLOT.DTMDATAORA,'DD/MM/YYYY') =
                      TO_DATE(AG_AGENDA.DTMDATAORA,'DD/MM/YYYY') AND
              AG_SLOT.CODSTATOSLOT = 'AA' AND
              AG_SPI_SLOT.PRGSPI = AG_AGENDA.PRGSPI AND
              AG_AGENDA.CODCPI = codParCpi AND
              AG_AGENDA.PRGAPPUNTAMENTO = prgParAppuntamento;
  rec_slot     cursorSlot%ROWTYPE;
  dtmVarDataOraApp  AG_AGENDA.DTMDATAORA%TYPE;
  numVarMinutiApp    AG_AGENDA.NUMMINUTI%TYPE;
  dataFineApp      DATE;
  dataFineSlot    DATE;
  dtmVarDataOraSlot  AG_SLOT.DTMDATAORA%TYPE;
  numVarMinutiSlot  AG_SLOT.NUMMINUTI%TYPE;
  codVarStatoSlot   AG_SLOT.CODSTATOSLOT%TYPE;
  flagVarStato     DE_STATO_APPUNTAMENTO.FLGATTIVO%TYPE;
  codVarStato      DE_STATO_APPUNTAMENTO.CODSTATOAPPUNTAMENTO%TYPE;
  lcount        integer;
  lcountslot      integer;
  bCancellaAppunt    BOOLEAN := TRUE;
  numVarKloSlot    AG_SLOT.NUMKLOSLOT%TYPE := null;
  sFlagCancella    integer := 1;
  ErrCodeOutAllinea   NUMBER := null;
  nErroreStored    NUMBER := 0;
  bCanCommit      boolean := true;
  str_where       varchar2(2000);
  BEGIN
    SELECT AG_AGENDA.DTMDATAORA,
           AG_AGENDA.NUMMINUTI,
           AG_AGENDA.CODSTATOAPPUNTAMENTO,
           DE_STATO_APPUNTAMENTO.FLGATTIVO
    INTO dtmVarDataOraApp,
         numVarMinutiApp,
         codVarStato,
         flagVarStato
    FROM AG_AGENDA
    INNER JOIN DE_STATO_APPUNTAMENTO ON (AG_AGENDA.CODSTATOAPPUNTAMENTO =
            DE_STATO_APPUNTAMENTO.CODSTATOAPPUNTAMENTO)
    WHERE AG_AGENDA.CODCPI = codParCpi AND
          AG_AGENDA.PRGAPPUNTAMENTO = prgParAppuntamento;
    dataFineApp := dtmVarDataOraApp + (1/(24*60)*numVarMinutiApp);
    IF (UPPER(flagVarStato) = 'N') THEN
    --NESSUN CONTROLLO
        -- Log della Delete su AG_LAVORATORE
        str_where := ' WHERE AG_LAVORATORE.CODCPI = ''' || codParCpi ||
               ''' AND AG_LAVORATORE.PRGAPPUNTAMENTO = ' || prgParAppuntamento;
        PG_LOG.DOLOG('D', 'AG_LAVORATORE', cdnParUtente, str_where);
      DELETE FROM AG_LAVORATORE
      WHERE AG_LAVORATORE.CODCPI = codParCpi AND
            AG_LAVORATORE.PRGAPPUNTAMENTO = prgParAppuntamento;
      -- Log della Delete su AG_AGENDA
        str_where := ' WHERE AG_AGENDA.CODCPI = ''' || codParCpi ||
               ''' AND AG_AGENDA.PRGAPPUNTAMENTO = ' || prgParAppuntamento;
        PG_LOG.DOLOG('D', 'AG_AGENDA', cdnParUtente, str_where);
      DELETE FROM AG_AGENDA
      WHERE AG_AGENDA.CODCPI = codParCpi AND
            AG_AGENDA.PRGAPPUNTAMENTO = prgParAppuntamento;
    ELSE
      --CONTROLLI E ALLINEAMENTI
      SELECT COUNT(*)
            INTO lcount
            FROM AG_LAVORATORE
            WHERE AG_LAVORATORE.CODCPI = codParCpi AND
                  AG_LAVORATORE.PRGAPPUNTAMENTO = prgParAppuntamento;
      IF (lcount > 0) THEN
        IF (NOT cursorLav%ISOPEN) THEN
          OPEN cursorLav;
        END IF;
        FETCH cursorLav INTO rec_lav;
        IF (cursorLav%ROWCOUNT > 0) THEN
        --PRGAPPUNTAMENTO LEGATO CON IL PATTO,CANCELLAZIONE NON POSSIBILE
          bCancellaAppunt := FALSE;
        END IF;
      END IF;
      IF (bCancellaAppunt = TRUE) THEN
          SELECT count(*)
              INTO lcountslot
              FROM AG_SLOT
              WHERE AG_SLOT.CODCPIAPPUNTAMENTO = codParCpi AND
                    AG_SLOT.PRGAPPUNTAMENTO = prgParAppuntamento;
          IF (lcountslot > 0) THEN
               SELECT NUMKLOSLOT
              INTO numVarKloSlot
              FROM AG_SLOT
              WHERE AG_SLOT.CODCPIAPPUNTAMENTO = codParCpi AND
                    AG_SLOT.PRGAPPUNTAMENTO = prgParAppuntamento;
              numVarKloSlot := numVarKloSlot + 1;
          UPDATE AG_SLOT
          SET CODCPIAPPUNTAMENTO = null,
              PRGAPPUNTAMENTO = null,
              CODSTATOSLOT = 'C',
              NUMAZIENDEPRENOTATE = 0,
              NUMLAVPRENOTATI = 0,
              CDNUTMOD = cdnParUtente,
              DTMMOD = sysdate,
              NUMKLOSLOT = numVarKloSlot
          WHERE AG_SLOT.CODCPIAPPUNTAMENTO = codParCpi AND
                      AG_SLOT.PRGAPPUNTAMENTO = prgParAppuntamento;
           END IF;
        --CHIAMATA A PDALLINEAMENTOSLOT
        nErroreStored := pdAllineamentoSlot(codParCpi,
                          prgParAppuntamento,
                          null,
                          codVarStato,
                          cdnParUtente,
                          sFlagCancella,
                              ErrCodeOutAllinea);
        IF (nErroreStored <> 0 OR ErrCodeOutAllinea is not null) THEN
            rollback;
          return 2; --allineamento slot fallito
        ELSE
          -- Log della Delete su AG_LAVORATORE
            str_where := ' WHERE AG_LAVORATORE.CODCPI = ''' || codParCpi ||
               ''' AND AG_LAVORATORE.PRGAPPUNTAMENTO = ' || prgParAppuntamento;
            PG_LOG.DOLOG('D', 'AG_LAVORATORE', cdnParUtente, str_where);
          DELETE FROM AG_LAVORATORE
          WHERE AG_LAVORATORE.CODCPI = codParCpi AND
                AG_LAVORATORE.PRGAPPUNTAMENTO = prgParAppuntamento;
          -- Log della Delete su AG_AGENDA
            str_where := ' WHERE AG_AGENDA.CODCPI = ''' || codParCpi ||
               ''' AND AG_AGENDA.PRGAPPUNTAMENTO = ' || prgParAppuntamento;
            PG_LOG.DOLOG('D', 'AG_AGENDA', cdnParUtente, str_where);
          DELETE FROM AG_AGENDA
          WHERE AG_AGENDA.CODCPI = codParCpi AND
                AG_AGENDA.PRGAPPUNTAMENTO = prgParAppuntamento;
        END IF;
      ELSE
      --PRGAPPUNTAMENTO LEGATO CON IL PATTO,CANCELLAZIONE NON POSSIBILE
        RETURN 1;
      END IF;
    END IF;
    COMMIT;
    RETURN 0;
    exception
    when others then
      ErrCodeOut:=sqlcode;
    dbms_output.put_line('errore'||sqlcode ||' '||sqlerrm);
    rollback;
    return -1;
  END pdCancellaAppuntamento;
  --
  /*****************************
  * CANCELLAZIONE MASSIVA SLOT *
  *****************************/
  function pdCancellaSlotMassiva(codParCpi in AG_SLOT.codCpi%TYPE,
                      dataParInizioStr in varchar2,
                     dataParFineStr in varchar2,
                     codParServizio in AG_SLOT.CODSERVIZIO%TYPE,
                     prgSpiOperatore in AG_SPI_SLOT.PRGSPI%TYPE,
               cdnParUtente in AG_SLOT.CDNUTINS%TYPE,
                     ErrCodeOut OUT NUMBER) RETURN NUMBER IS
  lcount        integer;
  dataParInizio    DATE;
  dataParFine      DATE;
  bCancellaSlot    BOOLEAN:=FALSE;
  str_where      varchar2(2000);
  BEGIN
    dataParInizio := to_date(dataParInizioStr,'dd/mm/yyyy');
    dataParFine := to_date(dataParFineStr,'dd/mm/yyyy');
    IF (codParServizio is null AND prgSpiOperatore is null) THEN
      SELECT COUNT(*)
      INTO lcount
      FROM AG_SLOT
      WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,'DD/MM/YYYY', 'nls_date_language = english'),'DD/MM/YYYY') BETWEEN
        dataParInizio AND dataParFine AND
            AG_SLOT.CODSTATOSLOT IN ('AA','P','T') AND
            AG_SLOT.CODCPI = codParCpi;
      IF (lcount = 0) THEN
          -- Log della Delete su AG_SLOT
        str_where := ' WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,''DD/MM/YYYY'', ''nls_date_language = english''),''DD/MM/YYYY'') BETWEEN ''' ||
                 dataParInizio || ''' AND ''' || dataParFine || ''' AND AG_SLOT.CODCPI = ''' ||
               codParCpi || ''' ';
        PG_LOG.DOLOG('D', 'AG_SLOT', cdnParUtente, str_where);
        --
        DELETE FROM AG_SLOT
        WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,'DD/MM/YYYY', 'nls_date_language = english'),'DD/MM/YYYY') BETWEEN
          dataParInizio AND dataParFine AND
          AG_SLOT.CODCPI = codParCpi;
        bCancellaSlot := TRUE;
      ELSE
        RETURN 1;
      END IF;
    ELSE
      IF (codParServizio is not null AND prgSpiOperatore is null) THEN
        SELECT COUNT(*)
        INTO lcount
        FROM AG_SLOT
        WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,'DD/MM/YYYY', 'nls_date_language = english'),'DD/MM/YYYY') BETWEEN
          dataParInizio AND dataParFine AND
              AG_SLOT.CODSERVIZIO = codParServizio AND
              AG_SLOT.CODSTATOSLOT IN ('AA','P','T') AND
              AG_SLOT.CODCPI = codParCpi;
        IF (lcount = 0) THEN
            -- Log della Delete su AG_SLOT
          str_where := ' WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,''DD/MM/YYYY'', ''nls_date_language = english''),''DD/MM/YYYY'') BETWEEN ''' ||
                 dataParInizio || ''' AND ''' || dataParFine || ''' AND AG_SLOT.CODSERVIZIO = ''' ||
               codParServizio || ''' AND AG_SLOT.CODCPI = ''' || codParCpi || ''' ';
          PG_LOG.DOLOG('D', 'AG_SLOT', cdnParUtente, str_where);
            --
          DELETE FROM AG_SLOT
          WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,'DD/MM/YYYY', 'nls_date_language = english'),'DD/MM/YYYY') BETWEEN
            dataParInizio AND dataParFine AND
                      AG_SLOT.CODSERVIZIO = codParServizio AND
                      AG_SLOT.CODCPI = codParCpi;
          bCancellaSlot := TRUE;
        ELSE
          RETURN 1;
        END IF;
      ELSE
        IF (codParServizio is null AND prgSpiOperatore is not null) THEN
          SELECT COUNT(*)
          INTO lcount
          FROM AG_SLOT
          INNER JOIN AG_SPI_SLOT ON (AG_SLOT.PRGSLOT = AG_SPI_SLOT.PRGSLOT AND AG_SLOT.CODCPI = AG_SPI_SLOT.CODCPI)
          WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,'DD/MM/YYYY', 'nls_date_language = english'),'DD/MM/YYYY') BETWEEN
            dataParInizio AND dataParFine AND
                AG_SPI_SLOT.PRGSPI = prgSpiOperatore AND
                AG_SLOT.CODSTATOSLOT IN ('AA','P','T') AND
                AG_SLOT.CODCPI = codParCpi;
          IF (lcount = 0) THEN
              -- Log della Delete su AG_SLOT
            str_where := ' WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,''DD/MM/YYYY'', ''nls_date_language = english''),''DD/MM/YYYY'') BETWEEN ''' ||
                 dataParInizio || ''' AND ''' || dataParFine || ''' AND AG_SLOT.CODCPI = ''' ||
               codParCpi || ''' AND EXISTS (' ||
               'SELECT * FROM AG_SPI_SLOT WHERE AG_SPI_SLOT.PRGSLOT=AG_SLOT.PRGSLOT AND ' ||
                   'AG_SPI_SLOT.CODCPI=AG_SLOT.CODCPI AND AG_SPI_SLOT.PRGSPI=' || prgSpiOperatore || ')';
            PG_LOG.DOLOG('D', 'AG_SLOT', cdnParUtente, str_where);
              --
            DELETE FROM AG_SLOT
            WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,'DD/MM/YYYY', 'nls_date_language = english'),'DD/MM/YYYY') BETWEEN
              dataParInizio AND dataParFine AND
              AG_SLOT.CODCPI = codParCpi AND EXISTS (SELECT * FROM AG_SPI_SLOT WHERE AG_SPI_SLOT.PRGSLOT=AG_SLOT.PRGSLOT AND
                                                 AG_SPI_SLOT.CODCPI=AG_SLOT.CODCPI AND AG_SPI_SLOT.PRGSPI=prgSpiOperatore);
            bCancellaSlot := TRUE;
          ELSE
            RETURN 1;
          END IF;
        ELSE
          SELECT COUNT(*)
          INTO lcount
          FROM AG_SLOT
          INNER JOIN AG_SPI_SLOT ON (AG_SLOT.PRGSLOT = AG_SPI_SLOT.PRGSLOT AND AG_SLOT.CODCPI = AG_SPI_SLOT.CODCPI)
          WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,'DD/MM/YYYY', 'nls_date_language = english'),'DD/MM/YYYY') BETWEEN
              dataParInizio AND dataParFine AND
                AG_SLOT.CODSERVIZIO = codParServizio AND
                AG_SPI_SLOT.PRGSPI = prgSpiOperatore AND
                AG_SLOT.CODSTATOSLOT IN ('AA','P','T') AND
                AG_SLOT.CODCPI = codParCpi;
                IF (lcount = 0) THEN
            -- Log della Delete su AG_SLOT
            str_where := 'WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,''DD/MM/YYYY'', ''nls_date_language = english''),''DD/MM/YYYY'') BETWEEN ''' ||
                 dataParInizio || ''' AND ''' || dataParFine || ''' AND AG_SLOT.CODSERVIZIO=''' ||
               codParServizio || ''' AND AG_SLOT.CODCPI = ''' || codParCpi || ''' AND EXISTS (' ||
               'SELECT * FROM AG_SPI_SLOT WHERE AG_SPI_SLOT.PRGSLOT=AG_SLOT.PRGSLOT AND ' ||
                   'AG_SPI_SLOT.CODCPI=AG_SLOT.CODCPI AND AG_SPI_SLOT.PRGSPI=' || prgSpiOperatore || ')';
            PG_LOG.DOLOG('D', 'AG_SLOT', cdnParUtente, str_where);
            --
            DELETE FROM AG_SLOT
            WHERE TO_DATE(TO_CHAR(AG_SLOT.DTMDATAORA,'DD/MM/YYYY', 'nls_date_language = english'),'DD/MM/YYYY') BETWEEN
              dataParInizio AND dataParFine AND
                        AG_SLOT.CODSERVIZIO = codParServizio AND
                        AG_SLOT.CODCPI = codParCpi AND EXISTS (SELECT * FROM AG_SPI_SLOT WHERE AG_SPI_SLOT.PRGSLOT=AG_SLOT.PRGSLOT AND
                                                      AG_SPI_SLOT.CODCPI=AG_SLOT.CODCPI AND AG_SPI_SLOT.PRGSPI=prgSpiOperatore);
            bCancellaSlot := TRUE;
          ELSE
            RETURN 1;
          END IF;
        END IF;
      END IF;
    END IF;
    IF (bCancellaSlot = TRUE) THEN
      COMMIT;
    END IF;
    RETURN 0;
    exception
    when others then
      ErrCodeOut:=sqlcode;
    dbms_output.put_line('errore'||sqlcode ||' '||sqlerrm);
    rollback;
    return -1;
  END pdCancellaSlotMassiva;
--------------------------------------
/**************************
*   Funzioni di Utilità   *
**************************/
FUNCTION pdFirstLavApp(p_codCpi in AG_AGENDA.CODCPI%type,
              p_prgAppuntamento in AG_AGENDA.PRGAPPUNTAMENTO%type) RETURN varchar2 IS
  strCognNom varchar2(200) := null;
BEGIN
   begin
     select
         Initcap(an.strNome) || ' ' ||Initcap(an.strCognome) into strCognNom
     from ag_lavoratore l, an_lavoratore an
     where (l.CDNLAVORATORE=an.CDNLAVORATORE) and
         (l.CODCPI=p_codCpi and l.PRGAPPUNTAMENTO=p_prgAppuntamento)
         and rownum=1
     order by an.STRCOGNOME, an.STRNOME;
     exception when no_data_found then
        strCognNom := '';
   end;

   return strCognNom;

   exception
     when others then
       return null;
END pdFirstLavApp;
--
--
FUNCTION pdAppErr(p_codCpi in AG_AGENDA.CODCPI%type,
           p_prgAppuntamento in AG_AGENDA.PRGAPPUNTAMENTO%type) RETURN varchar2 IS
  strAppErr varchar2(200) := null;
BEGIN
   begin
     select to_char(prgAppuntamento) into strAppErr
     from vw_agenda_errd
     where
          codcpi=p_codCpi and prgAppuntamento=p_prgAppuntamento;
     exception when no_data_found then
        strAppErr := null;
   end;

   return strAppErr;

   exception
     when others then
       return null;
END pdAppErr;
--
--
FUNCTION pdSlotErr(p_codCpi in AG_SLOT.CODCPI%type,
           p_prgSlot in AG_SLOT.PRGSLOT%type) RETURN varchar2 is
   strSlotErr varchar2(200) := null;
BEGIN
   begin
     select to_char(prgSlot) into strSlotErr
     from vw_slot_errd
     where
          codcpi=p_codCpi and prgSlot=p_prgSlot;
     exception when no_data_found then
        strSlotErr := null;
   end;

   return strSlotErr;

   exception
     when others then
       return null;
END pdSlotErr;
/*****************************************
*   Inserimento Multiplo di nuovi Slot   *
*****************************************/
function pdInsMultiploSlot(p_dataInizio in varchar2,
                  p_dataFine in varchar2,
              p_prgSpi in varchar2,
              p_codServizio in varchar2,
              p_prgAmbiente in varchar2,
              p_numAzienda in varchar2,
              p_numLavoratori in varchar2,
              p_flgPubblico in varchar2,
              p_oraInizio in varchar2,
              p_oraFine in varchar2,
              p_numMinuti in varchar2,
              p_numQta in varchar2,
              p_codStatoSlot in varchar2,
                    p_codCpi in varchar2,
                    p_cdnUtente in varchar2,
                    strCodeOut OUT varchar2) RETURN NUMBER

IS
  parDataInizio date;
  parDataFine date;
  parPrgSlot AG_SLOT.PRGSLOT%type;
  parDtmDataOra AG_SLOT.DTMDATAORA%type;
  parPrgSpi AG_SPI_SLOT.PRGSPI%type;
  parCodServizio AG_SLOT.CODSERVIZIO%type;
  parPrgAmbiente AG_SLOT.PRGAMBIENTE%type;
  parNumAziende AG_SLOT.NUMAZIENDE%type;
  parNumLavoratori AG_SLOT.NUMLAVORATORI%type;
  parFlgPubblico AG_SLOT.FLGPUBBLICO%type;
  parNumMinuti number;
  parNumQta number;
  parCodStatoSlot AG_SLOT.CODSTATOSLOT%type;
  parCodCpi AG_SLOT.CODCPI%type;
  parCdnUtente AG_SLOT.CDNUTINS%type;

  insSlot boolean := true;
  varNumDT number;
  nro number;
  nroF number;
  nroG number;
  nroNonInseriti number := 0;
  nroErrori number := 0;
  varDataIns date;
  varDataInsFine date;
  varNumGiorno number;
BEGIN
  -- INIZIALIZZAZIONE
  
  parDataInizio := to_date(p_dataInizio, 'dd/mm/yyyy');
  parDataFine := to_date(p_dataFine, 'dd/mm/yyyy');
  parPrgSpi := p_prgSpi;
  parCodServizio := p_codServizio;
  parPrgAmbiente := p_prgAmbiente;
  parNumAziende := to_number(p_numAzienda);
  parNumLavoratori :=  to_number(p_numLavoratori);
  parFlgPubblico := p_flgPubblico;
  parNumMinuti :=  to_number(p_numMinuti);
  parNumQta := to_number(p_numQta);
  parCodStatoSlot :=  p_codStatoSlot;
  parCodCpi := p_codCpi;
  parCdnUtente := p_cdnUtente;
  varDataIns := parDataInizio;

  WHILE insSlot LOOP
      -- Controllo sulla FESTIVITA'
      /*
      varNumGiorno := to_number(to_char(varDataIns,'d', 'nls_date_language = english')) - varNumDT;
      if(varNumGiorno=0) then
         varNumGiorno := 7;
      end if;
      */
      -- 03/08/2017 Stefy bugfix da Forum Oracle 
      varNumGiorno := 1 + TRUNC(varDataIns) - TRUNC(varDataIns, 'IW');
      --
      select count(1) into nroF
      from ag_giornonl
      where
          (numgg = to_number(to_char(varDataIns,'dd', 'nls_date_language = english'))) and
        (nummm = to_number(to_char(varDataIns,'mm', 'nls_date_language = english'))) and
        (numaaaa = to_number(to_char(varDataIns,'yyyy', 'nls_date_language = english')) or numaaaa is null) and
        (codcpi = parCodCpi or codcpi is null) and
        (datInizioVal<=varDataIns and datFineVal>=varDataIns);
      --
      select count(1) into nroG
      from ag_giornonl
      where
          (numgsett = varNumGiorno) and
        (codcpi = parCodCpi or codcpi is null) and
        (datInizioVal<=varDataIns and datFineVal>=varDataIns);
      --
      if(nroF=0 and nroG=0) then
         parDtmDataOra := to_date(to_char(varDataIns,'dd/mm/yyyy', 'nls_date_language = english') || ' ' || p_oraInizio, 'dd/mm/yyyy hh24:mi');
       FOR i in 1 .. parNumQta LOOP
         -- Controllo di non sovrapposizione: se c'è già uno slot che si sovrappone non lo inserisco
         varDataInsFine := parDtmDataOra + (1/(24*60) * parNumMinuti);
         select count(1) into nro
         from ag_slot
             inner join ag_spi_slot on
                (ag_slot.PRGSLOT=ag_spi_slot.PRGSLOT and ag_slot.CODCPI=ag_spi_slot.CODCPI)
         where
             ag_slot.codCpi = parCodCpi and
            prgSpi = parPrgSpi and
            trunc(dtmDataOra)=trunc(parDtmDataOra) and
            (
             (dtmDataOra<=parDtmDataOra and
             parDtmDataOra<(dtmDataora+(1/(24*60)*numMinuti))
             and (dtmDataora+(1/(24*60)*numMinuti))<=varDataInsFine)
            OR
             (parDtmDataOra <= dtmDataOra and
             dtmDataOra < varDataInsFine and
             varDataInsFine <= (dtmDataOra+(1/(24*60)*numMinuti)))
            );
         --
         if(nro=0) then
--		   IF TRIM(TO_CHAR(parDtmDataOra, 'DY', 'nls_date_language = english' ) ) NOT IN ('SAT', 'SUN') THEN 
		   IF TRIM(TO_CHAR(parDtmDataOra, 'DY', 'nls_date_language = english' ) ) NOT IN ('SUN') THEN 
           select S_AG_SLOT.nextVal into parPrgSlot from dual;
           begin
             -- Inserisco lo Slot
             insert into AG_SLOT
             (PRGSLOT, CODCPI, DTMDATAORA,
             NUMMINUTI, CODSERVIZIO, PRGAMBIENTE,
             FLGPUBBLICO, NUMAZIENDE, NUMLAVORATORI,
             CODSTATOSLOT, CDNUTINS, DTMINS,
             CDNUTMOD, DTMMOD)
             values
             (parPrgSlot, parCodCpi, parDtmDataOra,
             parNumMinuti, parCodServizio, parPrgAmbiente,
             parFlgPubblico, parNumAziende, parNumLavoratori,
             parCodStatoSlot, parCdnUtente, sysdate,
             parCdnUtente, sysdate);
             -- Inserisco l'operatore per lo Slot
             insert into AG_SPI_SLOT
             (PRGSLOT, CODCPI, PRGSPI)
             values
             (parPrgSlot, parCodCpi, parPrgSpi);
             --
              exception
              when others then
                 --nroNonInseriti := nroNonInseriti + 1;
                nroErrori := nroErrori;
           end;
           end if;		   
         else
            nroNonInseriti := nroNonInseriti + 1;
         end if;
         -- Calcolo data e ora per lo slot successivo
         parDtmDataOra := parDtmDataOra + (1/(24*60) * parNumMinuti);
       END LOOP; -- FOR i in 1 .. parNumQta LOOP
      end if;

      varDataIns := varDataIns + 1;
      if(parDataFine < varDataIns) then
         insSlot := false;
      end if;
  END LOOP; -- while insSlot loop ...

  commit;
  if(nroNonInseriti>0) then
     strCodeOut := to_char(nroNonInseriti) || ' Slot non inseriti';
  end if;
  if(nroErrori>0) then
     if(length(strCodeOut)>0) then
        strCodeOut := strCodeOut || '<br>';
     end if;
     strCodeOut := strCodeOut || to_char(nroErrori) || ' errori di inserimento';
  end if;
  if(nroNonInseriti>0 or nroErrori>0) then
     return 1;
  else
     return 0;
  end if;
  --
  exception
        when others then
           dbms_output.put_line('errore'||sqlcode ||' '||sqlerrm);
           strCodeOut := sqlErrm;
           rollback;
           return -1;
END pdInsMultiploSlot;
--

function ao_aggiornaAppuntamentoIdCoap (
  
    in_prgAppuntamento in ag_agenda.prgAppuntamento%TYPE,
    in_strIdCoap in ag_agenda.STRIDCOAP%type,
	cdnParUtente in ag_agenda.CDNUTMOD%TYPE,
	in_doCommit in varchar2,
        
    ErrCodeOut OUT varchar2
    
  ) RETURN NUMBER
  IS
  
  nVarNumKloAgenda ag_agenda.numkloagenda%type;
  
  BEGIN
  
   SELECT AG_AGENDA.NUMKLOAGENDA 
    INTO nVarNumKloAgenda
    FROM AG_AGENDA
	WHERE PRGAPPUNTAMENTO = in_prgAppuntamento;

	
	PG_LOG.doLog('U', 'AG_AGENDA', cdnParUtente, ' WHERE PRGAPPUNTAMENTO = ' || in_prgAppuntamento);

	update AG_AGENDA
		set STRIDCOAP = in_strIdCoap, 			 
		NUMKLOAGENDA = nVarNumKloAgenda +1, cdnutmod = cdnParUtente, dtmmod = sysdate
	where PRGAPPUNTAMENTO = in_prgAppuntamento;
  
	return 0;
    exception
        when others then
           dbms_output.put_line('errore'||sqlcode ||' '||sqlerrm);
           ErrCodeOut := sqlErrm;
           rollback;
           return -1;
END ao_aggiornaAppuntamentoIdCoap;
--
END PG_AGENDA;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/pg_anagrafica_professionale_rp.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE pg_anagrafica_professionale_rp

IS
    FUNCTION GetDataFineMovEffForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.DATFINEMOV%TYPE;
	FUNCTION GetCodContrattoForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.CODCONTRATTO%TYPE;
	FUNCTION GetCodMonoTempoForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.CODMONOTEMPO%TYPE;
	FUNCTION GetOreLavorateForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.NUMORESETT%TYPE;
   	FUNCTION GetDatInizioComputoForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN CM_RICH_COMPUTO.DATINIZIO%TYPE;
    FUNCTION ExistsDatInizioComputoForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN VARCHAR2; 
    FUNCTION GetDtmModForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.DTMMOD%TYPE;
    FUNCTION GetCategoriaDaNullaOstaForRp(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE, 
			 				  Pprgazienda IN am_movimento.PRGAZIENDA%TYPE, 
							  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
							  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOCATEGORIA%TYPE; 
    FUNCTION GetTipoDaNullaOstaForRp(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE, 
			 				  Pprgazienda IN am_movimento.PRGAZIENDA%TYPE, 
							  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
							  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOTIPO%TYPE;
	FUNCTION GetTipoOrarioForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN DE_ORARIO.CODMONOORARIO%TYPE;
END pg_anagrafica_professionale_rp;
/

CREATE OR REPLACE PACKAGE BODY pg_anagrafica_professionale_rp
IS


   FUNCTION GetDataFineMovEffForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.DATFINEMOV%TYPE
   	 IS
	   VarMovi am_movimento.prgmovimento%TYPE;
	   VarSucc am_movimento.PRGMOVIMENTO%TYPE;
	   VarTipo varchar(3);
	   VarDatFineMovEffettiva am_movimento.DATFINEMOVEFFETTIVA%TYPE;
	   VarDateRet am_movimento.DATFINEMOVEFFETTIVA%TYPE;
	   VarDatInizioMov am_movimento.DATINIZIOMOV%TYPE;
	   
	 BEGIN
 	 	 varMovi := PprgMovimento;
		 select codtipomov, nvl(PRGMOVIMENTOSUCC,-1), DATFINEMOVEFFETTIVA, DATINIZIOMOV
		 into VarTipo, VarSucc, VarDatFineMovEffettiva, VarDatInizioMov
		 from am_movimento
	     where prgmovimento = varMovi;

		 WHILE (VarTipo <> 'CES' and VarSucc <> -1) loop
	  		VarMovi := VarSucc;
	  		select codtipomov, nvl(prgmovimentosucc,-1), DATFINEMOVEFFETTIVA, DATINIZIOMOV
			  into VarTipo, VarSucc, VarDatFineMovEffettiva, VarDatInizioMov
			  from am_movimento
			 where prgmovimento = varMovi;
	  	END LOOP;

		IF VarTipo <> 'CES' THEN
		   		VarDateRet := VarDatFineMovEffettiva;
		ELSE
		   		VarDateRet := VarDatInizioMov;
		END IF;

		RETURN VarDateRet;

   END;


   FUNCTION GetCodContrattoForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.CODCONTRATTO%TYPE
   IS
    VarMovi am_movimento.prgmovimento%TYPE;
    VarSucc am_movimento.PRGMOVIMENTO%TYPE;
    VarTipo varchar(3);
    VarCodContrattoRet am_movimento.CODCONTRATTO%TYPE;

  BEGIN
     varMovi := PprgMovimento;
     select am_movimento.codtipomov, nvl(am_movimento.PRGMOVIMENTOSUCC,-1), de_tipo_contratto.CODCONTRATTO
     into VarTipo, VarSucc, VarCodContrattoRet
     from am_movimento  
     left join de_tipo_contratto  on de_tipo_contratto.codtipocontratto = am_movimento.codtipocontratto    
     where prgmovimento = varMovi;

   WHILE (VarTipo <> 'CES' and VarSucc <> -1) loop
     VarMovi := VarSucc;
     select am_movimento.codtipomov, nvl(am_movimento.PRGMOVIMENTOSUCC,-1), de_tipo_contratto.CODCONTRATTO
        into VarTipo, VarSucc, VarCodContrattoRet
     from am_movimento
     left join de_tipo_contratto  on de_tipo_contratto.codtipocontratto = am_movimento.codtipocontratto
     where prgmovimento = varMovi;
    END LOOP;

  	RETURN VarCodContrattoRet;

   END;



	FUNCTION GetCodMonoTempoForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.CODMONOTEMPO%TYPE
	IS
	   VarMovi am_movimento.prgmovimento%TYPE;
	   VarSucc am_movimento.PRGMOVIMENTO%TYPE;
	   VarTipo varchar(3);
	   VarCodMonoTempoRet am_movimento.CODMONOTEMPO%TYPE;

	 BEGIN
 	 	 varMovi := PprgMovimento;
		 select codtipomov, nvl(PRGMOVIMENTOSUCC,-1), CODMONOTEMPO
		 into VarTipo, VarSucc, VarCodMonoTempoRet
		 from am_movimento
	     where prgmovimento = varMovi;

		 WHILE (VarTipo <> 'CES' and VarSucc <> -1) loop
	  		VarMovi := VarSucc;
	  		select codtipomov, nvl(prgmovimentosucc,-1), CODMONOTEMPO
			  into VarTipo, VarSucc, VarCodMonoTempoRet
			  from am_movimento
			 where prgmovimento = varMovi;
	  	END LOOP;

		RETURN VarCodMonoTempoRet;

   END;

   FUNCTION GetOreLavorateForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.NUMORESETT%TYPE
   IS
	   VarMovi am_movimento.prgmovimento%TYPE;
	   VarSucc am_movimento.PRGMOVIMENTO%TYPE;
	   VarTipo varchar(3);
	   VarOreLavorateRet am_movimento.NUMORESETT%TYPE;

	 BEGIN
 	 	 varMovi := PprgMovimento;
		 select codtipomov, nvl(PRGMOVIMENTOSUCC,-1), NUMORESETT
		 into VarTipo, VarSucc, VarOreLavorateRet
		 from am_movimento
	     where prgmovimento = varMovi;

		 WHILE (VarTipo <> 'CES' and VarSucc <> -1) loop
	  		VarMovi := VarSucc;
	  		select codtipomov, nvl(PRGMOVIMENTOSUCC,-1), NUMORESETT
		      into VarTipo, VarSucc, VarOreLavorateRet
			  from am_movimento
			 where prgmovimento = varMovi;
	  	END LOOP;

		RETURN VarOreLavorateRet;

   END;  

   FUNCTION GetDatInizioComputoForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN CM_RICH_COMPUTO.DATINIZIO%TYPE
   IS
	   VarMovi am_movimento.prgmovimento%TYPE;
	   VarSucc am_movimento.PRGMOVIMENTO%TYPE;
	   varDatMin cm_rich_computo.DATINIZIO%TYPE;
	   datInizioComp cm_rich_computo.DATINIZIO%TYPE;
	   
	 BEGIN
 	 	 varMovi := PprgMovimento;
		 varDatMin := null;
		 
		 LOOP	  					 
			 select min(comp.datinizio) 
			 into datInizioComp
			 from cm_rich_computo comp
			 inner join am_documento_coll coll on (comp.PRGRICHCOMPUTO = coll.STRCHIAVETABELLA) 
			 inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)   
			 where comp.prgmovimento = VarMovi  
			 and doc.CODSTATOATTO = 'PR' 
			 and doc.CODTIPODOCUMENTO = 'CMDCOMP';

			 if datInizioComp is not null then
			 	 	if varDatMin is not null then 
				 	   if datInizioComp < varDatMin then
					   	  varDatMin := datInizioComp;
					   end if;
				 	else 
				 	   varDatMin := datInizioComp;  
				 	end if;
			 end if;	
			 
	  		 select nvl(PRGMOVIMENTOSUCC,-1) 
		     into VarSucc 
			 from am_movimento
			 where prgmovimento = varMovi; 
			 
			 EXIT WHEN VarSucc = -1;			 
			 
			 VarMovi := VarSucc;
		 END LOOP;
		 
		 return trunc(varDatMin);
   	 END;

   FUNCTION ExistsDatInizioComputoForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN VARCHAR2
   IS
	   VarMovi am_movimento.prgmovimento%TYPE;
	   VarSucc am_movimento.PRGMOVIMENTO%TYPE;
	   res varchar2(8);
     checjkComp number;
	 BEGIN
		varMovi := PprgMovimento;
	    res := 'false';

	   LOOP
     
         select count(comp.prgrichcomputo)   
         into checjkComp      
         from cm_rich_computo comp, am_documento_coll coll, am_documento doc
         where comp.PRGRICHCOMPUTO = coll.STRCHIAVETABELLA
         and coll.PRGDOCUMENTO = doc.PRGDOCUMENTO
         and comp.prgmovimento = varMovi
         and doc.CODSTATOATTO = 'PR'
         and doc.CODTIPODOCUMENTO = 'CMDCOMP';
         
         if (checjkComp > 0) then
           select 'true'
           into res
           from dual where
           exists (select 1
                   from cm_rich_computo comp, am_documento_coll coll, am_documento doc
                   where comp.PRGRICHCOMPUTO = coll.STRCHIAVETABELLA
                   and coll.PRGDOCUMENTO = doc.PRGDOCUMENTO
                   and comp.prgmovimento = varMovi
                   and doc.CODSTATOATTO = 'PR'
                   and doc.CODTIPODOCUMENTO = 'CMDCOMP');
         end if;

		 select nvl(PRGMOVIMENTOSUCC,-1)
	     into VarSucc
		 from am_movimento
  		 where prgmovimento = varMovi;

		 EXIT WHEN VarSucc = -1 or res = 'true';

		 VarMovi := VarSucc;

	   END LOOP;

	   return res;

   END;
   
   FUNCTION GetDtmModForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.DTMMOD%TYPE
   IS
	   VarMovi   am_movimento.prgmovimento%TYPE;
	   VarSucc   am_movimento.PRGMOVIMENTO%TYPE;
	   varDtmMod am_movimento.DTMMOD%TYPE;
	   
	 BEGIN
 	 	 
 	 	 varMovi := PprgMovimento;
  		 select nvl(PRGMOVIMENTOSUCC,-1), dtmmod 
	     into VarSucc, varDtmMod  
		 from am_movimento
		 where prgmovimento = varMovi;

		 WHILE (VarSucc <> -1) loop
	  		 VarMovi := VarSucc;
	  		 select nvl(PRGMOVIMENTOSUCC,-1), dtmmod 
		     into VarSucc, varDtmMod  
			 from am_movimento
			 where prgmovimento = varMovi;
	  	 END LOOP;

		return varDtmMod;
   END;

   FUNCTION GetCategoriaDaNullaOstaForRp(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
			 				  Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
							  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
							  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOCATEGORIA%TYPE
   IS
     varCodMonoCat cm_nulla_osta.CODMONOCATEGORIA%TYPE;
     checkNo number;
	 BEGIN
      
     varCodMonoCat := null;

     select count(nuos.CODMONOCATEGORIA) into checkNo
				 from cm_nulla_osta nuos
				 inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA)
				 inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
				 where doc.CODSTATOATTO = 'PR'
				 and doc.CODTIPODOCUMENTO = 'NULOST'
			   	 and nuos.cdnlavoratore = Pcdnlavoratore
				 and nuos.prgazienda= Pprgazienda
				 and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni
				 order by abs(nuos.DATINIZIO - Pdatiniziomov) asc, nuos.CODMONOCATEGORIA desc;

     if (checkNo > 0) then 
       select CODMONOCATEGORIA
       into varCodMonoCat
       from (select abs(nuos.DATINIZIO - Pdatiniziomov), nuos.CODMONOCATEGORIA
           from cm_nulla_osta nuos
           inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA)
           inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
           where doc.CODSTATOATTO = 'PR'
           and doc.CODTIPODOCUMENTO = 'NULOST'
             and nuos.cdnlavoratore = Pcdnlavoratore
           and nuos.prgazienda= Pprgazienda
           and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni
           order by abs(nuos.DATINIZIO - Pdatiniziomov) asc, nuos.CODMONOCATEGORIA desc)
       where rownum = 1;    
     end if;

		 return varCodMonoCat;

   END;
   
   FUNCTION GetTipoDaNullaOstaForRp(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE, 
			 				  Pprgazienda IN am_movimento.PRGAZIENDA%TYPE, 
							  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
							  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOTIPO%TYPE 
   IS 
     varCodMonoTipo cm_nulla_osta.CODMONOTIPO%TYPE;
	 
	 BEGIN	 
	 
		 select CODMONOTIPO 
		 into varCodMonoTipo  
		 from (select abs(nuos.DATINIZIO - Pdatiniziomov), nuos.CODMONOCATEGORIA, nuos.CODMONOTIPO   
				 from cm_nulla_osta nuos 
				 inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA) 
				 inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)   
				 where doc.CODSTATOATTO = 'PR' 
				 and doc.CODTIPODOCUMENTO = 'NULOST'   		 
			   	 and nuos.cdnlavoratore = Pcdnlavoratore 
				 and nuos.prgazienda= Pprgazienda 
				 and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni 
				 order by abs(nuos.DATINIZIO - Pdatiniziomov) asc, nuos.CODMONOCATEGORIA desc)
		 where rownum = 1;  
		 
		 return varCodMonoTipo;
   
   END;    
   
   FUNCTION GetTipoOrarioForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN DE_ORARIO.CODMONOORARIO%TYPE
   IS
	   VarMovi am_movimento.prgmovimento%TYPE;
	   VarSucc am_movimento.PRGMOVIMENTO%TYPE;
	   VarTipo varchar(3);
	   codMonoOrario de_orario.CODMONOORARIO%TYPE;

	 BEGIN
 	 	 varMovi := PprgMovimento;
		 select mov.codtipomov, nvl(mov.PRGMOVIMENTOSUCC,-1), ora.codmonoorario
		 into VarTipo, VarSucc, codMonoOrario
		 from am_movimento mov, de_orario ora
	     where mov.codorario = ora.codorario
		 and mov.prgmovimento = varMovi;

		 WHILE (VarTipo <> 'CES' and VarSucc <> -1) loop
	  		 VarMovi := VarSucc;
			 select mov.codtipomov, nvl(mov.PRGMOVIMENTOSUCC,-1), ora.codmonoorario
			 into VarTipo, VarSucc, codMonoOrario
			 from am_movimento mov, de_orario ora
		     where mov.codorario = ora.codorario
			 and mov.prgmovimento = varMovi;
	  	END LOOP;

		RETURN codMonoOrario;

   END;

   
END pg_anagrafica_professionale_rp;
/






/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_COLL_MIRATO_2.sql
************************************************************************************** */


create or replace package PG_COLL_MIRATO_2 is

  -- Author  : COTICONE
  -- Created : 26/10/2007 11.54.51
  -- Purpose : 2.6.0

  TYPE typRefCurs IS REF CURSOR;

  function RICALCOLORIEPILOGOPROSP(p_prgProspettoInf number,
                                   p_flgConvenzione varchar2 ) RETURN number;
                                   
  function calcoloSommeTempiParziali(p_prgProspettoInf number) RETURN typRefCurs;   

  function calcoloSommeTPPerTipo(p_prgProspettoInf number,
                                 p_codTipoPTDisabile char,
                                 p_numPersPT OUT PI_DETT_PT_DISABILE.NUMLAVORATORI%type,
                                 p_numPersPTOltre50 OUT PI_DETT_PT_DISABILE.NUMLAVORATORI%type,
                                 p_numRiprPTMeno50 OUT PI_DETT_PT_DISABILE.DECCOPERTURA%type) RETURN number;                                                                    

  function f_config_battistoni RETURN VARCHAR2;
  
  --funzione non viene più chiamata
  function CONTROLLAPROSPETTO(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                              checkScopertura OUT number,
                              checkExistForza OUT number) RETURN number;

  function VERIFICAPROSPETTO(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                            err_percEsonero OUT number,
                            err_percCompensazione OUT number,
                            err_numCompInProv OUT number,
                            err_numCompArt18 OUT number,
                            err_numCompRiduz OUT number,
                            err_numCompensEcc OUT number,
                            err_dataConsegnaProspetto OUT number,
                            err_dataProspetto OUT number,
                            err_dataRiferimento OUT number,
                            err_checkProspStoriciz OUT number,
                            checkScopertura OUT number,
                            checkExistForza OUT number,
                            checkSospensione OUT number
                             ) RETURN NUMBER;

  function CHECKSCOPERTURA(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                           p_flgConvenzione varchar2) RETURN number;


  function AGGIORNA_CONV_PROVVEDIMENTO(p_prgrichcomputo cm_rich_computo.prgrichcomputo%type
) RETURN NUMBER;

  function GETSCOPERTURA(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                         p_flgConvenzione varchar2
                         ) RETURN varchar2;

  function GENERACOPIAPROSPETTO(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                             p_codProvincia cm_prospetto_inf.codprovincia%type,
                             p_numAnnoRifProspetto cm_prospetto_inf.numannorifprospetto%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                             p_checkAnnulla varchar2,
                             p_key varchar2,
                             p_out_prgprospettoinf OUT cm_prospetto_inf.prgprospettoinf%type
                             ) RETURN NUMBER;

  /**
  automatismo da esonero:
  dalla richiesta di esonero riportando la base computo del prospetto
  il prospetto viene aggiornato con la % di esonero e la data fino al
  e viene richiamata la procedura del ricalcola
  **/
  function AGGIORNAPROSPESONERO(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                                p_prgrichesondisabili  cm_rich_eson_disabili.prgrichesondisabili%type,
                                p_prgrichesonero  cm_rich_esonero.prgrichesonero%type) RETURN number;



  FUNCTION RECUPERA_PRGMOV_AVV_IN_L68(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE
                              ) RETURN AM_MOVIMENTO.Prgmovimento%TYPE;


  FUNCTION RECUPERA_PRGMOV_AVV(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
                              RETURN AM_MOVIMENTO.Prgmovimento%TYPE;

  /**
  recupero il prg del prospetto dal movimento che si è validato o inserito
   0 = tutto ok
  -1 = errore sql
  -2 = prospetto non nella provincia del sil
  **/
function GETPROSPETTOFROMMOVIMENTO(p_prgMovimento am_movimento.prgmovimento%type,
                                   p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                   p_key varchar2,
                                   p_codTipoMov am_movimento.codtipomov%type,
                                   p_prgProspettoOut OUT cm_prospetto_inf.prgprospettoinf%type
                                  ) RETURN NUMBER;

function aggiorna_ass_in_conv(p_prgMovAvv am_movimento.prgmovimento%type,
         p_prgMovCes am_movimento.prgmovimento%type
        ) RETURN NUMBER;


function CMAGGLAVDACOMPUTO(p_prgRichComputo cm_rich_computo.prgrichcomputo%type,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                           p_key varchar2,
                           out_annoProsp OUT cm_prospetto_inf.numannorifprospetto%type
                           ) RETURN NUMBER;

function CMAGGPROSPDASOSPENSIONE(p_prgRichSospensione cm_rich_sospensione.prgrichsospensione%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                             out_annoProsp OUT cm_prospetto_inf.numannorifprospetto%type
                               ) RETURN NUMBER;


function SaveLavDispDaComputo(p_prgRichComputo cm_rich_computo.prgrichcomputo%type,
                          p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                          p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                          p_key varchar2
                         ) RETURN NUMBER;

function BATCH_AGGIORNA_PROSPETTI(p_dataBatch varchar2
                                 ) RETURN NUMBER;

function STORICIZZA_PROSPETTO_SARE(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                                   p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                   ) RETURN NUMBER;

function GENERACOPIA_PROSPETTO_SARE(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                                    p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                    p_key varchar2
                                   ) RETURN NUMBER;

function BATCH_AGG_PROSPETTI_DA_MOV(p_dataBatch varchar2,
                                    p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                    p_key varchar2
                                   ) RETURN NUMBER;

function GET_PERC_INVALIDITA_L68(p_prgprospettoInf CM_PROSPETTO_INF.Prgprospettoinf%type,
                                 p_cdnLavoratore an_lavoratore.cdnlavoratore%type,
                                 p_encrypterKey varchar2,
                                 p_checkPercInvalidita OUT varchar2
                                 ) RETURN NUMBER;


function AggiornaScoperturaL68
(p_cdnLavoratore varchar, flgdisplim varchar, p_encrypterKey varchar, utenza number)
RETURN NUMBER;



end PG_COLL_MIRATO_2;
/

create or replace package body PG_COLL_MIRATO_2 is

function RICALCOLORIEPILOGOPROSP(p_prgProspettoInf number,
                                 p_flgConvenzione varchar2
                                 ) RETURN number is

CURSOR curProspetto IS
       SELECT P.PRGPROSPETTOINF,  P.PRGAZIENDA,
              P.PRGUNITA, P.PRGAZREFERENTE, 
          (CASE
				WHEN TRUNC(P.DTMINS) < TO_DATE('01/01/2012', 'DD/MM/YYYY') THEN
					(SELECT   (NVL(E.NUMDIRIGENTI,0) + NVL(E.NUMAPPRENDISTI,0) + NVL(E.NUMCFL,0) + NVL(E.NUMPARTTIME,0) +
			         NVL(E.NUMCIGS,0) + NVL(E.NUMTDMENO9MESI,0) + NVL(E.NUMTEMPORANEO,0) + NVL(E.NUMREINSERIMENTO,0) +
			         NVL(E.NUMDOMICILIO,0) + NVL(E.NUMSOCI,0) + NVL(E.NUMDISABILI,0) + NVL(E.NUMPROTETTE,0) +
			         NVL(E.NUMALTRI,0) + NVL(E.NUMLAVACQUISITI,0) + NVL(E.NUMPERSONALENONAMM_C3,0) + NVL(E.NUMPERSONALENONAMM_C4,0)
			         + NVL(E.NUMPERSONALEVIAGGIANTE,0) + NVL(E.NUMLSUSTABILI,0) + NVL(E.NUMLAVORATORIOPESTERO,0) 
			         + NVL(E.NUMLAVORATORIEDILIZIA,0) + NVL(E.NUMLAVEMERSINERO,0) + NVL(E.NUMINTERMITTENTI,0)) AS TOTALEESCLUSIONE
					FROM CM_ESCLUSIONE_PROSPETTO E
	          		WHERE E.PRGPROSPETTOINF = P.PRGPROSPETTOINF)    
	      		ELSE
		          (SELECT (NVL(E.NUMDIRIGENTI,0) + NVL(E.NUMAPPRENDISTI,0) + NVL(E.NUMCFL,0) + NVL(E.NUMPARTTIME,0) +
		                  NVL(E.NUMCIGS,0) + NVL(E.NUMTDMENO9MESI,0) + NVL(E.NUMREINSERIMENTO,0) +
		                  NVL(E.NUMDOMICILIO,0) + NVL(E.NUMSOCI,0) + NVL(E.NUMDISABILI,0) +
		                  (CASE 
				          	WHEN 
				          		(CASE 
				          			WHEN CEIL((1 * NVL(P.NUMDIPENDENTITOT,0))/100) - (1 * NVL(P.NUMDIPENDENTITOT,0)/100) >= 0.5 THEN
				          				FLOOR((1 * NVL(P.NUMDIPENDENTITOT,0))/100)
				          			ELSE CEIL((1 * NVL(P.NUMDIPENDENTITOT,0))/100)
				          		END) <= NVL(E.NUMPROTETTE,0) THEN (CASE 
													          			WHEN CEIL((1 * NVL(P.NUMDIPENDENTITOT,0))/100) - (1 * NVL(P.NUMDIPENDENTITOT,0)/100) >= 0.5 THEN
													          				FLOOR((1 * NVL(P.NUMDIPENDENTITOT,0))/100)
													          			ELSE CEIL((1 * NVL(P.NUMDIPENDENTITOT,0))/100)
													          	    END)
				            ELSE NVL(E.NUMPROTETTE,0)
					      END) +
		                  NVL(E.NUMALTRI,0) + NVL(E.NUMLAVACQUISITI,0) + NVL(E.NUMPERSONALENONAMM_C3,0) + NVL(E.NUMPERSONALENONAMM_C4,0) +
						  NVL(E.NUMPERSONALEVIAGGIANTE,0) + NVL(E.NUMLSUSTABILI,0) + NVL(E.NUMLAVORATORIOPESTERO,0) +
						  NVL(E.NUMLAVORATORIEDILIZIA,0) + NVL(E.NUMLAVEMERSINERO,0) + NVL(E.NUMINTERMITTENTI,0) + 
						  NVL(E.NUMTDMENO6MESI,0) + NVL(E.NUMSOMMINISTR,0) + NVL(E.NUMSOTTOSUOLO,0) +
						  NVL(P.NUMMASSOFISIOTERAPISTIFORZA,0) + NVL(P.NUMCENTNONVEDENTIFORZA,0) + NVL(P.NUMTELELAVFT,0) +
						  NVL(E.NUMIMPIANTIFUNE,0) + 
						  NVL(E.NUMSETTOREAUTOTRASP,0) + 
						  NVL(E.NUMMONTAGGI,0) + 
						  NVL(E.NUMCONTRINSERIMENTO,0) + 
						  NVL(E.NUMINAIL60X1000,0) +
						  (select nvl(sum(PI_DETT_PT_DISABILE.numLavoratori),0)
						   from PI_DETT_PT_DISABILE
						   where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
						   and PI_DETT_PT_DISABILE.codTipoPTDisabile in ('D', 'C', 'M')) +
						   (CASE
							WHEN 
							 (
							  (select nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0)
							   from PI_DETT_PT_DISABILE
							   where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
							   and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'T') - 
							   (select FLOOR(nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0))
							   from PI_DETT_PT_DISABILE
							   where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
							   and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'T')
							  ) > 0.5 THEN (select CEIL(nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0))
													   from PI_DETT_PT_DISABILE
													   where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
													   and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'T')
							ELSE 
								(select FLOOR(nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0))
										   from PI_DETT_PT_DISABILE
										   where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
										   and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'T')
						   END)
						  ) AS TOTALEESCLUSIONE
		                  FROM CM_ESCLUSIONE_PROSPETTO E
		                  WHERE E.PRGPROSPETTOINF = P.PRGPROSPETTOINF)
          END) AS TOTALEESCLUSIONE,        
          (SELECT (NVL(E.NUMDIRIGENTI,0) + NVL(E.NUMAPPRENDISTI,0) + NVL(E.NUMCFL,0) + NVL(E.NUMPARTTIME,0) +
                  NVL(E.NUMCIGS,0) + NVL(E.NUMTDMENO9MESI,0) + NVL(E.NUMREINSERIMENTO,0) +
                  NVL(E.NUMDOMICILIO,0) + NVL(E.NUMSOCI,0) + NVL(E.NUMDISABILI,0) +
                  (CASE 
		          	WHEN 
		          		(CASE 
		          			WHEN CEIL((1 * NVL(P.NUMDIPENDENTITOT,0))/100) - (1 * NVL(P.NUMDIPENDENTITOT,0)/100) >= 0.5 THEN
		          				FLOOR((1 * NVL(P.NUMDIPENDENTITOT,0))/100)
		          			ELSE CEIL((1 * NVL(P.NUMDIPENDENTITOT,0))/100)
		          		END) <= NVL(E.NUMPROTETTE,0) THEN (CASE 
											          			WHEN CEIL((1 * NVL(P.NUMDIPENDENTITOT,0))/100) - (1 * NVL(P.NUMDIPENDENTITOT,0)/100) >= 0.5 THEN
											          				FLOOR((1 * NVL(P.NUMDIPENDENTITOT,0))/100)
											          			ELSE CEIL((1 * NVL(P.NUMDIPENDENTITOT,0))/100)
											          	    END)
		            ELSE NVL(E.NUMPROTETTE,0)
			      END) +
                  NVL(E.NUMLAVACQUISITI,0) + NVL(E.NUMPERSONALENONAMM_C3,0) + NVL(E.NUMPERSONALENONAMM_C4,0) +
				  NVL(E.NUMLSUSTABILI,0) + NVL(E.NUMLAVORATORIOPESTERO,0) +
				  NVL(E.NUMLAVEMERSINERO,0) + NVL(E.NUMINTERMITTENTI,0) +
				  NVL(E.NUMTDMENO6MESI,0) + NVL(E.NUMSOMMINISTR,0) +
				  NVL(P.NUMMASSOFISIOTERAPISTIFORZA,0) + NVL(P.NUMCENTNONVEDENTIFORZA,0) + NVL(P.NUMTELELAVFT,0) +
				  NVL(E.NUMCONTRINSERIMENTO,0) +
				  (select nvl(sum(PI_DETT_PT_DISABILE.numLavoratori),0)
				   from PI_DETT_PT_DISABILE
				   where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
				   and PI_DETT_PT_DISABILE.codTipoPTDisabile in ('D', 'C', 'M')) +
				   (CASE
					WHEN 
					 (
					  (select nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0)
					   from PI_DETT_PT_DISABILE
					   where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
					   and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'T') - 
					   (select FLOOR(nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0))
					   from PI_DETT_PT_DISABILE
					   where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
					   and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'T')
					  ) > 0.5 THEN (select CEIL(nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0))
											   from PI_DETT_PT_DISABILE
											   where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
											   and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'T')
					ELSE 
						(select FLOOR(nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0))
								   from PI_DETT_PT_DISABILE
								   where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
								   and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'T')
				   END)
				  ) AS TOTALEESCLUSIONEART18
                  FROM CM_ESCLUSIONE_PROSPETTO E
                  WHERE E.PRGPROSPETTOINF = P.PRGPROSPETTOINF) AS TOTALEESCLUSIONEART18, 
              P.NUMORECCNL,
              P.CODPROVINCIA,
              P.CODMONOSTATOPROSPETTO,
              P.CODMONOPROV,
              P.NUMANNORIFPROSPETTO,
              TO_CHAR(P.DATCONSEGNAPROSPETTO, 'DD/MM/YYYY') AS DATCONSEGNAPROSPETTO,
              P.DATRIFINFORZA AS DATRIFINFORZA,
              P.DATPROSPETTO AS DATPROSPETTO,
              P.CODMONOCATEGORIA,
              NVL(P.NUMDIPENDENTITOT,0) AS NUMDIPENDENTITOT,
              NVL(P.NUMDIPENDENTINAZIONALE,0) AS NUMDIPNAZIONALE,
        	  NVL(P.NUMBASECOMPUTO,0) AS NUMBASECOMPUTO,
        	  NVL(P.numbasecomputoart18,0) AS NUMBASECOMPUTOART18,
        	  NVL(P.numbasecomputoart3,0) AS NUMBASECOMPUTOART3,
              NVL(P.NUMQUOTADISABILI,0) AS NUMQUOTADISABILI,
              NVL(P.NUMDISABILINOM,0) AS NUMDISABILINOM,
              NVL(P.NUMDISABILINUM,0) AS NUMDISABILINUM,
              NVL(P.NUMQUOTAART18,0) AS NUMQUOTAART18,
              NVL(P.NUMART18NOM,0) AS NUMART18NOM,
              NVL(P.NUMART18NUM,0) AS NUMART18NUM,
             TO_CHAR(P.DATPRIMAASSUNZIONE, 'DD/MM/YYYY') AS DATPRIMAASSUNZIONE,
          TO_CHAR(P.DATSECONDAASSUNZIONE, 'DD/MM/YYYY') AS DATSECONDAASSUNZIONE,
             NVL(P.NUMDISFORZA,0) AS NUMDISFORZA,
              NVL(P.NUMDISFORZARIFNOMI,0) AS NUMDISFORZARIFNOMI,
            NVL(P.NUMDISFORZANOMI,0) AS NUMDISFORZANOMI,
              NVL(P.NUMDISFORZARIFNUME,0) AS NUMDISFORZARIFNUME,
            NVL(P.NUMDISFORZANUME,0) AS NUMDISFORZANUME,
              NVL(P.NUMART18FORZA,0) AS NUMART18FORZA,
            NVL(P.NUMART18FORZARIFNOMI,0) AS NUMART18FORZARIFNOMI,
              NVL(P.NUMART18FORZANOMI,0) AS NUMART18FORZANOMI,
            NVL(P.NUMART18FORZARIFNUME,0) AS NUMART18FORZARIFNUME,
              NVL(P.NUMART18FORZANUME,0) AS NUMART18FORZANUME,
            P.FLGESONERO,
              P.NUMPERCESONERO,
            P.FLGGRADUALITA,
              P.FLGCOMPTERRITORIALE,
            P.FLGSOSPENSIONE,
              NVL(P.NUMCONVENZIONI,0) AS NUMCONVENZIONI,
            NVL(P.NUMLAVORATORICONV,0) AS NUMLAVORATORICONV,
              NVL(P.NUMDISCONVNUME,0) AS NUMDISCONVNUME,
            NVL(P.NUMDISCONVNOMI,0) AS NUMDISCONVNOMI,
              NVL(P.NUMART18CONVNUME,0) AS NUMART18CONVNUME,
            NVL(P.NUMART18CONVNOMI,0) AS NUMART18CONVNOMI,
              NVL(P.NUMDISCOMPTERRNOMI,0) AS NUMDISCOMPTERRNOMI,
            NVL(P.NUMDISCOMPTERRNUME,0) AS NUMDISCOMPTERRNUME,
              NVL(P.NUMART18COMPTERRNOMI,0) AS NUMART18COMPTERRNOMI,
             NVL(P.NUMART18COMPTERRNUME,0) AS NUMART18COMPTERRNUME,
              NVL(P.NUMDISESONNOMI,0) AS NUMDISESONNOMI,
            NVL(P.NUMDISESONNUME,0) AS NUMDISESONNUME,
              P.STRNOTE,
            P.CDNUTINS, P.DTMINS, P.CDNUTMOD, P.DTMMOD,
            P.NUMKLOPROSPETTOINF,
              TO_CHAR(P.DATFINEESONERO, 'dd/mm/yyyy') as DATFINEESONERO,
              P.DATFINEESONERO as data_esonero,
          P.FLGESONRICHPROROGA,
            TO_CHAR(P.DATESONRICHPROROGA, 'dd/mm/yyyy') as DATESONRICHPROROGA,
          TO_CHAR(P.DATCONCGRADUALITA, 'dd/mm/yyyy') as DATCONCGRADUALITA,
            P.NUMASSGRADUALITA,
          TO_CHAR(P.DATSOSPENSIONE, 'dd/mm/yyyy') as DATSOSPENSIONE,
          P.NUMQUOTADISGRAD,
            P.NUMLAVINFORZAGRAD,
            nvl(P.NUMDISBATTISTONI,0) as NUMDISBATTISTONI ,
            nvl(P.NUMBATTISTONIINFORZA,0) as NUMBATTISTONIINFORZA,
            nvl(P.NUMART18BATTISTONI,0) as NUMART18BATTISTONI,
            nvl(p.numtotlavconvart18,0) as numtotlavconvart18,
            nvl(p.numtotlavconvdis,0) as numtotlavconvdis,
            nvl(p.NUMSCOPCENTNONVEDENTI,0) as NUMSCOPCENTNONVEDENTI,
            nvl(p.NUMSCOPMASSOFISIOTERAPISTI,0) as NUMSCOPMASSOFISIOTERAPISTI,
            nvl(p.NUMCENTNONVEDENTIFORZA,0) as NUMCENTNONVEDENTIFORZA,
            nvl(p.NUMMASSOFISIOTERAPISTIFORZA,0) as NUMMASSOFISIOTERAPISTIFORZA,
            nvl(p.NUMCENTNONVEDENTIOBBLIGO,0) as NUMCENTNONVEDENTIOBBLIGO,
            nvl(p.NUMMASSOFISIOTERAPISTIOBBLIGO,0) as NUMMASSOFISIOTERAPISTIOBBLIGO,
			nvl(P.NUMLAVESONEROAUTOCERT,0) as NUMLAVESONEROAUTOCERT,
            flg15dipendenti, nvl(U.FLGSEDE, 'N') as FLGSEDE, 
            COMUAZ.CODPROVINCIA as CODPROVINCIASEDE
 FROM CM_PROSPETTO_INF P
    INNER JOIN AN_AZIENDA A ON A.PRGAZIENDA = P.PRGAZIENDA
    INNER JOIN AN_UNITA_AZIENDA U ON U.PRGAZIENDA = A.PRGAZIENDA AND U.PRGUNITA = P.PRGUNITA
    INNER JOIN DE_COMUNE COMUAZ ON U.CODCOM = COMUAZ.CODCOM
    LEFT JOIN AN_AZ_REFERENTE R ON R.PRGAZIENDA = A.PRGAZIENDA
             AND R.PRGUNITA = U.PRGUNITA AND R.PRGAZREFERENTE = P.PRGAZREFERENTE
    INNER JOIN DE_COMUNE D ON D.CODCOM = U.CODCOM
    INNER JOIN DE_PROVINCIA PR ON PR.CODPROVINCIA = P.CODPROVINCIA
    WHERE P.PRGPROSPETTOINF = p_prgProspettoInf;


p_numannorifprospetto cm_prospetto_inf.numannorifprospetto%type;
p_codmonocategoria cm_prospetto_inf.codmonocategoria%type;
p_numdipnazionale cm_prospetto_inf.numdipendentinazionale%type;
p_numdipendentitot cm_prospetto_inf.numdipendentitot%type;
p_numMassoFisioTerapisti cm_prospetto_inf.nummassofisioterapistiforza%type;
p_prgAzienda cm_prospetto_inf.prgazienda%type;
p_prgUnita cm_prospetto_inf.prgunita%type;
p_datRifInForza cm_prospetto_inf.datRifInForza%type;
p_numpercesonero cm_prospetto_inf.numpercesonero%type;
p_flgEsonero cm_prospetto_inf.flgesonero%type;
p_codMonoStatoProspetto cm_prospetto_inf.codmonostatoprospetto%type;
-- var quota
p_numQuotaDisabili number(10,3);
p_numDisabiliNom number(10,3);
p_numDisabiliNum number(10,3);
p_numQuotaArt18 number(10,3);
p_numArt18Nom number(10,3);
p_numArt18Num number(10,3);
-- var in forza
p_numDisForza number(10,3);
p_numDisForzaNomi number(10,3);
p_numDisForzaNomiPiu number(10,3);
p_numDisForzaNomiMeno number(10,3);
p_numDisForzaNume number(10,3);
p_numDisForzaNumePiu number(10,3);
p_numDisForzaNumeMeno number(10,3);
p_numDisForzaRifNomi number(10,3);
p_numDisForzaRifNume number(10,3);
p_numDisForzaNomiTot number(10,3);
p_numDisForzaNumeTot number(10,3);
p_numArt18Forza number(10,3);
p_numArt18ForzaNomi number(10,3);
p_numArt18ForzaNomiPiu number(10,3);
p_numArt18ForzaNomiMeno number(10,3);
p_numArt18ForzaNume number(10,3);
p_numArt18ForzaNumePiu number(10,3);
p_numArt18ForzaNumeMeno number(10,3);
p_numArt18ForzaRifNomi number(10,3);
p_numArt18ForzaRifNume number(10,3);
p_numArt18ForzaNomiTot number(10,3);
p_numArt18ForzaNumeTot number(10,3);

-- comp terr
p_numDisCompTerrNomi number(10,3);
p_numDisCompTerrNume number(10,3);
p_numArt18CompTerrNomi number(10,3);
p_numArt18CompTerrNume number(10,3);
p_numDisCompTerrPiu number(10,3);
p_numDisCompTerrMeno number(10,3);
p_numArt18CompTerrPiu number(10,3);
p_numArt18CompTerrMeno number(10,3);

-- esonero
p_numEsonero number(10,3);
p_numlavesoneroAutoCert cm_prospetto_inf.NUMLAVESONEROAUTOCERT%type;
p_numDisEsonNomi number(10,3);
p_numDisEsonNume number(10,3);
p_datfineesonero cm_prospetto_inf.datfineesonero%type;
checkEsonero number;

-- 22/03/2010 -  Battistoni - Donisi
p_numdisbattistoni cm_prospetto_inf.numdisbattistoni%type;
p_numbattistoniinforza cm_prospetto_inf.numbattistoniinforza%type;
p_numart18battistoni  cm_prospetto_inf.numart18battistoni%type;
scopdislordo number(10,3);
scopart18lordo number(10,3);
p_configbattistoni varchar2(2);

-- convenzioni
p_numdisconvnume number(10,3);
p_numdisconvnomi number(10,3);
p_numart18convnume number(10,3);
p_numart18convnomi number(10,3);

-- 31/03/2010 - convezioni - Donisi
p_numtotlavconvart18 cm_prospetto_inf.numtotlavconvart18%type;
p_numtotlavconvdis cm_prospetto_inf.numtotlavconvdis%type;
p_numdisconvnume_aux number(10,3);
p_numdisconvnomi_aux number(10,3);
p_numart18convnume_aux number(10,3);
p_numart18convnomi_aux number(10,3);

-- 06/04/2010 - Scopertura Centralinisti Non Vedenti e Masso Fisioterapista - Donisi
p_numscopcentnonvedenti cm_prospetto_inf.NUMSCOPCENTNONVEDENTI%type;
p_numcentnonvedenti cm_prospetto_inf.NUMCENTNONVEDENTIFORZA%type;
p_numscopmassofisioterapisti cm_prospetto_inf.NUMSCOPMASSOFISIOTERAPISTI%type;

-- 21/10/2010 - flg15dipendenti
p_flg15dipendenti cm_prospetto_inf.flg15dipendenti%type;

p_baseComputo number;
p_baseComputoArt18 number;
p_baseComputoArt18Naz number;
p_sommaEsclusione number(10,3);
p_sommaEsclusioneart18 number(10,3);
p_disabiliinforza cm_prospetto_inf.NUMQUOTADISABILI%type;
p_numkloprospettoinf cm_prospetto_inf.numkloprospettoinf%type;

p_percDisQuotaTotA number;
p_percArt18QuotaTotA number;
p_numConvenzioniAzienda number;
p_numLavConvenzioneAzienda number;
p_dataProxAss varchar2(10);
p_dataProspetto cm_prospetto_inf.datprospetto%type;
p_gap number;
queryWhere varchar2(1000);
p_esuberi number(10,3);
p_esuberiTotal number(10,3);
p_quota_obbligo_dovuta number(10,3);
p_data_ins_prospetto cm_prospetto_inf.dtmins%type;
p_sede_legale an_unita_azienda.flgsede%type;
p_cod_provincia_prospetto de_comune.codprovincia%type;
p_cod_provincia_sedelegale de_comune.codprovincia%type;
p_cod_provincia_polo de_comune.codprovincia%type;
p_centralinistiparttime PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
p_massofisioparttime PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
p_coperturacentparttime PI_DETT_PT_DISABILE.DECCOPERTURA%type;
p_coperturamassofisioparttime PI_DETT_PT_DISABILE.DECCOPERTURA%type;
begin

  FOR rec in curProspetto LOOP
      p_numkloprospettoinf := rec.numkloprospettoinf;
      p_numannorifprospetto := rec.numannorifprospetto;
      p_datRifInForza := rec.datRifInForza;
      p_codmonocategoria := rec.codmonocategoria;
      p_sommaEsclusione := rec.TOTALEESCLUSIONE;
      p_sommaEsclusioneart18 := rec.TOTALEESCLUSIONEART18;
      p_disabiliinforza := rec.NUMQUOTADISABILI;
      p_numbattistoniinforza := rec.NUMBATTISTONIINFORZA;
      p_data_ins_prospetto := rec.DTMINS;
      
      p_numMassoFisioTerapisti := rec.NUMMASSOFISIOTERAPISTIFORZA;
      p_numcentnonvedenti := rec.NUMCENTNONVEDENTIFORZA;
      
      p_numdipnazionale := rec.numdipnazionale;
      p_numdipendentitot := rec.numdipendentitot;
      p_dataProspetto := rec.datprospetto;

      p_flgEsonero := rec.flgEsonero;
      p_numpercesonero := nvl(rec.numpercesonero,0);
      p_datfineesonero := rec.data_esonero;
	  p_numlavesoneroAutoCert := rec.NUMLAVESONEROAUTOCERT;

      p_flg15dipendenti := rec. flg15dipendenti;

      if (p_dataProspetto is null) then
         if (p_datfineesonero is null) then
            checkEsonero := 0;
         elsif (trunc(sysdate) <= trunc(p_datfineesonero)) then
            checkEsonero := 1;
         else
            checkEsonero := 0;
         end if;
      else
         if (p_datfineesonero is null) then
            checkEsonero := 0;
         elsif (trunc(p_dataProspetto) <= trunc(p_datfineesonero)) then
            checkEsonero := 1;
         else
            checkEsonero := 0;
         end if;
      end if;

      p_prgazienda := rec.prgAzienda;
      p_prgunita := rec.prgUnita;

      p_numDisabiliNom := rec.numDisabiliNom;
      p_numDisabiliNum := rec.numDisabiliNum;

      p_numDisForzaRifNomi := rec.numDisForzaRifNomi;
      p_numDisForzaRifNume := rec.numDisForzaRifNume;
      p_numArt18ForzaRifNomi := rec.numArt18ForzaRifNomi;
      p_numArt18ForzaRifNume := rec.numArt18ForzaRifNume;

      p_codMonoStatoProspetto := rec.codMonoStatoProspetto;
      
      p_cod_provincia_prospetto := rec.codProvincia;
	  
	  p_baseComputoArt18Naz := rec.NUMBASECOMPUTOART18;
      
	  -- Se la provincia della sede legale è la stessa della provincia del prospetto
	  -- allora p_sede_legale = S e in questo caso vengono attribuite le quote disabili per azienda di fascia B e C
	  -- altrimenti p_sede_legale = N e di conseguenza le quote disabili non vengono attribuite
	  begin
		select com.codprovincia into p_cod_provincia_sedelegale
		from an_unita_azienda uaz 
		inner join de_comune com on (uaz.codcom = com.codcom)
		where uaz.prgazienda = p_prgazienda and uaz.flgsede = 'S';
		
		if (p_cod_provincia_sedelegale = p_cod_provincia_prospetto) then
			p_sede_legale := 'S';
		else
			p_sede_legale := 'N';
		end if;
	   exception
		when others then
			p_sede_legale := 'N';
	   end;
	      
      if (p_codMonoStatoProspetto = 'A') then
          -- calcolo base computo come differenza tra numero dipendenti provinciali e la somma delle esclusioni
          p_baseComputo := nvl(p_numdipendentitot,0) - nvl(p_sommaEsclusione,0);
          p_baseComputoArt18 := nvl(p_numdipendentitot,0) - nvl(p_sommaEsclusioneart18,0);
          
          if (p_baseComputo < 0) then
             p_baseComputo := 0;
          end if;
          
          if (p_baseComputoArt18 < 0) then
             p_baseComputoArt18 := 0;
          end if;
		  
		  --QUOTA DI RISERVA CATEGORIE PROTETTE ART.18
		  if (p_baseComputoArt18Naz > 150) then
				p_percArt18QuotaTotA := (1*p_baseComputoArt18)/100;
		  else
				if (p_baseComputoArt18Naz > 50 and p_baseComputoArt18Naz <= 150 and p_sede_legale = 'S') then
					p_percArt18QuotaTotA := 1;
				else
					p_percArt18QuotaTotA := 0;
				end if;
		  end if;
		  
		  -- QUOTA ART. 18
		  p_numQuotaArt18 := nvl(p_percArt18QuotaTotA,0);
		  p_gap := ceil(p_numQuotaArt18) - p_numQuotaArt18;
		  if (p_gap >= 0.5) then
		     p_numQuotaArt18 := floor(nvl(p_percArt18QuotaTotA,0));
		  else
		     p_numQuotaArt18 := ceil(p_numQuotaArt18);
		  end if;
		  -- QUOTA ART. 18 NOMINATIVA 60% della quota tot
		  p_numArt18Nom := (60*nvl(p_numQuotaArt18,0)/100);
		  p_gap := ceil(p_numArt18Nom) - p_numArt18Nom;
		  if (p_gap >= 0.5) then
			p_numArt18Nom := floor(60*nvl(p_numQuotaArt18,0)/100);
		  else
			p_numArt18Nom := ceil(p_numArt18Nom);
		  end if;
		  -- QUOTA ART. 18 NUMERICA 40% della quota tot
		  p_numArt18Num := (40*nvl(p_numQuotaArt18,0)/100);
		  p_gap := ceil(p_numArt18Num) - p_numArt18Num;
		  if (p_gap >= 0.5) then
		    p_numArt18Num := floor(40*nvl(p_numQuotaArt18,0)/100);
		  else
			p_numArt18Num := ceil(p_numArt18Num);
		  end if;
		  
          if (p_codmonocategoria = 'A') then
          		p_percDisQuotaTotA := (7*p_baseComputo)/100;
				
                --QUOTA DISABILI 7% della base computo
                p_numQuotaDisabili := nvl(p_percDisQuotaTotA,0);
                p_gap := ceil(p_numQuotaDisabili) - p_numQuotaDisabili;
                if (p_gap >= 0.5) then
                   p_numQuotaDisabili := floor(nvl(p_percDisQuotaTotA,0));
                else
                   p_numQuotaDisabili := ceil(p_numQuotaDisabili);
                end if;

                --QUOTA DISABILI NOM 60% della quota tot
                p_numDisabiliNom := nvl((60*p_numquotadisabili)/100,0);
                p_gap := ceil(p_numDisabiliNom) - p_numDisabiliNom;
                if (p_gap >= 0.5) then
                   p_numDisabiliNom := floor((60*p_numquotadisabili)/100);
                else
                   p_numDisabiliNom := ceil(p_numDisabiliNom);
                end if;

                --QUOTA DISABILI NUM 40% della quota tot
                p_numDisabiliNum := nvl((40*p_numquotadisabili)/100,0);
                p_gap := ceil(p_numDisabiliNum) - p_numDisabiliNum;
                if (p_gap >= 0.5) then
                   p_numDisabiliNum := floor((40*p_numquotadisabili)/100);
                else
                   p_numDisabiliNum := ceil(p_numDisabiliNum);
                end if;

                --  flg15
                -- Quando il p_flg15dipendenti è uguale a S, la quota disabili è 0
                if( p_flg15dipendenti = 'S') then
                    p_numQuotaDisabili := 0;
                    p_numDisabiliNom := 0;
                    p_numDisabiliNum := 0;
                end if;

                -- ESONERO
                if (p_flgEsonero = 'S' AND checkEsonero = 1) then
                    p_numEsonero := (p_numpercesonero*nvl(p_numQuotaDisabili,0))/100;
                    p_gap := ceil(p_numEsonero) - p_numEsonero;
                    if (p_gap >= 0.5) then
                       p_numEsonero := floor((p_numpercesonero*nvl(p_numQuotaDisabili,0))/100);
                    else
                       p_numEsonero := ceil(p_numEsonero);
                    end if;
                else
                    p_numEsonero := 0;
                end if;

				p_numEsonero := p_numEsonero + p_numlavesoneroAutoCert;
				
                -- Battistoni In forza
                if (trunc(p_data_ins_prospetto) < TO_DATE('01/01/2012', 'DD/MM/YYYY')) then
	      			select nvl(round(sum(r.deccopertura),2),0) into p_numbattistoniinforza
	                from cm_pi_lav_riserva r, CM_PROSPETTO_INF a
	                where r.prgprospettoinf = p_prgProspettoInf
	               	and r.prgprospettoinf = a.prgprospettoinf
	              	and r.flgbattistoni='S'
	               	and nvl(r.datiniziorapp,trunc(sysdate)) <= nvl(a.datprospetto,trunc(sysdate)) and
	               	nvl(a.datprospetto,trunc(sysdate)) <= nvl(r.datfinerapp,trunc(sysdate));
				end if;


          elsif (p_codmonocategoria = 'B') then
				-- QUOTA DISABILI
				if (p_sede_legale = 'S') then
	                p_numquotadisabili := round(2, 0);
	                --QUOTA DISABILI NOM
	                p_numdisabilinom := 1;
	                --QUOTA DISABILI NUM
	                p_numdisabilinum := 1;
	            else
	            	p_numquotadisabili := 0;
	                --QUOTA DISABILI NOM
	                p_numdisabilinom := 0;
	                --QUOTA DISABILI NUM
	                p_numdisabilinum := 0;
	            end if;
				
                -- flg15
                -- Quando il p_flg15dipendenti è uguale a S, la quota disabili è 0
                if( p_flg15dipendenti = 'S') then
                    p_numQuotaDisabili := 0;
                    p_numDisabiliNom := 0;
                    p_numDisabiliNum := 0;
                end if;
				
                -- ESONERO
                if (p_flgEsonero = 'S' AND checkEsonero = 1) then
                    p_numEsonero := (p_numpercesonero*2)/100;
                    p_gap := ceil(p_numEsonero) - p_numEsonero;
                    if (p_gap >= 0.5) then
                       p_numEsonero := floor((p_numpercesonero*2)/100);
                    else
                       p_numEsonero := ceil(p_numEsonero);
                    end if;
                else
                    p_numEsonero := 0;
                end if;
				
				p_numEsonero := p_numEsonero + p_numlavesoneroAutoCert;

          elsif (p_codmonocategoria = 'C') then
                -- QUOTA DISABILI
				if (p_sede_legale = 'S') then
	                p_numquotadisabili := round(1, 0);
	                --QUOTA DISABILI NOM
	                p_numdisabilinom := 1;
	                --QUOTA DISABILI NUM
	                p_numdisabilinum := 0;
	            else
	            	p_numquotadisabili := 0;
	                --QUOTA DISABILI NOM
	                p_numdisabilinom := 0;
	                --QUOTA DISABILI NUM
	                p_numdisabilinum := 0;
	            end if;
				
                --  flg15
                -- Quando il p_flg15dipendenti è uguale a S, la quota disabili è 0
                if( p_flg15dipendenti = 'S') then
                    p_numQuotaDisabili := 0;
                    p_numDisabiliNom := 0;
                    p_numDisabiliNum := 0;
                end if;

                -- ESONERO
                if (p_flgEsonero = 'S' AND checkEsonero = 1) then
                    p_numEsonero := (p_numpercesonero*1)/100;
                    p_gap := ceil(p_numEsonero) - p_numEsonero;
                    if (p_gap >= 0.5) then
                       p_numEsonero := floor((p_numpercesonero*1)/100);
                    else
                       p_numEsonero := ceil(p_numEsonero);
                    end if;
				else
                    p_numEsonero := 0;
                end if;
				
				p_numEsonero := p_numEsonero + p_numlavesoneroAutoCert;
          else
				-- QUOTA DISABILI
				p_numQuotaDisabili := 0;
				p_numDisabiliNom := 0;
				p_numDisabiliNum := 0;
		  end if;

          -- calcolo disabili in forza nominativa da sommare per assunzioni
          -- vengono calcolati quelli successivi alla data di riferimento

          if (p_dataProspetto is null) then

              select nvl(round(sum(l.deccopertura),2),0) into p_numDisForzaNomiPiu
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'D'
              and l.codmonotipo = 'M'
              and (l.datiniziorapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- calcolo disabili in forza nominativo da sottrarre per cessazioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numDisForzaNomiMeno
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'D'
              and l.codmonotipo = 'M'
              and (l.datfinerapp <= decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, trunc(sysdate), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- disabili in forza nominativo
              p_numDisForzaNomi := p_numDisForzaNomiPiu - p_numDisForzaNomiMeno;

              -- calcolo disabili in forza numerico da sommare per assunzioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numDisForzaNumePiu
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'D'
              and l.codmonotipo = 'R'
              and (l.datiniziorapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- calcolo disabili in forza numerico da sottrarre per cessazioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numDisForzaNumeMeno
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'D'
              and l.codmonotipo = 'R'
              and (l.datfinerapp <= decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, trunc(sysdate), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- disabili in forza numerico
              p_numDisForzaNume := p_numDisForzaNumePiu - p_numDisForzaNumeMeno;

              p_numDisForzaNomiTot := p_numDisForzaNomi + p_numDisForzaRifNomi;
              p_numDisForzaNumeTot := p_numDisForzaNume + p_numDisForzaRifNume;

              p_numDisForza := p_numDisForzaNomiTot + p_numDisForzaNumeTot;

              -- calcolo art18 in forza nominativa da sommare per assunzioni
              -- vengono calcolati quelli successivi alla data di riferimento
              select nvl(round(sum(l.deccopertura),2),0) into p_numArt18ForzaNomiPiu
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'A'
              and l.codmonotipo = 'M'
              and (l.datiniziorapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- calcolo disabili in forza nominativo da sottrarre per cessazioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numArt18ForzaNomiMeno
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'A'
              and l.codmonotipo = 'M'
              and (l.datfinerapp <= decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, trunc(sysdate), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- disabili in forza nominativo
              p_numArt18ForzaNomi := p_numArt18ForzaNomiPiu - p_numArt18ForzaNomiMeno;

              -- calcolo disabili in forza numerico da sommare per assunzioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numArt18ForzaNumePiu
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'A'
              and l.codmonotipo = 'R'
              and (l.datiniziorapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- calcolo disabili in forza numerico da sottrarre per cessazioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numArt18ForzaNumeMeno
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'A'
              and l.codmonotipo = 'R'
              and (l.datfinerapp <= decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, trunc(sysdate), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- disabili in forza numerico
              p_numArt18ForzaNume := p_numArt18ForzaNumePiu - p_numArt18ForzaNumeMeno;

              p_numArt18ForzaNomiTot := p_numArt18ForzaNomi + p_numArt18ForzaRifNomi;
              p_numArt18ForzaNumeTot := p_numArt18ForzaNume + p_numArt18ForzaRifNume;

              p_numArt18Forza := p_numArt18ForzaNomiTot + p_numArt18ForzaNumeTot;

          else

              select nvl(round(sum(l.deccopertura),2),0) into p_numDisForzaNomiPiu
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'D'
              and l.codmonotipo = 'M'
              and (l.datiniziorapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and (l.datiniziorapp <= decode(to_char(p_dataProspetto, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_dataProspetto, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- calcolo disabili in forza nominativo da sottrarre per cessazioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numDisForzaNomiMeno
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'D'
              and l.codmonotipo = 'M'
              and (l.datfinerapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and (l.datfinerapp < decode(to_char(p_dataProspetto, 'dd/mm/yyyy'), null, trunc(sysdate), to_date(to_char(p_dataProspetto, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- disabili in forza nominativo
              p_numDisForzaNomi := p_numDisForzaNomiPiu - p_numDisForzaNomiMeno;

              -- calcolo disabili in forza numerico da sommare per assunzioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numDisForzaNumePiu
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'D'
              and l.codmonotipo = 'R'
              and (l.datiniziorapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and (l.datiniziorapp <= decode(to_char(p_dataProspetto, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_dataProspetto, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- calcolo disabili in forza numerico da sottrarre per cessazioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numDisForzaNumeMeno
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'D'
              and l.codmonotipo = 'R'
              and (l.datfinerapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and (l.datfinerapp < decode(to_char(p_dataProspetto, 'dd/mm/yyyy'), null, trunc(sysdate), to_date(to_char(p_dataProspetto, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- disabili in forza numerico
              p_numDisForzaNume := p_numDisForzaNumePiu - p_numDisForzaNumeMeno;

              p_numDisForzaNomiTot := p_numDisForzaNomi + p_numDisForzaRifNomi;
              p_numDisForzaNumeTot := p_numDisForzaNume + p_numDisForzaRifNume;

              p_numDisForza := p_numDisForzaNomiTot + p_numDisForzaNumeTot;

              -- calcolo art18 in forza nominativa da sommare per assunzioni
              -- vengono calcolati quelli successivi alla data di riferimento
              select nvl(round(sum(l.deccopertura),2),0) into p_numArt18ForzaNomiPiu
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'A'
              and l.codmonotipo = 'M'
              and (l.datiniziorapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and (l.datiniziorapp <= decode(to_char(p_dataProspetto, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_dataProspetto, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- calcolo disabili in forza nominativo da sottrarre per cessazioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numArt18ForzaNomiMeno
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'A'
              and l.codmonotipo = 'M'
              and (l.datfinerapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and (l.datfinerapp < decode(to_char(p_dataProspetto, 'dd/mm/yyyy'), null, trunc(sysdate), to_date(to_char(p_dataProspetto, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- disabili in forza nominativo
              p_numArt18ForzaNomi := p_numArt18ForzaNomiPiu - p_numArt18ForzaNomiMeno;

              -- calcolo disabili in forza numerico da sommare per assunzioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numArt18ForzaNumePiu
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'A'
              and l.codmonotipo = 'R'
              and (l.datiniziorapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and (l.datiniziorapp <= decode(to_char(p_dataProspetto, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_dataProspetto, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- calcolo disabili in forza numerico da sottrarre per cessazioni
              select nvl(round(sum(l.deccopertura),2),0) into p_numArt18ForzaNumeMeno
              from cm_pi_lav_riserva l
              where l.prgprospettoinf = p_prgProspettoInf
              and l.codmonocategoria = 'A'
              and l.codmonotipo = 'R'
              and (l.datfinerapp > decode(to_char(p_datRifInForza, 'dd/mm/yyyy'), null, to_date('01/01/1800', 'dd/mm/yyyy'), to_date(to_char(p_datRifInForza, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and (l.datfinerapp < decode(to_char(p_dataProspetto, 'dd/mm/yyyy'), null, trunc(sysdate), to_date(to_char(p_dataProspetto, 'dd/mm/yyyy'), 'dd/mm/yyyy')))
              and to_char(l.datiniziorapp, 'yyyy') <= p_numannorifprospetto
              and l.decoretotali is not null
              and l.decorelavorate is not null;
              -- disabili in forza numerico
              p_numArt18ForzaNume := p_numArt18ForzaNumePiu - p_numArt18ForzaNumeMeno;

              p_numArt18ForzaNomiTot := p_numArt18ForzaNomi + p_numArt18ForzaRifNomi;
              p_numArt18ForzaNumeTot := p_numArt18ForzaNume + p_numArt18ForzaRifNume;

              p_numArt18Forza := p_numArt18ForzaNomiTot + p_numArt18ForzaNumeTot;

          end if;

          --calcolo compensazione terr disabili nominativa +
          select nvl(sum(pc.numinteressati),0) into p_numDisCompTerrPiu
          from cm_pi_compensazione pc
          where pc.prgprospettoinf = p_prgProspettoInf
          and pc.codmonoeccdiff = 'E'
          and pc.codmonocategoria = 'D';

          --calcolo compensazione terr disabili nominativa -
          select nvl(sum(pc.numinteressati),0) into p_numDisCompTerrMeno
          from cm_pi_compensazione pc
          where pc.prgprospettoinf = p_prgProspettoInf
          and pc.codmonoeccdiff = 'D'
          and pc.codmonocategoria = 'D';

          p_numDisCompTerrNomi := round((60*(p_numDisCompTerrPiu - p_numDisCompTerrMeno))/100,0);
          p_numDisCompTerrNume := round((40*(p_numDisCompTerrPiu - p_numDisCompTerrMeno))/100,0);

          --calcolo compensazione terr art18 nominativa +
          select nvl(sum(pc.numinteressati),0) into p_numArt18CompTerrPiu
          from cm_pi_compensazione pc
          where pc.prgprospettoinf = p_prgProspettoInf
          and pc.codmonoeccdiff = 'E'
          and pc.codmonocategoria = 'A';

          --calcolo compensazione art18  nominativa -
          select nvl(sum(pc.numinteressati),0) into p_numArt18CompTerrMeno
          from cm_pi_compensazione pc
          where pc.prgprospettoinf = p_prgProspettoInf
          and pc.codmonoeccdiff = 'D'
          and pc.codmonocategoria = 'A';

          p_numArt18CompTerrNomi := round((60*(p_numArt18CompTerrPiu - p_numArt18CompTerrMeno))/100,0);
          p_numArt18CompTerrNume := round((40*(p_numArt18CompTerrPiu - p_numArt18CompTerrMeno))/100,0);

          -- calcolo numero esonero disabili numerici e nominativi
          p_numDisEsonNomi := round((60*p_numEsonero)/100,0);
          p_numDisEsonNume := round((40*p_numEsonero)/100,0);

          -- CONVENZIONI
          -- nel caso di FLGCONVENZIONI = 'S' vengono considerate anche le assunzioni in convenzione
          if (p_flgconvenzione = 'S') then

            if (p_dataProspetto is null) then
              -- disabili nominativo
              select nvl(sum(cd.numlavoratori), 0) into p_numdisconvnomi
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'D'
              and cd.codmonotipo = 'M'
              and trunc(cd.datscadenza) >= trunc(sysdate)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );



              -- disabili numerico
              select nvl(sum(cd.numlavoratori), 0) into p_numdisconvnume
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'D'
              and cd.codmonotipo = 'R'
              and trunc(cd.datscadenza) >= trunc(sysdate)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              -- art18 nominativo
              select nvl(sum(cd.numlavoratori), 0) into p_numart18convnomi
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'A'
              and cd.codmonotipo = 'M'
              and trunc(cd.datscadenza) >= trunc(sysdate)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              -- art18 numerico
              select nvl(sum(cd.numlavoratori), 0) into p_numart18convnume
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'A'
              and cd.codmonotipo = 'R'
              and trunc(cd.datscadenza) >= trunc(sysdate)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              -- numero di convenzioni attive
              select count(c.prgconv) into p_numConvenzioniAzienda
              from cm_convenzione c
              where c.codprovincia = p_cod_provincia_prospetto
			  and c.codstatorichiesta = 'DE'
              and c.prgazienda = p_prgazienda
              and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
              and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
              or c.datscadenza is null);



              -- numero di num lavoratori in convenzioni attive
              select nvl(sum(cd.numlavoratori), 0) into p_numLavConvenzioneAzienda
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where --csa.flgscopertura = 'S'
              csa.codstato not in ('DEC' ,'CES')
              and trunc(cd.datscadenza) >= trunc(sysdate)
              and cd.prgconv IN (select c.prgconv
                                  from cm_convenzione c
                                  where c.codprovincia = p_cod_provincia_prospetto
								  and c.codstatorichiesta = 'DE'
                                  and c.prgazienda = p_prgazienda
                                  and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                  and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                  or c.datscadenza is null)
                                  );

              -- 31/03/2010 - Dis. Num. Tot. convezione previsti(scaduti e n scaduti)
              -- disabili nominativo
              select nvl(sum(cd.numlavoratori), 0) into p_numdisconvnomi_aux
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'D'
              and cd.codmonotipo = 'M'
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );



              -- disabili numerico
              select nvl(sum(cd.numlavoratori), 0) into p_numdisconvnume_aux
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'D'
              and cd.codmonotipo = 'R'
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              p_numtotlavconvdis := p_numdisconvnume_aux + p_numdisconvnomi_aux;
              -- 31/03/2010 - Art. 18 Num. Tot. convezione previsti(scaduti e n scaduti)
              -- art18 nominativo
              select nvl(sum(cd.numlavoratori), 0) into p_numart18convnomi_aux
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'A'
              and cd.codmonotipo = 'M'
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              -- art18 numerico
              select nvl(sum(cd.numlavoratori), 0) into p_numart18convnume_aux
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'A'
              and cd.codmonotipo = 'R'
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

               p_numtotlavconvart18 := p_numart18convnume_aux + p_numart18convnomi_aux;

            else

              -- disabili nominativo
              select nvl(sum(cd.numlavoratori), 0) into p_numdisconvnomi
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'D'
              and cd.codmonotipo = 'M'
              and trunc(cd.datscadenza) >= trunc(p_dataProspetto)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and (trunc(c.datconvenzione) <= trunc(p_dataProspetto)
                                and trunc(c.datscadenza) >= trunc(p_dataProspetto)
                                or c.datscadenza is null)
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              -- disabili numerico
              select nvl(sum(cd.numlavoratori), 0) into p_numdisconvnume
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'D'
              and cd.codmonotipo = 'R'
              and trunc(cd.datscadenza) >= trunc(p_dataProspetto)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and (trunc(c.datconvenzione) <= trunc(p_dataProspetto)
                                and trunc(c.datscadenza) >= trunc(p_dataProspetto)
                                or c.datscadenza is null)
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              -- art18 nominativo
              select nvl(sum(cd.numlavoratori), 0) into p_numart18convnomi
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'A'
              and cd.codmonotipo = 'M'
              and trunc(cd.datscadenza) >= trunc(p_dataProspetto)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and (trunc(c.datconvenzione) <= trunc(p_dataProspetto)
                                and trunc(c.datscadenza) >= trunc(p_dataProspetto)
                                or c.datscadenza is null)
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              -- art18 numerico
              select nvl(sum(cd.numlavoratori), 0) into p_numart18convnume
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'A'
              and cd.codmonotipo = 'R'
              and trunc(cd.datscadenza) >= trunc(p_dataProspetto)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and (trunc(c.datconvenzione) <= trunc(p_dataProspetto)
                                and trunc(c.datscadenza) >= trunc(p_dataProspetto)
                                or c.datscadenza is null)
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              -- numero di convenzioni attive
              select count(c.prgconv) into p_numConvenzioniAzienda
              from cm_convenzione c
              where c.codprovincia = p_cod_provincia_prospetto
			  and c.codstatorichiesta = 'DE'
              and c.prgazienda = p_prgazienda
              and (trunc(c.datconvenzione) <= trunc(p_dataProspetto)
              and trunc(c.datscadenza) >= trunc(p_dataProspetto)
              or c.datscadenza is null)
              and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
              and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
              or c.datscadenza is null);

              -- numero di num lavoratori in convenzioni attive
              select nvl(sum(cd.numlavoratori), 0) into p_numLavConvenzioneAzienda
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where --csa.flgscopertura = 'S'
              csa.codstato not in ('DEC' ,'CES')
              and trunc(cd.datscadenza) >= trunc(p_dataProspetto)
              and cd.prgconv IN (select c.prgconv
                                  from cm_convenzione c
                                  where c.codprovincia = p_cod_provincia_prospetto
								  and c.codstatorichiesta = 'DE'
                                  and c.prgazienda = p_prgazienda
                                  and (trunc(c.datconvenzione) <= trunc(p_dataProspetto)
                                  and trunc(c.datscadenza) >= trunc(p_dataProspetto)
                                  or c.datscadenza is null)
                                  and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                  and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                  or c.datscadenza is null)
                                  );
                 -- 31/03/2010 - Dis. Num. Tot. convezione previsti(scaduti e n scaduti)
              -- disabili nominativo
              select nvl(sum(cd.numlavoratori), 0) into p_numdisconvnomi_aux
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'D'
              and cd.codmonotipo = 'M'
              and trunc(cd.datscadenza) >= trunc(p_dataProspetto)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and (trunc(c.datconvenzione) <= trunc(p_dataProspetto)
                                and trunc(c.datscadenza) >= trunc(p_dataProspetto)
                                or c.datscadenza is null)
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              -- disabili numerico

              select nvl(sum(cd.numlavoratori), 0) into p_numdisconvnume_aux
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'D'
              and cd.codmonotipo = 'R'
              and trunc(cd.datscadenza) >= trunc(p_dataProspetto)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and (trunc(c.datconvenzione) <= trunc(p_dataProspetto)
                                and trunc(c.datscadenza) >= trunc(p_dataProspetto)
                                or c.datscadenza is null)
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              p_numtotlavconvdis := p_numdisconvnume_aux + p_numdisconvnomi_aux;
              -- 31/03/2010 - Art. 18 Num. Tot. convezione previsti(scaduti e n scaduti)
              -- art18 nominativo
              select nvl(sum(cd.numlavoratori), 0) into p_numart18convnomi_aux
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'A'
              and cd.codmonotipo = 'M'
              and trunc(cd.datscadenza) >= trunc(p_dataProspetto)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and (trunc(c.datconvenzione) <= trunc(p_dataProspetto)
                                and trunc(c.datscadenza) >= trunc(p_dataProspetto)
                                or c.datscadenza is null)
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );

              -- art18 numerico
                select nvl(sum(cd.numlavoratori), 0) into p_numart18convnume_aux
              from cm_conv_dettaglio cd
              inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
              where csa.flgscopertura = 'S'
              and cd.codmonocategoria = 'A'
              and cd.codmonotipo = 'R'
              and trunc(cd.datscadenza) >= trunc(p_dataProspetto)
              and cd.prgconv IN (select c.prgconv
                                from cm_convenzione c
                                where c.codprovincia = p_cod_provincia_prospetto
								and c.codstatorichiesta = 'DE'
                                and c.prgazienda = p_prgazienda
                                and (trunc(c.datconvenzione) <= trunc(p_dataProspetto)
                                and trunc(c.datscadenza) >= trunc(p_dataProspetto)
                                or c.datscadenza is null)
                                and to_char(trunc(c.datconvenzione,'YYYY'), 'YYYY') <= p_numannorifprospetto
                                and (to_char(trunc(c.datscadenza,'YYYY'), 'YYYY') >= p_numannorifprospetto
                                or c.datscadenza is null)
                                );


               p_numtotlavconvart18 := p_numart18convnume_aux + p_numart18convnomi_aux;

            end if;

          end if;
          
		  
		  if (trunc(p_data_ins_prospetto) < TO_DATE('01/01/2012', 'DD/MM/YYYY')) then
			  -- L. Battistoni
			  p_configbattistoni := f_config_battistoni();
			  
			  p_numdisbattistoni := 0;
			  p_numart18battistoni := 0;

			  if (p_configbattistoni = '2') then
				-- conf 2 Trento
				if (p_codmonocategoria = 'A') then
					/* scopdislordo := 0;
					 scopart18lordo := 0;
					 scopdislordo := p_numDisForza - p_numQuotaDisabili;
					 scopart18lordo := p_numArt18Forza - p_numQuotaArt18;
					 --regole or e min (abs(scopDisLordo), scopArt18Lordo,MaxUtil, inforzaart18batt)
					 if ((scopdislordo >=0) OR (scopart18lordo <= 0)) then
						p_numdisbattistoni := 0;
					 else*/
						-- 1% BC - p_percArt18QuotaTotA
						p_numdisbattistoni := least(p_percArt18QuotaTotA,p_numbattistoniinforza);

					 --end if;
				end if;
			  else
			  -- conf 1 Umbria  e le altre
				if (p_codmonocategoria = 'A') then
					 scopdislordo := 0;
					 scopart18lordo := 0;
					 scopdislordo := p_numDisForza - p_numQuotaDisabili;
					 scopart18lordo := p_numArt18Forza - p_numQuotaArt18;
					 --regole or min (abs(scopDisLordo), scopArt18Lordo,MaxUtil, inforzaart18batt)
					 if ((scopdislordo >=0) OR (scopart18lordo <= 0)) then
						p_numdisbattistoni := 0;
						p_numart18battistoni := 0;
					 else
						p_numdisbattistoni := least(p_percArt18QuotaTotA,p_numbattistoniinforza,scopart18lordo,abs(scopdislordo));
						p_numart18battistoni := p_numdisbattistoni * -1;
					 end if;
				end if;
			  end if;
		  else
			  -- Calcolo esuberi
	          p_esuberiTotal := 0;
	          
	          if ( (p_codmonocategoria = 'A') and (nvl(p_numArt18Forza, 0) > nvl(p_numQuotaArt18, 0)) ) then
	          	p_esuberi := nvl(p_numArt18Forza, 0) - nvl(p_numQuotaArt18, 0);
				
	          	p_quota_obbligo_dovuta := (1*p_baseComputoArt18)/100;
	          	p_gap := ceil(p_quota_obbligo_dovuta) - p_quota_obbligo_dovuta;
	            if (p_gap >= 0.5) then
	               p_quota_obbligo_dovuta := floor(p_quota_obbligo_dovuta);
	            else
	               p_quota_obbligo_dovuta := ceil(p_quota_obbligo_dovuta);
	            end if;
	          	
	            if (p_numbattistoniinforza < p_quota_obbligo_dovuta) then
	            	p_esuberiTotal := p_numbattistoniinforza;
	            else
	            	p_esuberiTotal := p_quota_obbligo_dovuta;
	            end if;
				
	            if (p_esuberiTotal > p_esuberi) then
	            	p_esuberiTotal := p_esuberi;
	            end if;
	            
	            if (p_esuberiTotal < 0) then
	            	p_esuberiTotal := 0;
	            end if;
	          	
	          end if;
	          
	          p_numdisbattistoni := nvl(p_esuberiTotal, 0);
	          if (p_numdisbattistoni > 0) then
	          	p_numart18battistoni := p_numdisbattistoni; --p_numdisbattistoni * -1;
	          else
	          	p_numart18battistoni := 0;	
	          end if;
			  
		  end if;
		  	   
		  select nvl(sum(PI_DETT_PT_DISABILE.numLavoratori),0) into p_centralinistiparttime
		  from PI_DETT_PT_DISABILE
		  where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
		  and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'C' and nvl(PI_DETT_PT_DISABILE.flgOltre50, 'N') = 'S';
		   
		  select nvl(sum(PI_DETT_PT_DISABILE.numLavoratori),0) into p_massofisioparttime
		  from PI_DETT_PT_DISABILE
		  where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
		  and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'M' and nvl(PI_DETT_PT_DISABILE.flgOltre50, 'N') = 'S';
		  
		  select nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0) into p_coperturacentparttime
		  from PI_DETT_PT_DISABILE
		  where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
		  and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'C' and nvl(PI_DETT_PT_DISABILE.flgOltre50, 'N') = 'N';
		   
		  select nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0) into p_coperturamassofisioparttime
		  from PI_DETT_PT_DISABILE
		  where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
		  and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'M' and nvl(PI_DETT_PT_DISABILE.flgOltre50, 'N') = 'N';
		  
		  if ( (p_coperturacentparttime) - (FLOOR(p_coperturacentparttime)) > 0.5) then
			p_coperturacentparttime := CEIL(p_coperturacentparttime);
		  else
			p_coperturacentparttime := FLOOR(p_coperturacentparttime);
		  end if;
		  
		  if ( (p_coperturamassofisioparttime) - (FLOOR(p_coperturamassofisioparttime)) > 0.5) then
			p_coperturamassofisioparttime := CEIL(p_coperturamassofisioparttime);
		  else
			p_coperturamassofisioparttime := FLOOR(p_coperturamassofisioparttime);
		  end if;
		  
		  -- Scopertura Centralinista Non Vedenti e masso fisioterapisti
		  p_numscopcentnonvedenti := rec.NUMCENTNONVEDENTIOBBLIGO - rec.NUMCENTNONVEDENTIFORZA - (p_centralinistiparttime + p_coperturacentparttime);
          p_numscopmassofisioterapisti := rec.NUMMASSOFISIOTERAPISTIOBBLIGO - rec.NUMMASSOFISIOTERAPISTIFORZA - (p_massofisioparttime + p_coperturamassofisioparttime);
		  
          -- aggiorno i dati del riepilogo del prospetto
          update cm_prospetto_inf pi set
          pi.datrifinforza = p_datrifinforza,
          pi.numbasecomputo = p_baseComputo,
          pi.numbasecomputoart3prov = p_baseComputo,
          pi.numbasecomputoart18prov = p_baseComputoArt18,
          pi.numquotadisabili = p_numQuotaDisabili,
          pi.numdisabilinom = p_numDisabiliNom,
          pi.numdisabilinum = p_numDisabiliNum,
          pi.numquotaart18 = p_numQuotaArt18,
          pi.numart18nom = p_numArt18Nom,
          pi.numart18num = p_numArt18Num,
          pi.numdisforzanomi = p_numDisForzaNomi,
          pi.numdisforzanume = p_numDisForzaNume,
          pi.numdisforza = p_numDisForza,
          pi.numart18forzanomi = p_numArt18ForzaNomi,
          pi.numart18forzanume = p_numArt18ForzaNume,
          pi.numart18forza = p_numArt18Forza,
          pi.numdiscompterrnomi = p_numDisCompTerrNomi,
          pi.numdiscompterrnume = p_numDisCompTerrNume,
          pi.numart18compterrnomi = p_numArt18CompTerrNomi,
          pi.numart18compterrnume = p_numArt18CompTerrNume,
          pi.numDisEsonNomi = p_numDisEsonNomi,
          pi.numDisEsonNume = p_numDisEsonNume,
          pi.numdisconvnomi = p_numdisconvnomi,
          pi.numdisconvnume = p_numdisconvnume,
          pi.numart18convnomi = p_numart18convnomi,
          pi.numart18convnume = p_numart18convnume,
          pi.numconvenzioni = p_numConvenzioniAzienda,
          pi.numlavoratoriconv = p_numLavConvenzioneAzienda,
          pi.numdisbattistoni = p_numdisbattistoni,
          pi.numbattistoniinforza = p_numbattistoniinforza,
          pi.numart18battistoni = p_numart18battistoni,
          pi.numtotlavconvart18 = p_numtotlavconvart18,
          pi.numtotlavconvdis =  p_numtotlavconvdis,
          pi.NUMSCOPCENTNONVEDENTI = p_numscopcentnonvedenti,
          pi.NUMSCOPMASSOFISIOTERAPISTI = p_numscopmassofisioterapisti,
          pi.numkloprospettoinf = p_numkloprospettoinf+1
          where pi.prgprospettoinf = p_prgProspettoInf;

      end if;

  END LOOP;

  return 0;

  exception
      when no_data_found then p_configbattistoni := 0;

      when others then
           dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
           return -1;


end RICALCOLORIEPILOGOPROSP;

function calcoloSommeTempiParziali(p_prgProspettoInf number) RETURN typRefCurs is
                         
    str varchar(1000);
    risultato typRefCurs;
    
    calcolo_S number;
    p_numPersPT_S PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
    p_numPersPTOltre50_S PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
    p_numRiprPTMeno50_S PI_DETT_PT_DISABILE.DECCOPERTURA%type;
    
    calcolo_V number;
    p_numPersPT_V PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
    p_numPersPTOltre50_V PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
    p_numRiprPTMeno50_V PI_DETT_PT_DISABILE.DECCOPERTURA%type;  
    
    calcolo_D number;
    p_numPersPT_D PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
    p_numPersPTOltre50_D PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
    p_numRiprPTMeno50_D PI_DETT_PT_DISABILE.DECCOPERTURA%type;
    
    calcolo_C number;
    p_numPersPT_C PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
    p_numPersPTOltre50_C PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
    p_numRiprPTMeno50_C PI_DETT_PT_DISABILE.DECCOPERTURA%type;
    
    calcolo_M number;
    p_numPersPT_M PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
    p_numPersPTOltre50_M PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
    p_numRiprPTMeno50_M PI_DETT_PT_DISABILE.DECCOPERTURA%type;
    
    p_numPersPT_T PI_DETT_PT_DISABILE.NUMLAVORATORI%type;
    p_numRiprPT_T PI_DETT_PT_DISABILE.DECCOPERTURA%type;          

begin    

    calcolo_S := PG_COLL_MIRATO_2.calcoloSommeTPPerTipo(p_prgProspettoInf, 'S', p_numPersPT_S, p_numPersPTOltre50_S, p_numRiprPTMeno50_S);
    calcolo_V := PG_COLL_MIRATO_2.calcoloSommeTPPerTipo(p_prgProspettoInf, 'V', p_numPersPT_V, p_numPersPTOltre50_V, p_numRiprPTMeno50_V);
    calcolo_D := PG_COLL_MIRATO_2.calcoloSommeTPPerTipo(p_prgProspettoInf, 'D', p_numPersPT_D, p_numPersPTOltre50_D, p_numRiprPTMeno50_D);
    calcolo_C := PG_COLL_MIRATO_2.calcoloSommeTPPerTipo(p_prgProspettoInf, 'C', p_numPersPT_C, p_numPersPTOltre50_C, p_numRiprPTMeno50_C);
    calcolo_M := PG_COLL_MIRATO_2.calcoloSommeTPPerTipo(p_prgProspettoInf, 'M', p_numPersPT_M, p_numPersPTOltre50_M, p_numRiprPTMeno50_M);
    
    select nvl(sum(PI_DETT_PT_DISABILE.numLavoratori),0) into p_numPersPT_T
	from PI_DETT_PT_DISABILE
	where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
	and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'T';
    
    select nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0) into p_numRiprPT_T
    from PI_DETT_PT_DISABILE
    where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
    and PI_DETT_PT_DISABILE.codTipoPTDisabile = 'T'; 
                        
    str := 'select ' ||
            to_char(p_numPersPT_S) || ' as numPersPT_S, ' ||
            to_char(p_numPersPTOltre50_S) || ' as numPersPTOltre50_S, ' ||
            to_char(p_numRiprPTMeno50_S, '9999.99') || ' as numRiprPTMeno50_S, ' ||
            to_char(p_numPersPT_V) || ' as numPersPT_V, ' ||
            to_char(p_numPersPTOltre50_V) || ' as numPersPTOltre50_V, ' ||
            to_char(p_numRiprPTMeno50_V, '9999.99') || ' as numRiprPTMeno50_V, ' ||
            to_char(p_numPersPT_D) || ' as numPersPT_D, ' ||
            to_char(p_numPersPTOltre50_D) || ' as numPersPTOltre50_D, ' ||
            to_char(p_numRiprPTMeno50_D, '9999.99') || ' as numRiprPTMeno50_D, ' ||
            to_char(p_numPersPT_C) || ' as numPersPT_C, ' ||
            to_char(p_numPersPTOltre50_C) || ' as numPersPTOltre50_C, ' ||
            to_char(p_numRiprPTMeno50_C, '9999.99') || ' as numRiprPTMeno50_C, ' ||                       
            to_char(p_numPersPT_M) || ' as numPersPT_M, ' ||
            to_char(p_numPersPTOltre50_M) || ' as numPersPTOltre50_M, ' ||
            to_char(p_numRiprPTMeno50_M, '9999.99') || ' as numRiprPTMeno50_M, ' ||        
            to_char(p_numPersPT_T) || ' as numPersPT_T, ' ||
            to_char(p_numRiprPT_T, '9999.99') || ' as numRiprPT_T ' ||                 
            ' from dual';

    open risultato for str;
    return risultato;

end calcoloSommeTempiParziali;


function calcoloSommeTPPerTipo(p_prgProspettoInf number,
                           p_codTipoPTDisabile char,
                           p_numPersPT OUT PI_DETT_PT_DISABILE.NUMLAVORATORI%type,
                           p_numPersPTOltre50 OUT PI_DETT_PT_DISABILE.NUMLAVORATORI%type,
                           p_numRiprPTMeno50 OUT PI_DETT_PT_DISABILE.DECCOPERTURA%type
                         ) RETURN number is

begin                         

    select nvl(sum(PI_DETT_PT_DISABILE.numLavoratori),0) into p_numPersPT
	from PI_DETT_PT_DISABILE
	where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
	and PI_DETT_PT_DISABILE.codTipoPTDisabile = p_codTipoPTDisabile;
    
    select nvl(sum(PI_DETT_PT_DISABILE.numLavoratori),0) into p_numPersPTOltre50
	from PI_DETT_PT_DISABILE
	where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
	and PI_DETT_PT_DISABILE.codTipoPTDisabile = p_codTipoPTDisabile and nvl(PI_DETT_PT_DISABILE.flgOltre50, 'N') = 'S';    
		  
    select nvl(sum(PI_DETT_PT_DISABILE.decCopertura),0) into p_numRiprPTMeno50
    from PI_DETT_PT_DISABILE
    where PI_DETT_PT_DISABILE.prgprospettoinf = p_prgProspettoInf
    and PI_DETT_PT_DISABILE.codTipoPTDisabile = p_codTipoPTDisabile and nvl(PI_DETT_PT_DISABILE.flgOltre50, 'N') = 'N'; 
  
    return 0;

exception
    when others then
        dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
        return -1;

end calcoloSommeTPPerTipo;

function f_config_battistoni RETURN VARCHAR2 is

p_configbattistoni varchar2(2);

begin

  select to_char(ts_config_loc.num) num into p_configbattistoni
          from ts_config_loc, de_tipo_config, ts_generale
          where ts_generale.codprovinciasil = ts_config_loc.strcodrif
          and de_tipo_config.codtipoconfig = ts_config_loc.codtipoconfig
          and ts_config_loc.codtipoconfig = 'LEG_BAT';

  return p_configbattistoni;

  exception
      when no_data_found then RETURN '0';

      when others then
           dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
           return '0';


end f_config_battistoni;
/********************************************************************************************
* controllo dati del prospetto prima della storicizzazione                                  *
* vengono effettuati i seguenti controlli:                                                  *
* 1) verifica del prospetto                                                                 *
* 2) obbligatorietà data consegna                                                           *
* 3) verifica che non esista nessun prospetto storicizzato per l'azienda, anno e provinicia *
*********************************************************************************************/
function CONTROLLAPROSPETTO(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                            checkScopertura OUT number,
                            checkExistForza OUT number
                             ) RETURN NUMBER is

p_fascia cm_prospetto_inf.codmonocategoria%type;
p_dataPrimaAssunzione cm_prospetto_inf.datprimaassunzione%type;
p_dataSecondaAssunzione cm_prospetto_inf.datsecondaassunzione%type;
p_flgEsonero cm_prospetto_inf.flgesonero%type;
p_numPercEsonero cm_prospetto_inf.numpercesonero%type;
p_flgCompTerritoriale cm_prospetto_inf.flgcompterritoriale%type;
p_prgAzienda cm_prospetto_inf.prgazienda%type;
p_prgUnita cm_prospetto_inf.prgunita%type;
p_numanno cm_prospetto_inf.numannorifprospetto%type;
p_dataConsegna cm_prospetto_inf.datconsegnaprospetto%type;
p_dataRiferimento cm_prospetto_inf.datrifinforza%type;
p_dataProspetto cm_prospetto_inf.datprospetto%type;
p_codProvincia cm_prospetto_inf.codprovincia%type;
p_flgobbligol68 an_azienda.flgobbligol68%type;
numCompensazioni number;
numCompInProv number;
numCompArt18 number;
numCompRiduz number;
numCompensEcc number;
p_numCandidatiL68 number;
p_numCandidatiMov number;
checkProspStor number;
p_numLavForza number;

err_dataPrimaAssunzione number;
err_percEsonero number;
err_percCompensazione number;
err_numCompInProv number;
err_numCompArt18 number;
err_numCompRiduz number;
err_numCompensEcc number;
err_flgObbligoL68 number;
err_incrocioMovimenti number;

err_dataConsegnaProspetto number;
err_dataRiferimento number;
err_dataProspetto number;
err_checkProspStoriciz number;

-- var calcolo scopertura
checkScoperturaProsp number;

begin

  -- 1 verifica prospetto
  err_dataPrimaAssunzione := 0;
  err_percEsonero := 0;
  err_percCompensazione := 0;
  err_numCompInProv := 0;
  err_numCompArt18 := 0;
  err_numCompRiduz := 0;
  err_numCompensEcc := 0;
  err_flgObbligoL68 := 0;
  err_incrocioMovimenti := 0;

  err_dataConsegnaProspetto := 0;
  err_dataRiferimento := 0;
  err_dataProspetto := 0;

  select p.codmonocategoria, p.datprimaassunzione, p.datsecondaassunzione,
  p.flgesonero, p.numpercesonero,
  p.flgcompterritoriale,
  p.prgazienda, p.prgunita, p.numannorifprospetto,
  p.datconsegnaprospetto, p.codprovincia,
  p.datrifinforza, p.datprospetto
  into p_fascia, p_dataPrimaAssunzione, p_dataSecondaAssunzione,
  p_flgEsonero, p_numPercEsonero,
  p_flgCompTerritoriale,
  p_prgAzienda, p_prgunita, p_numanno,
  p_dataConsegna, p_codProvincia,
  p_dataRiferimento, p_dataProspetto
  from cm_prospetto_inf p
  where p.prgprospettoinf = p_prgProspettoInf;

  select az.FLGOBBLIGOL68
  into p_flgobbligol68
  from an_azienda az
  where az.prgazienda = p_prgAzienda;

  -- errore autorizzazioni: mancanza percentuale esonero
  if (p_flgEsonero = 'S') then
     if (p_numPercEsonero is null) then
        err_percEsonero := 1;

        return 2;
     end if;
  end if;
  -- errore autorizzazioni: mancanza di compensazione territoriale
  if (p_flgCompTerritoriale = 'S') then
    select count(comp.prgcompensaz) into numCompensazioni
    from cm_pi_compensazione comp
    where comp.prgprospettoinf = p_prgProspettoInf;

    if (numCompensazioni = 0 ) then
        err_percCompensazione := 1;

        return 3;
    end if;
	
	--la provincia indicata nella compensazione deve essere diversa 
	--dalla provincia del prospetto quando cf azienda gruppo non è valorizzato.
	select count(comp.prgcompensaz) into numCompInProv
	from cm_pi_compensazione comp
	where comp.prgprospettoinf = p_prgProspettoInf
	and comp.codprovincia = (select p.codprovincia from cm_prospetto_inf p where p.prgprospettoinf = p_prgProspettoInf)
	and comp.strcfazcapogruppo is null;
		
	if (numCompInProv > 0) then
		err_numCompInProv := 1;
		return 10;
	end if;
	
    if (p_fascia = 'B' or p_fascia = 'C') then
	  
      select count(comp.prgcompensaz) into numCompArt18
      from cm_pi_compensazione comp
      where comp.prgprospettoinf = p_prgProspettoInf
      and codmonocategoria = 'A';

      if (numCompArt18 > 0) then
            err_numCompArt18 := 1;

        return 9;
      end if;

      select count(comp.prgcompensaz) into numCompRiduz
      from cm_pi_compensazione comp
      where comp.prgprospettoinf = p_prgProspettoInf
      and CODMONOECCDIFF = 'E';

      if (numCompRiduz > 0) then
            err_numCompRiduz := 1;

         return 11;
      end if;

      select count(comp.prgcompensaz) into numCompensEcc
      from cm_pi_compensazione comp
      where comp.prgprospettoinf = p_prgProspettoInf
      and comp.codmonoeccdiff = 'D';

      if (p_fascia = 'B' and numCompensEcc > 2) then
		err_numCompensEcc := 1;

	    return 8;
      end if;

      if (p_fascia = 'C' and numCompensEcc > 1) then
            err_numCompensEcc := 1;

         return 8;
      end if;

   end if; -- end if fascia B o C
  end if; -- end if errore autorizzazioni: mancanza di compensazione territoriale

  -- data consegna prospetto obbligatoria
  if (p_dataConsegna is null) then
     err_dataConsegnaProspetto := 1;

     return 4;
  end if;

  -- data riferimento prospetto obbligatoria
  if (p_datariferimento is null) then
     err_dataRiferimento := 1;

     return 5;
  end if;

  -- data prospetto obbligatoria
  if (p_dataprospetto is null) then
     err_dataProspetto := 1;

     return 6;
  end if;

  -- verifica che azienda, provincia, anno e data prospetto non siano ripetuti per prospetti storicizzati
  select count(pros.prgprospettoinf) into checkProspStor
  from cm_prospetto_inf pros
  where pros.prgazienda = p_prgAzienda
  and pros.codprovincia = p_codProvincia
  and pros.numannorifprospetto = p_numanno
  and pros.CODMONOSTATOPROSPETTO in ('S','U')
  and pros.datprospetto = p_dataprospetto;

  if (checkProspStor > 0) then
     err_checkProspStoriciz := 1;

     return 7;
  end if;

  -- warning per la presenza di scoipertura
  checkScopertura := pg_coll_mirato_2.checkscopertura(p_prgprospettoinf, 'S');

  -- warning per la presenza di eventuali lavoratori in forza successivi a data prospetto
  select nvl(round(sum(l.deccopertura),2),0) into p_numLavForza
  from cm_pi_lav_riserva l
  where l.prgprospettoinf = p_prgProspettoInf
  and l.datiniziorapp > p_dataprospetto
  and l.decoretotali is not null
  and l.decorelavorate is not null;

  if (p_numLavForza > 0) then
     checkexistforza := 1;
  else
     checkexistforza := 0;
  end if;

  return 0;

  exception
      when others then
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return -1;

end CONTROLLAPROSPETTO;


/********************************************************************************************
* verifica dati del prospetto                                                               *
*********************************************************************************************/
function VERIFICAPROSPETTO(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                            err_percEsonero OUT number,
                            err_percCompensazione OUT number,
                            err_numCompInProv OUT number,
                            err_numCompArt18 OUT number,
                            err_numCompRiduz OUT number,
                            err_numCompensEcc OUT number,
                            err_dataConsegnaProspetto OUT number,
                            err_dataProspetto OUT number,
                            err_dataRiferimento OUT number,
                            err_checkProspStoriciz OUT number,
                            checkScopertura OUT number,
                            checkExistForza OUT number,
                            checkSospensione OUT number
                             ) RETURN NUMBER is

p_fascia cm_prospetto_inf.codmonocategoria%type;
p_dataPrimaAssunzione cm_prospetto_inf.datprimaassunzione%type;
p_dataSecondaAssunzione cm_prospetto_inf.datsecondaassunzione%type;
p_flgEsonero cm_prospetto_inf.flgesonero%type;
p_numPercEsonero cm_prospetto_inf.numpercesonero%type;
p_flgCompTerritoriale cm_prospetto_inf.flgcompterritoriale%type;
p_prgAzienda cm_prospetto_inf.prgazienda%type;
p_prgUnita cm_prospetto_inf.prgunita%type;
p_numanno cm_prospetto_inf.numannorifprospetto%type;
p_dataConsegna cm_prospetto_inf.datconsegnaprospetto%type;
p_dataRiferimento cm_prospetto_inf.datrifinforza%type;
p_dataProspetto cm_prospetto_inf.datprospetto%type;
p_codProvincia cm_prospetto_inf.codprovincia%type;
p_flgobbligol68 an_azienda.flgobbligol68%type;
p_flggradualita cm_prospetto_inf.flggradualita%type;
p_flgsospensione cm_prospetto_inf.flgsospensione%type;
p_datsospensione cm_prospetto_inf.datsospensione%type;

numCompensazioni number;
numCompInProv number;
numCompArt18 number;
numCompRiduz number;
numCompensEcc number;
p_numCandidatiL68 number;
p_numCandidatiMov number;
checkProspStor number;
p_numLavForza number;


err_dataPrimaAssunzione number;
err_flgObbligoL68 number;
err_incrocioMovimenti number;

checkNumCompArt18 number;
checkNumCompRiduz number;
checkNumCompensEcc number;

/*
err_percEsonero number;
err_percCompensazione number;
err_numCompInProv number;
err_numCompArt18 number;
err_numCompRiduz number;
err_numCompensEcc number;


err_dataConsegnaProspetto number;
err_dataRiferimento number;
err_dataProspetto number;
err_checkProspStoriciz number;

-- var calcolo scopertura
checkScoperturaProsp number;
*/
begin

  -- 1 verifica prospetto
  err_dataPrimaAssunzione := 0;
  err_percEsonero := 0;
  err_percCompensazione := 0;
  err_numCompInProv := 0;
  err_numCompArt18 := 0;
  err_numCompRiduz := 0;
  err_numCompensEcc := 0;
  err_flgObbligoL68 := 0;
  err_incrocioMovimenti := 0;

  err_dataConsegnaProspetto := 0;
  err_dataRiferimento := 0;
  err_dataProspetto := 0;

  select p.codmonocategoria, p.datprimaassunzione, p.datsecondaassunzione,
  p.flgesonero, p.numpercesonero,
  p.flgcompterritoriale,
  p.prgazienda, p.prgunita, p.numannorifprospetto,
  p.datconsegnaprospetto, p.codprovincia,
  p.datrifinforza, p.datprospetto,
  p.flggradualita, p.flgsospensione, p.datsospensione
  into p_fascia, p_dataPrimaAssunzione, p_dataSecondaAssunzione,
  p_flgEsonero, p_numPercEsonero,
  p_flgCompTerritoriale,
  p_prgAzienda, p_prgunita, p_numanno,
  p_dataConsegna, p_codProvincia,
  p_dataRiferimento, p_dataProspetto,
  p_flggradualita, p_flgsospensione, p_datsospensione
  from cm_prospetto_inf p
  where p.prgprospettoinf = p_prgProspettoInf;

  select az.FLGOBBLIGOL68
  into p_flgobbligol68
  from an_azienda az
  where az.prgazienda = p_prgAzienda;

  -- errore autorizzazioni: mancanza percentuale esonero
  if (p_flgEsonero = 'S') then
     if (p_numPercEsonero is null) then
        err_percEsonero := 1;
     end if;
  end if;
  -- errore autorizzazioni: mancanza di compensazione territoriale
  if (p_flgCompTerritoriale = 'S') then
	select count(comp.prgcompensaz) into numCompensazioni
    from cm_pi_compensazione comp
    where comp.prgprospettoinf = p_prgProspettoInf;

    if (numCompensazioni = 0 ) then
		err_percCompensazione := 1;
    end if;
	 
	--la provincia indicata nella compensazione deve essere diversa 
	--dalla provincia del prospetto quando cf azienda gruppo non è valorizzato.
	select count(comp.prgcompensaz) into numCompInProv
	from cm_pi_compensazione comp
	where comp.prgprospettoinf = p_prgProspettoInf
	and comp.codprovincia = (select p.codprovincia from cm_prospetto_inf p where p.prgprospettoinf = p_prgProspettoInf)
	and comp.strcfazcapogruppo is null;
		
	if (numCompInProv > 0) then
		err_numCompInProv := 1;
	end if;
	 

	if (p_fascia = 'B' or p_fascia = 'C') then
		
		select count(comp.prgcompensaz) into numCompArt18
		from cm_pi_compensazione comp
		where comp.prgprospettoinf = p_prgProspettoInf
		and codmonocategoria = 'A';

		if (numCompArt18 > 0) then
			select sum(nvl(comp.numinteressati,0)) into checkNumCompArt18
			from cm_pi_compensazione comp
			where comp.prgprospettoinf = p_prgProspettoInf
			and codmonocategoria = 'A';
			if (checkNumCompArt18 > 0) then
				err_numCompArt18 := 1;
			end if;
		end if;

		/*
		-- dona/dome 05/09/2012 
		select count(comp.prgcompensaz) into numCompRiduz
		  from cm_pi_compensazione comp
		  where comp.prgprospettoinf = p_prgProspettoInf
		and CODMONOECCDIFF = 'E';

		if (numCompRiduz > 0) then
		  select sum(nvl(comp.numinteressati,0)) into checkNumCompRiduz
		  from cm_pi_compensazione comp
		  where comp.prgprospettoinf = p_prgProspettoInf
		  and CODMONOECCDIFF = 'E';
		  if (checkNumCompRiduz > 0) then
			 err_numCompRiduz := 1;
		  end if;
		end if;
		*/

		select count(comp.prgcompensaz) into numCompensEcc
		from cm_pi_compensazione comp
		where comp.prgprospettoinf = p_prgProspettoInf
		and comp.codmonoeccdiff = 'D';

		if (p_fascia = 'B' and numCompensEcc > 0) then
            select sum(nvl(comp.numinteressati,0)) into checkNumCompensEcc
            from cm_pi_compensazione comp
            where comp.prgprospettoinf = p_prgProspettoInf
            and comp.codmonoeccdiff = 'D';

            if (checkNumCompensEcc > 2) then
               err_numCompensEcc := 1;
            end if;
		end if;

		if (p_fascia = 'C' and numCompensEcc > 0) then
            select sum(nvl(comp.numinteressati,0)) into checkNumCompensEcc
            from cm_pi_compensazione comp
            where comp.prgprospettoinf = p_prgProspettoInf
            and comp.codmonoeccdiff = 'D';

            if (checkNumCompensEcc > 1) then
               err_numCompensEcc := 1;
            end if;
		end if;

	end if; --end if (p_fascia = 'B' or p_fascia = 'C')
  end if; --end if (p_flgCompTerritoriale = 'S')

  -- data consegna prospetto obbligatoria
  if (p_dataConsegna is null) then
     err_dataConsegnaProspetto := 1;
  end if;

  -- data riferimento prospetto non obbligatoria
  /*
  if (p_datariferimento is null) then
     err_dataRiferimento := 1;

  end if;
  */

  -- data prospetto obbligatoria
  if (p_dataprospetto is null) then
     err_dataProspetto := 1;
  end if;

  -- verifica che azienda, provincia, anno e data prospetto non siano ripetuti per prospetti storicizzati
  select count(pros.prgprospettoinf) into checkProspStor
  from cm_prospetto_inf pros
  where pros.prgazienda = p_prgAzienda
  and pros.codprovincia = p_codProvincia
  and pros.numannorifprospetto = p_numanno
  and pros.CODMONOSTATOPROSPETTO in ('S','U')
  and pros.datprospetto = p_dataprospetto;

  if (checkProspStor > 0) then
     err_checkProspStoriciz := 1;
  end if;

  -- warning per la presenza di scoipertura
  checkScopertura := pg_coll_mirato_2.checkscopertura(p_prgprospettoinf, 'S');

  -- warning per la presenza di eventuali lavoratori in forza successivi a data prospetto
  select nvl(round(sum(l.deccopertura),2),0) into p_numLavForza
  from cm_pi_lav_riserva l
  where l.prgprospettoinf = p_prgProspettoInf
  and l.datiniziorapp > p_dataprospetto
  and l.decoretotali is not null
  and l.decorelavorate is not null;

  if (p_numLavForza > 0) then
     checkexistforza := 1;
  else
     checkexistforza := 0;
  end if;

  -- warning per le sospensioni
  if (p_flgsospensione = 'S') then
     if (p_dataprospetto is not null) then
       if (trunc(p_datsospensione) >= trunc(p_dataprospetto)) then
          checksospensione := 1;
       else
          checksospensione := 0;
       end if;
     else
       checksospensione := 0;
     end if;
  end if;


  return 0;

  exception
      when others then
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return -1;

end VERIFICAPROSPETTO;

/********************************************************************************************
* verifica se esiste la scopertura di un prospetto                                          *
*********************************************************************************************/
function CHECKSCOPERTURA(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                         p_flgConvenzione varchar2
                             ) RETURN NUMBER is


-- var calcolo scopertura
p_baseComputo cm_prospetto_inf.numbasecomputo%type;
p_numQuotaDisabili cm_prospetto_inf.numquotadisabili%type;
p_numDisabiliNom cm_prospetto_inf.numDisabiliNom%type;
p_numDisabiliNum cm_prospetto_inf.numDisabiliNum%type;
p_numQuotaArt18 cm_prospetto_inf.numQuotaArt18%type;
p_numArt18Nom cm_prospetto_inf.numArt18Nom%type;
p_numArt18Num cm_prospetto_inf.numArt18Num%type;
p_numDisForzaNomi cm_prospetto_inf.numDisForzaNomi%type;
p_numDisForzaNume cm_prospetto_inf.numDisForzaNume%type;
p_numDisForza cm_prospetto_inf.numDisForza%type;
p_numArt18ForzaNomi cm_prospetto_inf.numArt18ForzaNomi%type;
p_numArt18ForzaNume cm_prospetto_inf.numArt18ForzaNume%type;
p_numArt18Forza cm_prospetto_inf.numArt18Forza%type;
p_numDisCompTerrNomi cm_prospetto_inf.numDisCompTerrNomi%type;
p_numDisCompTerrNume cm_prospetto_inf.numDisCompTerrNume%type;
p_numArt18CompTerrNomi cm_prospetto_inf.numArt18CompTerrNomi%type;
p_numArt18CompTerrNume cm_prospetto_inf.numArt18CompTerrNume%type;
p_numDisEsonNomi cm_prospetto_inf.numDisEsonNomi%type;
p_numDisEsonNume cm_prospetto_inf.numDisEsonNume%type;
p_numdisconvnomi cm_prospetto_inf.numdisconvnomi%type;
p_numdisconvnume cm_prospetto_inf.numdisconvnume%type;
p_numart18convnomi cm_prospetto_inf.numart18convnomi%type;
p_numart18convnume cm_prospetto_inf.numart18convnume%type;

p_flggradualita cm_prospetto_inf.flggradualita%type;
p_numquotadisgrad cm_prospetto_inf.numquotadisgrad%type;
p_numlavinforzagrad cm_prospetto_inf.numlavinforzagrad%type;

p_numdisforzarifnomi cm_prospetto_inf.numdisforzarifnomi%type;
p_numdisforzarifnume cm_prospetto_inf.numdisforzarifnume%type;
p_numart18forzarifnomi cm_prospetto_inf.numart18forzarifnomi%type;
p_numart18forzarifnume cm_prospetto_inf.numart18forzarifnume%type;

p_disScoperturaTotNomi number;
p_art18ScoperturaTotNomi number;
p_disScoperturaTotNume number;
p_art18ScoperturaTotNume number;
p_disScoperturaTot number;
p_art18ScoperturaTot number;
conf_n_vedente varchar(3);

--battistoni
p_numdisbattistoni cm_prospetto_inf.numdisbattistoni%type;
p_numbattistoniinforza cm_prospetto_inf.numbattistoniinforza%type;
p_numart18battistoni  cm_prospetto_inf.numart18battistoni%type;

-- n_vendente e massofisio
p_numscopcentnonvedenti  cm_prospetto_inf.numscopcentnonvedenti%type;
p_numscopmassofisioterapisti  cm_prospetto_inf.numscopmassofisioterapisti%type;


begin

  select nvl(pi.numbasecomputo,0),
  nvl(pi.numquotadisabili,0),
  nvl(pi.numdisabilinom,0),
  nvl(pi.numdisabilinum,0),
  nvl(pi.numquotaart18,0),
  nvl(pi.numart18nom,0),
  nvl(pi.numart18num,0),
  nvl(pi.NUMDISFORZARIFNOMI,0),
  nvl(pi.numdisforzanomi,0),
  nvl(pi.numdisforzanume,0),
  nvl(pi.numdisforza,0),
  nvl(pi.NUMDISFORZARIFNUME,0),
  nvl(pi.numart18forzanomi,0),
  nvl(pi.numart18forzanume,0),
  nvl(pi.numart18forza,0),
  nvl(pi.numart18forzarifnomi,0),
  nvl(pi.numart18forzarifnume,0),
  nvl(pi.numdiscompterrnomi,0),
  nvl(pi.numdiscompterrnume,0),
  nvl(pi.numart18compterrnomi,0),
  nvl(pi.numart18compterrnume,0),
  nvl(pi.numDisEsonNomi,0),
  nvl(pi.numDisEsonNume,0),
  nvl(pi.numdisconvnomi,0),
  nvl(pi.numdisconvnume,0),
  nvl(pi.numart18convnomi,0),
  nvl(pi.numart18convnume,0),
  nvl(pi.flggradualita,0),
  nvl(pi.numquotadisgrad,0),
  nvl(pi.numlavinforzagrad,0),
  --battistoni
  nvl(pi.numdisbattistoni,0),
  nvl(pi.numbattistoniinforza,0),
  nvl(pi.numart18battistoni,0),
  -- centra e masso
  nvl(pi.numscopcentnonvedenti,0),
  nvl(pi.numscopmassofisioterapisti,0)
  into
  p_baseComputo,
  p_numQuotaDisabili,
  p_numDisabiliNom,
  p_numDisabiliNum,
  p_numQuotaArt18,
  p_numArt18Nom,
  p_numArt18Num,
  p_numdisforzarifnomi,
  p_numDisForzaNomi,
  p_numDisForzaNume,
  p_numDisForza,
  p_numdisforzarifnume,
  p_numArt18ForzaNomi,
  p_numArt18ForzaNume,
  p_numArt18Forza,
  p_numart18forzarifnomi,
  p_numart18forzarifnume,
  p_numDisCompTerrNomi,
  p_numDisCompTerrNume,
  p_numArt18CompTerrNomi,
  p_numArt18CompTerrNume,
  p_numDisEsonNomi,
  p_numDisEsonNume,
  p_numdisconvnomi,
  p_numdisconvnume,
  p_numart18convnomi,
  p_numart18convnume,
  p_flggradualita,
  p_numquotadisgrad,
  p_numlavinforzagrad,
  p_numdisbattistoni,
  p_numbattistoniinforza,
  p_numart18battistoni,
  p_numscopcentnonvedenti,
  p_numscopmassofisioterapisti
  from cm_prospetto_inf pi
  where pi.prgprospettoinf = p_prgProspettoInf;

  -- in caso di gradualità la scopertura è data dalla differenza tra quota - lav in forza gradualita
  if (p_flggradualita = 'S') then
     p_disScoperturaTot := p_numquotadisgrad - p_numlavinforzagrad;
     p_art18ScoperturaTot := 0;
  else
    if (p_flgconvenzione = 'S') then
      -- scopertura nominativa disabile
      p_disScoperturaTotNomi := p_numDisabiliNom - (p_numDisForzaNomi+p_numdisforzarifnomi) - p_numdisconvnomi + p_numDisCompTerrNomi - p_numDisEsonNomi;
      -- scopertura nominativa art18
      p_art18ScoperturaTotNomi := p_numArt18Nom - (p_numArt18ForzaNomi+p_numart18forzarifnomi) - p_numart18convnomi + p_numArt18CompTerrNomi;

      -- scopertura numerica disabile
      p_disScoperturaTotNume := p_numDisabiliNum - (p_numDisForzaNume+p_numdisforzarifnume) - p_numdisconvnume + p_numDisCompTerrNume - p_numDisEsonNume;
      -- scopertura numerica art18
      p_art18ScoperturaTotNume := p_numArt18Num - (p_numArt18ForzaNume+p_numart18forzarifnume) - p_numart18convnume + p_numArt18CompTerrNume;
    else
       -- scopertura nominativa disabile
      p_disScoperturaTotNomi := p_numDisabiliNom - (p_numDisForzaNomi+p_numdisforzarifnomi) + p_numDisCompTerrNomi - p_numDisEsonNomi;
      -- scopertura nominativa art18
      p_art18ScoperturaTotNomi := p_numArt18Nom - (p_numArt18ForzaNomi+p_numart18forzarifnomi)  + p_numArt18CompTerrNomi;

      -- scopertura numerica disabile
      p_disScoperturaTotNume := p_numDisabiliNum - (p_numDisForzaNume+p_numdisforzarifnume) + p_numDisCompTerrNume - p_numDisEsonNume;
      -- scopertura numerica art18
      p_art18ScoperturaTotNume := p_numArt18Num - (p_numArt18ForzaNume+p_numart18forzarifnume) + p_numArt18CompTerrNume;
    end if;


    -- calcolo scopertura totale disabile - Battistoni
    p_disScoperturaTot := p_disScoperturaTotNomi + p_disScoperturaTotNume - p_numdisbattistoni;
    -- calcolo scopertura totale art18 - Battistoni
    p_art18ScoperturaTot := p_art18ScoperturaTotNomi + p_art18ScoperturaTotNume - p_numart18battistoni;

  end if;



  if (p_disScoperturaTot > 0) then
       return 1;
  end if;

  if (p_art18ScoperturaTot > 0) then
       return 1;
  end if;

 return 0;

  exception
      when others then
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return -1;

end CHECKSCOPERTURA;

function GETSCOPERTURA(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                       p_flgConvenzione varchar2
                       ) RETURN varchar2 is


-- var calcolo scopertura
p_baseComputo cm_prospetto_inf.numbasecomputo%type;
p_numQuotaDisabili cm_prospetto_inf.numquotadisabili%type;
p_numDisabiliNom cm_prospetto_inf.numDisabiliNom%type;
p_numDisabiliNum cm_prospetto_inf.numDisabiliNum%type;
p_numQuotaArt18 cm_prospetto_inf.numQuotaArt18%type;
p_numArt18Nom cm_prospetto_inf.numArt18Nom%type;
p_numArt18Num cm_prospetto_inf.numArt18Num%type;
p_numDisForzaNomi cm_prospetto_inf.numDisForzaNomi%type;
p_numDisForzaNume cm_prospetto_inf.numDisForzaNume%type;
p_numDisForza cm_prospetto_inf.numDisForza%type;
p_numArt18ForzaNomi cm_prospetto_inf.numArt18ForzaNomi%type;
p_numArt18ForzaNume cm_prospetto_inf.numArt18ForzaNume%type;
p_numArt18Forza cm_prospetto_inf.numArt18Forza%type;
p_numDisCompTerrNomi cm_prospetto_inf.numDisCompTerrNomi%type;
p_numDisCompTerrNume cm_prospetto_inf.numDisCompTerrNume%type;
p_numArt18CompTerrNomi cm_prospetto_inf.numArt18CompTerrNomi%type;
p_numArt18CompTerrNume cm_prospetto_inf.numArt18CompTerrNume%type;
p_numDisEsonNomi cm_prospetto_inf.numDisEsonNomi%type;
p_numDisEsonNume cm_prospetto_inf.numDisEsonNume%type;
p_numdisconvnomi cm_prospetto_inf.numdisconvnomi%type;
p_numdisconvnume cm_prospetto_inf.numdisconvnume%type;
p_numart18convnomi cm_prospetto_inf.numart18convnomi%type;
p_numart18convnume cm_prospetto_inf.numart18convnume%type;

p_flggradualita cm_prospetto_inf.flggradualita%type;
p_numquotadisgrad cm_prospetto_inf.numquotadisgrad%type;
p_numlavinforzagrad cm_prospetto_inf.numlavinforzagrad%type;

p_numdisforzarifnomi cm_prospetto_inf.numdisforzarifnomi%type;
p_numdisforzarifnume cm_prospetto_inf.numdisforzarifnume%type;
p_numart18forzarifnomi cm_prospetto_inf.numart18forzarifnomi%type;
p_numart18forzarifnume cm_prospetto_inf.numart18forzarifnume%type;
-- Battistoni
p_numdisbattistoni cm_prospetto_inf.numdisbattistoni%type;
p_numbattistoniinforza cm_prospetto_inf.numbattistoniinforza%type;
p_numart18battistoni  cm_prospetto_inf.numart18battistoni%type;

p_disScoperturaTotNomi number;
p_art18ScoperturaTotNomi number;
p_disScoperturaTotNume number;
p_art18ScoperturaTotNume number;
p_disScoperturaTot number;
p_art18ScoperturaTot number;
strScopertura varchar2(1000);

begin

  select nvl(pi.numbasecomputo,0),
  nvl(pi.numquotadisabili,0),
  nvl(pi.numdisabilinom,0),
  nvl(pi.numdisabilinum,0),
  nvl(pi.numquotaart18,0),
  nvl(pi.numart18nom,0),
  nvl(pi.numart18num,0),
  nvl(pi.NUMDISFORZARIFNOMI,0),
  nvl(pi.numdisforzanomi,0),
  nvl(pi.numdisforzanume,0),
  nvl(pi.numdisforza,0),
  nvl(pi.NUMDISFORZARIFNUME,0),
  nvl(pi.numart18forzanomi,0),
  nvl(pi.numart18forzanume,0),
  nvl(pi.numart18forza,0),
  nvl(pi.numart18forzarifnomi,0),
  nvl(pi.numart18forzarifnume,0),
  nvl(pi.numdiscompterrnomi,0),
  nvl(pi.numdiscompterrnume,0),
  nvl(pi.numart18compterrnomi,0),
  nvl(pi.numart18compterrnume,0),
  nvl(pi.numDisEsonNomi,0),
  nvl(pi.numDisEsonNume,0),
  nvl(pi.numdisconvnomi,0),
  nvl(pi.numdisconvnume,0),
  nvl(pi.numart18convnomi,0),
  nvl(pi.numart18convnume,0),
  nvl(pi.flggradualita,0),
  nvl(pi.numquotadisgrad,0),
  nvl(pi.numlavinforzagrad,0),
  nvl(pi.numdisbattistoni,0),
  nvl(pi.numbattistoniinforza,0),
  nvl(pi.numart18battistoni,0)
  into
  p_baseComputo,
  p_numQuotaDisabili,
  p_numDisabiliNom,
  p_numDisabiliNum,
  p_numQuotaArt18,
  p_numArt18Nom,
  p_numArt18Num,
  p_numdisforzarifnomi,
  p_numDisForzaNomi,
  p_numDisForzaNume,
  p_numDisForza,
  p_numdisforzarifnume,
  p_numArt18ForzaNomi,
  p_numArt18ForzaNume,
  p_numArt18Forza,
  p_numart18forzarifnomi,
  p_numart18forzarifnume,
  p_numDisCompTerrNomi,
  p_numDisCompTerrNume,
  p_numArt18CompTerrNomi,
  p_numArt18CompTerrNume,
  p_numDisEsonNomi,
  p_numDisEsonNume,
  p_numdisconvnomi,
  p_numdisconvnume,
  p_numart18convnomi,
  p_numart18convnume,
  p_flggradualita,
  p_numquotadisgrad,
  p_numlavinforzagrad,
  p_numdisbattistoni,
  p_numbattistoniinforza,
  p_numart18battistoni
  from cm_prospetto_inf pi
  where pi.prgprospettoinf = p_prgProspettoInf;
  -- p_disScoperturaTot
  -- p_art18ScoperturaTot

  -- in caso di gradualità la scopertura è data dalla differenza tra quota - lav in forza gradualita
  if (p_flggradualita = 'S') then

     p_disScoperturaTotNomi := 0;
     p_art18ScoperturaTotNomi := 0;
     p_disScoperturaTotNume := 0;
     p_art18ScoperturaTotNume := 0;

     p_disScoperturaTot := p_numquotadisgrad - p_numlavinforzagrad;
     p_art18ScoperturaTot := 0;
  else
    if (p_flgconvenzione = 'S') then
      -- scopertura nominativa disabile
      p_disScoperturaTotNomi := p_numDisabiliNom - (p_numDisForzaNomi+p_numdisforzarifnomi) - p_numdisconvnomi + p_numDisCompTerrNomi - p_numDisEsonNomi;
      -- scopertura nominativa art18
      p_art18ScoperturaTotNomi := p_numArt18Nom - (p_numArt18ForzaNomi+p_numart18forzarifnomi) - p_numart18convnomi + p_numArt18CompTerrNomi;

      -- scopertura numerica disabile
      p_disScoperturaTotNume := p_numDisabiliNum - (p_numDisForzaNume+p_numdisforzarifnume) - p_numdisconvnume + p_numDisCompTerrNume - p_numDisEsonNume;
      -- scopertura numerica art18
      p_art18ScoperturaTotNume := p_numArt18Num - (p_numArt18ForzaNume+p_numart18forzarifnume) - p_numart18convnume + p_numArt18CompTerrNume;
    else
       -- scopertura nominativa disabile
      p_disScoperturaTotNomi := p_numDisabiliNom - (p_numDisForzaNomi+p_numdisforzarifnomi) + p_numDisCompTerrNomi - p_numDisEsonNomi;
      -- scopertura nominativa art18
      p_art18ScoperturaTotNomi := p_numArt18Nom - (p_numArt18ForzaNomi+p_numart18forzarifnomi)  + p_numArt18CompTerrNomi;

      -- scopertura numerica disabile
      p_disScoperturaTotNume := p_numDisabiliNum - (p_numDisForzaNume+p_numdisforzarifnume) + p_numDisCompTerrNume - p_numDisEsonNume;
      -- scopertura numerica art18
      p_art18ScoperturaTotNume := p_numArt18Num - (p_numArt18ForzaNume+p_numart18forzarifnume) + p_numArt18CompTerrNume;
    end if;

    -- calcolo scopertura totale disabile - Battistoni
    p_disScoperturaTot := p_disScoperturaTotNomi + p_disScoperturaTotNume - p_numdisbattistoni;
    -- calcolo scopertura totale art18 - Battistoni
    p_art18ScoperturaTot := p_art18ScoperturaTotNomi + p_art18ScoperturaTotNume - p_numart18battistoni;

  end if;
  
  strScopertura := p_disScoperturaTot ||';'||
                   p_disScoperturaTotNomi ||';'||
                   p_disScoperturaTotNume ||';'||
                   p_art18ScoperturaTot ||';'||
                   p_art18ScoperturaTotNomi ||';'||
                   p_art18ScoperturaTotNume;

  return strScopertura;

end GETSCOPERTURA;


/***************************************************************************************
* genera una nuovo del prospettoin corso d'anno dal prospetto storicizzato o annullato *
* p_checkAnnulla = 1 annulla il prospetto in corso d'anno (nuova gestione)
*                = 0 come prima se è presente genera errore
***************************************************************************************/
function GENERACOPIAPROSPETTO(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                             p_codProvincia cm_prospetto_inf.codprovincia%type,
                             p_numAnnoRifProspetto cm_prospetto_inf.numannorifprospetto%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                             p_checkAnnulla varchar2,
                             p_key varchar2,
                             p_out_prgprospettoinf OUT cm_prospetto_inf.prgprospettoinf%type
                             ) RETURN NUMBER is

codprovinciasil ts_generale.codprovinciasil%type;
codregionesil ts_generale.codregionesil%type;
flgpoloreg ts_generale.flgpoloreg%type;
codregioneprospetto de_provincia.codregione%type;
checkProviniciaInterna number;
checkExistProsp number;
newPrgProspetto cm_prospetto_inf.prgprospettoinf%type;
p_prgAzienda cm_prospetto_inf.prgazienda%type;
p_prgUnita cm_prospetto_inf.prgunita%type;
p_dataProspetto cm_prospetto_inf.datprospetto%type;
p_dataProspettoStr varchar2(10);
parprgdoccoll number;
checkProsp number;
parprgdocblob number;
parprgdoc number;
queryWhere varchar2(1000);
p_codCpi de_cpi.codcpi%type;
p_datInizioVal cm_prospetto_inf.datconsegnaprospetto%type;
p_prgDocumento am_documento.prgDocumento%type;
p_numKloDocumento am_documento.numKloDocumento%type;

-- ale 28/02/2011
p_prgMovimento am_movimento.prgmovimento%type;
p_dataInizioAnnoProspettoStr varchar2(10);
prgMovAvv am_movimento.prgmovimento%type;
checkNumber number;
p_errCode number;


  begin

    -- recupero la provinica del sil
    -- per verificare se il prospetto fa riferimento ad una provinica interna o esterna
    select ts.codProvinciaSil, de.codCpiCapoluogo codCpi, ts.codregionesil, nvl(ts.flgpoloreg, 'N') as flgpoloreg
    into codprovinciasil, p_codCpi, codregionesil, flgpoloreg
    from ts_generale ts
    inner join de_provincia de on (de.codProvincia = ts.codProvinciaSil);

    if (flgpoloreg = 'N') then
		if (codprovinciasil = p_codProvincia) then
			checkProviniciaInterna := 1;
		else
			checkProviniciaInterna := 0;
		end if;
	else
		select codregione
		into codregioneprospetto
		from de_provincia
		where codprovincia = p_codProvincia;
	  
		if (codregionesil = codregioneprospetto) then
			checkProviniciaInterna := 1;
		else
			checkProviniciaInterna := 0;
		end if;
	end if;

      -- verifica che esiste già un prospetto in corso d'anno per azienda, provincia, anno
      select p.prgazienda, p.prgunita,
       decode(p.DATCONSEGNAPROSPETTO,NULL,trunc(sysdate),p.DATCONSEGNAPROSPETTO) as datInizioVal
      into p_prgAzienda, p_prgUnita, p_datInizioVal
      from cm_prospetto_inf p
    where p.prgprospettoinf = p_prgprospettoinf;

      select count(p.prgprospettoinf) into checkExistProsp
      from cm_prospetto_inf p
      where p.prgazienda = p_prgazienda
      and p.codprovincia = p_codprovincia
      and p.numannorifprospetto = p_numannorifprospetto
      and p.codmonostatoprospetto = 'A';

      -- errore prospetto duplicato
      if (checkExistProsp > 0) then
         -- annullo il prosp in corso d'anno per poi crearne uno nuovo
         if (p_checkAnnulla = '1') then

            queryWhere := ' where prgazienda = ' || p_prgazienda
                       || ' and codprovincia = ' || p_codprovincia
                       || ' and numannorifprospetto = ' || p_numannorifprospetto
                       || ' and codmonostatoprospetto = ''A'' ';

            PG_LOG.doLog('U', 'CM_PROSPETTO_INF', p_cdnUtente, queryWhere);

      select doc.prgdocumento, doc.numKloDocumento
      into p_prgDocumento, p_numKloDocumento
      from cm_prospetto_inf p
      inner join AM_DOCUMENTO_COLL coll ON (p.PRGPROSPETTOINF = to_number(coll.STRCHIAVETABELLA))
      inner join AM_DOCUMENTO doc ON (doc.PRGDOCUMENTO = coll.PRGDOCUMENTO)
      where p.prgazienda = p_prgazienda
      and p.codprovincia = p_codprovincia
      and p.codmonostatoprospetto = 'A'
      and p.numannorifprospetto = p_numannorifprospetto and doc.CODTIPODOCUMENTO = 'PINF';

            update cm_prospetto_inf p
            set p.codmonostatoprospetto = 'N',
                p.numkloprospettoinf = p.numkloprospettoinf + 1,
                p.cdnutmod = p_cdnUtente,
                p.dtmmod = sysdate
            where p.prgazienda = p_prgazienda
            and p.codprovincia = p_codprovincia
            and p.numannorifprospetto = p_numannorifprospetto
            and p.codmonostatoprospetto = 'A';

      update am_documento
      set codstatoatto = 'AN', numKloDocumento = p_numKloDocumento + 1
      where prgdocumento = p_prgDocumento;
     else
            p_out_prgprospettoinf := p_prgprospettoinf;
            return 1;
         end if;
	 end if;

      p_dataProspettoStr := '01/01/'||to_char(sysdate, 'YYYY');
      p_dataProspetto := to_date(p_dataProspettoStr, 'dd/mm/yyyy');
	  
      -- inizio copia del prospetto
      select s_cm_prospetto_inf.nextval into newprgprospetto from dual;

      p_out_prgprospettoinf := newprgprospetto;

      if (checkProviniciaInterna = 1) then

         insert into cm_prospetto_inf
          (prgprospettoinf,
            prgazienda,
            prgunita,
            prgazreferente,
            numoreccnl,
            codprovincia,
            codmonostatoprospetto,
            codmonoprov,
            numannorifprospetto,
            datconsegnaprospetto,
            datrifinforza,
            datprospetto,
            numdipendentinazionale,
            codmonocategoria,
            numdipendentitot,
            numbasecomputo,
            numquotadisabili,
            numdisabilinom,
            numdisabilinum,
            numquotaart18,
            numart18nom,
            numart18num,
            datprimaassunzione,
            datsecondaassunzione,
            numdisforza,
            numdisforzarifnomi,
            numdisforzanomi,
            numdisforzarifnume,
            numdisforzanume,
            numart18forza,
            numart18forzarifnomi,
            numart18forzanomi,
            numart18forzarifnume,
            numart18forzanume,
            flgesonero,
            numpercesonero,
            datfineesonero,
            flgesonrichproroga,
            datesonrichproroga,
            flggradualita,
            datconcgradualita,
            numassgradualita,
            numquotadisgrad,
            numlavinforzagrad,
            flgcompterritoriale,
            flgsospensione,
            datsospensione,
            numconvenzioni,
            numlavoratoriconv,
            numdisconvnume,
            numdisconvnomi,
            numart18convnume,
            numart18convnomi,
            numdiscompterrnomi,
            numdiscompterrnume,
            numart18compterrnomi,
            numart18compterrnume,
            numdisesonnomi,
            numdisesonnume,
            strnote,
            cdnutins,
            dtmins,
            cdnutmod,
            dtmmod,
            numassconvsare,
            datcompterritoriale,
            codcomunicazione,
            codcomunicazioneorig,
            --battistoni
            numdisbattistoni,
            numbattistoniinforza,
            numart18battistoni,
            -- conv
            numtotlavconvdis,
            numtotlavconvart18,
            -- scopertura n vedenti
            numscopcentnonvedenti,
            numscopmassofisioterapisti,
            numcentnonvedentiforza,
            nummassofisioterapistiforza,
            numcentnonvedentiobbligo,
            nummassofisioterapistiobbligo,
            flg15dipendenti,
			NUMPERCGRADUALITA,
			CODMONOSTATOSOSP,
			CODMONOCAUSALESOSP,
			NUMLAVORATORISOSP,
			FLGSOSPENSIONEMOB,
			numbasecomputoart3, numbasecomputoart18, numbasecomputoart3prov, numbasecomputoart18prov,
			flgcapogruppo, strcfazcapogruppo, flgcompetenza, flgcapogruppoestera, datrifq3,
			datFineSospMBNazionale,
			NUMTELELAVFT, NUMSOMMFT, NUMCONV12BIS14FT, 
			FLGESONEROAUTOCERT, DATESONEROAUTOCERT, NUMLAV60XMILLE, NUMPERCESONEROAUTOCERT, NUMLAVESONEROAUTOCERT
          )
          select
            newprgprospetto,
            pro.prgazienda,
            pro.prgunita,
            pro.prgazreferente,
            case 
                when pro.numoreccnl = 0 then 40
                   else pro.numoreccnl
			end as numoreccnl,  
            p_codprovincia,
            'A',
            'M',
            p_numannorifprospetto,
            null,
            pro.datrifinforza,
            p_dataProspetto,
            pro.numdipendentinazionale,
            pro.codmonocategoria,
            pro.numdipendentitot,
            pro.numbasecomputo,
            pro.numquotadisabili,
            pro.numdisabilinom,
            pro.numdisabilinum,
            pro.numquotaart18,
            pro.numart18nom,
            pro.numart18num,
            pro.datprimaassunzione,
            pro.datsecondaassunzione,
            pro.numdisforza,
            pro.numdisforzarifnomi,
            pro.numdisforzanomi,
            pro.numdisforzarifnume,
            pro.numdisforzanume,
            pro.numart18forza,
            pro.numart18forzarifnomi,
            pro.numart18forzanomi,
            pro.numart18forzarifnume,
            pro.numart18forzanume,
            pro.flgesonero,
            pro.numpercesonero,
            pro.datfineesonero,
            pro.flgesonrichproroga,
            pro.datesonrichproroga,
            pro.flggradualita,
            pro.datconcgradualita,
            pro.numassgradualita,
            pro.numquotadisgrad,
            pro.numlavinforzagrad,
            pro.flgcompterritoriale,
            pro.flgsospensione,
            pro.datsospensione,
            pro.numconvenzioni,
            pro.numlavoratoriconv,
            pro.numdisconvnume,
            pro.numdisconvnomi,
            pro.numart18convnume,
            pro.numart18convnomi,
            pro.numdiscompterrnomi,
            pro.numdiscompterrnume,
            pro.numart18compterrnomi,
            pro.numart18compterrnume,
            pro.numdisesonnomi,
            pro.numdisesonnume,
            pro.strnote,
            p_cdnutente,
            sysdate,
            p_cdnutente,
            sysdate,
            pro.numassconvsare,
            pro.datcompterritoriale,
            null,
            pro.codcomunicazione,
            --battistoni
            pro.numdisbattistoni,
            pro.numbattistoniinforza,
            pro.numart18battistoni,
            -- conv
            pro.numtotlavconvdis,
            pro.numtotlavconvart18,
            -- scopertura n vedenti
            pro.numscopcentnonvedenti,
            pro.numscopmassofisioterapisti,
            pro.numcentnonvedentiforza,
            pro.nummassofisioterapistiforza,
            pro.numcentnonvedentiobbligo,
            pro.nummassofisioterapistiobbligo,
            pro.flg15dipendenti,
            pro.NUMPERCGRADUALITA,
			pro.CODMONOSTATOSOSP,
			pro.CODMONOCAUSALESOSP,
			pro.NUMLAVORATORISOSP,
			pro.FLGSOSPENSIONEMOB,
			pro.numbasecomputoart3, pro.numbasecomputoart18, pro.numbasecomputoart3prov, pro.numbasecomputoart18prov, 
			pro.flgcapogruppo, pro.strcfazcapogruppo, pro.flgcompetenza, pro.flgcapogruppoestera, pro.datrifq3,
			pro.datFineSospMBNazionale,
			pro.NUMTELELAVFT, pro.NUMSOMMFT, pro.NUMCONV12BIS14FT, 
			pro.FLGESONEROAUTOCERT, pro.DATESONEROAUTOCERT, pro.NUMLAV60XMILLE, pro.NUMPERCESONEROAUTOCERT, pro.NUMLAVESONEROAUTOCERT
          from cm_prospetto_inf pro
          where pro.prgprospettoinf = p_prgProspettoInf;

      else

          insert into cm_prospetto_inf
          (prgprospettoinf,
            prgazienda,
            prgunita,
            prgazreferente,
            numoreccnl,
            codprovincia,
            codmonostatoprospetto,
            codmonoprov,
            numannorifprospetto,
            datconsegnaprospetto,
            datrifinforza,
            datprospetto,
            numdipendentinazionale,
            codmonocategoria,
            numdipendentitot,
            numbasecomputo,
            numquotadisabili,
            numdisabilinom,
            numdisabilinum,
            numquotaart18,
            numart18nom,
            numart18num,
            datprimaassunzione,
            datsecondaassunzione,
            numdisforza,
            numdisforzarifnomi,
            numdisforzanomi,
            numdisforzarifnume,
            numdisforzanume,
            numart18forza,
            numart18forzarifnomi,
            numart18forzanomi,
            numart18forzarifnume,
            numart18forzanume,
            flgesonero,
            numpercesonero,
            datfineesonero,
            flgesonrichproroga,
            datesonrichproroga,
            flggradualita,
            datconcgradualita,
            numassgradualita,
            numquotadisgrad,
            numlavinforzagrad,
            flgcompterritoriale,
            flgsospensione,
            datsospensione,
            numconvenzioni,
            numlavoratoriconv,
            numdisconvnume,
            numdisconvnomi,
            numart18convnume,
            numart18convnomi,
            numdiscompterrnomi,
            numdiscompterrnume,
            numart18compterrnomi,
            numart18compterrnume,
            numdisesonnomi,
            numdisesonnume,
            strnote,
            cdnutins,
            dtmins,
            cdnutmod,
            dtmmod,
            numassconvsare,
            datcompterritoriale,
            codcomunicazione,
            codcomunicazioneorig,
              --battistoni
            numdisbattistoni,
            numbattistoniinforza,
            numart18battistoni,
            -- conv
            numtotlavconvdis,
            numtotlavconvart18,
            -- scopertura n vedenti
            numscopcentnonvedenti,
            numscopmassofisioterapisti,
            numcentnonvedentiforza,
            nummassofisioterapistiforza,
            numcentnonvedentiobbligo,
            nummassofisioterapistiobbligo,
            flg15dipendenti,
            NUMPERCGRADUALITA,
			CODMONOSTATOSOSP,
			CODMONOCAUSALESOSP,
			NUMLAVORATORISOSP,
			FLGSOSPENSIONEMOB,
			numbasecomputoart3, numbasecomputoart18, numbasecomputoart3prov, numbasecomputoart18prov,
			flgcapogruppo, strcfazcapogruppo, flgcompetenza, flgcapogruppoestera, datrifq3,
			datFineSospMBNazionale,
			NUMTELELAVFT, NUMSOMMFT, NUMCONV12BIS14FT, 
			FLGESONEROAUTOCERT, DATESONEROAUTOCERT, NUMLAV60XMILLE, NUMPERCESONEROAUTOCERT, NUMLAVESONEROAUTOCERT
            )
          select
            newprgprospetto,
            pro.prgazienda,
            pro.prgunita,
            pro.prgazreferente,
            case 
                when pro.numoreccnl = 0 then 40
                   else pro.numoreccnl
			end as numoreccnl,
            p_codprovincia,
            'A',
            'M',
            p_numannorifprospetto,
            null,
            pro.datrifinforza,
            p_dataProspetto,
            pro.numdipendentinazionale,
            pro.codmonocategoria,
            pro.numdipendentitot,
            pro.numbasecomputo,
            pro.numquotadisabili,
            pro.numdisabilinom,
            pro.numdisabilinum,
            pro.numquotaart18,
            pro.numart18nom,
            pro.numart18num,
            pro.datprimaassunzione,
            pro.datsecondaassunzione,
            pro.numdisforza,
            pro.numdisforzarifnomi,
            pro.numdisforzanomi,
            pro.numdisforzarifnume,
            pro.numdisforzanume,
            pro.numart18forza,
            pro.numart18forzarifnomi,
            pro.numart18forzanomi,
            pro.numart18forzarifnume,
            pro.numart18forzanume,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            pro.numconvenzioni,
            pro.numlavoratoriconv,
            pro.numdisconvnume,
            pro.numdisconvnomi,
            pro.numart18convnume,
            pro.numart18convnomi,
            pro.numdiscompterrnomi,
            pro.numdiscompterrnume,
            pro.numart18compterrnomi,
            pro.numart18compterrnume,
            pro.numdisesonnomi,
            pro.numdisesonnume,
            pro.strnote,
            p_cdnutente,
            sysdate,
            p_cdnutente,
            sysdate,
            pro.numassconvsare,
            pro.datcompterritoriale,
            null,
            pro.codcomunicazione,
              --battistoni
            pro.numdisbattistoni,
            pro.numbattistoniinforza,
            pro.numart18battistoni,
            -- conv
            pro.numtotlavconvdis,
            pro.numtotlavconvart18,
            -- scopertura n vedenti
            pro.numscopcentnonvedenti,
            pro.numscopmassofisioterapisti,
            pro.numcentnonvedentiforza,
            pro.nummassofisioterapistiforza,
            pro.numcentnonvedentiobbligo,
            pro.nummassofisioterapistiobbligo,
            pro.flg15dipendenti,
            pro.NUMPERCGRADUALITA,
			pro.CODMONOSTATOSOSP,
			pro.CODMONOCAUSALESOSP,
			pro.NUMLAVORATORISOSP,
			pro.FLGSOSPENSIONEMOB,
			pro.numbasecomputoart3, pro.numbasecomputoart18, pro.numbasecomputoart3prov, pro.numbasecomputoart18prov,
			pro.flgcapogruppo, pro.strcfazcapogruppo, pro.flgcompetenza, pro.flgcapogruppoestera, pro.datrifq3,
			pro.datFineSospMBNazionale,
			pro.NUMTELELAVFT, pro.NUMSOMMFT, pro.NUMCONV12BIS14FT, 
			pro.FLGESONEROAUTOCERT, pro.DATESONEROAUTOCERT, pro.NUMLAV60XMILLE, pro.NUMPERCESONEROAUTOCERT, pro.NUMLAVESONEROAUTOCERT
          from cm_prospetto_inf pro
          where pro.prgprospettoinf = p_prgProspettoInf;

      end if;

      checkProsp := pg_gestamm.insertdocumento(parprgdoc => parprgdoc,
                    parcodcpi => p_codCpi,
                    parcdnlav => '',
                    parprgazienda => p_prgAzienda,
                    parprgunita => p_prgUnita,
                    parcodtipodoc => 'PINF',
                    parflgautocertif => '',
                    parstrdesc => 'Prospetto informativo ' || p_numAnnoRifProspetto,
                    parflgdocamm => '',
                    parflgdocidentifp => '',
                    pardatainizio => to_char(p_datInizioVal, 'dd/mm/yyyy'),
                    parstrnumdoc => '',
                    parenterilascio => '',
                    parcodmonoio => 'I',
                    pardataacqril => to_char(sysdate, 'dd/mm/yyyy'),
                    parcodmodalitaacqri => '',
                    parcodtipofile => '',
                    parstrnomedoc => '',
                    pardatafine => '',
                    parnumannoprot => '',
                    parnumprot => '',
                    parstrnote => '',
                    parcdnutins => p_cdnutente,
                    parcdnutmod => p_cdnutente,
                    pardataprotocollazione => '',
                    parcodstatoatto => 'NP',
                    parprgdocblob => parprgdocblob,
                    parpagina => 'CMProspRiepilogoPage',
                    parprgdoccoll => parprgdoccoll,
                    parstrchiavetabella => newprgprospetto);

	  if (checkProsp <> 0) then
		raise_application_error (-70000, 'Errore nella protocollazione del documento');
	  end if;

	  insert into cm_esclusione_prospetto
      (prgprospettoinf,
      numdirigenti,
      numcigs,
      numapprendisti,
      numcfl,
      numparttime,
      numtdmeno9mesi,
      numtemporaneo,
      numreinserimento,
      numdomicilio,
      numsoci,
      numdisabili,
      numprotette,
      numaltri,
      NUMLAVACQUISITI,
      NUMPERSONALENONAMM_C3,
      NUMPERSONALENONAMM_C4,
      NUMPERSONALEVIAGGIANTE,
      NUMLSUSTABILI,
      NUMLAVORATORIOPESTERO,
      NUMLAVORATORIEDILIZIA,
      NUMLAVEMERSINERO,
      NUMINTERMITTENTI,
	  NUMTDMENO6MESI, NUMSOMMINISTR, NUMSOTTOSUOLO,
	  NUMIMPIANTIFUNE,
	  NUMSETTOREAUTOTRASP,
	  NUMMONTAGGI,
	  NUMCONTRINSERIMENTO,
	  NUMINAIL60X1000)
      select
      newprgprospetto,
      escl.numdirigenti,
      escl.numcigs,
      escl.numapprendisti,
      escl.numcfl,
      escl.numparttime,
      escl.numtdmeno9mesi,
      0, --numTemporaneo viene settato a zero e non si considera nel calcolo esclusioni
      escl.numreinserimento,
      escl.numdomicilio,
      escl.numsoci,
      escl.numdisabili,
      escl.numprotette,
      escl.numaltri,
      escl.NUMLAVACQUISITI,
      escl.NUMPERSONALENONAMM_C3,
      escl.NUMPERSONALENONAMM_C4,
      escl.NUMPERSONALEVIAGGIANTE,
      escl.NUMLSUSTABILI,
      escl.NUMLAVORATORIOPESTERO,
      escl.NUMLAVORATORIEDILIZIA,
      escl.NUMLAVEMERSINERO,
      escl.NUMINTERMITTENTI,
	  escl.NUMTDMENO6MESI, escl.NUMSOMMINISTR, escl.NUMSOTTOSUOLO,
	  escl.NUMIMPIANTIFUNE,
	  escl.NUMSETTOREAUTOTRASP,
	  escl.NUMMONTAGGI,
	  escl.NUMCONTRINSERIMENTO,
	  escl.NUMINAIL60X1000
      from cm_esclusione_prospetto escl
      where escl.prgprospettoinf = p_prgprospettoinf;

      insert into cm_parttime_prospetto
      (prgparttimeprospetto,
      prgprospettoinf,
      numlavoratori,
      decorelavorate,
      decoretotali)
      select
      s_cm_parttime_prospetto.nextval,
      newprgprospetto,
      numlavoratori,
      decorelavorate,
      decoretotali
      from cm_parttime_prospetto pp
      where pp.prgprospettoinf = p_prgprospettoinf;
      
      insert into cm_intermittenti_prospetto
      (PRGINTERMITTENTI,
      PRGPROSPETTOINF,
      NUMLAVORATORI,
      DECORESETTCONTRATTO,
      DECORESETTLAVORATE,
      CDNUTINS,
      DTMINS,
      CDNUTMOD,
      DTMMOD)
      select
      s_cm_intermittenti_prospetto.nextval,
      newprgprospetto,
      interm.NUMLAVORATORI,
      interm.DECORESETTCONTRATTO,
      interm.DECORESETTLAVORATE,
      interm.CDNUTINS,
      SYSDATE,
      interm.CDNUTMOD,
      SYSDATE
      from cm_intermittenti_prospetto interm
      where interm.prgprospettoinf = p_prgprospettoinf;
      
      insert into cm_assunz_pb_selezione
      (PRGASSPUBSELEZIONE,
      PRGPROSPETTOINF,
      CODREGIONE,
      NUMSALDODISABILI,
      NUMSALDOEXART18,
      CDNUTINS,
      DTMINS,
      CDNUTMOD,
      DTMMOD, STRNOTE)
      select
      s_cm_assunz_pb_selezione.nextval,
      newprgprospetto,
      pb.CODREGIONE,
      pb.NUMSALDODISABILI,
      pb.NUMSALDOEXART18,
      pb.CDNUTINS,
      SYSDATE,
      pb.CDNUTMOD,
      SYSDATE, pb.STRNOTE
      from cm_assunz_pb_selezione pb
      where pb.prgprospettoinf = p_prgprospettoinf;
	  
	  insert into pi_dett_pt_disabile
      (prgdettptdisabile, prgprospettoinf, codtipoptdisabile,
	   numlavoratori, decorariosettsvolto, decorariosettcontrattuale, flgoltre50, deccopertura)
      select
      s_pi_dett_pt_disabile.nextval, newprgprospetto, dett.codtipoptdisabile,
	   dett.numlavoratori, dett.decorariosettsvolto, dett.decorariosettcontrattuale, dett.flgoltre50, dett.deccopertura
      from pi_dett_pt_disabile dett 
      where dett.prgprospettoinf = p_prgprospettoinf;


      -- solamente se fa riferimento ad una provincia interna
      -- bisogna inserire i lavoratori L68, posti disponibili e compensazioni
      if (checkProviniciaInterna = 1) then

        insert into cm_pi_lav_riserva
        (prglavriserva,
        prgprospettoinf,
        cdnlavoratore,
        strcodicefiscalelav,
        strcognomelav,
        strnomelav,
        codmonocategoria,
        codmonotipo,
        codmansione,
        datiniziorapp,
        datfinerapp,
        codcontratto,
        decorelavorate,
        decoretotali,
        flgconvenzione,
        strnote,
        deccopertura,
        cdnutins,
        dtmins,
        cdnutmod,
        dtmmod,
        FLGBATTISTONI,
        flgdisplim, numpercdisabilita, codassprotetta
        )
        select
        s_cm_pi_lav_riserva.nextval,
        newprgprospetto,
        plr.cdnlavoratore,
        plr.strcodicefiscalelav,
        plr.strcognomelav,
        plr.strnomelav,
        plr.codmonocategoria,
        plr.codmonotipo,
        plr.codmansione,
        plr.datiniziorapp,
        plr.datfinerapp,
        plr.codcontratto,
        plr.decorelavorate,
        plr.decoretotali,
        plr.flgconvenzione,
        plr.strnote,
        plr.deccopertura,
        p_cdnutente,
        sysdate,
        p_cdnutente,
        sysdate,
        plr.flgbattistoni,
        plr.flgdisplim, plr.numpercdisabilita, plr.codassprotetta
        from cm_pi_lav_riserva plr
        where plr.prgprospettoinf = p_prgprospettoinf;

		insert into cm_pi_mansione_disp
        (prgmansionidisp,
        prgprospettoinf,
        codmansione,
        numposti,
        codmonocategoria,
        strnote,
        cdnutins,
        dtmins,
        cdnutmod,
        dtmmod,
        codcomdisp,
        codmonotipo)
        select
        s_cm_pi_mansione_disp.nextval,
        newprgprospetto,
        pmd.codmansione,
        pmd.numposti,
        pmd.codmonocategoria,
        pmd.strnote,
        p_cdnutente,
        sysdate,
        p_cdnutente,
        sysdate,
        pmd.codcomdisp,
        pmd.codmonotipo
        from cm_pi_mansione_disp pmd
        where pmd.prgprospettoinf = p_prgprospettoinf;

        insert into cm_pi_compensazione
        (prgcompensaz,
        prgprospettoinf,
        codprovincia,
        strsede,
        codmonoeccdiff,
        codmonocategoria,
        NUMINTERESSATI, strcfazcapogruppo)
        select
        s_cm_pi_compensazione.nextval,
        newprgprospetto,
        pc.codprovincia,
        pc.strsede,
        pc.codmonoeccdiff,
        pc.codmonocategoria,
        pc.numinteressati, pc.strcfazcapogruppo
        from cm_pi_compensazione pc
        where pc.prgprospettoinf = p_prgprospettoinf;

		-- ale 28/02
        p_dataInizioAnnoProspettoStr := '01/01/'||to_char(p_numAnnoRifProspetto);       
        
        
		--ricuperare i dati (già ci sono)
		select prosp.prgazienda, prosp.prgunita
                      into p_prgAzienda, p_prgunita
               FROM CM_PROSPETTO_INF prosp
               inner join an_azienda az on az.prgazienda = prosp.prgazienda
               inner join an_unita_azienda uaz on uaz.prgazienda = prosp.prgazienda and uaz.prgunita = prosp.prgunita
               --inner join de_comune dc on dc.codcom = uaz.codcom
               --inner join de_provincia dp on dp.codprovincia = dc.codprovincia
               WHERE prosp.prgprospettoinf = p_prgprospettoInf;
			   
			   
			   
		if (flgpoloreg = 'N') then
			DECLARE
               CURSOR movimentiDispCursor IS
					SELECT prgmovimento
                        FROM am_movimento am,
                        an_azienda an,
                        an_unita_azienda,
                        de_contratto dc,
                        de_comune co
                        WHERE am.prgazienda = an.prgazienda
                        AND am.prgunita = an_unita_azienda.prgunita
                        AND an.prgazienda = an_unita_azienda.prgazienda
                        AND an_unita_azienda.codcom = co.codcom
                        AND am.codcontratto = dc.codcontratto
                        AND NVL (dc.flgtirocini, 'N') != 'S'
                        AND am.codstatoatto = 'PR'
                        AND (flginterasspropria = 'S' OR an.codtipoazienda <> 'INT')
                        AND ( am.flglegge68= 'S' or am.codtipoass = 'NOH' or am.codtipoass = 'NU2' or
                        decode(pg_anagrafica_professionale_rp.GetCategoriaDaNullaOstaForRp(am.cdnlavoratore,am.prgazienda,am.datiniziomov,30), null, 'N', 'S') = 'S' or
                        pg_anagrafica_professionale_rp.ExistsDatInizioComputoForRp(am.prgmovimento) = 'true' )
                        and an.prgazienda = p_prgAzienda
                        --and an_unita_azienda.prgunita = p_prgunita
                        and co.codprovincia = codprovinciasil                      
                        --and trunc(am.dtmins) between 
                        and trunc(am.datiniziomov) between                        
                        to_date(p_dataInizioAnnoProspettoStr, 'dd/mm/yyyy')                        
                        and trunc(sysdate);

			BEGIN
				OPEN movimentiDispCursor;
				LOOP
					FETCH movimentiDispCursor INTO p_prgMovimento;
					EXIT WHEN movimentiDispCursor%NOTFOUND;

					-- recupero il prg del movimento di avviamento
					prgMovAvv := pg_coll_mirato_2.recupera_prgmov_avv_in_l68(p_prgMovimento);

					if (prgMovAvv is not null) then
					  -- aggiorno il prospetto
						checkNumber := pg_coll_mirato.AggLavMovDispNew(prgMovAvv, newprgprospetto, p_cdnutente, p_key, p_errCode);


						if (checkNumber = -1) then
							   insert into cm_scarto_lav68
									(PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
									values
									((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, newprgprospetto, 'errore batch aggiorna prospetto da movimento: ' || p_errCode, 'ERRSTM');
						end if;
					else

						insert into cm_scarto_lav68
						(PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
						values
						((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, p_prgprospettoInf, 'errore batch aggiorna prospetto da movimento, avviamneto non trovato', 'ERRSTM');
					end if;
				END LOOP;
				CLOSE movimentiDispCursor;
            END;
		else
			DECLARE
               CURSOR movimentiDispCursor IS
					SELECT prgmovimento
                        FROM am_movimento am,
                        an_azienda an,
                        an_unita_azienda,
                        de_contratto dc,
                        de_comune co
                        WHERE am.prgazienda = an.prgazienda
                        AND am.prgunita = an_unita_azienda.prgunita
                        AND an.prgazienda = an_unita_azienda.prgazienda
                        AND an_unita_azienda.codcom = co.codcom
                        AND am.codcontratto = dc.codcontratto
                        AND NVL (dc.flgtirocini, 'N') != 'S'
                        AND am.codstatoatto = 'PR'
                        AND (flginterasspropria = 'S' OR an.codtipoazienda <> 'INT')
                        AND ( am.flglegge68= 'S' or am.codtipoass = 'NOH' or am.codtipoass = 'NU2' or
                        decode(pg_anagrafica_professionale_rp.GetCategoriaDaNullaOstaForRp(am.cdnlavoratore,am.prgazienda,am.datiniziomov,30), null, 'N', 'S') = 'S' or
                        pg_anagrafica_professionale_rp.ExistsDatInizioComputoForRp(am.prgmovimento) = 'true' )
                        and an.prgazienda = p_prgAzienda
                        --and an_unita_azienda.prgunita = p_prgunita
                        and co.codprovincia in (select codprovincia from de_provincia where codregione = codregionesil)                      
                        --and trunc(am.dtmins) between 
                        and trunc(am.datiniziomov) between                        
                        to_date(p_dataInizioAnnoProspettoStr, 'dd/mm/yyyy')                        
                        and trunc(sysdate);

			BEGIN
				OPEN movimentiDispCursor;
				LOOP
					FETCH movimentiDispCursor INTO p_prgMovimento;
					EXIT WHEN movimentiDispCursor%NOTFOUND;

					-- recupero il prg del movimento di avviamento
					prgMovAvv := pg_coll_mirato_2.recupera_prgmov_avv_in_l68(p_prgMovimento);

					if (prgMovAvv is not null) then
					  -- aggiorno il prospetto
						checkNumber := pg_coll_mirato.AggLavMovDispNew(prgMovAvv, newprgprospetto, p_cdnutente, p_key, p_errCode);


						if (checkNumber = -1) then
							   insert into cm_scarto_lav68
									(PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
									values
									((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, newprgprospetto, 'errore batch aggiorna prospetto da movimento: ' || p_errCode, 'ERRSTM');
						end if;
					else

						insert into cm_scarto_lav68
						(PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
						values
						((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, p_prgprospettoInf, 'errore batch aggiorna prospetto da movimento, avviamneto non trovato', 'ERRSTM');
					end if;
				END LOOP;
				CLOSE movimentiDispCursor;
            END;
		end if;
	  
      end if; --end if (checkProviniciaInterna = 1) then
      
	  insert into cm_riepilogonazionale 
		(prgprospettoinf,numlavoratoribc,numquotarisdisabili, 
		 numquotariscatprot,numsospensioni, numesoneri, 
		 numdisabiliforza, numcatprotforza, numcatprotdisabiliforza,
		 numscoperturadis,numscoperturacatprot,strnote,
		 numbasecomputoart3, numbasecomputoart18, flgsospensione, numquotaesuberiart18
		 )
	  select 
		 newprgprospetto, numlavoratoribc,numquotarisdisabili, 
		 numquotariscatprot,numsospensioni, numesoneri, 
		 numdisabiliforza, numcatprotforza, numcatprotdisabiliforza,
		 numscoperturadis,numscoperturacatprot,strnote,
		 numbasecomputoart3, numbasecomputoart18, flgsospensione, numquotaesuberiart18
	  from cm_riepilogonazionale
	  where prgprospettoinf = p_prgprospettoinf;
	  
	  insert into cm_riepilogoprovinciale 
		(prgriepilogoprov,numlavoratoribc,numsospensioni,
		 numdisabiliforza,numcatprotforza, numcatprotdisabiliforza,
		 numquotarisdisabili, numquotariscatprot, numesoneri,
		 numscoperturadis, numscoperturacatprot, numcompcatprot,
		 numcompdisabili, prgprospettoinf, codprovincia,
		 codmonoeccdiffdisabili, codmonoeccdiffcatprot,
		 numlavoratoribcart3, numlavoratoribcart18, flgsospensione)
	  select 
		s_cm_riepilogoprovinciale.nextval,numlavoratoribc,numsospensioni,
		 numdisabiliforza,numcatprotforza, numcatprotdisabiliforza,
		 numquotarisdisabili, numquotariscatprot, numesoneri,
		 numscoperturadis, numscoperturacatprot, numcompcatprot,
		 numcompdisabili, newprgprospetto, codprovincia,
		 codmonoeccdiffdisabili, codmonoeccdiffcatprot,
		 numlavoratoribcart3, numlavoratoribcart18, flgsospensione
	  from cm_riepilogoprovinciale
	  where prgprospettoinf = p_prgprospettoinf;
	   
	  -- fine copia del prospetto
      return 0;

  exception
      when others then
         --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return -1;

end GENERACOPIAPROSPETTO;

function AGGIORNAPROSPESONERO(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                              p_prgrichesondisabili  cm_rich_eson_disabili.prgrichesondisabili%type,
                              p_prgrichesonero  cm_rich_esonero.prgrichesonero%type
                             ) RETURN NUMBER is

p_numpercesonero cm_rich_esonero.numpercesonero%type;
p_datfine cm_rich_esonero.datfine%type;
p_datfineesonero cm_prospetto_inf.datfineesonero%type;
checkNum number;

begin

  select re.numpercesonero, re.datfine
  into p_numpercesonero, p_datfine
  from cm_rich_esonero re
  where re.prgrichesonero = p_prgrichesonero;

  select pi.datfineesonero
  into p_datfineesonero
  from cm_prospetto_inf pi
  where pi.prgprospettoinf = p_prgProspettoInf;

  -- viene aggiornato il prospetto solamente se la data fine è diversa da quelle nel prospetto
  update cm_prospetto_inf cpi
  set
  cpi.numpercesonero = p_numpercesonero,
  cpi.datfineesonero = p_datfine,
  cpi.flgesonero = 'S',
  cpi.numkloprospettoinf = cpi.numkloprospettoinf+1
  where cpi.prgprospettoinf = p_prgprospettoinf;

  -- eseguo ricalcolo
  checkNum := pg_coll_mirato_2.ricalcoloriepilogoprosp(p_prgprospettoinf, 'S');

  return checkNum;

  exception
      when others then
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return -1;

end AGGIORNAPROSPESONERO;

FUNCTION RECUPERA_PRGMOV_AVV_IN_L68(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.Prgmovimento%TYPE
IS
 rowMov AM_MOVIMENTO%ROWTYPE;
 prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
BEGIN
 -- Continuo a recuperare il record del movimento precedente finche' non trovo quello con 'AVV' (o non ce l'ho).
 prgMovCiclo := prgMov;
 LOOP

  IF prgMovCiclo IS NULL THEN
     EXIT;
  END IF;

  -- Recupero il record relativo al prgMovimento in ingresso
  SELECT MOV.*
  INTO rowMov
  FROM AM_MOVIMENTO MOV
  WHERE MOV.PRGMOVIMENTO = prgMovCiclo;

  -- Se non trovato, esco dal ciclo
  EXIT WHEN SQL%NOTFOUND;

  -- Se ho trovato il movimento con 'AVV', rendo il record
  IF rowMov.CODTIPOMOV = 'AVV' and rowMov.PRGMOVIMENTOPREC is null
     and (rowMov.FLGLEGGE68 = 'S' or rowMov.codtipoass = 'NOH' or rowMov.codtipoass = 'NU2'
     or pg_anagrafica_professionale_rp.GetCategoriaDaNullaOstaForRp(rowMov.cdnlavoratore,rowMov.prgazienda,rowMov.datiniziomov,30) is not null
     or pg_anagrafica_professionale_rp.ExistsDatInizioComputoForRp(rowMov.prgmovimento) = 'true' )  THEN
   RETURN rowMov.Prgmovimento;
  END IF;

  -- Continuo a ciclare (passo al movimento precedente)
  prgMovCiclo := rowMov.PRGMOVIMENTOPREC;

 END LOOP;

 RETURN NULL;

END RECUPERA_PRGMOV_AVV_IN_L68;


FUNCTION RECUPERA_PRGMOV_AVV(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.Prgmovimento%TYPE
IS
 rowMov AM_MOVIMENTO%ROWTYPE;
 prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
BEGIN
 -- Continuo a recuperare il record del movimento precedente finche' non trovo quello con 'AVV' (o non ce l'ho).
 prgMovCiclo := prgMov;
 LOOP

  IF prgMovCiclo IS NULL THEN
     EXIT;
  END IF;

  -- Recupero il record relativo al prgMovimento in ingresso
  SELECT MOV.*
  INTO rowMov
  FROM AM_MOVIMENTO MOV
  WHERE MOV.PRGMOVIMENTO = prgMovCiclo;

  -- Se non trovato, esco dal ciclo
  EXIT WHEN SQL%NOTFOUND;

  -- Se ho trovato il movimento con 'AVV', rendo il record
  IF rowMov.CODTIPOMOV = 'AVV' and rowMov.PRGMOVIMENTOPREC is null THEN
   RETURN rowMov.Prgmovimento;
  END IF;

  -- Continuo a ciclare (passo al movimento precedente)
  prgMovCiclo := rowMov.PRGMOVIMENTOPREC;

 END LOOP;

 RETURN NULL;

END RECUPERA_PRGMOV_AVV;


function GETPROSPETTOFROMMOVIMENTO(p_prgMovimento am_movimento.prgmovimento%type,
                                   p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                   p_key varchar2,
                                   p_codTipoMov am_movimento.codtipomov%type,
                                   p_prgProspettoOut OUT cm_prospetto_inf.prgprospettoinf%type
                                  ) RETURN NUMBER is

prgMovAvv am_movimento.prgmovimento%type;
p_prgazienda an_azienda.prgazienda%type;
p_prgunita an_unita_azienda.prgunita%type;
p_codprovincia de_provincia.codprovincia%type;
p_datiniziomov varchar2(10);
p_datfinemov varchar2(10);
p_cdnlavoratore am_movimento.cdnlavoratore%type;
codprovinciasil ts_generale.codprovinciasil%type;
codregionesil ts_generale.codregionesil%type;
codregionesedeaz de_provincia.codregione%type;
flgpoloreg ts_generale.flgpoloreg%type;
checkProviniciaInterna number;
checkLavRiserva number;
p_checkMov varchar2(1);
checkNumber number;
errorCode number;
checkProsp number;
p_prgProspetto cm_prospetto_inf.prgprospettoinf%type;

begin
-- valore di default per verificare se c'è un errore
p_prgProspettoOut := 0;
checkNumber := 0;

prgMovAvv := pg_coll_mirato_2.recupera_prgmov_avv_in_l68(p_prgMovimento);

if (prgMovAvv is not null) then

 if (prgMovAvv = p_prgMovimento) then
  checkNumber := pg_coll_mirato_2.aggiorna_ass_in_conv(prgMovAvv,null);
 end if;

 if (prgMovAvv != p_prgMovimento and p_codTipoMov = 'CES') then
  checkNumber := pg_coll_mirato_2.aggiorna_ass_in_conv(prgMovAvv,p_prgMovimento);
 end if;

 if (checkNumber != -5) then

  select m.prgazienda, uaz.prgunita, dp.codprovincia,
  to_char(m.datiniziomov, 'dd/mm/yyyy') as datiniziomov, to_char(m.datfinemov,'dd/mm/yyyy') as datfinemov,
  m.cdnlavoratore
  into p_prgazienda, p_prgunita, p_codprovincia, p_datiniziomov, p_datfinemov, p_cdnlavoratore
  from am_movimento m
  inner join an_azienda az on az.prgazienda = m.prgazienda
  inner join an_unita_azienda uaz on uaz.prgazienda = m.prgazienda and uaz.prgunita = m.prgunita
  inner join de_comune dc on dc.codcom = uaz.codcom
  inner join de_provincia dp on dp.codprovincia = dc.codprovincia
  where m.prgmovimento = p_prgMovimento;

  -- recupero la provinica del sil
  -- per verificare se il prospetto fa riferimento ad una provinica interna o esterna
  SELECT codprovinciasil, codregionesil, nvl(flgpoloreg, 'N') as flgpoloreg
  into codprovinciasil, codregionesil, flgpoloreg
  FROM ts_generale;

  if (flgpoloreg = 'N') then
	  if (codprovinciasil = p_codProvincia) then
	   checkProviniciaInterna := 1;
	  else
	   checkProviniciaInterna := 0;
	  end if;
  else
	  select codregione
	  into codregionesedeaz
	  from de_provincia
	  where codprovincia = p_codprovincia;
	  
	  if (codregionesil = codregionesedeaz) then
	   checkProviniciaInterna := 1;
	  else
	   checkProviniciaInterna := 0;
	  end if;
  end if;

  -- recupero il prospetto
  if (checkProviniciaInterna = 1) then

   SELECT count(PI.PRGPROSPETTOINF) into checkProsp
   FROM CM_PROSPETTO_INF PI
   WHERE
   PI.NUMANNORIFPROSPETTO >= to_char(to_date(p_datiniziomov, 'dd/mm/yyyy'), 'yyyy')
   AND ((p_datfinemov is null) OR (PI.NUMANNORIFPROSPETTO <= to_char(to_date(p_datfinemov, 'dd/mm/yyyy'), 'yyyy')))
   AND PI.CODMONOSTATOPROSPETTO = 'A'
   AND PI.PRGAZIENDA = p_prgazienda
   AND PI.CODPROVINCIA = p_codprovincia
   order by NUMANNORIFPROSPETTO desc;

   if (checkProsp > 0) then
    select x.prgProspettoInf
    into p_prgProspetto
    from (
    SELECT PI.PRGPROSPETTOINF
    FROM CM_PROSPETTO_INF PI
    WHERE
    PI.NUMANNORIFPROSPETTO >= to_char(to_date(p_datiniziomov, 'dd/mm/yyyy'), 'yyyy')
    AND ((p_datfinemov is null)  OR (PI.NUMANNORIFPROSPETTO <= to_char(to_date(p_datfinemov, 'dd/mm/yyyy'), 'yyyy')))
    AND PI.CODMONOSTATOPROSPETTO = 'A'
    AND PI.PRGAZIENDA = p_prgazienda
    AND PI.CODPROVINCIA = p_codprovincia
    order by NUMANNORIFPROSPETTO desc) x
    where rownum = 1;

    if (p_prgProspetto != 0 AND p_prgProspetto is not null) then
     p_prgProspettoOut := p_prgProspetto;

     checkNumber := pg_coll_mirato.agglavmovdispnew(prgMovAvv,
       p_prgProspetto,
       p_cdnUtente,
       p_key,
       errorCode);

    else
     insert into cm_scarto_lav68
     (PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
     values
     ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, p_prgProspetto, 'errore procedura pg_coll_mirato.agglavmovdispnew: ' || errorCode, 'ERRSTM');

     checkNumber := -1;
    end if;
   else
    -- inserisco lo scarto
    insert into cm_scarto_lav68
    (PRGSCARTOLAVL68,prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
    values
    ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, null, 'prospetto non trovato', 'NOPRINF');

    checkNumber := -4;
   end if;
  else
   checkNumber :=  -2;
  end if;
 else
  -- inserisco lo scarto
  insert into cm_scarto_lav68
  (PRGSCARTOLAVL68,prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
  values
  ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, null, 'errore agg. assunzione in convenzione', 'ERRSTM');
 end if;
else
 checkNumber := -3;
end if;

return checkNumber;

exception
 when others then
 errorcode := 'Errore= ' || sqlcode || ' ' || sqlerrm;
 insert into cm_scarto_lav68
 (PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
 values
 ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, p_prgProspetto, 'errore procedura: ' || errorCode, 'ERRSTM');

 return -1;

end GETPROSPETTOFROMMOVIMENTO;



function AGGIORNA_CONV_PROVVEDIMENTO(p_prgrichcomputo cm_rich_computo.prgrichcomputo%type
) RETURN NUMBER is

p_cdnLavoratore an_lavoratore.cdnlavoratore%type;
p_prgAzienda an_azienda.prgazienda%type;
p_motivoComputo de_computo.strdescrizione%type;
p_datiniComputo cm_rich_computo.datinizio%type;


-- check
check_convdettaglio_lav number;
check_convdettaglio_azienda number;

p_prgconvdettaglio cm_conv_dettaglio.prgconvdettaglio%type;
p_codStatoOld varchar2(8);
p_codStatoNew varchar2(8);
checkConv number;
begin

  select h.cdnlavoratore, h.prgazienda, i. strdescrizione , h. datinizio
  into p_cdnLavoratore, p_prgAzienda, p_motivoComputo, p_datiniComputo
  from CM_RICH_COMPUTO h , de_computo i
  where
  h. codmotcomputo = i. codmotcomputo and
  h. prgrichcomputo = p_prgrichcomputo;


-- verifico la convenzione lav
  select count(cd.prgconvdettaglio)
  into check_convdettaglio_lav
  from cm_convenzione c
  inner join cm_conv_dettaglio cd on (cd.prgconv = c.prgconv)
  where c.codstatorichiesta = 'DE'
  and c.prgazienda = p_prgazienda
  and trunc(c.datconvenzione,'yyyy') <= p_datiniComputo
  and (c.datscadenza is null or (trunc(c.datscadenza,'yyyy') >= p_datiniComputo and trunc(c.datscadenza,'yyyy') >= trunc(sysdate,'yyyy')))
  and cd.cdnlavoratore = p_cdnLavoratore
  and cd.codstato = 'PRE';
-- stato previsto


-- verifico la convenzione azienda
  select count(cd.prgconvdettaglio)
  into check_convdettaglio_azienda
  from cm_convenzione c
  inner join cm_conv_dettaglio cd on (cd.prgconv = c.prgconv)
  where c.codstatorichiesta = 'DE'
  and c.prgazienda = p_prgazienda
  and trunc(c.datconvenzione,'yyyy') <= p_datiniComputo
  and (c.datscadenza is null or (trunc(c.datscadenza,'yyyy') >= p_datiniComputo and trunc(c.datscadenza,'yyyy') >= trunc(sysdate,'yyyy')))
 -- and cd.cdnlavoratore = p_cdnLavoratore
  and cd.numlavoratori = 1
  and cd.codstato = 'PRE';
-- stato previsto

  if (check_convdettaglio_lav = 0 and check_convdettaglio_azienda = 0) then
     -- n c'è convenzione
     return -1;
  else
     if (check_convdettaglio_lav > 0 ) then

         -- prendo il num della convezione
         select prgconvdettaglio
         into p_prgconvdettaglio
         from (
         select cd.prgconvdettaglio
         from cm_convenzione c
         inner join cm_conv_dettaglio cd on (cd.prgconv = c.prgconv)
         where c.codstatorichiesta = 'DE'
         and c.prgazienda = p_prgazienda
         and trunc(c.datconvenzione,'yyyy') <= p_datiniComputo
         and (c.datscadenza is null or (trunc(c.datscadenza,'yyyy') >= p_datiniComputo and trunc(c.datscadenza,'yyyy') >= trunc(sysdate,'yyyy')))
         and cd.cdnlavoratore = p_cdnLavoratore
         and cd.codstato = 'PRE')
         where rownum = 1;


         -- faccio update
          update cm_conv_dettaglio
          set codstato = 'AVV'
          where prgconvdettaglio = p_prgconvdettaglio;

          return 1;
          -- Tolta la convenzione con il lav

     else if(check_convdettaglio_azienda > 0 and check_convdettaglio_lav = 0) then

          -- prendo il num della convezione
         select prgconvdettaglio
         into p_prgconvdettaglio
         from (
         select cd.prgconvdettaglio
         from cm_convenzione c
         inner join cm_conv_dettaglio cd on (cd.prgconv = c.prgconv)
         where c.codstatorichiesta = 'DE'
         and c.prgazienda = p_prgazienda
         and trunc(c.datconvenzione,'yyyy') <= p_datiniComputo
         and (c.datscadenza is null or (trunc(c.datscadenza,'yyyy') >= p_datiniComputo and trunc(c.datscadenza,'yyyy') >= trunc(sysdate,'yyyy')))
         and cd.codstato = 'PRE')
         where rownum = 1;


         -- faccio update
          update cm_conv_dettaglio
          set codstato = 'AVV'
          where prgconvdettaglio = p_prgconvdettaglio;

          return 2;
          -- Tolta la convenzione con l'azienda



          end if;
      end if;
  end if;

  exception
      when others then
         return -5;

end aggiorna_conv_provvedimento;


function aggiorna_ass_in_conv(p_prgMovAvv am_movimento.prgmovimento%type,
         p_prgMovCes am_movimento.prgmovimento%type
        ) RETURN NUMBER is

p_cdnLavoratore an_lavoratore.cdnlavoratore%type;
p_prgAzienda an_azienda.prgazienda%type;
p_datinizioavv am_movimento.datiniziomov%type;
p_datinizioces am_movimento.datiniziomov%type;
p_datInizioPerScad am_movimento.datiniziomov%type;
check_convdettaglio number;
p_prgconvdettaglio cm_conv_dettaglio.prgconvdettaglio%type;
p_codStatoOld varchar2(8);
p_codStatoNew varchar2(8);
checkConv number;
begin

  select prgazienda, trunc(datiniziomov, 'yyyy') as datiniziomov, cdnlavoratore
  into p_prgazienda, p_datinizioavv, p_cdnlavoratore
  from am_movimento
  where prgmovimento = p_prgMovAvv;

  if (p_prgMovCes is null) then

     p_codStatoOld := 'PRE';
     p_codStatoNew := 'AVV';
     p_datInizioPerScad := p_datinizioavv;

  else

     select trunc(datiniziomov, 'yyyy') as datiniziomov
     into p_datinizioces
     from am_movimento
     where prgmovimento = p_prgMovCes;

     p_codStatoOld := 'AVV';
     p_codStatoNew := 'CES';
     p_datInizioPerScad := p_datinizioces;

  end if;

  select count(cd.prgconvdettaglio)
  into check_convdettaglio
  from cm_convenzione c
  inner join cm_conv_dettaglio cd on (cd.prgconv = c.prgconv)
  where c.codstatorichiesta = 'DE'
  and c.prgazienda = p_prgazienda
  and trunc(c.datconvenzione,'yyyy') <= p_datinizioavv
  and (c.datscadenza is null or (trunc(c.datscadenza,'yyyy') >= p_datInizioPerScad and trunc(c.datscadenza,'yyyy') >= trunc(sysdate,'yyyy')))
  and cd.cdnlavoratore = p_cdnLavoratore
  and cd.codstato = p_codStatoOld;

  if (check_convdettaglio > 0) then

     select count(cd.prgconvdettaglio) into checkConv
     from cm_convenzione c
     inner join cm_conv_dettaglio cd on (cd.prgconv = c.prgconv)
     where c.codstatorichiesta = 'DE'
     and c.prgazienda = p_prgazienda
     and trunc(c.datconvenzione,'yyyy') <= p_datinizioavv
     and (c.datscadenza is null or (trunc(c.datscadenza,'yyyy') >= p_datInizioPerScad and trunc(c.datscadenza,'yyyy') >= trunc(sysdate,'yyyy')))
     and cd.cdnlavoratore = p_cdnLavoratore
     and cd.codstato = p_codStatoOld;

     if (checkConv > 0) then

         select prgconvdettaglio
         into p_prgconvdettaglio
         from (
         select cd.prgconvdettaglio
         from cm_convenzione c
         inner join cm_conv_dettaglio cd on (cd.prgconv = c.prgconv)
         where c.codstatorichiesta = 'DE'
         and c.prgazienda = p_prgazienda
         and trunc(c.datconvenzione,'yyyy') <= p_datinizioavv
         and (c.datscadenza is null or (trunc(c.datscadenza,'yyyy') >= p_datInizioPerScad and trunc(c.datscadenza,'yyyy') >= trunc(sysdate,'yyyy')))
         and cd.cdnlavoratore = p_cdnLavoratore
         and cd.codstato = p_codStatoOld )
         where rownum = 1;

         update cm_conv_dettaglio
         set codstato = p_codStatoNew
         where prgconvdettaglio = p_prgconvdettaglio;

      end if;
  end if;

  return 0;

  exception
      when others then
         return -5;

end aggiorna_ass_in_conv;

function CMAGGLAVDACOMPUTO(p_prgRichComputo cm_rich_computo.prgrichcomputo%type,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                           p_key varchar2,
                           out_annoProsp OUT cm_prospetto_inf.numannorifprospetto%type
                           ) RETURN NUMBER is

p_prgAzienda cm_rich_computo.prgazienda%type;
p_prgUnita cm_rich_computo.prgUnita%type;
p_prgMovimento cm_rich_computo.prgmovimento%type;
p_datInizio varchar2(10);
codprovinciasil ts_generale.codprovinciasil%type;
codregionesil ts_generale.codregionesil%type;
flgpoloreg ts_generale.flgpoloreg%type;
codregionemovimento de_provincia.codregione%type;

p_prgProspetto cm_prospetto_inf.prgprospettoinf%type;
p_annoProsp cm_prospetto_inf.numannorifprospetto%type;
checkProsp number;
p_datiniziomov varchar2(10);
p_datfinemov varchar2(10);
prgMovAvv am_movimento.prgmovimento%type;

p_prgaziendaMov am_movimento.prgazienda%type;
p_prgunitaMov am_movimento.prgunita%type;
p_codprovincia de_provincia.codprovincia%type;
p_codprovinciacomp cm_rich_computo.codprovincia%type;
p_codprovinciaMov de_provincia.codprovincia%type;
checkProviniciaInterna number;

checkNumber number;
errorcode varchar2(500);
p_errCode NUMBER;


p_configProvv number;
checkConvenzione number;
begin

     out_annoProsp := 0;


     select nvl( (select to_char(ts_config_loc.num) num from ts_config_loc
                   where strcodrif=(select ts_generale.codprovinciasil from ts_generale) and codtipoconfig='CMCOMP') , 0)
           into p_configProvv
      from dual;

     select rc.prgazienda, rc.prgunita, rc.prgmovimento,
            to_char(rc.datinizio, 'dd/mm/yyyy'), dc.codprovincia, rc.codprovincia
     into p_prgAzienda, p_prgUnita, p_prgMovimento, p_datInizio, p_codprovincia, p_codprovinciacomp
     from cm_rich_computo rc
     inner join an_azienda az on az.prgazienda = rc.prgazienda
     inner join an_unita_azienda uaz on uaz.prgazienda = rc.prgazienda and uaz.prgunita = rc.prgunita
     inner join de_comune dc on dc.codcom = uaz.codcom
     inner join de_provincia dp on dp.codprovincia = dc.codprovincia
     where rc.prgrichcomputo = p_prgRichComputo;

     -- recupero la provinica del sil
     -- per verificare se il prospetto fa riferimento ad una provinica interna o esterna
	 SELECT codprovinciasil, codregionesil, nvl(flgpoloreg, 'N') as flgpoloreg
	 into codprovinciasil, codregionesil, flgpoloreg
     FROM ts_generale;
	 
     if (p_prgMovimento is not null) then

         select to_char(m.datiniziomov, 'dd/mm/yyyy') as datiniziomov,
                to_char(pg_anagrafica_professionale_rp.getdatafinemoveffforrp(p_prgMovimento), 'dd/mm/yyyy') as datfinemov,
                az.prgazienda, uaz.prgunita, dp.codprovincia
         into p_datiniziomov, p_datfinemov,
              p_prgaziendaMov, p_prgunitaMov, p_codprovinciaMov
         from am_movimento m
         inner join an_azienda az on az.prgazienda = m.prgazienda
         inner join an_unita_azienda uaz on uaz.prgazienda = m.prgazienda and uaz.prgunita = m.prgunita
         inner join de_comune dc on dc.codcom = uaz.codcom
         inner join de_provincia dp on dp.codprovincia = dc.codprovincia
         where m.prgmovimento = p_prgMovimento;

		 if (flgpoloreg = 'N') then
			 if (codprovinciasil = p_codprovinciaMov) then
				checkProviniciaInterna := 1;
			 else
				checkProviniciaInterna := 0;
			 end if;
		 else
			 select codregione
			 into codregionemovimento
			 from de_provincia
			 where codprovincia = p_codprovinciaMov;
	  
			 if (codregionesil = codregionemovimento) then
				checkProviniciaInterna := 1;
			 else
				checkProviniciaInterna := 0;
			 end if;
		 end if;

         -- recupero il prospetto
         if (checkProviniciaInterna = 1) then

             SELECT count(PI.PRGPROSPETTOINF) into checkProsp
             FROM CM_PROSPETTO_INF PI
             WHERE
             PI.NUMANNORIFPROSPETTO >= to_char(to_date(p_datInizio, 'dd/mm/yyyy'), 'yyyy')
             AND ((p_datfinemov is null) OR (PI.NUMANNORIFPROSPETTO <= to_char(to_date(p_datfinemov, 'dd/mm/yyyy'), 'yyyy')))
             AND PI.CODMONOSTATOPROSPETTO = 'A'
             AND PI.PRGAZIENDA = p_prgazienda
             AND PI.CODPROVINCIA = p_codprovinciaMov
             order by NUMANNORIFPROSPETTO desc;

             if (checkProsp > 0) then
                  select x.prgProspettoInf, x.NUMANNORIFPROSPETTO
                  into p_prgProspetto, p_annoProsp
                  from (
                  SELECT PI.PRGPROSPETTOINF, pi.numannorifprospetto
                  FROM CM_PROSPETTO_INF PI
                  WHERE
                  PI.NUMANNORIFPROSPETTO >= to_char(to_date(p_datInizio, 'dd/mm/yyyy'), 'yyyy')
                  AND ((p_datfinemov is null)  OR (PI.NUMANNORIFPROSPETTO <= to_char(to_date(p_datfinemov, 'dd/mm/yyyy'), 'yyyy')))
                  AND PI.CODMONOSTATOPROSPETTO = 'A'
                  AND PI.PRGAZIENDA = p_prgazienda
                  AND PI.CODPROVINCIA = p_codprovinciaMov
                  order by NUMANNORIFPROSPETTO desc) x
                  where rownum = 1;

                  if (p_prgProspetto != 0 AND p_prgProspetto is not null) then

                         -- verifico che quel computo è presente nella lista dei movimenti disponibili del prospetto
                         prgMovAvv := pg_coll_mirato_2.recupera_prgmov_avv(p_prgMovimento);

                         if (prgMovAvv is not null) then

                               checkNumber := pg_coll_mirato.AggLavMovDispNew(prgMovAvv, p_prgProspetto, p_cdnutente, p_key, p_errCode);


                               if (checkNumber = -1) then

                                   insert into cm_scarto_lav68
                                        (PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
                                        values
                                        ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, p_prgProspetto, 'errore procedura pg_coll_mirato.agglavmovdispnew: ' || p_errCode, 'ERRSTM');
                               else



                                   if(p_configProvv = 1) then

                                        checkConvenzione := pg_coll_mirato_2.AGGIORNA_CONV_PROVVEDIMENTO(p_prgRichComputo);

                                        if( checkConvenzione = 1 or checkConvenzione = 2 )  then
                                              checkNumber := -5;
                                        end if;
                                   end if;


                                   -- messaggio di avvenuto inserimento
                                   out_annoProsp := p_annoProsp;
                               end if;

                         else
                              -- non esiste l'avviamento associato

                              insert into cm_scarto_lav68
                                  (PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
                                  values
                                  ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), 0, sysdate, null, 'avviamento corrispondete non trovato', 'NOMOVAVV');

                              checkNumber :=  -2;

                         end if;

                 end if;
             else
                -- non esiste il prospetto associato

                insert into cm_scarto_lav68
                      (PRGSCARTOLAVL68,prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
                      values
                      ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), 0, sysdate, null, 'prospetto non trovato', 'NOPRINF');

                checkNumber :=  -4;
             end if;
         else
              -- non esiste il prospetto associato
              insert into cm_scarto_lav68
                    (PRGSCARTOLAVL68,prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
                    values
                    ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), 0, sysdate, null, 'provincia prospetto diversa dal movimento', 'NOPRINF');

              checkNumber :=  -4;
         end if;
     else

         -- non esiste il movimento
		 if (flgpoloreg = 'N') then
			 if (codprovinciasil = p_codprovinciacomp) then
				checkProviniciaInterna := 1;
			 else
				checkProviniciaInterna := 0;
			 end if;
		 else
			 select codregione
			 into codregionemovimento
			 from de_provincia
			 where codprovincia = p_codprovinciacomp;
	  
			 if (codregionesil = codregionemovimento) then
				checkProviniciaInterna := 1;
			 else
				checkProviniciaInterna := 0;
			 end if;
		 end if;

         -- recupero il prospetto
         if (checkProviniciaInterna = 1) then
			 
             SELECT count(PI.PRGPROSPETTOINF) into checkProsp
             FROM CM_PROSPETTO_INF PI
             WHERE
             PI.NUMANNORIFPROSPETTO >= to_char(to_date(p_datInizio, 'dd/mm/yyyy'), 'yyyy')
             AND PI.CODMONOSTATOPROSPETTO = 'A'
             AND PI.PRGAZIENDA = p_prgazienda
             AND PI.CODPROVINCIA = p_codprovinciacomp
             order by NUMANNORIFPROSPETTO desc;

             if (checkProsp > 0) then
                  select x.prgProspettoInf, x.NUMANNORIFPROSPETTO
                  into p_prgProspetto, p_annoProsp
                  from (
                  SELECT PI.PRGPROSPETTOINF, pi.numannorifprospetto
                  FROM CM_PROSPETTO_INF PI
                  WHERE
                  PI.NUMANNORIFPROSPETTO >= to_char(to_date(p_datInizio, 'dd/mm/yyyy'), 'yyyy')
                  AND PI.CODMONOSTATOPROSPETTO = 'A'
                  AND PI.PRGAZIENDA = p_prgazienda
                  AND PI.CODPROVINCIA = p_codprovinciacomp
                  order by NUMANNORIFPROSPETTO desc) x
                  where rownum = 1;


                  if (p_prgProspetto != 0 AND p_prgProspetto is not null) then
                     -- inserisco il lavoratore L68 da computo
                     checkNumber := pg_coll_mirato_2.SaveLavDispDaComputo(p_prgRichComputo, p_prgProspetto, p_cdnutente, p_key);
					 
                     if (checkNumber = -1) then

                         insert into cm_scarto_lav68
                              (PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
                              values
                              ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), 0, sysdate, p_prgProspetto, 'errore procedura pg_coll_mirato.SaveLavDispDaComputo', 'ERRSTM');
                     else
                       -- messaggio di avvenuto inserimento

                        if(p_configProvv = 1) then

                            checkConvenzione := pg_coll_mirato_2. AGGIORNA_CONV_PROVVEDIMENTO(p_prgRichComputo);
                            if( checkConvenzione = 1 or checkConvenzione = 2 )  then
                                  checkNumber := -5;
                            end if;
                        end if;

                        out_annoProsp := p_annoProsp;
                     end if;

                  end if;
              else
                  -- non esiste il prospetto associato

                  insert into cm_scarto_lav68
                        (PRGSCARTOLAVL68,prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
                        values
                        ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), 0, sysdate, null, 'prospetto non trovato', 'NOPRINF');

                  checkNumber :=  -4;
              end if;
         else
              -- non esiste il prospetto associato
              insert into cm_scarto_lav68
                    (PRGSCARTOLAVL68,prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
                    values
                    ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), 0, sysdate, null, 'provincia prospetto diversa dal movimento', 'NOPRINF');

              checkNumber :=  -4;
         end if;
     end if;

     return checkNumber;

     exception
     when others then
         -- errore generico
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         errorcode := 'Errore= ' || sqlcode || ' ' || sqlerrm;
         if (p_prgMovimento is null) then
            p_prgMovimento := 0;
         end if;
         insert into cm_scarto_lav68
                 (PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
                 values
                 ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, p_prgProspetto, 'errore procedura CMAGGLAVDACOMPUTO: ' || errorCode, 'ERRSTM');

         return -1;

end CMAGGLAVDACOMPUTO;

function CMAGGPROSPDASOSPENSIONE(p_prgRichSospensione cm_rich_sospensione.prgrichsospensione%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                             out_annoProsp OUT cm_prospetto_inf.numannorifprospetto%type
                               ) RETURN NUMBER is

p_prgAzienda cm_rich_sospensione.prgazienda%type;
codprovinciasil ts_generale.codprovinciasil%type;
codregionesil ts_generale.codregionesil%type;
flgpoloreg ts_generale.flgpoloreg%type;
codprovinciacurr de_provincia.codprovincia%type;
checkTrovatoProspetto boolean := false;

p_prgProspetto cm_prospetto_inf.prgprospettoinf%type;
p_annoProsp cm_prospetto_inf.numannorifprospetto%type;
checkProsp number;
p_datiniziososp varchar2(10);
p_datfinesosp varchar2(10);

checkNumber number;
errorcode varchar2(500);

begin

	out_annoProsp := 0;
	checkNumber :=  0;

	select sosp.prgazienda, to_char(sosp.datiniziososp, 'dd/mm/yyyy'), to_char(sosp.datfinesosp, 'dd/mm/yyyy')
	into p_prgAzienda, p_datiniziososp, p_datfinesosp
	from cm_rich_sospensione sosp
	where sosp.prgrichsospensione = p_prgRichSospensione;

    -- recupero la provincia del sil
    -- per verificare se il prospetto fa riferimento ad una provincia interna o esterna
    SELECT codprovinciasil, codregionesil, nvl(flgpoloreg, 'N') as flgpoloreg
	into codprovinciasil, codregionesil, flgpoloreg
    FROM ts_generale;

    if (flgpoloreg = 'N') then
		
		SELECT count(PI.PRGPROSPETTOINF) into checkProsp
		FROM CM_PROSPETTO_INF PI
		WHERE PI.NUMANNORIFPROSPETTO >= to_char(to_date(p_datiniziososp, 'dd/mm/yyyy'), 'yyyy')
		AND PI.NUMANNORIFPROSPETTO <= to_char(to_date(p_datfinesosp, 'dd/mm/yyyy'), 'yyyy')
		AND PI.CODMONOSTATOPROSPETTO = 'A'
		AND PI.PRGAZIENDA = p_prgazienda
		AND PI.CODPROVINCIA = codprovinciasil
		order by NUMANNORIFPROSPETTO desc;

		if (checkProsp > 0) then

			select x.prgProspettoInf, x.NUMANNORIFPROSPETTO
			into p_prgProspetto, p_annoProsp
			from (
			SELECT PI.PRGPROSPETTOINF, pi.numannorifprospetto
			FROM CM_PROSPETTO_INF PI
			WHERE PI.NUMANNORIFPROSPETTO >= to_char(to_date(p_datiniziososp, 'dd/mm/yyyy'), 'yyyy')
			AND PI.NUMANNORIFPROSPETTO <= to_char(to_date(p_datfinesosp, 'dd/mm/yyyy'), 'yyyy')
			AND PI.CODMONOSTATOPROSPETTO = 'A'
			AND PI.PRGAZIENDA = p_prgazienda
			AND PI.CODPROVINCIA = codprovinciasil
			order by NUMANNORIFPROSPETTO desc) x
			where rownum = 1;

			out_annoProsp := p_annoProsp;

			update cm_prospetto_inf pi
			set pi.flgsospensione = 'S',
			pi.datsospensione = to_date(p_datfinesosp, 'dd/mm/yyyy'),
			numkloprospettoinf = numkloprospettoinf + 1
			where pi.prgprospettoinf = p_prgProspetto;

		else

		   -- non esiste il prospetto associato

			insert into cm_scarto_lav68
			(PRGSCARTOLAVL68,prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
			values
			((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), 0, sysdate, null, 'prospetto non trovato (da sospensione)', 'NOPRINF');

			checkNumber :=  -2;

		end if;
	
	else
		checkTrovatoProspetto := false;
		DECLARE
		  CURSOR provinceReg IS
				SELECT codprovincia
				FROM de_provincia
				WHERE codregione = codregionesil;
		BEGIN
			OPEN provinceReg;
				LOOP
					FETCH provinceReg INTO codprovinciacurr;
					EXIT WHEN provinceReg%NOTFOUND;
				
					SELECT count(PI.PRGPROSPETTOINF) into checkProsp
					FROM CM_PROSPETTO_INF PI
					WHERE PI.NUMANNORIFPROSPETTO >= to_char(to_date(p_datiniziososp, 'dd/mm/yyyy'), 'yyyy')
					AND PI.NUMANNORIFPROSPETTO <= to_char(to_date(p_datfinesosp, 'dd/mm/yyyy'), 'yyyy')
					AND PI.CODMONOSTATOPROSPETTO = 'A'
					AND PI.PRGAZIENDA = p_prgazienda
					AND PI.CODPROVINCIA = codprovinciacurr
					order by NUMANNORIFPROSPETTO desc;

					if (checkProsp > 0) then
					
						checkTrovatoProspetto := true;

						select x.prgProspettoInf, x.NUMANNORIFPROSPETTO
						into p_prgProspetto, p_annoProsp
						from (
						SELECT PI.PRGPROSPETTOINF, pi.numannorifprospetto
						FROM CM_PROSPETTO_INF PI
						WHERE PI.NUMANNORIFPROSPETTO >= to_char(to_date(p_datiniziososp, 'dd/mm/yyyy'), 'yyyy')
						AND PI.NUMANNORIFPROSPETTO <= to_char(to_date(p_datfinesosp, 'dd/mm/yyyy'), 'yyyy')
						AND PI.CODMONOSTATOPROSPETTO = 'A'
						AND PI.PRGAZIENDA = p_prgazienda
						AND PI.CODPROVINCIA = codprovinciacurr
						order by NUMANNORIFPROSPETTO desc) x
						where rownum = 1;

						out_annoProsp := p_annoProsp;

						update cm_prospetto_inf pi
						set pi.flgsospensione = 'S',
						pi.datsospensione = to_date(p_datfinesosp, 'dd/mm/yyyy'),
						numkloprospettoinf = numkloprospettoinf + 1
						where pi.prgprospettoinf = p_prgProspetto;

					end if;

				END LOOP;
			CLOSE provinceReg;
			
			
			 if (not checkTrovatoProspetto) then
				-- non esiste il prospetto associato nel polo sil regionale

				insert into cm_scarto_lav68
				(PRGSCARTOLAVL68,prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
				values
				((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), 0, sysdate, null, 'prospetto polo sil regionale non trovato (da sospensione)', 'NOPRINF');

				checkNumber :=  -2;
			 end if;
			
		END;
	
	end if;

    return checkNumber;

    exception
    when others then
         -- errore generico
         errorcode := 'Errore= ' || sqlcode || ' ' || sqlerrm;
         insert into cm_scarto_lav68
                 (PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
                 values
                 ((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), 0, sysdate, p_prgProspetto, 'errore procedura CMAGGPROSPDASOSPENSIONE: ' || errorCode, 'ERRSTM');

         return -1;

end CMAGGPROSPDASOSPENSIONE;


function SaveLavDispDaComputo(p_prgRichComputo cm_rich_computo.prgrichcomputo%type,
                          p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                          p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                          p_key varchar2
                         ) RETURN NUMBER IS

p_cdnLavoratore cm_rich_computo.cdnlavoratore%type;
p_prgazienda cm_rich_computo.prgazienda%type;
p_prgunita cm_rich_computo.prgunita%type;
p_decoresettimanali cm_rich_computo.decoresettimanali%type;
p_decoretotali cm_rich_computo.decoretotali%type;
p_codmonocategoria cm_rich_computo.codmonocategoria%type;
p_datinizio cm_rich_computo.datinizio%type;
p_categoriaPro cm_prospetto_inf.codmonocategoria%type;
p_deccopertura cm_pi_lav_riserva.deccopertura%type;
p_prglavriserva cm_pi_lav_riserva.prglavriserva%type;
p_strcodicefiscalelav an_lavoratore.strcodicefiscale%type;
p_strcognome an_lavoratore.strcognome%type;
p_strnome an_lavoratore.strnome%type;
checkLavRiserva number;
p_numoreccnl cm_prospetto_inf.numoreccnl%type;
begin

  select cc.cdnlavoratore, cc.prgazienda, cc.prgunita,
         cc.decoresettimanali, cc.decoretotali, cc.codmonocategoria,
         cc.datinizio
    into p_cdnLavoratore, p_prgazienda, p_prgunita,
         p_decoresettimanali, p_decoretotali, p_codmonocategoria,
         p_datinizio
  from cm_rich_computo cc
  where cc.prgrichcomputo = p_prgRichComputo;

  select pro.codmonocategoria, pro.NUMORECCNL
  into p_categoriaPro, p_numoreccnl
  from cm_prospetto_inf pro
  where pro.prgprospettoinf = p_prgProspettoInf;

  if (p_codMonoCategoria is null) then
     p_codMonoCategoria := 'D';
  end if;

  p_deccopertura := null;

  if (p_decoretotali is null) then
      p_deccopertura := 1;
      p_decoresettimanali := p_numoreccnl;
      p_decoretotali := p_numoreccnl;
  else
      if (p_categoriaPro = 'C') then
           p_deccopertura := 1;
           p_decoresettimanali := p_decoretotali;
      else
           if (p_decoretotali != 0) then
              p_deccopertura := round(p_decoresettimanali / p_decoretotali,2);
           end if;
      end if;
  end if;

  if (p_deccopertura > 0.50 AND p_deccopertura < 1) then
    p_deccopertura := round(p_deccopertura);
  end if;

  select l.strcodicefiscale, l.strcognome, l.strnome
  into p_strcodicefiscalelav, p_strcognome, p_strnome
  from an_lavoratore l
  where l.cdnlavoratore = p_cdnLavoratore;

  select count(lr.prglavriserva)
  into checkLavRiserva
  from cm_pi_lav_riserva lr
  inner join cm_prospetto_inf pi on pi.prgprospettoinf = lr.prgprospettoinf
  where lr.strcodicefiscalelav = p_strcodicefiscalelav
  and lr.datiniziorapp = p_datinizio
  and pi.prgprospettoinf = p_prgProspettoInf;


  if (checkLavRiserva = 0) then

   INSERT INTO cm_pi_lav_riserva
   (prglavriserva,
   prgprospettoinf,
   cdnlavoratore,
   strcodicefiscalelav,
   strcognomelav,
   strnomelav,
   codmonocategoria,
   codmonotipo,
   codmansione,
   datiniziorapp,
   flgconvenzione,
   deccopertura,
   decorelavorate,
   decoretotali,
   cdnutins,
   dtmins,
   cdnutmod,
   dtmmod)
   VALUES
   (s_cm_pi_lav_riserva.nextval,
   p_prgProspettoInf,
   p_cdnlavoratore,
   p_strcodicefiscalelav,
   p_strcognome,
   p_strnome,
   p_codmonocategoria,
   'R',
   null,
   p_datinizio,
   'N',
   p_deccopertura,
   p_decoresettimanali,
   p_decoretotali,
   p_cdnutente,
   sysdate,
   p_cdnutente,
   sysdate);

  else

   select lr.prglavriserva
   into p_prgLavRiserva
   from cm_pi_lav_riserva lr
   inner join cm_prospetto_inf pi on pi.prgprospettoinf = lr.prgprospettoinf
   where lr.strcodicefiscalelav = p_strcodicefiscalelav
   and lr.datiniziorapp = p_datinizio
   and pi.prgprospettoinf = p_prgProspettoInf
   and rownum = 1;

   UPDATE cm_pi_lav_riserva
   SET prgprospettoinf = p_prgProspettoInf,
      cdnlavoratore = p_cdnlavoratore,
    strcodicefiscalelav = p_strcodicefiscalelav,
    strcognomelav = p_strcognome,
    strnomelav = p_strnome,
    codmonocategoria = p_codmonocategoria,
    codmonotipo = 'R',
    datiniziorapp = p_datinizio,
    flgconvenzione = 'N',
    deccopertura = p_deccopertura,
    decorelavorate = p_decoresettimanali,
    decoretotali = p_decoretotali,
    cdnutmod = p_cdnutente,
    dtmmod = sysdate,
    numklolavriserva = numklolavriserva + 1
   WHERE prglavriserva = p_prgLavRiserva;

  end if;

  return 0;

  exception
      when others then
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         return -1;

end SaveLavDispDaComputo;


function BATCH_AGGIORNA_PROSPETTI(p_dataBatch varchar2
                                 ) RETURN NUMBER is


p_prgprospettoInf CM_PROSPETTO_INF.Prgprospettoinf%type;
codprovinciasil ts_generale.codprovinciasil%type;
codregionesil ts_generale.codregionesil%type;
flgpoloreg ts_generale.flgpoloreg%type;
retVal number;
p_data varchar2(10);
p_ora number;
begin

  -- DONA 30/06/2010
    -- la data di aggiornamento del prospetto dipende dalla data di lancio del batch
    -- nel caso di batch notturno la data deve essere quella del giorno successivo al lancio
    -- nel caso di batch lanciato manualmente la data è quella di lancio

    p_ora := to_number(to_char(sysdate, 'HH24'));

    if (p_dataBatch is null) then
       if (p_ora > 18) then
          p_data := to_char(sysdate+1, 'dd/mm/yyyy');
       else
           p_data := to_char(sysdate, 'dd/mm/yyyy');
       end if;
    else
       if (trunc(sysdate) >= to_date(p_dataBatch, 'dd/mm/yyyy')) then
           if (p_ora > 18) then
              p_data := to_char(sysdate+1, 'dd/mm/yyyy');
           else
               p_data := to_char(sysdate, 'dd/mm/yyyy');
           end if;
       else
          p_data := p_dataBatch;
       end if;
    end if;
	
    SELECT codprovinciasil, codregionesil, nvl(flgpoloreg, 'N') as flgpoloreg
	into codprovinciasil, codregionesil, flgpoloreg
    FROM ts_generale;

	if (flgpoloreg = 'N') then
		DECLARE
			CURSOR prospettiBatch IS
				SELECT PI.PRGPROSPETTOINF
				FROM CM_PROSPETTO_INF PI
				WHERE
				PI.NUMANNORIFPROSPETTO = to_char(to_date(p_data, 'dd/mm/yyyy'), 'yyyy')
				AND PI.CODPROVINCIA = codprovinciasil
				AND PI.CODMONOSTATOPROSPETTO = 'A';
		BEGIN
		OPEN prospettiBatch;
           LOOP
               FETCH prospettiBatch INTO p_prgprospettoInf;
               EXIT WHEN prospettiBatch%NOTFOUND;

               -- salvo la data prospetto dei prospetti da ricalcolare
               update cm_prospetto_inf pi set
                pi.datprospetto = to_date(p_data, 'dd/mm/yyyy'),
                pi.numkloprospettoinf = pi.numkloprospettoinf + 1
                where pi.prgprospettoinf = p_prgprospettoInf;

               -- eseguo il ricalcolo
               retVal := pg_coll_mirato_2.ricalcoloriepilogoprosp(p_prgprospettoInf, 'S');

		END LOOP;
		CLOSE prospettiBatch;
		END;
	  else
		DECLARE
			CURSOR prospettiBatch IS
				SELECT PI.PRGPROSPETTOINF
				FROM CM_PROSPETTO_INF PI
				WHERE
				PI.NUMANNORIFPROSPETTO = to_char(to_date(p_data, 'dd/mm/yyyy'), 'yyyy')
				AND PI.CODPROVINCIA in (select codprovincia from de_provincia where codregione = codregionesil)
				AND PI.CODMONOSTATOPROSPETTO = 'A';
		BEGIN
		OPEN prospettiBatch;
           LOOP
               FETCH prospettiBatch INTO p_prgprospettoInf;
               EXIT WHEN prospettiBatch%NOTFOUND;

               -- salvo la data prospetto dei prospetti da ricalcolare
               update cm_prospetto_inf pi set
                pi.datprospetto = to_date(p_data, 'dd/mm/yyyy'),
                pi.numkloprospettoinf = pi.numkloprospettoinf + 1
                where pi.prgprospettoinf = p_prgprospettoInf;

               -- eseguo il ricalcolo
               retVal := pg_coll_mirato_2.ricalcoloriepilogoprosp(p_prgprospettoInf, 'S');

		END LOOP;
		CLOSE prospettiBatch;
		END;
	end if;
	return 0;

	exception
      when others then
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         return -1;

end BATCH_AGGIORNA_PROSPETTI;

function STORICIZZA_PROSPETTO_SARE(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                                   p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                   ) RETURN NUMBER is

checkNum number;
p_err_percEsonero number;
p_err_percCompensazione number;
p_err_numCompInProv number;
p_err_numCompArt18 number;
p_err_numCompRiduz number;
p_err_numCompensEcc number;
p_err_dataConsegnaProspetto number;
p_err_dataProspetto number;
p_err_dataRiferimento number;
p_err_checkProspStoriciz number;
p_checkScopertura number;
p_checkExistForza number;
p_checkSospensione number;
p_strNote varchar2(1000);
checkError number;

p_strNoteOrig cm_prospetto_inf.strnote%type;
p_numannorifprospetto cm_prospetto_inf.numannorifprospetto%type;
p_prgAzienda cm_prospetto_inf.prgAzienda%type;
p_prgunita cm_prospetto_inf.prgunita%type;
p_annodatprospetto varchar2(4);
p_annosysdate varchar2(4);
p_codprovincia cm_prospetto_inf.codprovincia%type;
p_out_prgprospettoinf cm_prospetto_inf.prgprospettoinf%type;
checkCopia number;
checkProsp number;
parprgdoc number;
parprgdocblob number;
parprgdoccoll number;
p_parcodstatoatto varchar2(2);

p_numprotocollo am_protocollo.numprotocollo%type;
p_numannoprot am_protocollo.numannoprot%type;
p_dataoraprot varchar2(100);
checkProt number;

p_codCpi de_cpi.codcpi%type;
p_datInizioVal cm_prospetto_inf.datconsegnaprospetto%type;
p_esuberi number(10,3);
p_codmonocategoria cm_prospetto_inf.codmonocategoria%type;
p_esuberiTotal number(10,3);
p_quota_obbligo_dovuta number(10,3);
p_data_ins_prospetto cm_prospetto_inf.dtmins%type;
p_cod_mono_stato_prospetto cm_prospetto_inf.codmonostatoprospetto%type;
p_numQuotaArt18 number(10,3);
p_numArt18Forza number(10,3);
p_baseComputoArt18 number;
p_numdipendentitot cm_prospetto_inf.numdipendentitot%type;
p_numMassoFisioTerapisti cm_prospetto_inf.nummassofisioterapistiforza%type;
p_numcentnonvedenti cm_prospetto_inf.NUMCENTNONVEDENTIFORZA%type;
p_disabiliinforza cm_prospetto_inf.NUMQUOTADISABILI%type;
p_gap number;
p_numbattistoniinforza cm_prospetto_inf.numbattistoniinforza%type;
p_numdisbattistoni cm_prospetto_inf.numdisbattistoni%type;
p_numart18battistoni  cm_prospetto_inf.numart18battistoni%type;

begin

  checkNum := pg_coll_mirato_2.verificaprospetto(p_prgProspettoInf,
                                                  p_err_percEsonero,
                                                  p_err_percCompensazione,
                                                  p_err_numCompInProv,
                                                  p_err_numCompArt18,
                                                  p_err_numCompRiduz,
                                                  p_err_numCompensEcc,
                                                  p_err_dataConsegnaProspetto,
                                                  p_err_dataProspetto,
                                                  p_err_dataRiferimento,
                                                  p_err_checkProspStoriciz,
                                                  p_checkScopertura,
                                                  p_checkExistForza,
                                                  p_checkSospensione
                                                  );
	

  select p.strnote, p.numannorifprospetto, to_char(p.datprospetto, 'yyyy'), to_char(sysdate, 'yyyy'),
       p.codprovincia, p.prgazienda, p.prgunita,
     decode(p.DATCONSEGNAPROSPETTO,NULL,trunc(sysdate),p.DATCONSEGNAPROSPETTO) as datInizioVal,
     p.dtmins, p.codmonostatoprospetto, p.numquotaart18, p.numart18forza, NVL(p.NUMDIPENDENTITOT,0) AS NUMDIPENDENTITOT,
     nvl(p.NUMMASSOFISIOTERAPISTIFORZA,0) as NUMMASSOFISIOTERAPISTIFORZA, nvl(p.NUMCENTNONVEDENTIFORZA,0) as NUMCENTNONVEDENTIFORZA,
     NVL(p.NUMQUOTADISABILI,0) AS NUMQUOTADISABILI, nvl(p.NUMBATTISTONIINFORZA,0) as NUMBATTISTONIINFORZA,
     nvl(numbasecomputoart18prov, 0) AS numbasecomputoart18prov, P.CODMONOCATEGORIA
  into p_strNoteOrig, p_numannorifprospetto, p_annodatprospetto, p_annosysdate,
       p_codprovincia, p_prgAzienda, p_prgunita, p_datInizioVal, 
       p_data_ins_prospetto, p_cod_mono_stato_prospetto, p_numQuotaArt18, p_numArt18Forza, p_numdipendentitot,
       p_numMassoFisioTerapisti, p_numcentnonvedenti, p_disabiliinforza, p_numbattistoniinforza,
       p_baseComputoArt18, p_codmonocategoria
  from cm_prospetto_inf p
  where p.prgprospettoinf = p_prgProspettoInf;
  
  
  -- Calcolo esuberi
  if (p_cod_mono_stato_prospetto = 'V' and trunc(p_data_ins_prospetto) >= TO_DATE('01/01/2012', 'DD/MM/YYYY')) then
  	  p_esuberiTotal := 0;
      
      if ( (p_codmonocategoria) = 'A' and (nvl(p_numArt18Forza, 0) > nvl(p_numQuotaArt18, 0)) ) then
      	p_esuberi := nvl(p_numArt18Forza, 0) - nvl(p_numQuotaArt18, 0);
      	
      	p_quota_obbligo_dovuta := (1*p_baseComputoArt18)/100;
      	p_gap := ceil(p_quota_obbligo_dovuta) - p_quota_obbligo_dovuta;
        if (p_gap >= 0.5) then
           p_quota_obbligo_dovuta := floor(p_quota_obbligo_dovuta);
        else
           p_quota_obbligo_dovuta := ceil(p_quota_obbligo_dovuta);
        end if;
      	
        if (p_numbattistoniinforza < p_quota_obbligo_dovuta) then
        	p_esuberiTotal := p_numbattistoniinforza;
        else
        	p_esuberiTotal := p_quota_obbligo_dovuta;
        end if;
        
        
        if (p_esuberiTotal > p_esuberi) then
        	p_esuberiTotal := p_esuberi;
        end if;
      	
      end if;
      
      p_numdisbattistoni := nvl(p_esuberiTotal, 0);
      if (p_numdisbattistoni > 0) then
      	p_numart18battistoni := p_numdisbattistoni * -1;
      else
      	p_numart18battistoni := 0;
      end if;
  
  end if;

  select de.codCpiCapoluogo codCpi
  into p_codCpi
  from ts_generale ts
  inner join de_provincia de on (de.codProvincia = ts.codProvinciaSil);

  p_strNote := '';
  checkError := 0;

  -- errori trattati come errore bloccante
  if (p_err_percEsonero = 1) then
      p_strNote := p_strNote || ' - è stata indicata la presenza di un esonero senza indicare la percentuale ';
      if (checkError = 0) then
         checkError := 1;
      end if;
  end if;

  if (p_err_percCompensazione = 1) then
      p_strNote := p_strNote || ' - è stata indicata la presenza di una compensazione territoriale per la quale non è stato inserito nessun dettaglio ';
      if (checkError = 0) then
         checkError := 1;
      end if;
  end if;

  if (p_err_numCompInProv = 1) then
      p_strNote := p_strNote || ' - autocompensazione territoriale non può essere riferita alla stessa provincia del prospetto ';
      if (checkError = 0) then
         checkError := 1;
      end if;
  end if;

  if (p_err_numCompArt18 = 1) then
      p_strNote := p_strNote || ' - autocompensazione territoriale non può eccedere la quota di riserva art.18 ';
      if (checkError = 0) then
         checkError := 1;
      end if;
  end if;

  if (p_err_numCompRiduz = 1) then
      p_strNote := p_strNote || ' - autocompensazione non può essere in riduzione ';
      if (checkError = 0) then
         checkError := 1;
      end if;
  end if;

  if (p_err_numCompensEcc = 1) then
      p_strNote := p_strNote || ' - autocompensazione territoriale non può eccedere la quota di riserva disabili ';
      if (checkError = 0) then
         checkError := 1;
      end if;
  end if;

  if (p_err_dataConsegnaProspetto = 1) then
      p_strNote := p_strNote || ' - non è stata valorizzata la data consegna prospetto ';
      if (checkError = 0) then
         checkError := 1;
      end if;
  end if;

  if (p_err_dataProspetto = 1) then
      p_strNote := p_strNote || ' - non è stata valorizzata la data prospetto ';
      if (checkError = 0) then
         checkError := 1;
      end if;
  end if;

  if (p_err_dataRiferimento = 1) then
      p_strNote := p_strNote || ' - non è stata valorizzata la data riferimento prospetto ';
      if (checkError = 0) then
         checkError := 1;
      end if;
  end if;

  if (p_err_checkProspStoriciz = 1) then
      p_strNote := p_strNote || ' - esiste già un prospetto storicizzato per azienda, provincia, anno e data prospetto ';
      if (checkError = 0) then
         checkError := 1;
      end if;
  end if;

  if (p_checkScopertura = 1) then
      p_strNote := p_strNote || ' - il prospetto risulta avere una scopertura ';
  end if;

  if (p_checkExistForza = 1) then
      p_strNote := p_strNote || ' - controllare i lavoratori in forza, esistono lavoratori dopo la data prospetto inserita ';
  end if;

  if (p_checkSospensione = 1) then
      p_strNote := p_strNote || ' - azienda risulta in sospensione';
  end if;

  -- DONA 05/02/2008 NUOVA GESTIONE PROSP DA SARE
  -- Viene storicizzato se non vi sono errori e
  -- se il prospetto ha aaaa (anno riferimento/ data riferimento)
  -- uguale ad anno corrente oppure anno corrente +1
  -- viene creata una copia in corso d'anno per anno = aaaa+1 (data riferimento)

  if (checkError = 0) then
    -- viene storicizzato il prospetto
    if (p_cod_mono_stato_prospetto = 'V' and trunc(p_data_ins_prospetto) >= TO_DATE('01/01/2012', 'DD/MM/YYYY')) then
	    update cm_prospetto_inf cpi
	    set  cpi.CODMONOSTATOPROSPETTO = 'S',
	         cpi.strnote = PG_UTILS.TRUNC_DESC_OTTIMIZZATA(p_strNote, 1000, p_strNoteOrig),
	         cpi.CDNUTMOD = p_cdnUtente,
	         cpi.DTMMOD = SYSDATE,
	         cpi.numkloprospettoinf = cpi.numkloprospettoinf+1,
	         cpi.numdisbattistoni = p_numdisbattistoni,
	         cpi.numart18battistoni = p_numart18battistoni
	    where cpi.prgprospettoinf = p_prgprospettoinf;
	else
		update cm_prospetto_inf cpi
	    set  cpi.CODMONOSTATOPROSPETTO = 'S',
	         cpi.strnote = PG_UTILS.TRUNC_DESC_OTTIMIZZATA(p_strNote, 1000, p_strNoteOrig),
	         cpi.CDNUTMOD = p_cdnUtente,
	         cpi.DTMMOD = SYSDATE,
	         cpi.numkloprospettoinf = cpi.numkloprospettoinf+1
	    where cpi.prgprospettoinf = p_prgprospettoinf;
	end if;
  else
    -- viene settato il campo note
    if (p_cod_mono_stato_prospetto = 'V' and trunc(p_data_ins_prospetto) >= TO_DATE('01/01/2012', 'DD/MM/YYYY')) then
	    update cm_prospetto_inf cpi
	    set  cpi.strnote = PG_UTILS.TRUNC_DESC_OTTIMIZZATA(p_strNote, 1000, p_strNoteOrig),
	         cpi.CDNUTMOD = p_cdnUtente,
	         cpi.DTMMOD = SYSDATE,
	         cpi.numkloprospettoinf = cpi.numkloprospettoinf+1,
	         cpi.numdisbattistoni = p_numdisbattistoni,
	         cpi.numart18battistoni = p_numart18battistoni
	    where cpi.prgprospettoinf = p_prgprospettoinf;
	else
		update cm_prospetto_inf cpi
	    set  cpi.strnote = PG_UTILS.TRUNC_DESC_OTTIMIZZATA(p_strNote, 1000, p_strNoteOrig),
	         cpi.CDNUTMOD = p_cdnUtente,
	         cpi.DTMMOD = SYSDATE,
	         cpi.numkloprospettoinf = cpi.numkloprospettoinf+1
	    where cpi.prgprospettoinf = p_prgprospettoinf;
	end if;
  end if;

/*
  -- protocollazione prospetto
  select(am_protocollo.numprotocollo + 1) numprotocollo,
  am_protocollo.numannoprot,
  TO_CHAR (SYSDATE, 'dd/mm/yyyy hh24:mi') AS dataoraprot
  into p_numprotocollo, p_numannoprot, p_dataoraprot
  from am_protocollo
  where numannoprot = to_char(sysdate,'yyyy')
  for update;

  checkProt := pg_gestamm.insertdocumento(parprgdoc => parprgdoc,
              parcodcpi => p_codCpi,
              parcdnlav => '',
              parprgazienda => p_prgAzienda,
              parprgunita => p_prgunita,
              parcodtipodoc => 'PINF',
              parflgautocertif => '',
              parstrdesc => 'Prospetto informativo ' || p_numAnnoRifProspetto,
              parflgdocamm => '',
              parflgdocidentifp => '',
              pardatainizio => to_char(p_datInizioVal, 'dd/mm/yyyy'),
              parstrnumdoc => '',
              parenterilascio => '',
              parcodmonoio => 'I',
              pardataacqril => to_char(sysdate, 'dd/mm/yyyy'),
              parcodmodalitaacqri => '',
              parcodtipofile => '',
              parstrnomedoc => '',
              pardatafine => '',
              parnumannoprot => p_numannoprot,
              parnumprot => p_numprotocollo,
              parstrnote => '',
              parcdnutins => p_cdnUtente,
              parcdnutmod => p_cdnUtente,
              pardataprotocollazione => p_dataoraprot,
              parcodstatoatto => 'PR',
              parprgdocblob => parprgdocblob,
              parpagina => 'CMProspRiepilogoPage',
              parprgdoccoll => parprgdoccoll,
              parstrchiavetabella => p_prgprospettoinf);

   if (checkProt = 0) then

      update am_protocollo set
      numprotocollo = p_numprotocollo,
      numkloprotocollo = numkloprotocollo+1
      where numannoprot = to_char(sysdate,'yyyy');
   else
      raise_application_error (-70000, 'Errore nella protocollazione del documento');
   end if;
*/
   return 0;

   exception
      when others then
         return -1;

end STORICIZZA_PROSPETTO_SARE;

function GENERACOPIA_PROSPETTO_SARE(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                                   p_cdnUtente TS_UTENTE.CDNUT%TYPE, 
                                   p_key varchar2
                                   
                                   ) RETURN NUMBER is

p_strNoteOrig cm_prospetto_inf.strnote%type;
p_numannorifprospetto cm_prospetto_inf.numannorifprospetto%type;
p_prgAzienda cm_prospetto_inf.prgAzienda%type;
p_prgunita cm_prospetto_inf.prgunita%type;
p_annodatprospetto varchar2(4);
p_annosysdate varchar2(4);
p_codprovincia cm_prospetto_inf.codprovincia%type;
p_out_prgprospettoinf cm_prospetto_inf.prgprospettoinf%type;
checkCopia number;
checkProsp number;
parprgdoc number;
parprgdocblob number;
parprgdoccoll number;
p_parcodstatoatto varchar2(2);

begin


  select p.strnote, p.numannorifprospetto, to_char(p.datprospetto, 'yyyy'), to_char(sysdate, 'yyyy'),
  p.codprovincia, p.prgazienda, p.prgunita
  into p_strNoteOrig, p_numannorifprospetto, p_annodatprospetto, p_annosysdate,
  p_codprovincia, p_prgAzienda, p_prgunita
  from cm_prospetto_inf p
  where p.prgprospettoinf = p_prgProspettoInf;

  checkCopia := 0;

  -- controllo se creare la copia
  if (p_annodatprospetto is not null) then
     if (to_number(p_annodatprospetto, '9999') = to_number(p_annosysdate, '9999')) then

         checkCopia := GENERACOPIAPROSPETTO(p_prgprospettoinf,
                                            p_codProvincia,
                                            to_number(p_annosysdate, '9999'),
                                            p_cdnUtente,
                                            '0',
                                            p_key,
                                            p_out_prgprospettoinf);

     elsif ((to_number(p_annodatprospetto, '9999')+1) =  to_number(p_annosysdate, '9999')) then

         checkCopia := GENERACOPIAPROSPETTO(p_prgprospettoinf,
                                            p_codProvincia,
                                            to_number(p_annosysdate, '9999'),
                                            p_cdnUtente,
                                            '0',
                                            p_key,
                                            p_out_prgprospettoinf);

     end if;
  end if;

  return checkCopia;

  exception
      when others then
         return -1;

end GENERACOPIA_PROSPETTO_SARE;


function BATCH_AGG_PROSPETTI_DA_MOV(p_dataBatch varchar2,
                                    p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                    p_key varchar2
                                   ) RETURN NUMBER is


p_prgprospettoInf CM_PROSPETTO_INF.Prgprospettoinf%type;
codprovinciasil ts_generale.codprovinciasil%type;
codregionesil ts_generale.codregionesil%type;
flgpoloreg ts_generale.flgpoloreg%type;
retVal number;
checkNumber number;
p_data varchar2(10);
p_ora number;
p_prgAzienda cm_prospetto_inf.prgazienda%type;
p_prgunita cm_prospetto_inf.prgunita%type;
p_prgMovimento am_movimento.prgmovimento%type;
p_errCode number;
prgMovAvv am_movimento.prgmovimento%type;
begin

    -- DONA 30/06/2010
    -- la data di aggiornamento del prospetto dipende dalla data di lancio del batch
    -- nel caso di batch notturno la data deve essere quella del giorno successivo al lancio
    -- nel caso di batch lanciato manualmente la data è quella di lancio

    p_ora := to_number(to_char(sysdate, 'HH24'));

    if (p_dataBatch is null) then
       if (p_ora > 18) then
          p_data := to_char(sysdate+1, 'dd/mm/yyyy');
       else
           p_data := to_char(sysdate, 'dd/mm/yyyy');
       end if;
    else
       if (trunc(sysdate) >= to_date(p_dataBatch, 'dd/mm/yyyy')) then
           if (p_ora > 18) then
              p_data := to_char(sysdate+1, 'dd/mm/yyyy');
           else
               p_data := to_char(sysdate, 'dd/mm/yyyy');
           end if;
       else
          p_data := p_dataBatch;
       end if;
    end if;

    SELECT codprovinciasil, codregionesil, nvl(flgpoloreg, 'N') as flgpoloreg
	into codprovinciasil, codregionesil, flgpoloreg
    FROM ts_generale;
	
	if (flgpoloreg = 'N') then

		DECLARE
		  CURSOR prospettiBatch IS
				SELECT PI.PRGPROSPETTOINF
				FROM CM_PROSPETTO_INF PI
				WHERE
				PI.NUMANNORIFPROSPETTO = to_char(to_date(p_data, 'dd/mm/yyyy'), 'yyyy')
				AND PI.CODPROVINCIA = codprovinciasil
				AND PI.CODMONOSTATOPROSPETTO = 'A';
		BEGIN
		  OPEN prospettiBatch;
			   LOOP
				   FETCH prospettiBatch INTO p_prgprospettoInf;
				   EXIT WHEN prospettiBatch%NOTFOUND;

				   select prosp.prgazienda, prosp.prgunita
						  into p_prgAzienda, p_prgunita
				   FROM CM_PROSPETTO_INF prosp
				   inner join an_azienda az on az.prgazienda = prosp.prgazienda
				   inner join an_unita_azienda uaz on uaz.prgazienda = prosp.prgazienda and uaz.prgunita = prosp.prgunita
				   --inner join de_comune dc on dc.codcom = uaz.codcom
				   --inner join de_provincia dp on dp.codprovincia = dc.codprovincia
				   WHERE prosp.prgprospettoinf = p_prgprospettoInf;

				   -- recupero per ogni prospetti i movimenti disponibili con DTMINS = sysdate
				   DECLARE
				   CURSOR movimentiDispCursor IS
						   SELECT prgmovimento
							FROM am_movimento am,
							an_azienda an,
							an_unita_azienda,
							de_contratto dc,
							de_comune co
							WHERE am.prgazienda = an.prgazienda
							AND am.prgunita = an_unita_azienda.prgunita
							AND an.prgazienda = an_unita_azienda.prgazienda
							AND an_unita_azienda.codcom = co.codcom
							AND am.codcontratto = dc.codcontratto
							AND NVL (dc.flgtirocini, 'N') != 'S'
							AND am.codstatoatto = 'PR'
							AND (flginterasspropria = 'S' OR an.codtipoazienda <> 'INT')
							AND ( am.flglegge68= 'S' or am.codtipoass = 'NOH' or am.codtipoass = 'NU2' or
							decode(pg_anagrafica_professionale_rp.GetCategoriaDaNullaOstaForRp(am.cdnlavoratore,am.prgazienda,am.datiniziomov,30), null, 'N', 'S') = 'S' or
							pg_anagrafica_professionale_rp.ExistsDatInizioComputoForRp(am.prgmovimento) = 'true' )
							and an.prgazienda = p_prgAzienda
							--and an_unita_azienda.prgunita = p_prgunita
							and co.codprovincia = codprovinciasil
							and trunc(am.dtmins) = to_date(p_data, 'dd/mm/yyyy');

				   BEGIN
						OPEN movimentiDispCursor;
						LOOP
							FETCH movimentiDispCursor INTO p_prgMovimento;
							EXIT WHEN movimentiDispCursor%NOTFOUND;

							-- recupero il prg del movimento di avviamento
							prgMovAvv := pg_coll_mirato_2.recupera_prgmov_avv_in_l68(p_prgMovimento);

							if (prgMovAvv is not null) then
							  -- aggiorno il prospetto
								checkNumber := pg_coll_mirato.AggLavMovDispNew(prgMovAvv, p_prgprospettoInf, p_cdnutente, p_key, p_errCode);


								if (checkNumber = -1) then
									   insert into cm_scarto_lav68
											(PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
											values
											((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, p_prgprospettoInf, 'errore batch aggiorna prospetto da movimento: ' || p_errCode, 'ERRSTM');
								end if;
							else

								insert into cm_scarto_lav68
								(PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
								values
								((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, p_prgprospettoInf, 'errore batch aggiorna prospetto da movimento, avviamneto non trovato', 'ERRSTM');
							end if;
						END LOOP;
						CLOSE movimentiDispCursor;
				   END;

				   -- eseguo il ricalcolo del riepilogo
				   retVal := pg_coll_mirato_2.ricalcoloriepilogoprosp(p_prgprospettoInf, 'S');

			   END LOOP;
		  CLOSE prospettiBatch;
		END;
	else
		DECLARE
			CURSOR prospettiBatch IS
				SELECT PI.PRGPROSPETTOINF
				FROM CM_PROSPETTO_INF PI
				WHERE
				PI.NUMANNORIFPROSPETTO = to_char(to_date(p_data, 'dd/mm/yyyy'), 'yyyy')
				AND PI.CODPROVINCIA in (select codprovincia from de_provincia where codregione = codregionesil)
				AND PI.CODMONOSTATOPROSPETTO = 'A';
		BEGIN
		  OPEN prospettiBatch;
			   LOOP
				   FETCH prospettiBatch INTO p_prgprospettoInf;
				   EXIT WHEN prospettiBatch%NOTFOUND;

				   select prosp.prgazienda, prosp.prgunita
						  into p_prgAzienda, p_prgunita
				   FROM CM_PROSPETTO_INF prosp
				   inner join an_azienda az on az.prgazienda = prosp.prgazienda
				   inner join an_unita_azienda uaz on uaz.prgazienda = prosp.prgazienda and uaz.prgunita = prosp.prgunita
				   --inner join de_comune dc on dc.codcom = uaz.codcom
				   --inner join de_provincia dp on dp.codprovincia = dc.codprovincia
				   WHERE prosp.prgprospettoinf = p_prgprospettoInf;

				   -- recupero per ogni prospetti i movimenti disponibili con DTMINS = sysdate
				   DECLARE
				   CURSOR movimentiDispCursor IS
						   SELECT prgmovimento
							FROM am_movimento am,
							an_azienda an,
							an_unita_azienda,
							de_contratto dc,
							de_comune co
							WHERE am.prgazienda = an.prgazienda
							AND am.prgunita = an_unita_azienda.prgunita
							AND an.prgazienda = an_unita_azienda.prgazienda
							AND an_unita_azienda.codcom = co.codcom
							AND am.codcontratto = dc.codcontratto
							AND NVL (dc.flgtirocini, 'N') != 'S'
							AND am.codstatoatto = 'PR'
							AND (flginterasspropria = 'S' OR an.codtipoazienda <> 'INT')
							AND ( am.flglegge68= 'S' or am.codtipoass = 'NOH' or am.codtipoass = 'NU2' or
							decode(pg_anagrafica_professionale_rp.GetCategoriaDaNullaOstaForRp(am.cdnlavoratore,am.prgazienda,am.datiniziomov,30), null, 'N', 'S') = 'S' or
							pg_anagrafica_professionale_rp.ExistsDatInizioComputoForRp(am.prgmovimento) = 'true' )
							and an.prgazienda = p_prgAzienda
							--and an_unita_azienda.prgunita = p_prgunita
							and co.codprovincia in (select codprovincia from de_provincia where codregione = codregionesil)
							and trunc(am.dtmins) = to_date(p_data, 'dd/mm/yyyy');

				   BEGIN
						OPEN movimentiDispCursor;
						LOOP
							FETCH movimentiDispCursor INTO p_prgMovimento;
							EXIT WHEN movimentiDispCursor%NOTFOUND;

							-- recupero il prg del movimento di avviamento
							prgMovAvv := pg_coll_mirato_2.recupera_prgmov_avv_in_l68(p_prgMovimento);

							if (prgMovAvv is not null) then
							  -- aggiorno il prospetto
								checkNumber := pg_coll_mirato.AggLavMovDispNew(prgMovAvv, p_prgprospettoInf, p_cdnutente, p_key, p_errCode);


								if (checkNumber = -1) then
									   insert into cm_scarto_lav68
											(PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
											values
											((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, p_prgprospettoInf, 'errore batch aggiorna prospetto da movimento: ' || p_errCode, 'ERRSTM');
								end if;
							else

								insert into cm_scarto_lav68
								(PRGSCARTOLAVL68, prgmovinmento, dtmscarto, prgprospetto, strerrore, codmotivo)
								values
								((select nvl(max(PRGSCARTOLAVL68),0)+1 from cm_scarto_lav68), p_prgMovimento, sysdate, p_prgprospettoInf, 'errore batch aggiorna prospetto da movimento, avviamneto non trovato', 'ERRSTM');
							end if;
						END LOOP;
						CLOSE movimentiDispCursor;
				   END;

				   -- eseguo il ricalcolo del riepilogo
				   retVal := pg_coll_mirato_2.ricalcoloriepilogoprosp(p_prgprospettoInf, 'S');

			   END LOOP;
		  CLOSE prospettiBatch;
		END;
		
	end if;

   return 0;

   exception
      when others then
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         return -1;

end BATCH_AGG_PROSPETTI_DA_MOV;

function GET_PERC_INVALIDITA_L68(p_prgprospettoInf CM_PROSPETTO_INF.Prgprospettoinf%type,
                                 p_cdnLavoratore an_lavoratore.cdnlavoratore%type,
                                 p_encrypterKey varchar2,
                                 p_checkPercInvalidita OUT varchar2
                                 ) RETURN NUMBER is

p_percInvalidita am_cm_iscr.numpercinvalidita%type;
p_fascia cm_prospetto_inf.codmonocategoria%type;
i number;

CURSOR curIscrCM IS
  select deisc.codmonotiporagg, isc.cdnlavoratore,
         isc.numpercinvalidita, isc.datdatafine,
         isc.datdatainizio
  from am_cm_iscr isc
  inner join de_cm_tipo_iscr deisc on deisc.codcmtipoiscr = isc.codcmtipoiscr
  inner join am_documento_coll coll on isc.PRGCMISCR = coll.STRCHIAVETABELLA
  inner join am_documento doc on coll.PRGDOCUMENTO = doc.PRGDOCUMENTO
  where doc.CODTIPODOCUMENTO = 'L68' and DOC.cdnlavoratore = p_cdnLavoratore
  and doc.CODSTATOATTO = 'PR'
  and isc.cdnlavoratore = encrypt(p_cdnLavoratore, p_encrypterKey)
  order by isc.datanzianita68 desc, deisc.codmonotiporagg desc, isc.datdatafine desc;

begin

   p_checkPercInvalidita := '0';
   i := 0;
   select p.codmonocategoria
   into p_fascia
   from cm_prospetto_inf p
   where p.prgprospettoinf = p_prgprospettoInf;

   if (p_fascia = 'C') then

     FOR iscrCM IN curIscrCM
     LOOP
         -- se ci sono più iscrizioni protocollate
         -- recupero solo la prima
         if (i < 1) then
            p_percInvalidita := iscrCM.numpercinvalidita;

            if (p_percInvalidita > 50) then
               p_checkPercInvalidita := '1';
            end if;
         end if;

         i := i+1;
     END LOOP;

   end if;

   return 0;

   exception
      when others then
         --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         return -1;

end GET_PERC_INVALIDITA_L68;

function AggiornaScoperturaL68
(p_cdnLavoratore varchar, flgdisplim varchar, p_encrypterKey varchar, utenza number)
RETURN NUMBER is


CURSOR c_curLav68 IS
   select * from cm_pi_lav_riserva b
   where b.cdnlavoratore = decrypt(p_cdnLavoratore, p_encrypterKey);

checkCMPART number;
copertura number(10,3);
getPercInvalidita number;
p_checkPercInvalidita number;
retRicalcoloProspetto number;
begin

    checkCMPART := 0;

    FOR rec in c_curLav68 LOOP


            copertura:=0;

             if (flgdisplim = 'S' or rec.flgdisplim = 'S') then
                    checkCMPART := 1;
            end if;

            if (flgdisplim = 'N' or rec.flgdisplim = 'N') then
                    checkCMPART := 0;
            end if;

            getPercInvalidita :=
            pg_coll_mirato_2.GET_PERC_INVALIDITA_L68(rec.prgprospettoinf,
                                 rec.cdnlavoratore,
                                 p_encrypterKey,
                                 p_checkPercInvalidita
                                 );

            if( checkCMPART = 1 or getPercInvalidita = 1) then
                  copertura := 1;
            else
                  copertura := rec.decorelavorate / rec.decoretotali;
                  if(copertura > 0.50) then
                       copertura := 1;
                  end if;
            end if;

           update cm_pi_lav_riserva
              set cm_pi_lav_riserva.deccopertura = copertura,
              cm_pi_lav_riserva.CDNUTMOD = utenza,
              cm_pi_lav_riserva.DTMMOD = SYSDATE,
              cm_pi_lav_riserva.numklolavriserva = cm_pi_lav_riserva.numklolavriserva+1
           where cm_pi_lav_riserva.strcodicefiscalelav = rec.strcodicefiscalelav
                  and cm_pi_lav_riserva.prgprospettoinf = rec.prgprospettoinf ;

           retRicalcoloProspetto := pg_coll_mirato_2.RICALCOLORIEPILOGOPROSP(rec.prgprospettoinf,'S');


        END LOOP;

        return 0;
    exception
      when others then
           dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
           return -1;
end AggiornaScoperturaL68;




end PG_COLL_MIRATO_2;
/



/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_COLL_MIRATO.sql
************************************************************************************** */


create or replace package PG_COLL_MIRATO is

  -- Author  : COTICONE
  -- Created : 01/02/2007 17.34.22
  -- Purpose :

  TYPE typRefCurs IS REF CURSOR;

  function calcoloScopertura(p_prgProspettoInf number,
                             p_flgConvenzione varchar2
                         ) RETURN typRefCurs;

  function checkScopertura(p_prgProspettoInf number,
                           p_flgConvenzione varchar2
                         ) RETURN NUMBER;

  function getScopertura(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                         p_flgConvenzione varchar2
                         ) RETURN varchar2;

  function InsLavMovimentiDisp(p_prgMov Am_Movimento.Prgmovimento%TYPE,
                             p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                             p_key varchar2,
                             p_errCode OUT number
                             ) RETURN NUMBER;

  function InsLavNullaOsta(p_prgNO Cm_Nulla_Osta.Prgnullaosta%type,
                             p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                             p_errCode OUT number
                             ) RETURN NUMBER;

  function GetNumIscrCM(p_codMonoTipoRagg DE_CM_TIPO_ISCR.CODMONOTIPORAGG%TYPE,
        p_cdnLavoratore AM_CM_ISCR.CDNLAVORATORE%TYPE,
        p_codProvincia  TS_CM_NUMERAZIONE.CODPROVINCIAPROV%TYPE
                        ) RETURN NUMBER;

  procedure setCondIscrLavCM(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
  p_cdnUtMod TS_UTENTE.CDNUTMOD%TYPE,
    p_encryptKey varchar2
      );

  function GetNumCMRegolaGenerale(p_codMonoTipoRagg DE_CM_TIPO_ISCR.CODMONOTIPORAGG%TYPE,
                              p_codProvincia  TS_CM_NUMERAZIONE.CODPROVINCIAPROV%TYPE
                      ) RETURN NUMBER;

  function verificaProspetto(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type)
                            RETURN typRefCurs;

  function checkIscrLavCMSoloChiuse(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
        p_datDichiarazione varchar2,
               p_encryptKey varchar2) RETURN varchar2;


  /********************************************************************************************
  * cambia lo stato del prospetto da ii corso a storicizzato                                  *
  * vengono effettuati i seguenti controlli:                                                  *
  * 1) verifica del prospetto                                                                 *
  * 2) obbligatorietà data consegna                                                           *
  * 3) verifica che non esista nessun prospetto storicizzato per l'azienda, anno e provinicia *
  *********************************************************************************************/
  function storicizzaProspetto(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                               p_cdnUtente TS_UTENTE.CDNUT%TYPE
                             ) RETURN NUMBER;

  function generaCopiaProspetto(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                             p_codProvincia cm_prospetto_inf.codprovincia%type,
                             p_numAnnoRifProspetto cm_prospetto_inf.numannorifprospetto%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                             p_out_prgprospettoinf OUT cm_prospetto_inf.prgprospettoinf%type
                             ) RETURN NUMBER;

  function CMcreaRosaNomGrezza(p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,     -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
                              p_codMonoTipoGrad DO_RICHIESTA_AZ.Codmonotipograd%type,
                              p_codEvasione Do_Evasione.Codevasione%type,
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE,      -- utente che effettua l'incrocio
                              p_errCode OUT number,         -- Codice di Errore
                              p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE, -- progressivo dell'incrocio
                              p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE    -- progressivo della rosa
                              ) RETURN NUMBER;

  function CMDeleteAdesioneLavoratore(p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
                                      p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
                                      p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,                  -- progressivo dell'adesione
                                      p_errCode OUT number           -- Codice di Errore
                                      ) RETURN NUMBER;

  function CMInsertAdesioneLavoratore(p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
                                      p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
                                      p_mesiSospensione number,
                                      p_prgSpiContatto Ag_Contatto.Prgspicontatto%TYPE,                 -- operatore selezionato
                                      p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
                                      p_cdnGruppo Ts_Gruppo.Cdngruppo%TYPE,                       -- gruppo a cui fa parte l'utente
                                      encrypterKey varchar2,
                                      p_qualifica varchar2,
                                      p_errCode OUT number           -- Codice di Errore
                                      ) RETURN NUMBER;

  /***************************************************************************************************
  * rende definitive tutte le graduatorie di quel tipo e ricalcola la posizione di ciascun lavoratore*
  ***************************************************************************************************/
  function CMSetGraduatoriaDefinitiva(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                                    p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                                    p_key varchar2)
                                   RETURN NUMBER;

  function CMRiapriGraduatorie(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                             p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                             p_prgRosa Do_Rosa.Prgrosa%TYPE,
                             p_motivo varchar2,
                             cdnutmod varchar2,
                             p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,               -- progressivo dell'incrocio
                             p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE,                        -- progressivo della rosa
                             p_errCode OUT number                                             -- Codice di Errore
                             )
                            RETURN NUMBER;

  function CMGestioneRiapertura(p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa da copiare
                                p_numklorosa Do_Rosa.Numklorosa%TYPE,                             -- Numklorosa della rosa da aggiornare
                                p_prgIncrocio Do_Incrocio.Prgincrocio%TYPE,                       -- progressivo dell'incricio da copiare
                                p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
                                p_prgMotivo AS_MOTIVO_APERTURAGRAD.Prgmotivoaperturagrad%TYPE
                                ) RETURN NUMBER;


  function checkPrgConfigPunteggio(tipoGraduatoria varchar2,
                                 p_strValore ts_config_punteggio.strvalore%TYPE)
                              RETURN NUMBER;

  function calcoloPunteggioLavoratore(p_prgNominativo number,
                                     tipoGraduatoria varchar2,
                                     p_mesianzianita number,
                                     p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                     p_cdnLavEncrypt varchar2,
                                     p_errCode OUT number )
                         RETURN NUMBER;
  function calcoloPunteggioLavoratoreArt1(p_cdnLavoratore do_nominativo.cdnlavoratore%type,
                                     p_prgIscrArt1 cm_iscr_art1.prgiscrart1%type,
                                     p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                     p_numAnnoRedditoCM number,
                                     out_punteggioIniziale OUT number,
                                     out_punteggioAnzianita OUT number,
                                     out_punteggioInvalidita OUT number,
                                     out_punteggioPersoneCarico OUT number,
                                     out_punteggioReddito OUT number,
                                     p_errCode OUT number )
                                     RETURN NUMBER;

  function calcoloPunteggioInvalidita(p_prgTipoIncrocio number,
                          p_cdnlavoratore number,
                          p_cdnLavEncrypt varchar2,
                          p_dataChiamatacm do_richiesta_az.datchiamatacm%type,
                          out_p_codcmtipoiscr OUT am_cm_iscr.codcmtipoiscr%type,
                          out_p_numpercinvalidita OUT am_cm_iscr.numpercinvalidita%type,
                          out_p_datanzianita68 OUT am_cm_iscr.datanzianita68%type)
                          RETURN NUMBER;

  function calcoloPunteggioInvaliditaArt1(p_cdnlavoratore number,
                                        p_prgIscrArt1 cm_iscr_art1.prgiscrart1%type)
                                       RETURN NUMBER;

  function checkNumPuntiPersCarico(tipoGraduatoria varchar2)
                              RETURN NUMBER;

  function calcoloPunteggioPersCarico(p_cdnlavoratore number,
                                      tipoGraduatoria varchar2,
                                      out_p_numPersone OUT do_nominativo.numpersone%type,
                                      out_p_datdichcarico OUT do_nominativo.datdichcarico%type)
                                    RETURN NUMBER;

  function incrementoNumPuntiAnzianita(tipoGraduatoria varchar2)
                              RETURN NUMBER;

  function checkNumPuntiMaxAnzianita(tipoGraduatoria varchar2)
                              RETURN NUMBER;

  function calcoloPunteggioAnzianita(p_cdnlavoratore number,
                                     p_mesiAnzianita number)
                                    RETURN NUMBER;

  function calcoloPunteggioAnzianitaArt1(p_cdnlavoratore number,
                                       p_prgIscrArt1 cm_iscr_art1.prgiscrart1%type)
                                    RETURN NUMBER;

  function checkNumPuntiRedditoMax(tipoGraduatoria varchar2)
                              RETURN NUMBER;

  function checkEuroRedditoOgni(tipoGraduatoria varchar2)
                              RETURN NUMBER;

  function incrementoNumPuntiReddito(tipoGraduatoria varchar2)
                              RETURN NUMBER;

  function incrementoArt1PuntiReddito(tipoGraduatoria varchar2)
                              RETURN NUMBER;

  function checkArt1EuroRedditoOgni(tipoGraduatoria varchar2)
                              RETURN NUMBER;

  function punteggioRedditoGradNumerica(p_cdnlavoratore number,
                                      p_prgTipoIncrocio number,
                                      p_prgRichiestaAz number,
                                      tipoGraduatoria varchar2,
                                      out_p_numReddito OUT do_nominativo.numreddito%type)
                                      RETURN NUMBER;

  function punteggioRedditoGradArt1(p_cdnlavoratore number,
                                  p_prgIscrArt1 number,
                                  p_numAnnoRedditoCM number,
                                  tipoGraduatoria varchar2)
                                  RETURN NUMBER;

  function calcolopunteggiodisocc(tipoGraduatoria varchar2)
                              RETURN NUMBER;

  function CMUpdatePunteggio(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                           p_prgConfigPunteggio Ts_Config_Punteggio.Prgconfigpunteggio%TYPE,
                           p_punteggio number,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE
                           ) RETURN NUMBER;

 function CMCalcolaPosizioneOld(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                            p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                            p_key varchar2)
                             RETURN NUMBER;

  function CMCalcolaPosizione(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                            p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                            p_key varchar2)
                             RETURN NUMBER;

  function CMSalvaApprovazGrad(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                             p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                             p_prgapprovazionegrad as_approvazione_grad.prgapprovazionegrad%TYPE,
                             p_numDetermina varchar2,
                             p_datProtocollazione varchar2,
                             p_datPubblicazione varchar2,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                ) RETURN NUMBER;


  function CMInsertLavArt1(p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
                         p_prgRosa do_rosa.prgrosa%type,
                         p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
                         p_errCode OUT number           -- Codice di Errore
                         ) RETURN NUMBER;

function protocollaImportIscrCM(encrypterKey varchar2
                     ) return number;

function setConfigTabProt(p_encryptKey varchar2) return number;

function calcoloGiorniLavorativi(p_dataInizio varchar2,
                                 p_dataFine varchar2,
                                 p_codCPI number)
                                 return number;

function checkTsConfigLocCalcSituazEson return number;

function getCalcoloSituazioneEsonero(p_prgrichesonero cm_rich_esonero.prgrichesonero%type,
                                     p_dataCalcolo varchar2,
                                     p_out_giorniLavorativi OUT varchar2,
                                     p_out_costoTotale OUT varchar2,
                                     p_out_costoVersato OUT varchar2)
                                     return number;

function checkSituazioneEsonero(p_prgrichesonero cm_rich_esonero.prgrichesonero%type)
                                return number;

function listaCalcoloSituazioneEsonero(p_prgrichesonero cm_rich_esonero.prgrichesonero%type,
                                     p_dataCalcolo varchar2)
                                     return typRefCurs;

function checkHistoryCM(p_cdnLavoratore An_Lavoratore.CDNLAVORATORE%type,
                     encrypterKey varchar2
                     ) return number;

function AggLavMovDispNew(p_prgMov Am_Movimento.Prgmovimento%TYPE,
                          p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                          p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                          p_key varchar2,
                          p_errCode OUT number
                         ) RETURN NUMBER;

function AggLavInConvDaNO(p_prgNullaOsta cm_nulla_osta.prgnullaosta%TYPE) RETURN NUMBER;


function CalcoloPuntPresLavIsc(
                                        p_DataRiferimento varchar2,
                                        p_Anno_Reddito number,
                                        tipoincrocio varchar2,
                                        tipoGraduatoria varchar2,
                                        p_mesianzianita number,
                                        p_cdnLavEncrypt varchar2,
                                             cdnLavoratoreDecrypt varchar2,
                                             prgiscr varchar2,
                                        out_p_numReddito OUT do_nominativo.numreddito%type,
                                        out_p_numPersone OUT do_nominativo.numpersone%type,
                                        out_p_datdichcarico OUT varchar2,
                                        out_p_codcmtipoiscr OUT do_nominativo.codcmtipoiscr%type,
                                        out_p_numpercinvalidita OUT do_nominativo.numpercinvalidita%type,
                                        out_p_datanzianita68 OUT varchar2,
                                        out_p_mesianzianita OUT do_nominativo.nummesianz%type,
                                        out_p_flgpatente OUT do_nominativo.flgpatente%type,
                                        out_p_codgradocapacitaloc OUT do_nominativo.codgradocapacitaloc%type,
                                        out_p_flgdisoccti OUT do_nominativo.flgdisoccti%type,
                                        out_p_codCmAnnota OUT do_nominativo.codcmannota%type,
                                        out_p_punt_iniziale OUT varchar2,
                                        out_p_punt_carico_fam OUT varchar2,
                                        out_p_punt_reddito OUT varchar2,
                                        out_p_punt_anzianita OUT varchar2,
                                        out_p_punt_invalidita OUT varchar2,
                                        out_p_punt_locomozione OUT varchar2,
                                        out_p_punt_patente OUT varchar2,
                                        out_p_punt_totale OUT varchar2,
                                        out_p_persone_carico OUT varchar2



                                        )       RETURN NUMBER;



function calcoloPunteggioPresLavoratore(p_prgNominativo number,
                                        tipoGraduatoria varchar2,
                                        p_mesianzianita number,
                                        p_cdnLavEncrypt varchar2,
                                        out_p_numReddito OUT do_nominativo.numreddito%type,
                                        out_p_numPersone OUT do_nominativo.numpersone%type,
                                        out_p_datdichcarico OUT varchar2,
                                        out_p_codcmtipoiscr OUT do_nominativo.codcmtipoiscr%type,
                                        out_p_numpercinvalidita OUT do_nominativo.numpercinvalidita%type,
                                        out_p_datanzianita68 OUT varchar2,
                                        out_p_mesianzianita OUT do_nominativo.nummesianz%type,
                                        out_p_flgpatente OUT do_nominativo.flgpatente%type,
                                        out_p_codgradocapacitaloc OUT do_nominativo.codgradocapacitaloc%type,
                                        out_p_flgdisoccti OUT do_nominativo.flgdisoccti%type,
                                        out_p_codCmAnnota OUT do_nominativo.codcmannota%type)
                                     RETURN NUMBER;


function CMUpdatePunteggioLavoratore(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                                     p_punteggio number,
                                     p_numReddito do_nominativo.numreddito%type,
                                     p_numPersone do_nominativo.numpersone%type,
                                     p_datdichcarico do_nominativo.datdichcarico%type,
                                     p_codcmtipoiscr do_nominativo.codcmtipoiscr%type,
                                     p_numpercinvalidita do_nominativo.numpercinvalidita%type,
                                     p_datanzianita68 do_nominativo.datanzianita68%type,
                                     p_mesianzianita do_nominativo.nummesianz%type,
                                     p_flagPatente do_nominativo.flgpatente%type,
                                     p_codgradocapacitaloc do_nominativo.codgradocapacitaloc%type,
                                     p_flagdisoccti do_nominativo.flgdisoccti%type,
                                     p_codCmAnnota do_nominativo.codcmannota%type
                                    ) RETURN NUMBER;

function CMUpdatePunteggioPresLav(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                                     p_punteggiopres number
                                    ) RETURN NUMBER;

function checkNumPunteggio(tipoGraduatoria varchar2,
                              flagDescr varchar2)
                              RETURN NUMBER;

function calcoloPunteggioLocomozione(p_cdnlavoratore number,
                                    p_cdnLavEncrypt varchar2,
                                    tipoGraduatoria varchar2,
                                    p_datachiamatacm do_richiesta_az.datchiamatacm%type,
                                    out_p_codgradocapacitaloc OUT do_nominativo.codgradocapacitaloc%type)
                                    RETURN NUMBER;

function calcoloPunteggioPatente(p_cdnlavoratore number,
                                 tipoGraduatoria varchar2,
                                 out_flgPatente OUT do_nominativo.flgpatente%type)
                                RETURN NUMBER;

function CMCreaGraduatoriaAnnuale(p_annoGraduatoria varchar2,
                                  p_dataRifGrad varchar2,
                                  p_annoRifReddito varchar2,
                                  p_codmonotipograd cm_graduatoria.codmonotipograd%type,
                                  p_strnota cm_graduatoria.strnota%type,
                                  encrypeterKey varchar2,
                                  p_cdnUtente TS_UTENTE.CDNUT%TYPE,
								  p_ambitoTerr varchar2,
                                  out_p_prggraduatoria OUT cm_graduatoria.prggraduatoria%type,
                                  p_errCode OUT number )
                                 RETURN NUMBER;

function CMCalcPunteggioGradUmbria(p_prgGraduatoria number,
                                   p_prggradnominativo number,
                                   p_prgcmiscr number,
                                   p_cdnLavoratore number,
                                   p_annoGraduatoria varchar2,
                                   p_dataRifGrad varchar2,
                                   p_annoRifReddito varchar2,
                                   p_codmonotipograd cm_graduatoria.codmonotipograd%type,
                                   encrypeterKey varchar2,
                                   flgRigenera varchar2,
                                   p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                   p_errCode OUT number )
                                   RETURN NUMBER;

procedure CMUpdatePunteggioGradAnnuale(p_prgGradnominativo cm_grad_nominativo.prggradnominativo%type,
                           p_prgConfigPunteggio Ts_Config_Punteggio.Prgconfigpunteggio%TYPE,
                           p_punteggio number,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE
                           );

function calcPuntInvaliditaGradAnnuale(p_codmonotipogradcm cm_graduatoria.codmonotipograd%type,
                                    p_cdnlavoratore number,
                                    p_cdnLavEncrypt varchar2,
                                    p_dataRifGrad varchar2,
                                    out_p_codcmtipoiscr OUT am_cm_iscr.codcmtipoiscr%type,
                                    out_p_numpercinvalidita OUT am_cm_iscr.numpercinvalidita%type,
                                    out_p_datanzianita68 OUT am_cm_iscr.datanzianita68%type)
                                    RETURN NUMBER;

function punteggioRedditoGradUmbria(p_cdnlavoratore number,
                                      p_annoCM cm_graduatoria.numannoreddito%type,
                                      tipoGraduatoria varchar2,
                                      out_p_numReddito OUT do_nominativo.numreddito%type)
                                      RETURN NUMBER;

function CMupdatepuntlavGradAnnuale(p_prgGradnominativo cm_grad_nominativo.prggradnominativo%type,
                                     p_punteggio number,
                                     p_numReddito cm_grad_nominativo.numreddito%type,
                                     p_numPersone cm_grad_nominativo.numpersone%type,
                                     p_datdichcarico cm_grad_nominativo.datdichcarico%type,
                                     p_codcmtipoiscr cm_grad_nominativo.codcmtipoiscr%type,
                                     p_numpercinvalidita cm_grad_nominativo.numpercinvalidita%type,
                                     p_datanzianita68 cm_grad_nominativo.datanzianita68%type,
                                     p_mesianzianita cm_grad_nominativo.nummesianz%type,
                                     p_flagPatente cm_grad_nominativo.flgpatente%type,
                                     p_codgradocapacitaloc cm_grad_nominativo.codgradocapacitaloc%type
                                    ) RETURN NUMBER;

function CMCalcPosizioneGradAnnuale(p_prgGraduatoria cm_graduatoria.prggraduatoria%type,
                                    p_key varchar2)
                                    RETURN NUMBER;

function CMRigeneraGradAnnuale(p_prgGraduatoria number,
                              encrypeterKey varchar2,
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                              out_p_prggraduatoria OUT cm_graduatoria.prggraduatoria%type)
                              RETURN NUMBER;

function CMAnnullaGradAnnuale(p_prgGraduatoria cm_graduatoria.prggraduatoria%type,
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE)
                              RETURN NUMBER;

function calcoloPuntAnzianitaUmbria(p_cdnlavoratore number,
                                    p_dataRifGrad varchar2,
                                    p_cdnLavEncrypt am_cm_iscr.cdnlavoratore%type,
                                    p_prgCMIscr am_cm_iscr.prgcmiscr%type,
                                    out_p_mesianzianita OUT cm_grad_nominativo.nummesianz%type)
                                    RETURN NUMBER;

procedure BatchChiusuraCmSuperamentoEta(p_result OUT Varchar2,
                      p_dataRifEta IN varchar2,
                     p_ut IN TS_UTENTE.CDNUT%TYPE,
                    p_key varchar2);

function calcoloPunteggioAnnota(p_cdnLavEncrypt am_cm_iscr.cdnlavoratore%type,
                                p_dataChiamatacm do_richiesta_az.datchiamatacm%type,
                                 tipoGraduatoria varchar2,
                                 out_codCmAnnota OUT do_nominativo.codcmannota%type)
                                RETURN NUMBER;
                                
function InsertCmGradNominativo(p_newprggraduatoria cm_graduatoria.prggraduatoria%type,
                                p_cdnLavoratore an_lavoratore.cdnlavoratore%type, 
                                p_codCpi an_lav_storia_inf.codcpitit%type, 
                                p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                ) RETURN NUMBER;

function DeleteCmGradNominativo(p_newprggraduatoria cm_graduatoria.prggraduatoria%type) RETURN NUMBER;                                                                

end PG_COLL_MIRATO;
/
create or replace package body PG_COLL_MIRATO is

function calcoloScopertura(p_prgProspettoInf number,
                           p_flgConvenzione varchar2
                         ) RETURN typRefCurs is
CURSOR curProspetto IS
         select p.prgprospettoinf, p.prgazienda, p.prgunita,
              e.numdirigenti, e.numapprendisti, e.numcfl, e.numparttime,
              e.numcigs,
         e.numtdmeno9mesi,
         e.numtemporaneo,
         e.numreinserimento,
         e.numdomicilio,
         e.numsoci,
         e.numdisabili,
         e.numprotette,
         e.numaltri,
         e.NUMLAVACQUISITI,
         e.NUMPERSONALENONAMM_C3,
         e.NUMPERSONALENONAMM_C4,
         e.NUMPERSONALEVIAGGIANTE,
         e.NUMLSUSTABILI,
         e.NUMLAVORATORIOPESTERO,
         e.NUMLAVORATORIEDILIZIA,
         e.NUMLAVEMERSINERO,
         e.NUMINTERMITTENTI,
       p.prgazreferente, p.numoreccnl, p.codprovincia,
       p.codmonostatoprospetto, p.codmonoprov, p.numannorifprospetto,
       to_char(p.datconsegnaprospetto, 'dd/mm/yyyy') as datconsegnaprospetto,
       p.numdipendentinazionale, p.codmonocategoria,
       p.numdipendentitot, p.numbasecomputo, p.numquotadisabili,
       p.numdisabilinom, p.numdisabilinum, p.numquotaart18,
       p.numart18nom, p.numart18num,
       to_char(p.datprimaassunzione, 'dd/mm/yyyy') as datprimaassunzione,
       to_char(p.datsecondaassunzione, 'dd/mm/yyyy') as datsecondaassunzione,
       p.numdisforza, p.numart18forza,
       p.flgesonero, p.numpercesonero, p.flggradualita,
       p.flgcompterritoriale, p.flgsospensione, p.numconvenzioni,
       p.strnote, p.cdnutins, p.dtmins, p.cdnutmod, p.dtmmod, p.numkloprospettoinf
     from cm_prospetto_inf p
          left join cm_esclusione_prospetto e on e.prgprospettoinf = p.prgprospettoinf
     where p.prgprospettoinf = p_prgProspettoInf;

p_numannorifprospetto cm_prospetto_inf.numannorifprospetto%type;
p_codmonocategoria cm_prospetto_inf.codmonocategoria%type;
p_numdirigenti cm_esclusione_prospetto.numdirigenti%type;
p_numapprendisti cm_esclusione_prospetto.numapprendisti%type;
p_numcfl cm_esclusione_prospetto.numcfl%type;
p_numparttime cm_esclusione_prospetto.numparttime%type;
p_numdipendentitot cm_prospetto_inf.numdipendentitot%type;
p_numquotadisabili cm_prospetto_inf.numquotadisabili%type;
p_numdisabilinom cm_prospetto_inf.numdisabilinom%type;
p_numdisabilinum cm_prospetto_inf.numdisabilinum%type;
p_flgEsonero cm_prospetto_inf.flgesonero%type;
p_numpercesonero cm_prospetto_inf.numpercesonero%type;

p_numcigs cm_esclusione_prospetto.numcigs%type;
p_numtdmeno9mesi cm_esclusione_prospetto.numtdmeno9mesi%type;
p_numtemporaneo cm_esclusione_prospetto.numtemporaneo%type;
p_numreinserimento cm_esclusione_prospetto.numreinserimento%type;
p_numdomicilio cm_esclusione_prospetto.numdomicilio%type;
p_numsoci cm_esclusione_prospetto.numsoci%type;
p_numdisabili cm_esclusione_prospetto.numdisabili%type;
p_numprotette cm_esclusione_prospetto.numprotette%type;
p_numaltri cm_esclusione_prospetto.numaltri%type;
p_numlavacquisiti cm_esclusione_prospetto.NUMLAVACQUISITI%type;
p_numpersnonamm_c3 cm_esclusione_prospetto.NUMPERSONALENONAMM_C3%type;
p_numpersnonamm_c4 cm_esclusione_prospetto.NUMPERSONALENONAMM_C4%type;
p_numpersviaggiante cm_esclusione_prospetto.NUMPERSONALEVIAGGIANTE%type;
p_numlsustabili cm_esclusione_prospetto.NUMLSUSTABILI%type;
p_numlavopestero cm_esclusione_prospetto.NUMLAVORATORIOPESTERO%type;
p_numlavedilizia cm_esclusione_prospetto.NUMLAVORATORIEDILIZIA%type;
p_numlavemersinero cm_esclusione_prospetto.NUMLAVEMERSINERO%type;
p_numintermittenti cm_esclusione_prospetto.NUMINTERMITTENTI%type;


p_prgAzienda cm_prospetto_inf.prgazienda%type;
p_prgUnita cm_prospetto_inf.prgunita%type;

p_baseComputo number;
p_sommaEsclusione number;
p_percDisQuotaTotA number;
p_percACQuotaTotA number;
p_numDisEcc number;
p_numDisDiff number;
p_numEsonero number;
p_sumCoperturaDisabili number;
p_sumCoperturaDisNom number;
p_sumCoperturaDisNum number;
p_scoperturaDisabiliTot number;
p_scoperturaDisabiliNom number;
p_scoperturaDisabiliNum number;
p_numQuotaArt18 number;
p_numArt18Ecc number;
p_numArt18Diff number;
p_numQuotaArt18Nom number;
p_numQuotaArt18Num number;
p_sumCoperturaArt18 number;
p_sumCoperturaArt18Nom number;
p_sumCoperturaArt18Num number;
p_scoperturaArt18Tot number;
p_scoperturaArt18Nom number;
p_scoperturaArt18Num number;
p_messaggioDisabili number;
p_messaggioArt18 number;

p_convenzioniAzienda number;

p_numdisabilinomDb number;
p_numdisabilinumDb number;
p_numart18nomDb number;
p_numart18numDb number;

conv_sommaArt18Nom number;
conv_sommaArt18Num number;
conv_sommaDisabiliNom number;
conv_sommaDisabiliNum number;

str varchar(1000);
risultato typRefCurs;
str1 varchar(1000);
begin

  p_messaggioDisabili := 0;
  p_messaggioArt18 := 0;

  FOR rec in curProspetto LOOP
      p_numannorifprospetto := rec.numannorifprospetto;
      p_codmonocategoria := rec.codmonocategoria;
      p_numdirigenti := rec.numdirigenti;
      p_numapprendisti := rec.numapprendisti;
      p_numcfl := rec.numcfl;
      p_numparttime := rec.numparttime;
      p_numdipendentitot := nvl(rec.numdipendentitot,0);
      p_flgEsonero := rec.flgEsonero;
      p_numpercesonero := nvl(rec.numpercesonero,0);

      p_numcigs := nvl(rec.numcigs,0);
   p_numtdmeno9mesi := nvl(rec.numtdmeno9mesi,0);
   p_numtemporaneo := nvl(rec.numtemporaneo,0);
   p_numreinserimento := nvl(rec.numreinserimento,0);
   p_numdomicilio := nvl(rec.numdomicilio,0);
   p_numsoci := nvl(rec.numsoci,0);
   p_numdisabili := nvl(rec.numdisabili,0);
   p_numprotette := nvl(rec.numprotette,0);
   p_numaltri := nvl(rec.numaltri,0);
   p_numlavacquisiti := nvl(rec.NUMLAVACQUISITI,0);
   p_numpersnonamm_c3 := nvl(rec.NUMPERSONALENONAMM_C3,0);
   p_numpersnonamm_c4 := nvl(rec.NUMPERSONALENONAMM_C4,0);
   p_numpersviaggiante := nvl(rec.NUMPERSONALEVIAGGIANTE,0);
   p_numlsustabili := nvl(rec.NUMLSUSTABILI,0);
   p_numlavopestero := nvl(rec.NUMLAVORATORIOPESTERO,0);
   p_numlavedilizia := nvl(rec.NUMLAVORATORIEDILIZIA,0);
   p_numlavemersinero := nvl(rec.NUMLAVEMERSINERO,0);
   p_numintermittenti := nvl(rec.NUMINTERMITTENTI,0);

      p_prgazienda := rec.prgAzienda;
      p_prgunita := rec.prgUnita;
     -- p_numquotadisabili := rec.numquotadisabili;
      p_numdisabilinomDb := rec.numdisabilinom;
      p_numdisabilinumDb := rec.numdisabilinum;
      p_numart18nomDb := rec.numart18nom;
      p_numart18numDb := rec.numart18num;

      --somma delle esclusioni
      p_sommaEsclusione := nvl(p_numdirigenti,0)+nvl(p_numapprendisti,0)+nvl(p_numcfl,0)+nvl(p_numparttime,0) + nvl(p_numcigs,0)
                           + nvl(p_numtdmeno9mesi,0) + nvl(p_numtemporaneo,0) + nvl(p_numreinserimento,0) + nvl(p_numdomicilio,0)
                           + nvl(p_numsoci,0) + nvl(p_numdisabili,0) + nvl(p_numprotette,0) + nvl(p_numaltri,0)
                           + nvl(p_numlavacquisiti,0) + nvl(p_numpersnonamm_c3,0) + nvl(p_numpersnonamm_c4,0) 
                           + nvl(p_numpersviaggiante,0) + nvl(p_numlsustabili,0) + nvl(p_numlavopestero,0)
                           + nvl(p_numlavedilizia,0) + nvl(p_numlavemersinero,0) + nvl(p_numintermittenti,0);
      
      -- calcolo base computo come differenza tra numero dipendenti provinciali e la somma delle esclusioni
      p_baseComputo := p_numdipendentitot - p_sommaEsclusione;
      if (p_baseComputo < 0) then
         p_baseComputo := 0;
      end if;

      --calcolo compensazione disabili in eccedenza
      select sum(nvl(pc.numinteressati, 0)) into p_numDisEcc
      from cm_pi_compensazione pc
      where pc.prgprospettoinf = p_prgProspettoInf
      and pc.codmonoeccdiff = 'E' and pc.codmonocategoria = 'D';

      --calcolo compensazione disabili in diminuzione
      select sum(nvl(pc.numinteressati, 0)) into p_numDisDiff
      from cm_pi_compensazione pc
      where pc.prgprospettoinf = p_prgProspettoInf
      and pc.codmonoeccdiff = 'D' and pc.codmonocategoria = 'D';

      --calcolo compensazione disabili in eccedenza
      select sum(nvl(pc.numinteressati, 0)) into p_numArt18Ecc
      from cm_pi_compensazione pc
      where pc.prgprospettoinf = p_prgProspettoInf
      and pc.codmonoeccdiff = 'E' and pc.codmonocategoria = 'A';

      --calcolo compensazione disabili in diminuzione
      select sum(nvl(pc.numinteressati, 0)) into p_numArt18Diff
      from cm_pi_compensazione pc
      where pc.prgprospettoinf = p_prgProspettoInf
      and pc.codmonoeccdiff = 'D' and pc.codmonocategoria = 'A';

      --calcolo della copertura disabili in forza totale
      select round(sum(l.deccopertura),2) into p_sumCoperturaDisabili
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'D'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      --calcolo della copertura disabili in forza nominativa
      select round(sum(l.deccopertura),2) into p_sumCoperturaDisNom
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'D'
      and l.codmonotipo = 'M'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      --calcolo della copertura disabili in forza numerica
      select round(sum(l.deccopertura),2) into p_sumCoperturaDisNum
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'D'
      and l.codmonotipo = 'R'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      --calcolo della copertura art 18 in forza totale
      select round(sum(l.deccopertura),2) into p_sumCoperturaArt18
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'A'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      --calcolo della copertura art 18 in forza nominativa
      select round(sum(l.deccopertura),2) into p_sumCoperturaArt18Nom
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'A'
      and l.codmonotipo = 'M'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      --calcolo della copertura art 18 in forza numerica
      select round(sum(l.deccopertura),2) into p_sumCoperturaArt18Num
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'A'
      and l.codmonotipo = 'R'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      if (p_codmonocategoria = 'A') then
            p_percDisQuotaTotA := (7*p_baseComputo)/100;
            p_percACQuotaTotA := (1*p_baseComputo)/100;
            -- calcolo la percentuale esonero da togliere
            if (p_flgEsonero = 'S') then
                p_numEsonero := (p_numpercesonero*nvl(p_percDisQuotaTotA,0))/100;
            else
                p_numEsonero := 0;
            end if;

            --QUOTA DISABILI
            p_numquotadisabili := round(nvl(p_percDisQuotaTotA,0) - nvl(p_numEsonero,0) + nvl(p_numDisEcc,0) - nvl(p_numDisDiff,0), 0);
            --QUOTA DISABILI NOM
            p_numdisabilinom := round((60*p_numquotadisabili)/100,0);
            --QUOTA DISABILI NUM
            p_numdisabilinum := round((40*p_numquotadisabili)/100,0);

            -- QUOTA ART. 18 TOTALE
            p_numQuotaArt18 := round(nvl(p_percACQuotaTotA,0) + nvl(p_numArt18Ecc,0) - nvl(p_numArt18Diff,0), 0);
            -- QUOTA ART. 18 NOMINATIVA
            p_numQuotaArt18Nom := round(60*nvl(p_numQuotaArt18,0)/100, 0);
            -- QUOTA ART. 18 NUMERICA
            p_numQuotaArt18Num := round(40*nvl(p_numQuotaArt18,0)/100, 0);

      elsif (p_codmonocategoria = 'B') then
            -- calcolo la percentuale esonero da togliere
            if (p_flgEsonero = 'S') then
                p_numEsonero := (p_numpercesonero*2)/100;
            else
                p_numEsonero := 0;
            end if;

            -- QUOTA DISABILI
            p_numquotadisabili := round(2 - nvl(p_numEsonero,0) + nvl(p_numDisEcc,0) - nvl(p_numDisDiff,0), 0);
            --QUOTA DISABILI NOM
            p_numdisabilinom := 1;
            --QUOTA DISABILI NUM
            p_numdisabilinum := 1;

            -- QUOTA ART. 18
            p_numQuotaArt18 := round(0 + nvl(p_numArt18Ecc,0) - nvl(p_numArt18Diff,0), 0);
            -- QUOTA ART. 18 NOMINATIVA
            p_numQuotaArt18Nom := 0;
            -- QUOTA ART. 18 NUMERICA
            p_numQuotaArt18Num := 0;

      elsif (p_codmonocategoria = 'C') then
            -- calcolo la percentuale esonero da togliere
            if (p_flgEsonero = 'S') then
                p_numEsonero := (p_numpercesonero*1)/100;
            else
                p_numEsonero := 0;
            end if;

            -- QUOTA DISABILI
            p_numquotadisabili := round(1 - nvl(p_numEsonero,0) + nvl(p_numDisEcc,0) - nvl(p_numDisDiff,0), 0);
            --QUOTA DISABILI NOM
            p_numdisabilinom := 1;
            --QUOTA DISABILI NUM
            p_numdisabilinum := 0;

            -- QUOTA ART. 18
            p_numQuotaArt18 := round(0 + nvl(p_numArt18Ecc,0) - nvl(p_numArt18Diff,0), 0);
            -- QUOTA ART. 18 NOMINATIVA
            p_numQuotaArt18Nom := 0;
            -- QUOTA ART. 18 NUMERICA
            p_numQuotaArt18Num := 0;

      end if;

      --DISABILI SCOPERTURA TOTALE
      p_scoperturaDisabiliTot := (nvl(p_numquotadisabili,0) - nvl(p_sumCoperturaDisabili,0));
      if (p_scoperturaDisabiliTot < 0) then
         p_scoperturaDisabiliTot := 0;
      end if;

      --DISABILI SCOPERTURA NOMINATIVA
      p_scoperturaDisabiliNom := (nvl(p_numdisabilinom,0) - nvl(p_sumCoperturaDisNom,0));
      if (p_scoperturaDisabiliNom < 0) then
         p_scoperturaDisabiliNom := 0;
      end if;

      --DISABILI SCOPERTURA NUMERICA
      p_scoperturaDisabiliNum := (nvl(p_numdisabilinum,0) - nvl(p_sumCoperturaDisNum,0));
      if (p_scoperturaDisabiliNum < 0) then
         p_scoperturaDisabiliNum := 0;
      end if;

      --ART 18 SCOPERTURA TOTALE
      p_scoperturaArt18Tot := (nvl(p_numquotaart18,0) - nvl(p_sumcoperturaart18,0));
      if (p_scoperturaArt18Tot < 0) then
         p_scoperturaArt18Tot := 0;
      end if;

      --ART 18 SCOPERTURA NOMINATIVA
      p_scoperturaArt18Nom := (nvl(p_numQuotaArt18Nom ,0)- nvl(p_sumCoperturaArt18Nom,0));
      if (p_scoperturaArt18Nom < 0) then
         p_scoperturaArt18Nom := 0;
      end if;

      --ART 18 SCOPERTURA NUMERICA
      p_scoperturaArt18Num := (nvl(p_numQuotaArt18Num,0) - nvl(p_sumCoperturaArt18Num,0));
      if (p_scoperturaArt18Num < 0) then
         p_scoperturaArt18Num := 0;
      end if;

      -- nel caso di FLGCONVENZIONI = 'S' vengono considerate anche le assunzioni in convenzione
      if (p_flgconvenzione = 'S') then
         -- recupero i vari totali dei lavoratori disabili e art18 numerico e nominativo
         select nvl(sum(cd.numlavoratori), 0) into conv_sommaArt18Nom
         from cm_conv_dettaglio cd
         inner join cm_convenzione c on c.prgconv = cd.prgconv
         inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
         --inner join am_documento_coll dc on dc.strchiavetabella = c.prgconv
         --inner join am_documento d on d.prgdocumento = dc.prgdocumento
         where csa.flgscopertura = 'S'
         and c.codstatorichiesta = 'DE'
         and c.prgazienda = p_prgazienda
         and to_number(to_char(c.datconvenzione, 'YYYY')) <= p_numannorifprospetto
         and cd.codmonocategoria = 'A'
         and cd.codmonotipo = 'M'
         and trunc(cd.datscadenza) >= trunc(sysdate)
         --and d.CODTIPODOCUMENTO = 'CMDCONV'
         --and d.CODSTATOATTO != 'AN'
         ;

         select nvl(sum(cd.numlavoratori), 0) into conv_sommaArt18Num
         from cm_conv_dettaglio cd
         inner join cm_convenzione c on c.prgconv = cd.prgconv
         inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
         --inner join am_documento_coll dc on dc.strchiavetabella = c.prgconv
         --inner join am_documento d on d.prgdocumento = dc.prgdocumento
         where csa.flgscopertura = 'S'
         and c.codstatorichiesta = 'DE'
         and c.prgazienda = p_prgazienda
         and to_number(to_char(c.datconvenzione, 'YYYY')) <= p_numannorifprospetto
         and cd.codmonocategoria = 'A'
         and cd.codmonotipo = 'R'
         and trunc(cd.datscadenza) >= trunc(sysdate)
         --and d.CODTIPODOCUMENTO = 'CMDCONV'
         --and d.CODSTATOATTO != 'AN'
         ;

         select nvl(sum(cd.numlavoratori), 0) into conv_sommaDisabiliNom
         from cm_conv_dettaglio cd
         inner join cm_convenzione c on c.prgconv = cd.prgconv
         inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
         --inner join am_documento_coll dc on dc.strchiavetabella = c.prgconv
         --inner join am_documento d on d.prgdocumento = dc.prgdocumento
         where csa.flgscopertura = 'S'
         and c.codstatorichiesta = 'DE'
         and c.prgazienda = p_prgazienda
         and to_number(to_char(c.datconvenzione, 'YYYY')) <= p_numannorifprospetto
         and cd.codmonocategoria = 'D'
         and cd.codmonotipo = 'M'
         and trunc(cd.datscadenza) >= trunc(sysdate)
         --and d.CODTIPODOCUMENTO = 'CMDCONV'
         --and d.CODSTATOATTO != 'AN'
         ;

         select nvl(sum(cd.numlavoratori), 0) into conv_sommaDisabiliNum
         from cm_conv_dettaglio cd
         inner join cm_convenzione c on c.prgconv = cd.prgconv
         inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
         --inner join am_documento_coll dc on dc.strchiavetabella = c.prgconv
         --inner join am_documento d on d.prgdocumento = dc.prgdocumento
         where csa.flgscopertura = 'S'
         and c.prgazienda = p_prgazienda
         and c.codstatorichiesta = 'DE'
         and to_number(to_char(c.datconvenzione, 'YYYY')) <= p_numannorifprospetto
         and cd.codmonocategoria = 'D'
         and cd.codmonotipo = 'R'
         and trunc(cd.datscadenza) >= trunc(sysdate)
         --and d.CODTIPODOCUMENTO = 'CMDCONV'
         --and d.CODSTATOATTO != 'AN'
         ;


         --DISABILI SCOPERTURA NOMINATIVA
         p_scoperturaDisabiliNom := p_scoperturaDisabiliNom - conv_sommaDisabiliNom;
         if (p_scoperturaDisabiliNom < 0) then
            p_scoperturaDisabiliNom := 0;
         end if;

         --DISABILI SCOPERTURA NUMERICA
         p_scoperturaDisabiliNum := p_scoperturaDisabiliNum - conv_sommaDisabiliNum;
         if (p_scoperturaDisabiliNum < 0) then
            p_scoperturaDisabiliNum := 0;
         end if;

         --DISABILI SCOPERTURA TOTALE
         p_scoperturaDisabiliTot := p_scoperturaDisabiliTot - (conv_sommaDisabiliNom + conv_sommaDisabiliNum);
         if (p_scoperturaDisabiliTot < 0) then
            p_scoperturaDisabiliTot := 0;
         end if;

         --ART 18 SCOPERTURA NOMINATIVA
         p_scoperturaArt18Nom := p_scoperturaArt18Nom - conv_sommaArt18Nom;
         if (p_scoperturaArt18Nom < 0) then
            p_scoperturaArt18Nom := 0;
         end if;

         --ART 18 SCOPERTURA NUMERICA
         p_scoperturaArt18Num := p_scoperturaArt18Num - conv_sommaArt18Num;
         if (p_scoperturaArt18Num < 0) then
           p_scoperturaArt18Num := 0;
         end if;

         --ART 18 SCOPERTURA TOTALE
         p_scoperturaArt18Tot := p_scoperturaArt18Tot - (conv_sommaArt18Num + conv_sommaArt18Nom);
         if (p_scoperturaArt18Tot < 0) then
            p_scoperturaArt18Tot := 0;
         end if;

      end if;

      select count(c.prgconv) into p_convenzioniAzienda
      from cm_convenzione c
      -- inner join am_documento_coll dc on dc.strchiavetabella = c.prgconv
      -- inner join am_documento d on d.prgdocumento = dc.prgdocumento
      where c.codstatorichiesta = 'DE'
      and c.prgazienda = p_prgazienda
      and to_number(to_char(c.datconvenzione, 'YYYY')) <= p_numannorifprospetto
      --and d.CODTIPODOCUMENTO = 'CMDCONV'
      --and d.CODSTATOATTO != 'AN'
      ;

      if ((nvl(p_numdisabilinomDb,0) + nvl(p_numdisabilinumDb,0)) != nvl(p_numquotadisabili,0)) then
         p_messaggioDisabili := 1;
      end if;

      if ((nvl(p_numart18nomDb,0) + nvl(p_numart18numDb,0)) != nvl(p_numQuotaArt18,0)) then
         p_messaggioArt18 := 1;
      end if;

/*
      if ((p_scoperturaDisabiliNom + p_scoperturaDisabiliNum) != p_scoperturaDisabiliTot) then
         p_messaggioDisabili := 1;
      end if;

      if ((p_scoperturaArt18Nom + p_scoperturaArt18Num) != p_scoperturaArt18Tot) then
         p_messaggioArt18 := 1;
      end if;
*/

      str := 'select ' ||
      to_char(nvl(p_baseComputo,0), '9999.99') || ' as BC_baseComputo ,' ||
      to_char(nvl(p_sommaEsclusione,0), '9999.99') || ' as TE_totaleEsclusioni ,' ||
      to_char(nvl(p_numquotadisabili,0), '9999.99') || ' as A_disabiliQuotaTotale ,' ||
      to_char(nvl(p_numdisabilinom,0), '9999.99') || ' as B_disabiliQuotaNominativa ,' ||
      to_char(nvl(p_numdisabilinum,0), '9999.99') || ' as C_disabiliQuotaNumerica ,' ||
      to_char(nvl(p_sumCoperturaDisabili,0), '9999.99') || ' as D_disabiliForzaTotale ,' ||
      to_char(nvl(p_sumCoperturaDisNom,0), '9999.99') || ' as E_disabiliForzaNominativa ,' ||
      to_char(nvl(p_sumCoperturaDisNum,0), '9999.99') || ' as F_disabiliForzaNumerica ,' ||
      to_char(nvl(p_scoperturaDisabiliTot,0), '9999.99') || ' as G_disabiliScoperturaTotale ,' ||
      to_char(nvl(p_scoperturaDisabiliNom,0), '9999.99') || ' as H_disabiliScoperturaNominativa ,' ||
      to_char(nvl(p_scoperturaDisabiliNum,0), '9999.99') || ' as I_disabiliScoperturaNumerica ,' ||
      to_char(nvl(p_numQuotaArt18,0), '9999.99') || ' as L_art18QuotaTotale ,' ||
      to_char(nvl(p_numQuotaArt18Nom,0), '9999.99') || ' as M_art18QuotaNominativa ,' ||
      to_char(nvl(p_numQuotaArt18Num,0), '9999.99') || ' as N_art18QuotaNumerica ,' ||
      to_char(nvl(p_sumCoperturaArt18,0), '9999.99') || ' as O_art18ForzaTotale ,' ||
      to_char(nvl(p_sumCoperturaArt18Nom,0), '9999.99') || ' as P_art18ForzaNominativa ,' ||
      to_char(nvl(p_sumCoperturaArt18Num,0), '9999.99') || ' as Q_art18ForzaNumerica ,' ||
      to_char(nvl(p_scoperturaArt18Tot,0), '9999.99') || ' as R_art18ScoperturaTotale ,' ||
      to_char(nvl(p_scoperturaArt18Nom,0), '9999.99') || ' as S_art18ScoperturaNominativa ,' ||
      to_char(nvl(p_scoperturaArt18Num,0), '9999.99') || ' as T_art18ScoperturaNumerica ,' ||
      to_char(nvl(p_convenzioniAzienda,0), '9999.99') || ' as convenzioniAzienda,' ||
      to_char(nvl(p_messaggioDisabili,0), '9999.99') || ' as msgDisabili ,' ||
      to_char(nvl(p_messaggioArt18,0), '9999.99') || ' as msgArt18 ' ||
      ' from dual';

  END LOOP;

  open risultato for str;
  return risultato;

end calcoloScopertura;

function checkScopertura(p_prgProspettoInf number,
                           p_flgConvenzione varchar2
                         ) RETURN NUMBER is
CURSOR curProspetto IS
         select p.prgprospettoinf, p.prgazienda, p.prgunita,
              e.numdirigenti, e.numapprendisti, e.numcfl, e.numparttime,
              e.numcigs,
         e.numtdmeno9mesi,
         e.numtemporaneo,
         e.numreinserimento,
         e.numdomicilio,
         e.numsoci,
         e.numdisabili,
         e.numprotette,
         e.numaltri,
         e.NUMLAVACQUISITI,
         e.NUMPERSONALENONAMM_C3,
         e.NUMPERSONALENONAMM_C4,
         e.NUMPERSONALEVIAGGIANTE,
         e.NUMLSUSTABILI,
         e.NUMLAVORATORIOPESTERO,
         e.NUMLAVORATORIEDILIZIA,
         e.NUMLAVEMERSINERO,
         e.NUMINTERMITTENTI,
       p.prgazreferente, p.numoreccnl, p.codprovincia,
       p.codmonostatoprospetto, p.codmonoprov, p.numannorifprospetto,
       to_char(p.datconsegnaprospetto, 'dd/mm/yyyy') as datconsegnaprospetto,
       p.numdipendentinazionale, p.codmonocategoria,
       p.numdipendentitot, p.numbasecomputo, p.numquotadisabili,
       p.numdisabilinom, p.numdisabilinum, p.numquotaart18,
       p.numart18nom, p.numart18num,
       to_char(p.datprimaassunzione, 'dd/mm/yyyy') as datprimaassunzione,
       to_char(p.datsecondaassunzione, 'dd/mm/yyyy') as datsecondaassunzione,
       p.numdisforza, p.numart18forza,
       p.flgesonero, p.numpercesonero, p.flggradualita,
       p.flgcompterritoriale, p.flgsospensione, p.numconvenzioni,
       p.strnote, p.cdnutins, p.dtmins, p.cdnutmod, p.dtmmod, p.numkloprospettoinf
     from cm_prospetto_inf p
          left join cm_esclusione_prospetto e on e.prgprospettoinf = p.prgprospettoinf
     where p.prgprospettoinf = p_prgProspettoInf;

p_codmonocategoria cm_prospetto_inf.codmonocategoria%type;
p_numdirigenti cm_esclusione_prospetto.numdirigenti%type;
p_numapprendisti cm_esclusione_prospetto.numapprendisti%type;
p_numcfl cm_esclusione_prospetto.numcfl%type;
p_numparttime cm_esclusione_prospetto.numparttime%type;
p_numdipendentitot cm_prospetto_inf.numdipendentitot%type;
p_numquotadisabili cm_prospetto_inf.numquotadisabili%type;
p_numdisabilinom cm_prospetto_inf.numdisabilinom%type;
p_numdisabilinum cm_prospetto_inf.numdisabilinum%type;
p_flgEsonero cm_prospetto_inf.flgesonero%type;
p_numpercesonero cm_prospetto_inf.numpercesonero%type;

p_numcigs cm_esclusione_prospetto.numcigs%type;
p_numtdmeno9mesi cm_esclusione_prospetto.numtdmeno9mesi%type;
p_numtemporaneo cm_esclusione_prospetto.numtemporaneo%type;
p_numreinserimento cm_esclusione_prospetto.numreinserimento%type;
p_numdomicilio cm_esclusione_prospetto.numdomicilio%type;
p_numsoci cm_esclusione_prospetto.numsoci%type;
p_numdisabili cm_esclusione_prospetto.numdisabili%type;
p_numprotette cm_esclusione_prospetto.numprotette%type;
p_numaltri cm_esclusione_prospetto.numaltri%type;
p_numlavacquisiti cm_esclusione_prospetto.NUMLAVACQUISITI%type;
p_numpersnonamm_c3 cm_esclusione_prospetto.NUMPERSONALENONAMM_C3%type;
p_numpersnonamm_c4 cm_esclusione_prospetto.NUMPERSONALENONAMM_C4%type;
p_numpersviaggiante cm_esclusione_prospetto.NUMPERSONALEVIAGGIANTE%type;
p_numlsustabili cm_esclusione_prospetto.NUMLSUSTABILI%type;
p_numlavopestero cm_esclusione_prospetto.NUMLAVORATORIOPESTERO%type;
p_numlavedilizia cm_esclusione_prospetto.NUMLAVORATORIEDILIZIA%type;
p_numlavemersinero cm_esclusione_prospetto.NUMLAVEMERSINERO%type;
p_numintermittenti cm_esclusione_prospetto.NUMINTERMITTENTI%type;

p_prgAzienda cm_prospetto_inf.prgazienda%type;
p_prgUnita cm_prospetto_inf.prgunita%type;

p_baseComputo number;
p_sommaEsclusione number;
p_percDisQuotaTotA number;
p_percACQuotaTotA number;
p_numDisEcc number;
p_numDisDiff number;
p_numEsonero number;
p_sumCoperturaDisabili number;
p_sumCoperturaDisNom number;
p_sumCoperturaDisNum number;
p_scoperturaDisabiliTot number;
p_scoperturaDisabiliNom number;
p_scoperturaDisabiliNum number;
p_numQuotaArt18 number;
p_numArt18Ecc number;
p_numArt18Diff number;
p_numQuotaArt18Nom number;
p_numQuotaArt18Num number;
p_sumCoperturaArt18 number;
p_sumCoperturaArt18Nom number;
p_sumCoperturaArt18Num number;
p_scoperturaArt18Tot number;
p_scoperturaArt18Nom number;
p_scoperturaArt18Num number;
p_messaggioDisabili number;
p_messaggioArt18 number;

conv_sommaArt18Nom number;
conv_sommaArt18Num number;
conv_sommaDisabiliNom number;
conv_sommaDisabiliNum number;

risultato number;

begin

  p_messaggioDisabili := 0;
  p_messaggioArt18 := 0;

  FOR rec in curProspetto LOOP
      p_codmonocategoria := rec.codmonocategoria;
      p_numdirigenti := rec.numdirigenti;
      p_numapprendisti := rec.numapprendisti;
      p_numcfl := rec.numcfl;
      p_numparttime := rec.numparttime;
      p_numdipendentitot := nvl(rec.numdipendentitot,0);
      p_flgEsonero := rec.flgEsonero;
      p_numpercesonero := nvl(rec.numpercesonero,0);

      p_numcigs := nvl(rec.numcigs,0);
   p_numtdmeno9mesi := nvl(rec.numtdmeno9mesi,0);
   p_numtemporaneo := nvl(rec.numtemporaneo,0);
   p_numreinserimento := nvl(rec.numreinserimento,0);
   p_numdomicilio := nvl(rec.numdomicilio,0);
   p_numsoci := nvl(rec.numsoci,0);
   p_numdisabili := nvl(rec.numdisabili,0);
   p_numprotette := nvl(rec.numprotette,0);
   p_numaltri := nvl(rec.numaltri,0);
   p_numlavacquisiti := nvl(rec.NUMLAVACQUISITI,0);
   p_numpersnonamm_c3 := nvl(rec.NUMPERSONALENONAMM_C3,0);
   p_numpersnonamm_c4 := nvl(rec.NUMPERSONALENONAMM_C4,0);
   p_numpersviaggiante := nvl(rec.NUMPERSONALEVIAGGIANTE,0);
   p_numlsustabili := nvl(rec.NUMLSUSTABILI,0);
   p_numlavopestero := nvl(rec.NUMLAVORATORIOPESTERO,0);
   p_numlavedilizia := nvl(rec.NUMLAVORATORIEDILIZIA,0);
   p_numlavemersinero := nvl(rec.NUMLAVEMERSINERO,0);
   p_numintermittenti := nvl(rec.NUMINTERMITTENTI,0);

      p_prgazienda := rec.prgAzienda;
      p_prgunita := rec.prgUnita;
     -- p_numquotadisabili := rec.numquotadisabili;
     -- p_numdisabilinom := rec.numdisabilinom;
     -- p_numdisabilinum := rec.numdisabilinum;

      --somma delle esclusioni
      p_sommaEsclusione := nvl(p_numdirigenti,0)+nvl(p_numapprendisti,0)+nvl(p_numcfl,0)+nvl(p_numparttime,0)
                           + nvl(p_numtdmeno9mesi,0) + nvl(p_numtemporaneo,0) + nvl(p_numreinserimento,0) + nvl(p_numdomicilio,0)
                           + nvl(p_numsoci,0) + nvl(p_numdisabili,0) + nvl(p_numprotette,0) + nvl(p_numaltri,0)
                           + nvl(p_numlavacquisiti,0) + nvl(p_numpersnonamm_c3,0) + nvl(p_numpersnonamm_c4,0) 
                           + nvl(p_numpersviaggiante,0) + nvl(p_numlsustabili,0) + nvl(p_numlavopestero,0)
                           + nvl(p_numlavedilizia,0) + nvl(p_numlavemersinero,0) + nvl(p_numintermittenti,0);
      -- calcolo base computo come differenza tra numero dipendenti provinciali e la somma delle esclusioni
      p_baseComputo := p_numdipendentitot - p_sommaEsclusione;
      if (p_baseComputo < 0) then
         p_baseComputo := 0;
      end if;

      --calcolo compensazione disabili in eccedenza
      select sum(nvl(pc.numinteressati,0)) into p_numDisEcc
      from cm_pi_compensazione pc
      where pc.prgprospettoinf = p_prgProspettoInf
      and pc.codmonoeccdiff = 'E' and pc.codmonocategoria = 'D';

      --calcolo compensazione disabili in diminuzione
      select sum(nvl(pc.numinteressati,0)) into p_numDisDiff
      from cm_pi_compensazione pc
      where pc.prgprospettoinf = p_prgProspettoInf
      and pc.codmonoeccdiff = 'D' and pc.codmonocategoria = 'D';

      --calcolo compensazione disabili in eccedenza
      select sum(nvl(pc.numinteressati,0)) into p_numArt18Ecc
      from cm_pi_compensazione pc
      where pc.prgprospettoinf = p_prgProspettoInf
      and pc.codmonoeccdiff = 'E' and pc.codmonocategoria = 'A';

      --calcolo compensazione disabili in diminuzione
      select sum(nvl(pc.numinteressati,0)) into p_numArt18Diff
      from cm_pi_compensazione pc
      where pc.prgprospettoinf = p_prgProspettoInf
      and pc.codmonoeccdiff = 'D' and pc.codmonocategoria = 'A';

      --calcolo della copertura disabili in forza totale
      select round(sum(l.deccopertura),2) into p_sumCoperturaDisabili
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'D'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      --calcolo della copertura disabili in forza nominativa
      select round(sum(l.deccopertura),2) into p_sumCoperturaDisNom
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'D'
      and l.codmonotipo = 'M'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      --calcolo della copertura disabili in forza numerica
      select round(sum(l.deccopertura),2) into p_sumCoperturaDisNum
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'D'
      and l.codmonotipo = 'R'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      --calcolo della copertura art 18 in forza totale
      select round(sum(l.deccopertura),2) into p_sumCoperturaArt18
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'A'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      --calcolo della copertura art 18 in forza nominativa
      select round(sum(l.deccopertura),2) into p_sumCoperturaArt18Nom
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'A'
      and l.codmonotipo = 'M'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      --calcolo della copertura art 18 in forza numerica
      select round(sum(l.deccopertura),2) into p_sumCoperturaArt18Num
      from cm_pi_lav_riserva l
      where l.prgprospettoinf = p_prgProspettoInf
      and l.codmonocategoria = 'A'
      and l.codmonotipo = 'R'
      and l.decoretotali is not null
      and l.decorelavorate is not null;

      if (p_codmonocategoria = 'A') then
            p_percDisQuotaTotA := (7*p_baseComputo)/100;
            p_percACQuotaTotA := (1*p_baseComputo)/100;
            -- calcolo la percentuale esonero da togliere
            if (p_flgEsonero = 'S') then
                p_numEsonero := (p_numpercesonero*nvl(p_percDisQuotaTotA,0))/100;
            else
                p_numEsonero := 0;
            end if;

            --QUOTA DISABILI
            p_numquotadisabili := round(nvl(p_percDisQuotaTotA,0) - nvl(p_numEsonero,0) + nvl(p_numDisEcc,0) - nvl(p_numDisDiff,0), 0);
            --QUOTA DISABILI NOM
            p_numdisabilinom := round((60*p_numquotadisabili)/100,0);
            --QUOTA DISABILI NUM
            p_numdisabilinum := round((40*p_numquotadisabili)/100,0);

            -- QUOTA ART. 18 TOTALE
            p_numQuotaArt18 := round(nvl(p_percACQuotaTotA,0) + nvl(p_numArt18Ecc,0) - nvl(p_numArt18Diff,0), 0);
            -- QUOTA ART. 18 NOMINATIVA
            p_numQuotaArt18Nom := round(60*nvl(p_numQuotaArt18,0)/100, 0);
            -- QUOTA ART. 18 NUMERICA
            p_numQuotaArt18Num := round(40*nvl(p_numQuotaArt18,0)/100, 0);

      elsif (p_codmonocategoria = 'B') then
            -- calcolo la percentuale esonero da togliere
            if (p_flgEsonero = 'S') then
                p_numEsonero := (p_numpercesonero*2)/100;
            else
                p_numEsonero := 0;
            end if;

            -- QUOTA DISABILI
            p_numquotadisabili := round(2 - nvl(p_numEsonero,0) + nvl(p_numDisEcc,0) - nvl(p_numDisDiff,0), 0);
            --QUOTA DISABILI NOM
            p_numdisabilinom := 1;
            --QUOTA DISABILI NUM
            p_numdisabilinum := 1;

            -- QUOTA ART. 18
            p_numQuotaArt18 := round(0 + nvl(p_numArt18Ecc,0) - nvl(p_numArt18Diff,0), 0);
            -- QUOTA ART. 18 NOMINATIVA
            p_numQuotaArt18Nom := 0;
            -- QUOTA ART. 18 NUMERICA
            p_numQuotaArt18Num := 0;

      elsif (p_codmonocategoria = 'C') then
            -- calcolo la percentuale esonero da togliere
            if (p_flgEsonero = 'S') then
                p_numEsonero := (p_numpercesonero*1)/100;
            else
                p_numEsonero := 0;
            end if;

            -- QUOTA DISABILI
            p_numquotadisabili := round(1 - nvl(p_numEsonero,0) + nvl(p_numDisEcc,0) - nvl(p_numDisDiff,0), 0);
            --QUOTA DISABILI NOM
            p_numdisabilinom := 1;
            --QUOTA DISABILI NUM
            p_numdisabilinum := 0;

            -- QUOTA ART. 18
            p_numQuotaArt18 := round(0 + nvl(p_numArt18Ecc,0) - nvl(p_numArt18Diff,0), 0);
            -- QUOTA ART. 18 NOMINATIVA
            p_numQuotaArt18Nom := 0;
            -- QUOTA ART. 18 NUMERICA
            p_numQuotaArt18Num := 0;

      end if;

      --DISABILI SCOPERTURA TOTALE
      p_scoperturaDisabiliTot := (nvl(p_numquotadisabili,0) - nvl(p_sumCoperturaDisabili,0));
      if (p_scoperturaDisabiliTot < 0) then
         p_scoperturaDisabiliTot := 0;
      end if;

      --DISABILI SCOPERTURA NOMINATIVA
      p_scoperturaDisabiliNom := (nvl(p_numdisabilinom,0) - nvl(p_sumCoperturaDisNom,0));
      if (p_scoperturaDisabiliNom < 0) then
         p_scoperturaDisabiliNom := 0;
      end if;

      --DISABILI SCOPERTURA NUMERICA
      p_scoperturaDisabiliNum := (nvl(p_numdisabilinum,0) - nvl(p_sumCoperturaDisNum,0));
      if (p_scoperturaDisabiliNum < 0) then
         p_scoperturaDisabiliNum := 0;
      end if;

      --ART 18 SCOPERTURA TOTALE
      p_scoperturaArt18Tot := (nvl(p_numquotaart18,0) - nvl(p_sumcoperturaart18,0));
      if (p_scoperturaArt18Tot < 0) then
         p_scoperturaArt18Tot := 0;
      end if;

      --ART 18 SCOPERTURA NOMINATIVA
      p_scoperturaArt18Nom := (nvl(p_numQuotaArt18Nom ,0)- nvl(p_sumCoperturaArt18Nom,0));
      if (p_scoperturaArt18Nom < 0) then
         p_scoperturaArt18Nom := 0;
      end if;

      --ART 18 SCOPERTURA NUMERICA
      p_scoperturaArt18Num := (nvl(p_numQuotaArt18Num,0) - nvl(p_sumCoperturaArt18Num,0));
      if (p_scoperturaArt18Num < 0) then
         p_scoperturaArt18Num := 0;
      end if;

      -- nel caso di FLGCONVENZIONI = 'S' vengono considerate anche le assunzioni in convenzione
      if (p_flgconvenzione = 'S') then
         -- recupero i vari totali dei lavoratori disabili e art18 numerico e nominativo
         select nvl(sum(cd.numlavoratori), 0) into conv_sommaArt18Nom
         from cm_conv_dettaglio cd
         inner join cm_convenzione c on c.prgconv = cd.prgconv
         inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
         --inner join am_documento_coll dc on dc.strchiavetabella = c.prgconv
         --inner join am_documento d on d.prgdocumento = dc.prgdocumento
         where csa.flgscopertura = 'S'
         and c.codstatorichiesta = 'DE'
         and c.prgazienda = p_prgazienda
         and c.prgunita = p_prgunita
         and cd.codmonocategoria = 'A'
         and cd.codmonotipo = 'M'
         and cd.datscadenza >= sysdate
         --and d.CODTIPODOCUMENTO = 'CMDCONV'
         --and d.CODSTATOATTO != 'AN'
         ;

         select nvl(sum(cd.numlavoratori), 0) into conv_sommaArt18Num
         from cm_conv_dettaglio cd
         inner join cm_convenzione c on c.prgconv = cd.prgconv
         inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
         --inner join am_documento_coll dc on dc.strchiavetabella = c.prgconv
         --inner join am_documento d on d.prgdocumento = dc.prgdocumento
         where csa.flgscopertura = 'S'
         and c.codstatorichiesta = 'DE'
         and c.prgazienda = p_prgazienda
         and c.prgunita = p_prgunita
         and cd.codmonocategoria = 'A'
         and cd.codmonotipo = 'R'
         and cd.datscadenza >= sysdate
         --and d.CODTIPODOCUMENTO = 'CMDCONV'
         --and d.CODSTATOATTO != 'AN'
         ;

         select nvl(sum(cd.numlavoratori), 0) into conv_sommaDisabiliNom
         from cm_conv_dettaglio cd
         inner join cm_convenzione c on c.prgconv = cd.prgconv
         inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
         --inner join am_documento_coll dc on dc.strchiavetabella = c.prgconv
         --inner join am_documento d on d.prgdocumento = dc.prgdocumento
         where csa.flgscopertura = 'S'
         and c.codstatorichiesta = 'DE'
         and c.prgazienda = p_prgazienda
         and c.prgunita = p_prgunita
         and cd.codmonocategoria = 'D'
         and cd.codmonotipo = 'M'
         and cd.datscadenza >= sysdate
         --and d.CODTIPODOCUMENTO = 'CMDCONV'
         --and d.CODSTATOATTO != 'AN'
         ;

         select nvl(sum(cd.numlavoratori), 0) into conv_sommaDisabiliNum
         from cm_conv_dettaglio cd
         inner join cm_convenzione c on c.prgconv = cd.prgconv
         inner join DE_CONV_STATO_ASS csa on csa.codstato = cd.codstato
         --inner join am_documento_coll dc on dc.strchiavetabella = c.prgconv
         --inner join am_documento d on d.prgdocumento = dc.prgdocumento
         where csa.flgscopertura = 'S'
         and c.codstatorichiesta = 'DE'
         and c.prgazienda = p_prgazienda
         and c.prgunita = p_prgunita
         and cd.codmonocategoria = 'D'
         and cd.codmonotipo = 'R'
         and cd.datscadenza >= sysdate
         --and d.CODTIPODOCUMENTO = 'CMDCONV'
         --and d.CODSTATOATTO != 'AN'
         ;

         --DISABILI SCOPERTURA NOMINATIVA
         p_scoperturaDisabiliNom := p_scoperturaDisabiliNom - conv_sommaDisabiliNom;
         if (p_scoperturaDisabiliNom < 0) then
            p_scoperturaDisabiliNom := 0;
         end if;

         --DISABILI SCOPERTURA NUMERICA
         p_scoperturaDisabiliNum := p_scoperturaDisabiliNum - conv_sommaDisabiliNum;
         if (p_scoperturaDisabiliNum < 0) then
            p_scoperturaDisabiliNum := 0;
         end if;

         --DISABILI SCOPERTURA TOTALE
         p_scoperturaDisabiliTot := p_scoperturaDisabiliTot - (conv_sommaDisabiliNom + conv_sommaDisabiliNum);
         if (p_scoperturaDisabiliTot < 0) then
            p_scoperturaDisabiliTot := 0;
         end if;

         --ART 18 SCOPERTURA NOMINATIVA
         p_scoperturaArt18Nom := p_scoperturaArt18Nom - conv_sommaArt18Nom;
         if (p_scoperturaArt18Nom < 0) then
            p_scoperturaArt18Nom := 0;
         end if;

         --ART 18 SCOPERTURA NUMERICA
         p_scoperturaArt18Num := p_scoperturaArt18Num - conv_sommaArt18Num;
         if (p_scoperturaArt18Num < 0) then
           p_scoperturaArt18Num := 0;
         end if;

         --ART 18 SCOPERTURA TOTALE
         p_scoperturaArt18Tot := p_scoperturaArt18Tot - (conv_sommaArt18Num + conv_sommaArt18Nom);
         if (p_scoperturaArt18Tot < 0) then
            p_scoperturaArt18Tot := 0;
         end if;

      end if;

      if (p_scoperturaDisabiliTot > 0) then
         p_messaggioDisabili := 1;
      end if;

      if (p_scoperturaArt18Tot > 0) then
         p_messaggioArt18 := 1;
      end if;


/*
   if ((p_scoperturaDisabiliNom + p_scoperturaDisabiliNum) != p_scoperturaDisabiliTot) then
         p_messaggioDisabili := 1;
      end if;

      if ((p_scoperturaArt18Nom + p_scoperturaArt18Num) != p_scoperturaArt18Tot) then
         p_messaggioArt18 := 1;
      end if;
*/


  END LOOP;

  if (p_messaggioDisabili = 1) then
     return 1;
  end if;
  if (p_messaggioArt18 = 1) then
     return 1;
  end if;

  return 0;

end checkScopertura;


function getScopertura(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                       p_flgConvenzione varchar2
                       ) RETURN varchar2 is

risultatoScopertura typRefCurs;
strScopertura varchar2(1000);
disabiliScoperturaTotale varchar2(10);
disabiliScoperturaNominativa varchar2(10);
disabiliScoperturaNumerica varchar2(10);
art18ScoperturaTotale varchar2(10);
art18ScoperturaNominativa varchar2(10);
art18ScoperturaNumerica varchar2(10);
a1 varchar2(10);
a2 varchar2(10);
a3 varchar2(10);
a4 varchar2(10);
a5 varchar2(10);
a6 varchar2(10);
a7 varchar2(10);
a8 varchar2(10);
a9 varchar2(10);
a10 varchar2(10);
a11 varchar2(10);
a12 varchar2(10);
a13 varchar2(10);
a14 varchar2(10);
a15 varchar2(10);
a16 varchar2(10);
a17 varchar2(10);
a18 varchar2(10);
a19 varchar2(10);
a20 varchar2(10);
a21 varchar2(10);
a22 varchar2(10);
a23 varchar2(10);


begin

  select pg_coll_mirato.calcoloscopertura(p_prgProspettoInf, p_flgConvenzione) into risultatoScopertura
  from cm_prospetto_inf p
  where p.prgprospettoinf = p_prgProspettoInf;

  FETCH risultatoScopertura INTO a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23;

  disabiliScoperturaTotale := a9;
  disabiliScoperturaNominativa := a10;
  disabiliScoperturaNumerica := a11;
  art18ScoperturaTotale := a18;
  art18ScoperturaNominativa := a19;
  art18ScoperturaNumerica := a20;

  strScopertura := disabiliScoperturaTotale ||'-'||
                   disabiliScoperturaNominativa ||'-'||
                   disabiliScoperturaNumerica ||'-'||
                   art18ScoperturaTotale ||'-'||
                   art18ScoperturaNominativa ||'-'||
                   art18ScoperturaNumerica ;


  close risultatoScopertura;

  return strScopertura;

end getScopertura;


function InsLavMovimentiDisp(p_prgMov Am_Movimento.Prgmovimento%TYPE,
                             p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                             p_key varchar2,
                             p_errCode OUT number
                             ) RETURN NUMBER IS

p_cdnLavoratore an_lavoratore.cdnlavoratore%type;
p_strCognome an_lavoratore.strcognome%type;
p_strNome an_lavoratore.strnome%type;
p_strCodiceFiscale an_lavoratore.strcodicefiscale%type;
p_datInizioMov am_movimento.datiniziomov%type;
p_datFineMov am_movimento.datfinemov%type;
p_codTipoAss am_movimento.codtipoass%type;
p_codMansione am_movimento.codmansione%type;
p_codContratto am_movimento.codcontratto%type;
p_numConvenzioni am_movimento.numconvenzione%type;
p_checIscrCM varchar2(1);
p_flgConvenzione cm_pi_lav_riserva.flgconvenzione%type;
p_codMonoTipo cm_pi_lav_riserva.codmonotipo%type;
p_codMonoCategoria cm_pi_lav_riserva.codmonocategoria%type;
p_percInvalidita am_cm_iscr.numpercinvalidita%type;
p_categoriaPro cm_prospetto_inf.codmonocategoria%type;
p_deccopertura cm_pi_lav_riserva.deccopertura%type;
p_codmonotempo am_movimento.codmonotempo%type;
p_flgLegge68 am_movimento.flglegge68%type;

begin

  select cm_isc.codmonotiporagg, cm_isc.numpercinvalidita, lav.cdnlavoratore,
     lav.strCognome, lav.strNome, lav.strCodiceFiscale,
         mov.datIniziomov, mov.Datfinemov, mov.CODTIPOASS,
         mov.codMansione,
         CASE
          WHEN mov.codContratto = 'LT'                    /*tempo determinato*/
             THEN DECODE (mov.codmonotempo, 'D', mov.codcontratto, 'I', 'LP')
          WHEN mov.codcontratto = 'LP'                  /*tempo indeterminato*/
             THEN DECODE (mov.codmonotempo, 'D', 'LT', 'I', mov.codcontratto)
          WHEN mov.codcontratto NOT IN ('LT', 'LP')
             THEN mov.codcontratto
         END as codContratto,
         mov.Numconvenzione,
         mov.codmonotempo, mov.flgLegge68
  into p_checIscrCM, p_percInvalidita, p_cdnlavoratore,
    p_strCognome, p_strNome, p_strCodiceFiscale,
       p_datIniziomov, p_datFinemov, p_codTipoAss,
       p_codMansione, p_codContratto, p_numConvenzioni,
       p_codmonotempo, p_flgLegge68
  from
 (
 select deisc.codmonotiporagg, isc.cdnlavoratore, isc.numpercinvalidita
 from am_cm_iscr isc, de_cm_tipo_iscr deisc, am_documento_coll coll, am_documento doc,
	  AM_MOVIMENTO mov_cm
 where mov_cm.prgmovimento = p_prgmov and mov_cm.cdnlavoratore = decrypt(isc.cdnlavoratore(+),p_key)
 and isc.CODCMTIPOISCR = deisc.CODCMTIPOISCR
 and isc.datdatafine is null
 and isc.PRGCMISCR = coll.STRCHIAVETABELLA
 and coll.PRGDOCUMENTO = doc.PRGDOCUMENTO
 and doc.cdnlavoratore = mov_cm.cdnlavoratore
 and doc.CODTIPODOCUMENTO = 'L68'
 and doc.CODSTATOATTO = 'PR'
 order by deisc.codmonotiporagg desc
 ) cm_isc
 , AM_MOVIMENTO mov, AN_LAVORATORE lav
  where mov.cdnlavoratore = lav.cdnlavoratore
  and mov.prgmovimento = p_prgmov
  and decrypt(cm_isc.cdnlavoratore(+),p_key) = mov.cdnlavoratore and rownum = 1;

  select pro.codmonocategoria into p_categoriaPro
  from cm_prospetto_inf pro
  where pro.prgprospettoinf = p_prgProspettoInf;

  if (p_checIscrCM = 'A') then
     p_codMonoCategoria := 'A';
  else
     p_codMonoCategoria := 'D';
  end if;

  if (p_flgLegge68 = 'S' or p_codTipoAss = 'NU2') then
     p_codMonoTipo := 'R';
  else
     p_codMonoTipo := 'M';
  end if;

  if (p_numConvenzioni is not null) then
     p_flgConvenzione := 'S';
  end if;

  p_deccopertura := 0;

  if (p_categoriaPro = 'C') then
    if (p_percInvalidita > 50) then
       p_deccopertura := 1;
    end if;
  end if;

  INSERT INTO cm_pi_lav_riserva
  (prglavriserva,
  prgprospettoinf,
  cdnlavoratore,
  strcodicefiscalelav,
  strcognomelav,
  strnomelav,
  codmonocategoria,
  codmonotipo,
  codmansione,
  datiniziorapp,
  datfinerapp,
  codcontratto,
  flgconvenzione,
  deccopertura,
  cdnutins,
  dtmins,
  cdnutmod,
  dtmmod)
  VALUES
  (s_cm_pi_lav_riserva.nextval,
  p_prgProspettoInf,
  p_cdnlavoratore,
  p_strcodicefiscale,
  p_strcognome,
  p_strnome,
  p_codmonocategoria,
  p_codmonotipo,
  p_codmansione,
  p_datiniziomov,
  p_datfinemov,
  p_codcontratto,
  p_flgconvenzione,
  p_deccopertura,
  p_cdnutente,
  sysdate,
  p_cdnutente,
  sysdate);

  return 0;

  exception
      when others then
         p_errCode := sqlcode;
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return -1;

end InsLavMovimentiDisp;


function InsLavNullaOsta(p_prgNO Cm_Nulla_Osta.Prgnullaosta%type,
                             p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                             p_errCode OUT number
                             ) RETURN NUMBER IS

begin


  INSERT INTO cm_pi_lav_riserva
  (prglavriserva,
  prgprospettoinf,
  cdnlavoratore,
  strcodicefiscalelav,
  strcognomelav,
  strnomelav,
  codmonocategoria,
  codmonotipo,
  codmansione,
  datiniziorapp,
  datfinerapp,
  codcontratto,
  flgconvenzione,
  deccopertura,
  cdnutins,
  dtmins,
  cdnutmod,
  dtmmod)
  select
  s_cm_pi_lav_riserva.nextval,
  p_prgProspettoInf,
  n.cdnlavoratore,
  l.strcodicefiscale,
  l.strcognome,
  l.strnome,
  n.codmonocategoria,
  n.codmonotipo,
  n.codmansione,
  n.datinizio,
  n.datfine,
  null,
  n.flgconvenzione,
  null,
  p_cdnutente,
  sysdate,
  p_cdnutente,
  sysdate
  from cm_nulla_osta n
  inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
  where n.prgnullaosta = p_prgNO;


  return 0;

  exception
      when others then
         p_errCode := sqlcode;
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return -1;

end InsLavNullaOsta;

function GetNumIscrCM(p_codMonoTipoRagg DE_CM_TIPO_ISCR.CODMONOTIPORAGG%TYPE,
       p_cdnLavoratore AM_CM_ISCR.CDNLAVORATORE%TYPE,
       p_codProvincia  TS_CM_NUMERAZIONE.CODPROVINCIAPROV%TYPE
       ) RETURN NUMBER is

p_flgRiutilizzaProgCM ts_generale.flgRiutilizzaProgCM%type;
p_numIscr am_cm_iscr.numiscrizione%type;

begin
 SELECT flgRiutilizzaProgCM
 into p_flgRiutilizzaProgCM
 FROM ts_generale;

 if (p_flgRiutilizzaProgCM = 'S') then

  SELECT MAX(ISCR.numIscrizione)
  INTO p_numIscr
  FROM AM_CM_ISCR ISCR, DE_CM_TIPO_ISCR DE_ISCR
  WHERE ISCR.cdnLavoratore = p_cdnLavoratore
  AND ISCR.CODCMTIPOISCR = DE_ISCR.CODCMTIPOISCR
  AND DE_ISCR.CODMONOTIPORAGG = p_codMonoTipoRagg;

  if (p_numIscr is null) then
   p_numIscr := GetNumCMRegolaGenerale(p_codMonoTipoRagg, p_codProvincia);
  end if;

 elsif (p_flgRiutilizzaProgCM = 'N' OR p_flgRiutilizzaProgCM is null) then
  p_numIscr := GetNumCMRegolaGenerale(p_codMonoTipoRagg, p_codProvincia);
    end if;

    return p_numIscr;

end GetNumIscrCM;

function GetNumCMRegolaGenerale(p_codMonoTipoRagg DE_CM_TIPO_ISCR.CODMONOTIPORAGG%TYPE,
           p_codProvincia  TS_CM_NUMERAZIONE.CODPROVINCIAPROV%TYPE
        ) RETURN NUMBER is

p_numNumerazAlbo ts_cm_numerazione.numNumerazAlbo%type;
p_numKloNumerazione ts_cm_numerazione.numKloNumerazione%type;
p_numRighe number;

begin
 
 SELECT count(*)
 into p_numRighe
 FROM ts_cm_numerazione
 WHERE codmonotipo = p_codMonoTipoRagg
 AND codprovinciaprov = p_codProvincia;
 
 if p_numRighe = 0 then 
  return p_numNumerazAlbo;
 else
   SELECT numNumerazAlbo, numKloNumerazione
   into p_numNumerazAlbo, p_numKloNumerazione
   FROM ts_cm_numerazione
   WHERE codmonotipo = p_codMonoTipoRagg
   AND codprovinciaprov = p_codProvincia;
 
   UPDATE ts_cm_numerazione
   SET numNumerazAlbo = p_numNumerazAlbo + 1,
    numKloNumerazione = p_numKloNumerazione + 1
   WHERE codmonotipo = p_codMonoTipoRagg
   AND codprovinciaprov = p_codProvincia;

 return p_numNumerazAlbo;
 end if; 

exception
 when others then
  return GetNumCMRegolaGenerale(p_codMonoTipoRagg,p_codProvincia);

end GetNumCMRegolaGenerale;

procedure setCondIscrLavCM(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
 p_cdnUtMod TS_UTENTE.CDNUTMOD%TYPE,
 p_encryptKey varchar2
 ) is

checkIscr number;
newCheckIscr number;
newCond varchar2(1);

begin

  checkIscr := PG_INCROCIO.checkFlagCM(p_cdnLavoratore, p_encryptKey);

  SELECT count(1)
  INTO newCheckIscr
  FROM TS_CONFIG_TAB
  WHERE CDNCONFIGTAB = p_cdnLavoratore;

  if (checkIscr = 1) then
   newCond := 'S';
  end if;

  if (checkIscr = 0) then
   newCond := 'N';
  end if;

  if (newCheckIscr = 0) then
 INSERT INTO TS_CONFIG_TAB (CDNCONFIGTAB, FLGABILITA)
    VALUES (p_cdnLavoratore, newCond);
  else
   UPDATE TS_CONFIG_TAB
   SET FLGABILITA = newCond
    WHERE CDNCONFIGTAB = p_cdnLavoratore;
  end if;

end setCondIscrLavCM;


function verificaProspetto(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type
                         ) RETURN typRefCurs is

p_fascia cm_prospetto_inf.codmonocategoria%type;
p_dataPrimaAssunzione cm_prospetto_inf.datprimaassunzione%type;
p_dataSecondaAssunzione cm_prospetto_inf.datsecondaassunzione%type;
p_flgEsonero cm_prospetto_inf.flgesonero%type;
p_numPercEsonero cm_prospetto_inf.numpercesonero%type;
p_flgCompTerritoriale cm_prospetto_inf.flgcompterritoriale%type;
p_prgAzienda cm_prospetto_inf.prgazienda%type;
p_prgUnita cm_prospetto_inf.prgunita%type;
p_numanno cm_prospetto_inf.numannorifprospetto%type;
p_flgobbligol68 an_azienda.flgobbligol68%type;
numCompensazioni number;
p_numCandidatiL68 number;
p_numCandidatiMov number;

err_dataPrimaAssunzione number;
err_percEsonero number;
err_percCompensazione number;
err_flgObbligoL68 number;
err_incrocioMovimenti number;

str varchar(1000);
risultato typRefCurs;


begin

  err_dataPrimaAssunzione := 0;
  err_percEsonero := 0;
  err_percCompensazione := 0;
  err_flgObbligoL68 := 0;
  err_incrocioMovimenti := 0;

  select p.codmonocategoria, p.datprimaassunzione, p.datsecondaassunzione,
  p.flgesonero, p.numpercesonero,
  p.flgcompterritoriale,
  p.prgazienda, p.prgunita, p.numannorifprospetto
  into p_fascia, p_dataPrimaAssunzione, p_dataSecondaAssunzione,
  p_flgEsonero, p_numPercEsonero,
  p_flgCompTerritoriale,
  p_prgAzienda, p_prgunita, p_numanno
  from cm_prospetto_inf p
  where p.prgprospettoinf = p_prgProspettoInf;

  select az.FLGOBBLIGOL68
  into p_flgobbligol68
  from an_azienda az
  where az.prgazienda = p_prgAzienda;

  -- conteggio lavoratori L68 inseriti
  select count(distinct r.strcodicefiscalelav) into p_numCandidatiL68
 from cm_pi_lav_riserva r
 where r.prgprospettoinf = p_prgProspettoInf;

  -- conteggio movimenti dell'azienda
  SELECT count(distinct lav.strcodicefiscale) into p_numCandidatiMov
  FROM AM_MOVIMENTO MOV,
  DE_MV_TIPO_MOV TMOV,
  AN_UNITA_AZIENDA UAZ,
  AN_AZIENDA AZ,
  AN_LAVORATORE LAV,
  DE_COMUNE COM, DE_PROVINCIA PROV ,
  DE_TIPO_CONTRATTO,
  DE_MANSIONE MAN,
  DE_CONTRATTO CON
  WHERE MOV.codTipoMov = TMOV.codTipoMov
  AND MOV.CODTIPOCONTRATTO = DE_TIPO_CONTRATTO.CODTIPOCONTRATTO (+)
  AND uaz.CODCOM = COM.codCom (+)
  AND COM.codProvincia = PROV.codProvincia (+)
  AND MOV.prgAzienda = p_prgAzienda
  AND MOV.prgUnita = p_prgunita
  AND to_char(MOV.datInizioMov, 'YYYY') = p_numanno
 AND MOV.codTipoMov IN ('PRO', 'TRA', 'AVV')
 AND (MOV.flgLegge68 = 'S' OR MOV.codTipoAss IN ('NU2', 'NOH'))
 AND MOV.codStatoAtto = 'PR'
 AND MOV.cdnLavoratore = LAV.cdnLavoratore
 AND MOV.prgAzienda = AZ.prgAzienda
 AND MOV.prgAzienda = UAZ.prgAzienda
 AND MOV.prgUnita = UAZ.prgUnita
 AND UAZ.codCom = COM.codCom
 AND COM.codProvincia = PROV.codProvincia
 AND MAN.Codmansione = MOV.Codmansione
 AND CON.CODCONTRATTO = MOV.Codcontratto;


  -- errore dati generali: mancanza data prima assunzione se FASCIA C
  if (p_fascia = 'C') then
     if (p_dataPrimaAssunzione is null) then
        err_dataPrimaAssunzione := 1;
     end if;
  end if;
  -- errore autorizzazioni: mancanza percentuale esonero
  if (p_flgEsonero = 'S') then
     if (p_numPercEsonero is null) then
        err_percEsonero := 1;
     end if;
  end if;
  -- errore autorizzazioni: mancanza di compensazione territoriale
  if (p_flgCompTerritoriale = 'S') then
     select count(comp.prgcompensaz) into numCompensazioni
     from cm_pi_compensazione comp
     where comp.prgprospettoinf = p_prgProspettoInf;

     if (numCompensazioni = 0 ) then
        err_percCompensazione := 1;
     end if;
  end if;
  -- errore dati generale: azienda non soggetta all'obbligo L68
  if (p_flgobbligol68 is null OR p_flgobbligol68 != 'S') then
     err_flgObbligoL68 := 1;
  end if;
  -- errore lav l.68: numero candidati lav L68 diverso da quello dei movimenti
  if (p_numcandidatil68 <> p_numcandidatimov) then
     err_incrocioMovimenti := 1;
  end if;

  str := 'select ' || err_dataPrimaAssunzione || ' as err_dataPrimaAssunzione ,' ||
                    err_percEsonero || ' as err_percEsonero ,' ||
                    err_percCompensazione || ' as err_percCompensazione ,' ||
                    err_flgObbligoL68 || ' as err_flgObbligoL68 ,' ||
                    err_incrocioMovimenti || ' as err_incrocioMovimenti ' ||
      ' from dual';

  open risultato for str;
  return risultato;

end verificaProspetto;


/********************************************************************************************
* cambia lo stato del prospetto da in corso a storicizzato                                  *
* vengono effettuati i seguenti controlli:                                                  *
* 1) verifica del prospetto                                                                 *
* 2) obbligatorietà data consegna                                                           *
* 3) verifica che non esista nessun prospetto storicizzato per l'azienda, anno e provinicia *
*********************************************************************************************/
function storicizzaProspetto(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE
                             ) RETURN NUMBER is

p_fascia cm_prospetto_inf.codmonocategoria%type;
p_dataPrimaAssunzione cm_prospetto_inf.datprimaassunzione%type;
p_dataSecondaAssunzione cm_prospetto_inf.datsecondaassunzione%type;
p_flgEsonero cm_prospetto_inf.flgesonero%type;
p_numPercEsonero cm_prospetto_inf.numpercesonero%type;
p_flgCompTerritoriale cm_prospetto_inf.flgcompterritoriale%type;
p_prgAzienda cm_prospetto_inf.prgazienda%type;
p_prgUnita cm_prospetto_inf.prgunita%type;
p_numanno cm_prospetto_inf.numannorifprospetto%type;
p_dataConsegna cm_prospetto_inf.datconsegnaprospetto%type;
p_codProvincia cm_prospetto_inf.codprovincia%type;
p_flgobbligol68 an_azienda.flgobbligol68%type;
numCompensazioni number;
p_numCandidatiL68 number;
p_numCandidatiMov number;
checkProspStor number;

err_dataPrimaAssunzione number;
err_percEsonero number;
err_percCompensazione number;
err_flgObbligoL68 number;
err_incrocioMovimenti number;

err_dataConsegnaProseptto number;
err_checkProspStoriciz number;

begin

  -- 1 verifica prospetto
  err_dataPrimaAssunzione := 0;
  err_percEsonero := 0;
  err_percCompensazione := 0;
  err_flgObbligoL68 := 0;
  err_incrocioMovimenti := 0;

  err_dataConsegnaProseptto := 0;

  select p.codmonocategoria, p.datprimaassunzione, p.datsecondaassunzione,
  p.flgesonero, p.numpercesonero,
  p.flgcompterritoriale,
  p.prgazienda, p.prgunita, p.numannorifprospetto,
  p.datconsegnaprospetto, p.codprovincia
  into p_fascia, p_dataPrimaAssunzione, p_dataSecondaAssunzione,
  p_flgEsonero, p_numPercEsonero,
  p_flgCompTerritoriale,
  p_prgAzienda, p_prgunita, p_numanno,
  p_dataConsegna, p_codProvincia
  from cm_prospetto_inf p
  where p.prgprospettoinf = p_prgProspettoInf;

  select az.FLGOBBLIGOL68
  into p_flgobbligol68
  from an_azienda az
  where az.prgazienda = p_prgAzienda;

  -- conteggio lavoratori L68 inseriti
  select count(distinct r.strcodicefiscalelav) into p_numCandidatiL68
  from cm_pi_lav_riserva r
  where r.prgprospettoinf = p_prgProspettoInf;

  -- conteggio movimenti dell'azienda
  SELECT count(distinct lav.strcodicefiscale) into p_numCandidatiMov
  FROM AM_MOVIMENTO MOV,
  DE_MV_TIPO_MOV TMOV,
  AN_UNITA_AZIENDA UAZ,
  AN_AZIENDA AZ,
  AN_LAVORATORE LAV,
  DE_COMUNE COM, DE_PROVINCIA PROV ,
  DE_TIPO_CONTRATTO,
  DE_MANSIONE MAN,
  DE_CONTRATTO CON
  WHERE MOV.codTipoMov = TMOV.codTipoMov
  AND MOV.CODTIPOCONTRATTO = DE_TIPO_CONTRATTO.CODTIPOCONTRATTO (+)
  AND uaz.CODCOM = COM.codCom (+)
  AND COM.codProvincia = PROV.codProvincia (+)
  AND MOV.prgAzienda = p_prgAzienda
  AND MOV.prgUnita = p_prgunita
  AND to_char(MOV.datInizioMov, 'YYYY') = p_numanno
  AND MOV.codTipoMov IN ('PRO', 'TRA', 'AVV')
  AND (MOV.flgLegge68 = 'S' OR MOV.codTipoAss IN ('NU2', 'NOH'))
  AND MOV.codStatoAtto = 'PR'
  AND MOV.cdnLavoratore = LAV.cdnLavoratore
  AND MOV.prgAzienda = AZ.prgAzienda
  AND MOV.prgAzienda = UAZ.prgAzienda
  AND MOV.prgUnita = UAZ.prgUnita
  AND UAZ.codCom = COM.codCom
  AND COM.codProvincia = PROV.codProvincia
  AND MAN.Codmansione = MOV.Codmansione
  AND CON.CODCONTRATTO = MOV.Codcontratto;

  -- errore dati generali: mancanza data prima assunzione se FASCIA C
  if (p_fascia = 'C') then
     if (p_dataPrimaAssunzione is null) then
        err_dataPrimaAssunzione := 1;

        --return 1;
     end if;
  end if;
  -- errore autorizzazioni: mancanza percentuale esonero
  if (p_flgEsonero = 'S') then
     if (p_numPercEsonero is null) then
        err_percEsonero := 1;

        return 2;
     end if;
  end if;
  -- errore autorizzazioni: mancanza di compensazione territoriale
  if (p_flgCompTerritoriale = 'S') then
     select count(comp.prgcompensaz) into numCompensazioni
     from cm_pi_compensazione comp
     where comp.prgprospettoinf = p_prgProspettoInf;

     if (numCompensazioni = 0 ) then
        err_percCompensazione := 1;

        return 3;
     end if;
  end if;

  -- 2 data consegna prospetto obbligatoria
  if (p_dataConsegna is null) then
     err_dataConsegnaProseptto := 1;

     return 4;
  end if;

  -- 3 verifica che azienda, provincia e anno non siano ripetuti per prospetti storicizzati
  select count(pros.prgprospettoinf) into checkProspStor
  from cm_prospetto_inf pros
  where pros.prgazienda = p_prgAzienda
  and pros.codprovincia = p_codProvincia
  and pros.numannorifprospetto = p_numanno
  and pros.CODMONOSTATOPROSPETTO in ('S','U')
  and pros.datconsegnaprospetto = p_dataconsegna;

  if (checkProspStor > 0) then
     err_checkProspStoriciz := 1;

     return 5;
  end if;

  -- 4 viene storicizzato il prospetto
  update cm_prospetto_inf
  set CODMONOSTATOPROSPETTO = 'S',
       NUMKLOPROSPETTOINF=NUMKLOPROSPETTOINF+1,
       CDNUTMOD=p_cdnUtente,
       DTMMOD=sysdate
   where
     cm_prospetto_inf.prgprospettoinf = p_prgprospettoinf;

  return 0;

  exception
      when others then
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return -1;

end storicizzaProspetto;


/***************************************************************************************
* genera una nuovo del prospettoin corso d'anno dal prospetto storicizzato o annullato *
***************************************************************************************/
function generaCopiaProspetto(p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                             p_codProvincia cm_prospetto_inf.codprovincia%type,
                             p_numAnnoRifProspetto cm_prospetto_inf.numannorifprospetto%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                             p_out_prgprospettoinf OUT cm_prospetto_inf.prgprospettoinf%type
                             ) RETURN NUMBER is

codprovinciasil ts_generale.codprovinciasil%type;
checkProviniciaInterna number;
checkExistProsp number;
newPrgProspetto cm_prospetto_inf.prgprospettoinf%type;
p_prgAzienda cm_prospetto_inf.prgazienda%type;
p_prgUnita cm_prospetto_inf.prgunita%type;

  begin

      -- recupero la provinica del sil
      -- per verificare se il prospetto fa riferiment ad una provinica interna o esterna
      SELECT codprovinciasil into codprovinciasil
      FROM ts_generale;

      if (codprovinciasil = p_codProvincia) then
         checkProviniciaInterna := 1;
      else
         checkProviniciaInterna := 0;
      end if;

      -- verifica che esiste già un prospetto in corso d'anno per azienda, provincia, anno
      select p.prgazienda, p.prgunita into p_prgAzienda, p_prgUnita
      from cm_prospetto_inf p
      where p.prgprospettoinf = p_prgprospettoinf;

      select count(p.prgprospettoinf) into checkExistProsp
      from cm_prospetto_inf p
      where p.prgazienda = p_prgazienda
      and p.codprovincia = p_codprovincia
      and p.numannorifprospetto = p_numannorifprospetto
      and p.codmonostatoprospetto = 'A';

      -- errore prospetto duplicato
      if (checkExistProsp > 0) then
         return 1;
      end if;

      -- inizio copia del prospetto
      select s_cm_prospetto_inf.nextval into newprgprospetto from dual;

      p_out_prgprospettoinf := newprgprospetto;

      if (checkProviniciaInterna = 1) then

         insert into cm_prospetto_inf
          (prgprospettoinf,
            prgazienda,
            prgunita,
            prgazreferente,
            numoreccnl,
            codprovincia,
            codmonostatoprospetto,
            codmonoprov,
            numannorifprospetto,
            datconsegnaprospetto,
            numdipendentinazionale,
            codmonocategoria,
            numdipendentitot,
            numbasecomputo,
            numquotadisabili,
            numdisabilinom,
            numdisabilinum,
            numquotaart18,
            numart18nom,
            numart18num,
            datprimaassunzione,
            datsecondaassunzione,
            numdisforza,
            numart18forza,
            flgesonero,
            numpercesonero,
            flggradualita,
            flgcompterritoriale,
            flgsospensione,
            numconvenzioni,
            strnote,
            cdnutins,
            dtmins,
            cdnutmod,
            dtmmod)
          select
            newprgprospetto,
            pro.prgazienda,
            pro.prgunita,
            pro.prgazreferente,
            pro.numoreccnl,
            p_codprovincia,
            'A',
            pro.codmonoprov,
            p_numannorifprospetto,
            pro.datconsegnaprospetto,
            pro.numdipendentinazionale,
            pro.codmonocategoria,
            pro.numdipendentitot,
            pro.numbasecomputo,
            pro.numquotadisabili,
            pro.numdisabilinom,
            pro.numdisabilinum,
            pro.numquotaart18,
            pro.numart18nom,
            pro.numart18num,
            pro.datprimaassunzione,
            pro.datsecondaassunzione,
            pro.numdisforza,
            pro.numart18forza,
            pro.flgesonero,
            pro.numpercesonero,
            pro.flggradualita,
            pro.flgcompterritoriale,
            pro.flgsospensione,
            pro.numconvenzioni,
            pro.strnote,
            p_cdnutente,
            sysdate,
            p_cdnutente,
            sysdate
          from cm_prospetto_inf pro
          where pro.prgprospettoinf = p_prgProspettoInf;

      else

          insert into cm_prospetto_inf
          (prgprospettoinf,
            prgazienda,
            prgunita,
            prgazreferente,
            numoreccnl,
            codprovincia,
            codmonostatoprospetto,
            codmonoprov,
            numannorifprospetto,
            datconsegnaprospetto,
            numdipendentinazionale,
            codmonocategoria,
            numdipendentitot,
            numbasecomputo,
            numquotadisabili,
            numdisabilinom,
            numdisabilinum,
            numquotaart18,
            numart18nom,
            numart18num,
            datprimaassunzione,
            datsecondaassunzione,
            numdisforza,
            numart18forza,
            flgesonero,
            numpercesonero,
            flggradualita,
            flgcompterritoriale,
            flgsospensione,
            numconvenzioni,
            strnote,
            cdnutins,
            dtmins,
            cdnutmod,
            dtmmod)
          select
            newprgprospetto,
            pro.prgazienda,
            pro.prgunita,
            pro.prgazreferente,
            pro.numoreccnl,
            p_codprovincia,
            'A',
            pro.codmonoprov,
            p_numannorifprospetto,
            pro.datconsegnaprospetto,
            pro.numdipendentinazionale,
            pro.codmonocategoria,
            pro.numdipendentitot,
            pro.numbasecomputo,
            pro.numquotadisabili,
            pro.numdisabilinom,
            pro.numdisabilinum,
            pro.numquotaart18,
            pro.numart18nom,
            pro.numart18num,
            pro.datprimaassunzione,
            pro.datsecondaassunzione,
            pro.numdisforza,
            pro.numart18forza,
            null,
            null,
            null,
            null,
            null,
            null,
            pro.strnote,
            p_cdnutente,
            sysdate,
            p_cdnutente,
            sysdate
          from cm_prospetto_inf pro
          where pro.prgprospettoinf = p_prgProspettoInf;

      end if;

      insert into cm_esclusione_prospetto
      (prgprospettoinf,
      numdirigenti,
      numcigs,
      numapprendisti,
      numcfl,
      numparttime,
      numtdmeno9mesi,
      numtemporaneo,
      numreinserimento,
      numdomicilio,
      numsoci,
      numdisabili,
      numprotette,
      numaltri)
      select
      newprgprospetto,
      escl.numdirigenti,
      escl.numcigs,
      escl.numapprendisti,
      escl.numcfl,
      escl.numparttime,
      escl.numtdmeno9mesi,
      escl.numtemporaneo,
      escl.numreinserimento,
      escl.numdomicilio,
      escl.numsoci,
      escl.numdisabili,
      escl.numprotette,
      escl.numaltri
      from cm_esclusione_prospetto escl
      where escl.prgprospettoinf = p_prgprospettoinf;

      insert into cm_parttime_prospetto
      (prgparttimeprospetto,
      prgprospettoinf,
      numlavoratori,
      decorelavorate,
      decoretotali)
      select
      s_cm_parttime_prospetto.nextval,
      newprgprospetto,
      numlavoratori,
      decorelavorate,
      decoretotali
      from cm_parttime_prospetto pp
      where pp.prgprospettoinf = p_prgprospettoinf;


      -- solamente se fa riferimento ad una provincia interna
      -- bisogna inserire i lavoratori L68, posti disponibili e compensazioni
      if (checkProviniciaInterna = 1) then

        insert into cm_pi_lav_riserva
        (prglavriserva,
        prgprospettoinf,
        cdnlavoratore,
        strcodicefiscalelav,
        strcognomelav,
        strnomelav,
        codmonocategoria,
        codmonotipo,
        codmansione,
        datiniziorapp,
        datfinerapp,
        codcontratto,
        decorelavorate,
        decoretotali,
        flgconvenzione,
        strnote,
        deccopertura,
        cdnutins,
        dtmins,
        cdnutmod,
        dtmmod)
        select
        s_cm_pi_lav_riserva.nextval,
        newprgprospetto,
        plr.cdnlavoratore,
        plr.strcodicefiscalelav,
        plr.strcognomelav,
        plr.strnomelav,
        plr.codmonocategoria,
        plr.codmonotipo,
        plr.codmansione,
        plr.datiniziorapp,
        plr.datfinerapp,
        plr.codcontratto,
        plr.decorelavorate,
        plr.decoretotali,
        plr.flgconvenzione,
        plr.strnote,
        plr.deccopertura,
        p_cdnutente,
        sysdate,
        p_cdnutente,
        sysdate
        from cm_pi_lav_riserva plr
        where plr.prgprospettoinf = p_prgprospettoinf;


        insert into cm_pi_mansione_disp
        (prgmansionidisp,
        prgprospettoinf,
        codmansione,
        numposti,
        codmonocategoria,
        strnote,
        cdnutins,
        dtmins,
        cdnutmod,
        dtmmod)
        select
        s_cm_pi_mansione_disp.nextval,
        newprgprospetto,
        pmd.codmansione,
        pmd.numposti,
        pmd.codmonocategoria,
        pmd.strnote,
        p_cdnutente,
        sysdate,
        p_cdnutente,
        sysdate
        from cm_pi_mansione_disp pmd
        where pmd.prgprospettoinf = p_prgprospettoinf;

        insert into cm_pi_compensazione
        (prgcompensaz,
        prgprospettoinf,
        codprovincia,
        strsede,
        codmonoeccdiff,
        codmonocategoria,
        NUMINTERESSATI)
        select
        s_cm_pi_compensazione.nextval,
        newprgprospetto,
        pc.codprovincia,
        pc.strsede,
        pc.codmonoeccdiff,
        pc.codmonocategoria,
        pc.numinteressati
        from cm_pi_compensazione pc
        where pc.prgprospettoinf = p_prgprospettoinf;

      end if;

      return 0;

  exception
      when others then
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return -1;

end generaCopiaProspetto;


/************************************************************************************
* Funzione per la predisposizione dell'asta per le adesioni del collocamneto mirato *
*************************************************************************************/
function CMcreaRosaNomGrezza(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,     -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_codMonoTipoGrad DO_RICHIESTA_AZ.Codmonotipograd%type,
    p_codEvasione Do_Evasione.Codevasione%type,
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,      -- utente che effettua l'incrocio
    p_errCode OUT number,         -- Codice di Errore
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE, -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE    -- progressivo della rosa
) RETURN NUMBER IS
  p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
  check_codEvasione DO_EVASIONE.CODEVASIONE%TYPE;
  p_Originale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;
  p_TipoIncrocio DE_TIPO_INCROCIO.PRGTIPOINCROCIO%TYPE;
  p_TipoRosa DO_ROSA.PRGTIPOROSA%TYPE;
  p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE;
  checkIncrocio number;

  -- cursore sui vari tipi di incrocio possibile per la creazione della rosa
  /* possibili valori sono :
      10
      11
      12
   */
  CURSOR tipiIncrocioCursor IS
      SELECT ti.prgTipoIncrocio AS prgTipoIncrocio
      FROM De_Tipo_Incrocio ti
      WHERE ti.prgtipoincrocio IN (10,11,12);

  -- cursore sui tipi di profilo per la richiesta selezionata
  CURSOR tipiProfiliCursor IS
      SELECT al.prgAlternativa AS prgAlternativa
      FROM do_alternativa al
      WHERE al.prgrichiestaaz = p_prgRichiestaAz;

begin

   -- controllo che la richiesta sia relativa al CM
   -- se è diversa esco senza dare messaggio di errore (posso trovarmi nel caso
   -- di creazione del profilo)
   SELECT dev.codevasione into check_codEvasione
   FROM DO_EVASIONE dev
   WHERE dev.PRGRICHIESTAAZ = p_prgRichiestaAz;

   if (p_codEvasione = '') then
      if (check_codEvasione != 'CMA' AND check_codEvasione != 'CMG' )  then
         return 0;
      end if;
   elsif (p_codEvasione is null) then
      if (check_codEvasione is null) then
         return 0;
      elsif (check_codEvasione != 'CMA' AND check_codEvasione != 'CMG' )  then
         return 0;
      end if;
   elsif (p_codEvasione != 'CMA' AND p_codEvasione != 'CMG') then
      return 0;
   end if;

   -- Controllo che la richiesta non sia stata CHIUSA mentre si accedeva all'incrocio
  SELECT RICH2.PRGRICHIESTAAZ INTO p_Originale
  FROM DO_RICHIESTA_AZ RICH1
         INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
     WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;
  -- Per la rosa nominativa controllo la chiusura totale e la chiusura
  SELECT do_evasione.CDNSTATORICH into p_cdnStatoRich
  FROM DO_RICHIESTA_AZ, DO_EVASIONE
  WHERE (DO_RICHIESTA_AZ.PRGRICHIESTAAZ=DO_EVASIONE.PRGRICHIESTAAZ)
  AND DO_RICHIESTA_AZ.PRGRICHIESTAAZ=p_Originale;
  if(p_cdnStatoRich=5) then
   return 2;
   elsif (p_cdnStatoRich=4) then
   return 3;
  end if;

   -- verificare se ho già salvato (posso vedere se già esiste per i profili lo stesso prgrichiestaAz)
   -- ciclo sul cursore dei profili per recuperare tutti i profili per quella richiesta
   FOR profilo in tipiProfiliCursor
   LOOP

      p_prgAlternativa :=  profilo.prgAlternativa;

      -- ciclo sul cursor per recuperare i tipi di incrocio possibili per il CM
      FOR tipiIncrocio in tipiIncrocioCursor
      LOOP
         p_TipoIncrocio := tipiIncrocio.prgTipoIncrocio;

         -- verifico che per la terna di valori prgAlternativa, prgRichiestaAz, prgTipoIncrocio
         -- 1) se esiste nessun record in do_incrocio salto l'insrimento dell'incrocio
         -- 2) se non esiste inserisco l'incrocio e la rosa corrispondente
         SELECT COUNT(inc.prgIncrocio) into checkincrocio FROM do_incrocio inc
         WHERE inc.prgrichiestaaz = p_prgRichiestaAz
         AND inc.prgalternativa = p_prgAlternativa
         AND inc.prgtipoincrocio = p_TipoIncrocio;

         IF (checkincrocio = 0) THEN

           if (p_TipoIncrocio = 10) then
              p_TipoRosa := 1;
           elsif (p_TipoIncrocio = 11) then
              p_TipoRosa := 1;
           elsif (p_TipoIncrocio = 12) then
             p_TipoRosa := 2;
          end if;

          -- Calcolo il progressivo per la rosa e per l'incrocio
          select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
          select S_DO_ROSA.nextVal into p_out_prgRosa from dual;
          --dbms_output.put_line('Prg Incrocio=' || p_out_prgIncrocio || ' - Prg Rosa=' || p_out_prgRosa);
          -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio, inserisce anche il prgAlternativa
          insert into do_incrocio
          (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
          cdnUtIns, dtmIns, cdnUtMod, dtmMod)
          values
          (p_out_prgIncrocio, p_prgRichiestaAz, p_prgAlternativa, p_TipoIncrocio, 'C',
          p_cdnUtente, sysdate, p_cdnUtente, sysdate);
          -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
          insert into do_rosa
          (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
          values
          (p_out_prgRosa, null, p_out_prgIncrocio, p_TipoRosa, p_cdnUtente, sysdate, p_cdnUtente, sysdate);
          -- NB. Per le rose nomninative NON memorizzo i parametri dell'incrocio

         END IF;

     END LOOP;

   END LOOP;

   commit;

  return 0;

  exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;
end CMcreaRosaNomGrezza;

/**************************************************************************************
* Funzione per la cancellazione di una adesione per il lavoratore specifico           *
* e il cambio dello stato della rosa a temporanea se non vi sono altre adesioni       *
***************************************************************************************/
function CMDeleteAdesioneLavoratore(
    p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
      p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,                  -- progressivo dell'adesione
    p_errCode OUT number           -- Codice di Errore
) RETURN NUMBER IS

p_out_prgTipoRosa DO_ROSA.Prgtiporosa%TYPE;
p_out_dataIns DO_NOMINATIVO.Dtmins%TYPE;
checkAdesioni number;
checkDeleteContatto number;
p_prgRichiestaAz DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE;
p_prgincrocio DO_INCROCIO.PRGINCROCIO%TYPE;
checkNominativi number;
checkDelStoria number;
p_statoRich number;
begin

  select nom.dtmins into p_out_dataIns
  from do_nominativo nom
  where nom.prgnominativo = p_prgNominativo;


   select do_rosa.prgtiporosa, do_rosa.prgincrocio
          into p_out_prgtiporosa, p_prgincrocio
   from do_rosa
   where do_rosa.prgrosa = p_prgRosa;


   if (p_out_prgtiporosa = 2) then

      -- passo 1: cancello il punteggio riferito al lavoratore
       delete from cm_punteggio
                 where PRGNOMINATIVO = p_prgNominativo;

       -- passo 2: cancello l'adesione
       delete from do_nominativo
                 where PRGNOMINATIVO = p_prgNominativo
                 and CDNLAVORATORE = p_cdnLavoratore;

       -- controllo se vi sono altre adesione per la stessa richiesta
       -- per update rosa: non si aggiorna la rosa a temporanea perchè ci sono altre adesioni
       -- errore non bloccante
       select count(n.prgnominativo) into checkAdesioni
              from do_nominativo n
              where n.prgrosa = p_prgRosa
              and n.cdnlavoratore != p_cdnLavoratore;

       if (checkAdesioni = 0) then

         -- passo 2: aggiorno la rosa da grezza a temporanea
         UPDATE DO_ROSA
              SET DO_ROSA.PRGTIPOROSA = 1,
                 DO_ROSA.NUMKLOROSA = (SELECT TO_NUMBER(DO_ROSA.NUMKLOROSA+1) FROM DO_ROSA DOS WHERE DOS.PRGROSA = DO_ROSA.PRGROSA)
            WHERE DO_ROSA.PRGROSA = p_prgRosa;

       end if;

       -- passo 3: aggiorno lo stato di evasione della richiesta a INSERITA
       -- si controlla se vi sono altri nominativi che aderiscono sulla richiesta
       -- si controlla se la richiesta è in stato elaborazione match
       select inc.prgrichiestaaz into p_prgRichiestaAz
         from do_incrocio inc
         inner join do_rosa r on r.prgincrocio = inc.prgincrocio
         where r.prgrosa = p_prgrosa;

       select DO_EVASIONE.CDNSTATORICH into p_statoRich
       from DO_EVASIONE
       WHERE DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;

       if (p_statoRich = 2) then
         select count(n.prgnominativo) into checkNominativi
         from do_nominativo n
         where n.prgrosa IN
         (select r.prgrosa
                 from do_rosa r
                 inner join do_incrocio inc on inc.prgincrocio = r.prgrosa
                 where inc.prgrichiestaaz = p_prgRichiestaAz
                 and r.prgrosafiglia is null
                 and (r.prgtiporosa = 2 or r.prgtiporosa = 3));

         if (checkNominativi = 0) then

           UPDATE DO_EVASIONE
               SET DO_EVASIONE.CDNSTATORICH = 1,
                   DO_EVASIONE.DTMMOD = SYSDATE
               WHERE DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;

          end if;
       end if;

    else
       -- errore tipoRosa: la rosa non è grezza impossibile eliminare l'adesione
       return 1;
    end if;

    commit;

    return 0;


 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end CMDeleteAdesioneLavoratore;

/**************************************************************************************
* Funzione per l'inserimento di una adesione per il lavoratore specifico alla richiesta *
***************************************************************************************/
function CMInsertAdesioneLavoratore(p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
                                    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
                                    p_mesiSospensione number,
                                    p_prgSpiContatto Ag_Contatto.Prgspicontatto%TYPE,                 -- operatore selezionato
                                    p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
                                    p_cdnGruppo Ts_Gruppo.Cdngruppo%TYPE,                       -- gruppo a cui fa parte l'utente
                                    encrypterKey varchar2,
                                    p_qualifica varchar2,
                                    p_errCode OUT number           -- Codice di Errore
                                    ) RETURN NUMBER IS

p_out_prgNominativo DO_NOMINATIVO.Prgnominativo%TYPE;
p_prgRichiestaAz DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE;
p_prgincrocio DO_INCROCIO.Prgincrocio%TYPE;
p_prgAlternativa DO_INCROCIO.Prgalternativa%TYPE;
p_prgTipoIncrocio DO_INCROCIO.Prgtipoincrocio%TYPE;
statorich do_evasione.cdnstatorich%TYPE;
checkTipoInc number;
checkPunteggio number;
checkAdesione number;
checkReddito number;
checkDisocInoc number;
checkArt8 number;
checkArt18 number;
checkEsito number;
p_cdnLavEncrypt varchar2(255);
p_annoCM do_richiesta_az.numannoredditocm%type;
p_datChiamataCM do_richiesta_az.datchiamatacm%type;

p_codmonotipogradcm number;

begin

  select codmonotipogradcm into p_codmonotipogradcm from ts_generale;

  select i.prgtipoincrocio, i.prgincrocio, i.prgrichiestaaz, i.prgalternativa, i.prgtipoincrocio
         into checkTipoInc, p_prgincrocio, p_prgRichiestaAz, p_prgAlternativa, p_prgTipoIncrocio
  from do_rosa d
  inner join do_incrocio i on i.prgincrocio = d.prgincrocio
  WHERE d.PRGROSA = p_prgRosa;

  -- deve aver dichiarato il reddito
  select raz.numannoredditocm, raz.datchiamatacm
  into p_annoCM, p_datChiamataCM
  from do_richiesta_az raz
  inner join do_incrocio i on i.prgrichiestaaz = raz.prgrichiestaaz
  inner join do_rosa r on r.prgincrocio = i.prgincrocio
  WHERE r.PRGROSA = p_prgRosa;

  -- controlli sul lavoratore
  p_cdnLavEncrypt := encrypt(p_cdnLavoratore,encrypterKey);

  -- se Art.8 deve avere una iscrizione attiva al CM come disabile
  if (checkTipoInc = 10)  then
    select count(i.prgcmiscr) into checkArt8
    from am_cm_iscr i
    inner join de_cm_tipo_iscr t on t.codcmtipoiscr = i.codcmtipoiscr
    INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
    INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
    WHERE DOC.CODSTATOATTO = 'PR' and DOC.cdnlavoratore = p_cdnLavoratore
    and i.cdnlavoratore = p_cdnLavEncrypt
    and (i.datdatafine is null OR trunc(i.datdatafine) > trunc(p_datChiamataCM))
    and t.codmonotiporagg = 'D';

    if (checkArt8 = 0) then
       rollback;

       return 4;
    end if;
  end if;

  -- se Art.18 deve avere una iscrizione attiva al CM come altra categoria protetta
  if (checkTipoInc = 11)  then
    select count(i.prgcmiscr) into checkArt18
    from am_cm_iscr i
    inner join de_cm_tipo_iscr t on t.codcmtipoiscr = i.codcmtipoiscr
    INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
    INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
    WHERE DOC.CODSTATOATTO = 'PR' and DOC.cdnlavoratore = p_cdnLavoratore
    and i.cdnlavoratore = p_cdnLavEncrypt
    and (i.datdatafine is null OR trunc(i.datdatafine) > trunc(p_datChiamataCM))
    and t.codmonotiporagg = 'A';

    if (checkArt18 = 0) then
       rollback;

       return 5;
    end if;
  end if;

  if (p_codmonotipogradcm = 4) then
    -- per la VDA deve essere valorizzato il reddito ISEE   
    -- la data v.datinizioval deve esser >= p_datChiamataCM - 12 mesi
    select count(v.numvaloreisee) into checkReddito
        from AS_VALORE_ISEE v
        where v.cdnlavoratore = p_cdnLavoratore        
        and v.datinizioval <= p_datChiamataCM
        and v.datinizioval >= add_months(p_datChiamataCM, -12)
        and (v.datfineval >= p_datChiamataCM 
             or v.datfineval is null);
        
    if (checkReddito = 0) then
       rollback;
       --errore reddito ISEE  e data chiamata 12 mesi - codice errore 9 
       return 9;
    end if;
  elsif (p_codmonotipogradcm != 3 and p_codmonotipogradcm != 4) then
    select count(cmr.prglavreddito) into checkReddito
    from cm_lav_reddito cmr
    where cmr.cdnlavoratore = p_cdnLavoratore
    and cmr.numanno = p_annoCM;
    if (checkReddito = 0) then
       rollback;
       --errore reddito
       return 6;
    end if;
  end if;

  -- deve essere disoccupato i inoccopato
  select count(o.prgstatooccupaz) into checkDisocInoc
  from am_stato_occupaz  o
  inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
  where cdnLavoratore = p_cdnLavoratore
  and o.datfine is null
  and s.codstatooccupazragg in ('D', 'I');
  if (checkDisocInoc = 0) then
     rollback;
     --errore stato occupazionale
     return 7;
  end if;
  
  if (p_codmonotipogradcm = 4) then
    -- per la VDA non ci devono essere altre adesioni al CM 
    -- senza esito
    select count(1) into checkEsito
    from as_avv_selezione av
    where av.cdnlavoratore = p_cdnLavoratore
    and av.codesitoavvsel is null
    and av.prgtipoincrocio in (10,11,12);
    
    if (checkEsito > 0) then              
       rollback;
       --errore adesioni senza esito
       return 8;
    end if;
  end if;
  
  -- verifico che si è già inserito l'adesione per quella graduatoria in un proflo diverso
  select count(nom.prgnominativo) into checkAdesione
  from do_nominativo nom
  inner join do_rosa ros on ros.prgrosa = nom.prgrosa
  inner join do_incrocio inc on inc.prgincrocio = ros.prgincrocio
  inner join do_richiesta_az rich on rich.prgrichiestaaz = inc.prgrichiestaaz
  where nom.cdnlavoratore = p_cdnLavoratore
  and inc.prgtipoincrocio = p_prgTipoIncrocio
  and rich.prgrichiestaaz = p_prgRichiestaAz
  and ros.prgrosafiglia is null;

  -- errore non è possibile inserire due adesioni per la stesso tipo di graduatoria e profili diversi
  if (checkAdesione >= 1) then
     rollback;
     return 3;
  end if;

  -- Calcolo il progressivo per il nominativo
  select s_Do_Nominativo.nextVal into p_out_prgNominativo from dual;

  -- passo 1. inserisco la nuova adesione in do_nominativo per la rosa specifica
  insert into do_nominativo
  (PRGNOMINATIVO, CDNLAVORATORE, DTMINS, CDNUTINS, PRGROSA, CDNQUALIFICATO)
  values
  (p_out_prgNominativo, p_cdnLavoratore, sysdate, p_cdnUtente, p_prgRosa, p_qualifica);

  -- passo 2. aggiorno la rosa da temporanea a grezza
  UPDATE DO_ROSA
        SET DO_ROSA.PRGTIPOROSA = 2,
           DO_ROSA.NUMKLOROSA = (SELECT TO_NUMBER(DO_ROSA.NUMKLOROSA+1) FROM DO_ROSA DOS WHERE DOS.PRGROSA = DO_ROSA.PRGROSA)
      WHERE DO_ROSA.PRGROSA = p_prgRosa;


  -- passo 3. calcolo il punteggio del lavoratore
  checkPunteggio := calcoloPunteggioLavoratore(p_out_prgNominativo,
                                     'CM',
                                     p_mesiSospensione,
                                     p_cdnUtente,
                                     p_cdnLavEncrypt,
                                     p_errCode);

   -- cambio lo stato della richiesta ad ELABORAZIONE MATCH solamente se lo stato precedente è "inserita"
   select DO_EVASIONE.CDNSTATORICH into statorich from DO_EVASIONE where DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;

   if (statorich = 1) then
     UPDATE DO_EVASIONE
         SET DO_EVASIONE.CDNSTATORICH = 2,
             DO_EVASIONE.DTMMOD = SYSDATE
         WHERE DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;
   end if;

   return 0;

   exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end CMInsertAdesioneLavoratore;

/***************************************************************************************************
* rende definitive tutte le graduatorie di quel tipo e ricalcola la posizione di ciascun lavoratore*
***************************************************************************************************/
function CMSetGraduatoriaDefinitiva(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                                    p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                                    p_key varchar2)
                                   RETURN NUMBER IS

retNumber number;
p_cdnStatoRich number;

CURSOR roseCursor IS
    select r.prgrosa
    from do_richiesta_az rich
    inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
    inner join do_rosa r on r.prgincrocio = inc.prgincrocio
    inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
    where rich.prgrichiestaaz = p_prgRichiestaAz
    and inc.prgtipoincrocio = p_prgTipoIncrocio
    and r.prgrosafiglia is null
    and r.prgtiporosa = 2
    and a.prgalternativa = inc.prgalternativa;

begin

   retNumber := CMCalcolaPosizione(p_prgRichiestaAz, p_prgTipoIncrocio, p_key);
   retnumber := 0;

   if (retnumber = 0) then

      FOR rose IN roseCursor
      LOOP
           update do_rosa
           set do_rosa.prgTipoRosa = 3,
           do_rosa.NUMKLOROSA = NUMKLOROSA+1
               where do_rosa.prgRosa = rose.prgrosa;

      END LOOP;

     SELECT DO_EVASIONE.CDNSTATORICH into p_cdnStatoRich
     FROM DO_EVASIONE, DO_RICHIESTA_AZ
     WHERE DO_EVASIONE.PRGRICHIESTAAZ = DO_RICHIESTA_AZ.PRGRICHIESTAAZ
     AND DO_RICHIESTA_AZ.Prgrichiestaaz = p_prgRichiestaAz
     AND DO_RICHIESTA_AZ.NUMSTORICO = 0;

     if (p_cdnStatoRich = 2) then
       -- setto lo stato di evasione ad elaborata
       UPDATE DO_EVASIONE
       SET DO_EVASIONE.CDNSTATORICH = 3,
           DO_EVASIONE.DTMMOD = SYSDATE
       WHERE DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;
     end if;
   end if;

   commit;

   return retNumber;

   exception
    when others then
    dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
     rollback;
         return -1;

end CMSetGraduatoriaDefinitiva;

/***************************************************************************************************
* gestisce la riapertura di una graduatoria:                                                       *
* inserisce il motivo di riapertura                                                                *
* per ogni graduatoria definitiva dello stesso tipo viene creata una nuova graduatoria grezza      *
***************************************************************************************************/
function CMRiapriGraduatorie(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                             p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                             p_prgRosa Do_Rosa.Prgrosa%TYPE,
                             p_motivo varchar2,
                             cdnutmod varchar2,
                             p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,               -- progressivo dell'incrocio
                             p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE,                        -- progressivo della rosa
                             p_errCode OUT number                                             -- Codice di Errore
                             )
                            RETURN NUMBER IS

checkNumber number;
p_cdnStatoRich number;
p_out_prgMotivo number;

CURSOR roseCursor IS
    select r.prgrosa, r.numklorosa, inc.prgincrocio
    from do_richiesta_az rich
    inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
    inner join do_rosa r on r.prgincrocio = inc.prgincrocio
    inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
    where rich.prgrichiestaaz = p_prgRichiestaAz
    and inc.prgtipoincrocio = p_prgTipoIncrocio
    and r.prgrosafiglia is null
    and r.prgtiporosa = 3
    and a.prgalternativa = inc.prgalternativa;

begin

     -- Calcolo il progressivo per la motivazione
     select S_AS_MOTIVO_APERTURAGRAD.nextVal into p_out_prgMotivo from dual;

     -- inserisco il motivo nella tabella AS_MOTIVO_APERTURAGRAD
     insert into as_motivo_aperturagrad
     (prgmotivoaperturagrad, strmotivo, cdnutins, dtmins)
     values
     (p_out_prgMotivo, p_motivo, cdnutmod, sysdate);

      FOR rose IN roseCursor
      LOOP
          -- manca l'inserimento della motivazione
          checkNumber := CMGestioneRiapertura(rose.prgrosa,
                                            rose.numklorosa,
                                            rose.prgIncrocio,
                                            cdnutmod,
                                            p_out_prgMotivo
                                            );

          if (checknumber = 1) then
             return checknumber;
          end if;

      END LOOP;

     -- recupero i nuovi prgrosa e prgincrocio della rosa riaperta che sto visualizzando
     select ros.prgrosafiglia into p_out_prgRosa
     from do_rosa ros
     where ros.prgrosa = p_prgRosa;

     select ros.prgincrocio into p_out_prgIncrocio
     from do_rosa ros
     where ros.prgrosa = p_out_prgRosa;

    commit;

    return 0;

    exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end CMRiapriGraduatorie;

/***************************************************************************************************
* gestisce le operazione per la riapertura di una graduatoria                                      *
*(viene chiamata all'interno della funzione precedente)                                            *
***************************************************************************************************/
function CMGestioneRiapertura(p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa da copiare
                                p_numklorosa Do_Rosa.Numklorosa%TYPE,                             -- Numklorosa della rosa da aggiornare
                                p_prgIncrocio Do_Incrocio.Prgincrocio%TYPE,                       -- progressivo dell'incricio da copiare
                                p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
                                p_prgMotivo AS_MOTIVO_APERTURAGRAD.Prgmotivoaperturagrad%TYPE
                                ) RETURN NUMBER is

p_out_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE;
p_out_prgRosa DO_ROSA.PRGROSA%TYPE;
p_out_prgNominativo DO_NOMINATIVO.PRGNOMINATIVO%TYPE;
p_old_prgNominativo DO_NOMINATIVO.PRGNOMINATIVO%TYPE;

CURSOR nominativiCursor IS
   select PRGNOMINATIVO,
   CDNLAVORATORE
   from do_nominativo
   where do_nominativo.prgRosa = p_prgRosa;

begin

   -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;

  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  select p_out_prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  p_cdnUtente, sysdate, p_cdnUtente, sysdate
   from do_incrocio
   where do_incrocio.prgIncrocio = p_prgIncrocio;

   -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  select p_out_prgRosa, null, p_out_prgIncrocio, 2, p_cdnUtente, sysdate, p_cdnUtente, sysdate
   from do_rosa
   where do_rosa.prgRosa = p_prgRosa
   and do_rosa.prgIncrocio = p_prgIncrocio;


  FOR nominativi IN nominativiCursor
  LOOP
      p_old_prgNominativo := nominativi.PRGNOMINATIVO;

      select s_do_nominativo.nextVal into p_out_prgNominativo from dual;

      -- passo 3: insersco tutti i nominativi della rosa madre nella nuova rosa figlia
      insert into do_nominativo
     (PRGNOMINATIVO,
     CDNLAVORATORE,
     NUMORDINE,
     CODCPITIT,
     CODTIPOINS,
     DTMINS,
     CDNUTINS,
     CODTIPOCANC,
     STRMOTIVOCANC,
     DTMCANC,
     CDNUTCANC,
     PRGROSA,
     NUMPESOETA,
     NUMPESOTITOLO,
     NUMPESOMANSIONE,
     NUMPESOESP,
     NUMPESOINFO,
     NUMPESOLINGUA,
     DECINDICEVICINANZA,
     DATDICHIARAZIONE,
     numpunteggio,
     NUMANZIANITALSU,
     FLGPROFESSIONALITA,
     NUMCARICOFAM,
     DATISCRART1,
     NUMANNOPUNTART1,
     strpriorita,
    strnota,
    numreddito,
    numpersone,
    datdichcarico,
    codcmtipoiscr,
    numpercinvalidita,
    datanzianita68,
    dtmpunteggio,
    cdnutmodcm,
    dtmmodcm,
    numpunteggiopres,
    nummesianz,
    CODGRADOCAPACITALOC,
    FLGPATENTE,
    FLGDISOCCTI,
    CODCMANNOTA,
    CDNQUALIFICATO
     )
     select p_out_prgNominativo,
     CDNLAVORATORE,
     NUMORDINE,
     CODCPITIT,
     CODTIPOINS,
     sysdate,
     p_cdnUtente,
     CODTIPOCANC,
     STRMOTIVOCANC,
     DTMCANC,
     CDNUTCANC,
     p_out_prgRosa,
     NUMPESOETA,
     NUMPESOTITOLO,
     NUMPESOMANSIONE,
     NUMPESOESP,
     NUMPESOINFO,
     NUMPESOLINGUA,
     DECINDICEVICINANZA,
     DATDICHIARAZIONE,
     numpunteggio,
     NUMANZIANITALSU,
     FLGPROFESSIONALITA,
     NUMCARICOFAM,
     DATISCRART1,
     NUMANNOPUNTART1,
     strpriorita,
    strnota,
    numreddito,
    numpersone,
    datdichcarico,
    codcmtipoiscr,
    numpercinvalidita,
    datanzianita68,
    dtmpunteggio,
    cdnutmodcm,
    dtmmodcm,
    numpunteggiopres,
    nummesianz,
    CODGRADOCAPACITALOC,
    FLGPATENTE,
    FLGDISOCCTI,
    CODCMANNOTA,
    CDNQUALIFICATO
     from do_nominativo
     where do_nominativo.prgRosa = p_prgRosa
     and do_nominativo.prgNominativo = p_old_prgNominativo;

     -- storicizza il punteggio del nominativo in graduatoria
     insert into cm_punteggio
     (prgnominativo, prgconfigpunteggio, decpunteggio, cdnutins, dtmins)
      select p_out_prgNominativo, p.prgconfigpunteggio, p.decpunteggio, p_cdnUtente, sysdate
      from cm_punteggio p
      where p.prgnominativo = p_old_prgNominativo;


  END LOOP;


   -- passo 4: aggiorno nella rosa madre il prgRosaFiglia con il prgRosa della nuova rosa creata
   UPDATE DO_ROSA
   SET DO_ROSA.PRGROSAFIGLIA = p_out_prgRosa,
   DO_ROSA.NUMKLOROSA = p_numklorosa+1,
   DO_ROSA.Cdnutmod = p_cdnUtente,
   DO_ROSA.DTMMOD = SYSDATE,
   DO_ROSA.Prgmotivoaperturagrad = p_prgMotivo
   WHERE DO_ROSA.PRGROSA = p_prgRosa;

   return 0;

  exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end CMGestioneRiapertura;

/*****************************************************************
* recupero il prgConfigPunteggio a seconda della stringa passata *
* dalla tabella di configurazione                                *
*****************************************************************/
function checkPrgConfigPunteggio(tipoGraduatoria varchar2,
                                 p_strValore ts_config_punteggio.strvalore%TYPE)
                              RETURN NUMBER IS
p_prg number;
begin
        select cl.prgconfigpunteggio into p_prg
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = p_strValore;

        return p_prg;

        exception
        when no_data_found then
               return 0;

end checkPrgConfigPunteggio;

function calcoloPunteggioLavoratore(p_prgNominativo number,
                                     tipoGraduatoria varchar2,
                                     p_mesianzianita number,
                                     p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                     p_cdnLavEncrypt varchar2,
                                     p_errCode OUT number )
                         RETURN NUMBER IS

p_punteggioIniziale number;
p_punteggioInvalidita number;
p_punteggioPersoneCarico number;
p_punteggioAnzianita number;
p_punteggioReddito number;
p_punteggioLocomozione number;
p_punteggioPatente number;
p_punteggio number;
p_cdnLavoratore do_nominativo.cdnlavoratore%type;
p_prgTipoIncrocio do_incrocio.prgtipoincrocio%type;
p_codtipolista do_richiesta_az.codtipolista%type;
valueReturn number;
p_prgConfigPunteggio ts_config_punteggio.prgconfigpunteggio%type;
p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%type;

p_numReddito do_nominativo.numreddito%type;
p_numPersone do_nominativo.numpersone%type;
p_datdichcarico do_nominativo.datdichcarico%type;
p_codcmtipoiscr do_nominativo.codcmtipoiscr%type;
p_numpercinvalidita do_nominativo.numpercinvalidita%type;
p_datanzianita68 do_nominativo.datanzianita68%type;

p_codmonotipogradcm ts_generale.codmonotipogradcm%type;
p_codgradocapacitaloc do_nominativo.codgradocapacitaloc%type;
p_flgpatente do_nominativo.flgpatente%type;
p_dataChiamatacm do_richiesta_az.datchiamatacm%type;

p_annoCM do_richiesta_az.numannoredditocm%type;
p_prgcmiscr am_cm_iscr.prgcmiscr%type;
p_nummesianzianita number;
p_datdatainiziocm am_cm_iscr.datdatainizio%type;

checkDateReddito varchar2(1);
p_punteggioDisocc number;
checkDisocInoc number;
checkMovTI number;
p_flagdisoccti do_nominativo.flgdisoccti%type;
p_punteggioAnnota number;
p_codCmAnnota do_nominativo.codcmannota%type;

p_updatePunteggio number;

checkValoreISEE number;
valoreISEE as_valore_isee.numvaloreisee%type;
euroISEE_OGNI number;
puntiEuroISEE_MENO number;
puntiISEE_MAX number;

begin

     --selezione il tipo di calcolo della graduatoria dalla ts_generale
     -- 1: calcolo origiario
     -- 2: aggiunta del punteggio di locomozione e patente
     select codmonotipogradcm into p_codmonotipogradcm from ts_generale;

     select i.prgtipoincrocio, nom.cdnlavoratore, raz.codtipolista, raz.prgrichiestaaz, raz.datchiamatacm, raz.numannoredditocm
           into p_prgTipoIncrocio, p_cdnLavoratore, p_codtipolista, p_prgRichiestaAz, p_dataChiamatacm, p_annoCM
     from do_nominativo nom
     inner join do_rosa r on r.prgrosa = nom.prgrosa
     inner join do_incrocio i on i.prgincrocio = r.prgincrocio
     inner join do_richiesta_az raz on raz.prgrichiestaaz = i.prgrichiestaaz
     where nom.prgnominativo = p_prgNominativo;


     -- calcolo punteggio iniziale
     p_punteggioIniziale := pg_incrocio.calcolopunteggioiniziale('CM', 'INI');
     -- salvo il punteggio
     p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'INI');
     p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioIniziale, p_cdnUtente);

     if (p_prgTipoIncrocio = 10 OR p_prgTipoIncrocio = 11) then
        if (p_codmonotipogradcm = 3 or p_codmonotipogradcm = 4) then
           -- per la provincia di TRENTO e VDA

           -- calcolo punteggio in base all'invalidità
          p_punteggioInvalidita := calcoloPunteggioInvalidita(p_prgTipoIncrocio, p_cdnLavoratore, p_cdnLavEncrypt, p_dataChiamatacm, p_codcmtipoiscr, p_numpercinvalidita, p_datanzianita68);
          if (p_prgTipoIncrocio = 10) then
              -- salvo il punteggio
              p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'INVAL');
              p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioInvalidita, p_cdnUtente);
          end if;
        else
          -- calcolo punteggio in base all'invalidità
          p_punteggioInvalidita := calcoloPunteggioInvalidita(p_prgTipoIncrocio, p_cdnLavoratore, p_cdnLavEncrypt, p_dataChiamatacm, p_codcmtipoiscr, p_numpercinvalidita, p_datanzianita68);
          if (p_prgTipoIncrocio = 10) then
              -- salvo il punteggio
              p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'INVAL');
              p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioInvalidita, p_cdnUtente);
          end if;
          --calcolo punteggio persone a carico
          p_punteggioPersoneCarico := calcoloPunteggioPersCarico(p_cdnLavoratore, tipoGraduatoria, p_numPersone, p_datdichcarico);
          -- salvo il punteggio
          p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'PERS_CAR');
          p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioPersoneCarico, p_cdnUtente);
        end if;

        if (p_codmonotipogradcm = 2) then
           -- per la regione UMBRIA il calcolo del punteggio ANZIANITA e REDDITO è diverso
           -- simile all'art1
           -- calcolo punteggio mesi di anzianita
           -- calcolo punteggio mesi di anzianita PREGRESSA (-1*MESE) e REISCRIZIONE (+1*MESE) da APRILE 1988
           select prgcmiscr, datdatainizio
           into p_prgcmiscr, p_datdatainiziocm
           from (
           select ci.prgcmiscr, ci.datdatainizio
           from am_cm_iscr ci
           inner join de_cm_tipo_iscr deisc on deisc.codcmtipoiscr = ci.codcmtipoiscr
           INNER JOIN AM_DOCUMENTO_COLL COLL ON (CI.PRGCMISCR = COLL.STRCHIAVETABELLA)
           INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
           WHERE DOC.CODSTATOATTO = 'PR' and DOC.cdnlavoratore = p_cdnLavoratore
           and deisc.codmonotiporagg = DECODE(p_prgTipoIncrocio,
                                                  10, 'D', 11, 'A')
           and ci.cdnlavoratore = p_cdnLavEncrypt
           and decode(ci.datanzianita68, null, ci.datdatainizio, ci.datanzianita68) <= p_dataChiamatacm
           and (ci.datdatafine is null OR trunc(ci.datdatafine) >= trunc(p_dataChiamatacm))
           order by ci.datdatainizio desc)
           where rownum = 1;


           p_punteggioAnzianita := calcoloPuntAnzianitaUmbria(p_cdnLavoratore, to_char(p_dataChiamatacm, 'dd/mm/yyyy'), p_cdnLavEncrypt, p_prgcmiscr, p_nummesianzianita);
           -- salvo il punteggio
           p_prgConfigPunteggio := checkprgconfigpunteggio('CM', 'ANZ');
           p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioAnzianita, p_cdnUtente);
           if (p_updatePunteggio != 0) then
              return -1;
           end if;

           -- calcolo punteggio in base al reddito
           p_punteggioReddito := punteggioredditoGradUmbria(p_cdnLavoratore, p_annoCM, 'CM', p_numReddito);
           -- salvo il punteggio reddito
           p_prgConfigPunteggio := checkprgconfigpunteggio('CM', 'RED');
           p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioReddito, p_cdnUtente);
           if (p_updatePunteggio != 0) then
              return -1;
           end if;
        elsif (p_codmonotipogradcm = 3) then
           -- per la provincia di TRENTO

           -- calcolo punteggio mesi di anzianita
           p_punteggioAnzianita := calcoloPunteggioAnzianita(p_cdnLavoratore, p_mesianzianita);
           -- salvo il punteggio
           p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'ANZ');
           p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioAnzianita, p_cdnUtente);
           if (p_updatePunteggio != 0) then
              return -1;
           end if;

           -- punteggio lavoratore disocc non precario
           p_punteggioDisocc := 0;
           p_flagdisoccti := null;

           select count(o.prgstatooccupaz) into checkDisocInoc
           from am_stato_occupaz  o
           inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
           where cdnLavoratore = p_cdnLavoratore
           and o.datfine is null
           and s.codstatooccupazragg in ('D', 'I')
           and s.codstatooccupaz not in ('A212', 'B2');

           -- se non è precario allora ha sempre i 10 punti
           if (checkDisocInoc > 0) then

              p_punteggioDisocc := calcolopunteggiodisocc('CM');
              p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'DISOCC_TI');
              p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioDisocc, p_cdnUtente);
              if (p_updatePunteggio != 0) then
                 return -1;
              end if;

              p_flagdisoccti := 'S';

           else
              -- se è precario allora
              -- verifico se l'ultimo mov non è TI
              select count(*)
              into checkMovTI
              from am_movimento mov
              where MOV.cdnLavoratore = p_cdnLavoratore
              AND MOV.PRGMOVIMENTOSUCC IS NULL
              and mov.codstatoatto = 'PR'
              AND MOV.CODTIPOMOV in ('AVV', 'TRA', 'PRO')
              AND MOV.CODMONOTEMPO = 'I'
              AND MOV.DATFINEMOVEFFETTIVA IS NULL;

              if (checkMovTI = 0) then
                 p_punteggioDisocc := calcolopunteggiodisocc('CM');
                 p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'DISOCC_TI');
                 p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioDisocc, p_cdnUtente);
                 if (p_updatePunteggio != 0) then
                    return -1;
                 end if;

                 p_flagdisoccti := 'S';
              else
                 p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'DISOCC_TI');
                 p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioDisocc, p_cdnUtente);
                 if (p_updatePunteggio != 0) then
                    return -1;
                 end if;
                 p_flagdisoccti := 'N';
              end if;

           end if;

           --calcolo punteggio cm_annota
           p_punteggioAnnota := calcoloPunteggioAnnota(p_cdnLavEncrypt, p_dataChiamatacm, tipoGraduatoria, p_codCmAnnota);
           -- salvo il punteggio
           p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'ANNOTA');
           p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioAnnota, p_cdnUtente);
           if (p_updatePunteggio != 0) then
              return -1;
           end if;
           -- ISEE solo dopo il 01/01/2011

        elsif (p_codmonotipogradcm = 4) then
           -- VDA
           -- calcolo punteggio mesi di anzianita MAX 60
           p_punteggioAnzianita := calcoloPunteggioAnzianita(p_cdnLavoratore, p_mesianzianita);
           -- salvo il punteggio
           p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'ANZ');
           p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioAnzianita, p_cdnUtente);
           if (p_updatePunteggio != 0) then
              return -1;
           end if;
           
           -- calcolo punteggio in base al reddito ISEE 
            select count(v.numvaloreisee) into checkValoreISEE
              from AS_VALORE_ISEE v
               where v.cdnlavoratore = p_cdnLavoratore              
                and v.datinizioval <= p_dataChiamatacm
                and v.datinizioval >= add_months(p_dataChiamatacm, -12)
                and (v.datfineval >= p_dataChiamatacm 
                     or v.datfineval is null);
                            
              if (checkValoreISEE != 0) then
                  select v.numvaloreisee into p_numReddito
                  from AS_VALORE_ISEE v
                  where v.cdnlavoratore = p_cdnLavoratore                 
                  and v.datinizioval <= p_dataChiamatacm
                  and v.datinizioval >= add_months(p_dataChiamatacm, -12)
                  and (v.datfineval >= p_dataChiamatacm 
                       or v.datfineval is null);
              else       
                   p_numReddito := null;
              end if;
           
                     
           p_punteggioReddito := ROUND(0.005*p_numReddito, 1);                            
                      
           -- salvo il punteggio
           p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'RED');
           p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioReddito, p_cdnUtente);
           if (p_updatePunteggio != 0) then
              return -1;
           end if;
       
        else
           -- calcolo punteggio mesi di anzianita
           p_punteggioAnzianita := calcoloPunteggioAnzianita(p_cdnLavoratore, p_mesianzianita);
           -- salvo il punteggio
           p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'ANZ');
           p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioAnzianita, p_cdnUtente);
           if (p_updatePunteggio != 0) then
              return -1;
           end if;
           -- calcolo punteggio in base al reddito
           p_punteggioReddito := punteggioredditogradnumerica(p_cdnLavoratore, p_prgtipoincrocio, p_prgRichiestaAz, 'CM', p_numReddito);
           -- salvo il punteggio
           p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'RED');
           p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioReddito, p_cdnUtente);
           if (p_updatePunteggio != 0) then
              return -1;
           end if;
        end if;

        p_flgpatente := null;
        p_codgradocapacitaloc := null;

        if (p_codmonotipogradcm = 2) then
           --calcolo punteggio locomozione
           p_punteggioLocomozione := calcoloPunteggioLocomozione(p_cdnLavoratore, p_cdnLavEncrypt, tipoGraduatoria, p_dataChiamatacm, p_codgradocapacitaloc);
           -- salvo il punteggio
           p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'LOCOMOZIONE');
           p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioLocomozione, p_cdnUtente);
           if (p_updatePunteggio != 0) then
              return -1;
           end if;
           p_punteggioPatente := 0;
           if (p_punteggioLocomozione > 0) then
              --calcolo punteggio locomozione
              p_punteggioPatente := calcoloPunteggioPatente(p_cdnLavoratore, tipoGraduatoria, p_flgpatente);
              -- salvo il punteggio
              p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'PATENTE');
              p_updatePunteggio := CMupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, p_punteggioPatente, p_cdnUtente);
              if (p_updatePunteggio != 0) then
                 return -1;
              end if;
           end if;
           -- punteggio totale lavoratore graduatorie numeriche
           if (p_datanzianita68 < to_date('01/04/1988','dd/mm/yyyy')) then
              p_punteggio := p_punteggioIniziale - p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita - p_punteggioLocomozione;
           else
              p_punteggio := p_punteggioIniziale + p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita - p_punteggioLocomozione;
           end if;


           if (p_flgpatente = 'S') then
              p_punteggio := p_punteggio + p_punteggioPatente;
           else
              p_punteggio := p_punteggio - p_punteggioPatente;
           end if;
        elsif (p_codmonotipogradcm = 3) then
           -- per la provincia di TRENTO
           p_punteggio := p_punteggioIniziale + p_punteggioAnzianita + p_punteggioInvalidita + p_punteggioDisocc;
        elsif (p_codmonotipogradcm = 4) then
           -- per la provincia di VDA
           p_punteggio := p_punteggioIniziale + p_punteggioAnzianita + p_punteggioInvalidita - p_punteggioReddito;

        else
           -- punteggio totale lavoratore graduatorie numeriche
           p_punteggio := p_punteggioIniziale - p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita ;
        end if;

        if (p_codmonotipogradcm = 2) then
           valueReturn := CMupdatepunteggiolavoratore(p_prgNominativo, p_punteggio,
                                                 p_numReddito, p_numPersone,
                                                 p_datdichcarico, p_codcmtipoiscr,
                                                 p_numpercinvalidita, p_datanzianita68,
                                                 p_nummesianzianita, p_flgpatente, p_codgradocapacitaloc, null, null);
        elsif (p_codmonotipogradcm = 3) then
           -- inserisco il punteggio finale nella tabella do_nominativo
           valueReturn := CMupdatepunteggiolavoratore(p_prgNominativo, p_punteggio,
                                                 null, null,
                                                 null, p_codcmtipoiscr,
                                                 p_numpercinvalidita, p_datanzianita68,
                                                 p_mesianzianita, null, null, p_flagdisoccti, p_codCmAnnota);
        elsif (p_codmonotipogradcm = 4) then
           -- inserisco il punteggio finale nella tabella do_nominativo
           valueReturn := CMupdatepunteggiolavoratore(p_prgNominativo, p_punteggio,
                                                 p_numReddito, null,
                                                 null, p_codcmtipoiscr,
                                                 p_numpercinvalidita, p_datanzianita68,
                                                 p_mesianzianita, null, null, null, null);

        else
           -- inserisco il punteggio finale nella tabella do_nominativo
           valueReturn := CMupdatepunteggiolavoratore(p_prgNominativo, p_punteggio,
                                                 p_numReddito, p_numPersone,
                                                 p_datdichcarico, p_codcmtipoiscr,
                                                 p_numpercinvalidita, p_datanzianita68,
                                                 p_mesianzianita, p_flgpatente, p_codgradocapacitaloc, null, null);
        end if;
     end if;

     return valueReturn;

     exception
     when no_data_found then
          return -1;
     when others then
           p_errCode := sqlcode;
           --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
           rollback;
           return -1;

end calcoloPunteggioLavoratore;

function calcoloPunteggioLavoratoreArt1(p_cdnLavoratore do_nominativo.cdnlavoratore%type,
                                        p_prgIscrArt1 cm_iscr_art1.prgiscrart1%type,
                                        p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                        p_numAnnoRedditoCM number,
                                        out_punteggioIniziale OUT number,
                                        out_punteggioAnzianita OUT number,
                                        out_punteggioInvalidita OUT number,
                                        out_punteggioPersoneCarico OUT number,
                                        out_punteggioReddito OUT number,
                                        p_errCode OUT number )
                                        RETURN NUMBER IS

p_punteggioIniziale number;
p_punteggioInvalidita number;
p_punteggioPersoneCarico number;
p_punteggioAnzianita number;
p_punteggioReddito number;
p_punteggioReddito_calcolo number;
p_punteggio number;

p_numRedito do_nominativo.numreddito%type;
p_numPersone do_nominativo.numpersone%type;
p_datdichcarico do_nominativo.datdichcarico%type;
p_codcmtipoiscr do_nominativo.codcmtipoiscr%type;
p_numpercinvalidita do_nominativo.numpercinvalidita%type;
p_datanzianita68 do_nominativo.datanzianita68%type;

begin


     -- calcolo punteggio iniziale
     p_punteggioIniziale := pg_incrocio.calcolopunteggioiniziale('CM', 'INI');

     --calcolo punteggio persone a carico
     p_punteggioPersoneCarico := calcoloPunteggioPersCarico(p_cdnLavoratore, 'CM', p_numPersone, p_datdichcarico);

     -- calcolo punteggio mesi di anzianita PREGRESSA (-1*MESE) e REISCRIZIONE (+1*MESE) da APRILE 1988
     p_punteggioAnzianita := calcoloPunteggioAnzianitaArt1(p_cdnLavoratore, p_prgIscrArt1);

     -- calcolo punteggio % INVALIDITA art1
     p_punteggioInvalidita := calcoloPunteggioInvaliditaArt1(p_cdnLavoratore, p_prgIscrArt1);

     -- calcolo punteggio in base al reddito
     p_punteggioReddito := punteggioredditogradart1(p_cdnLavoratore, p_prgIscrArt1, p_numAnnoRedditoCM, 'CM');

     if (p_punteggioReddito = -1) then
        p_punteggioReddito_calcolo := 0;
     else
        p_punteggioReddito_calcolo := p_punteggioReddito;
     end if;

     -- punteggio totale lavoratore graduatorie numeriche
     p_punteggio := p_punteggioIniziale + p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito_calcolo - p_punteggioInvalidita;

     out_punteggioIniziale := p_punteggioIniziale;
     out_punteggioAnzianita := p_punteggioAnzianita;
     out_punteggioInvalidita := p_punteggioInvalidita;
     out_punteggioPersoneCarico := p_punteggioPersoneCarico;
     out_punteggioReddito := p_punteggioReddito;

     return p_punteggio;

     exception
     when no_data_found then
          return 0;
     when others then
           p_errCode := sqlcode;
           dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
           rollback;
           return -1;

end calcoloPunteggioLavoratoreArt1;

function calcoloPunteggioInvalidita(p_prgTipoIncrocio number,
                                    p_cdnlavoratore number,
                                    p_cdnLavEncrypt varchar2,
                                    p_dataChiamatacm do_richiesta_az.datchiamatacm%type,
                                    out_p_codcmtipoiscr OUT am_cm_iscr.codcmtipoiscr%type,
                                    out_p_numpercinvalidita OUT am_cm_iscr.numpercinvalidita%type,
                                    out_p_datanzianita68 OUT am_cm_iscr.datanzianita68%type)
                                    RETURN NUMBER IS

checkInvalidita number;
p_codMonoTipo TS_CM_PUNTI_INVALID.CODMONOTIPO%type;
p_codcmtipoiscr am_cm_iscr.codcmtipoiscr%type;
p_numpercinvalidita am_cm_iscr.numpercinvalidita%type;
puntiInvalidita ts_cm_punti_invalid.decpunti%type;
p_datanzianita68 am_cm_iscr.datanzianita68%type;
p_datdatainiziocm am_cm_iscr.datdatainizio%type;

begin
     puntiInvalidita := 0;

     if (p_prgTipoIncrocio = 10) then
        checkInvalidita := 1;
     elsif (p_prgTipoIncrocio = 11) then
        checkInvalidita := 0;
     elsif (p_prgTipoIncrocio = 12) then
        checkInvalidita := 1;
     end if;

     if (checkInvalidita = 1) then

       select codcmtipoiscr, numpercinvalidita, datanzianita68, datdatainizio
         into p_codcmtipoiscr, p_numpercinvalidita, p_datanzianita68, p_datdatainiziocm
         from (
       select i.codcmtipoiscr, i.numpercinvalidita,
              decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68) as datanzianita68,
              i.datdatainizio
       from am_cm_iscr i
       inner join de_cm_tipo_iscr t on t.codcmtipoiscr = i.codcmtipoiscr
       WHERE i.CODSTATOATTO = 'PR'
       and i.cdnlavoratore = p_cdnLavEncrypt
       and decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68) <= trunc(p_dataChiamatacm)
       and (i.datdatafine is null OR i.datdatafine >= trunc(p_dataChiamatacm))
       and t.codmonotiporagg = 'D'
       order by i.datdatainizio desc)
       where rownum = 1;

       out_p_codcmtipoiscr := p_codcmtipoiscr;
       out_p_numpercinvalidita := p_numpercinvalidita;
       out_p_datanzianita68 := p_datanzianita68;

       if (p_codcmtipoiscr = '04' OR p_codcmtipoiscr = '08' OR p_codcmtipoiscr = '12' OR p_codcmtipoiscr = '13' OR p_codcmtipoiscr = '09' OR p_codcmtipoiscr = '11') then
          select pi.decpunti into puntiInvalidita
          from ts_cm_punti_invalid pi
          where pi.codmonotipo = 'P'
          and pi.declimiteinf <= p_numpercinvalidita
          and p_numpercinvalidita <= pi.declimitesup;
       elsif (p_codcmtipoiscr = '01' OR p_codcmtipoiscr = '02' OR p_codcmtipoiscr = '03') then
          select pi.decpunti into puntiInvalidita
          from ts_cm_punti_invalid pi
          where pi.codmonotipo = 'C'
          and pi.declimiteinf <= p_numpercinvalidita
          and p_numpercinvalidita <= pi.declimitesup;
       end if;

     else
       select codcmtipoiscr, numpercinvalidita, datanzianita68, datdatainizio
       into p_codcmtipoiscr, p_numpercinvalidita, p_datanzianita68, p_datdatainiziocm
       from (
       select i.codcmtipoiscr, i.numpercinvalidita,
              decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68) as datanzianita68,
              i.datdatainizio
       from am_cm_iscr i
       inner join de_cm_tipo_iscr t on t.codcmtipoiscr = i.codcmtipoiscr
       WHERE i.CODSTATOATTO = 'PR'
       and i.cdnlavoratore = p_cdnLavEncrypt
       and decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68) <= trunc(p_dataChiamatacm)
       and (i.datdatafine is null OR i.datdatafine >= trunc(p_dataChiamatacm))
       and t.codmonotiporagg = 'A'
       order by i.datdatainizio desc)
       where rownum = 1;

       out_p_codcmtipoiscr := p_codcmtipoiscr;
       out_p_numpercinvalidita := p_numpercinvalidita;
       out_p_datanzianita68 := p_datanzianita68;

     end if;

     return puntiInvalidita;

     exception
     when no_data_found then
          return 0;

end calcoloPunteggioInvalidita;

function calcoloPunteggioInvaliditaArt1(p_cdnlavoratore number,
                                        p_prgIscrArt1 cm_iscr_art1.prgiscrart1%type)
                                       RETURN NUMBER IS

checkInvalidita number;
p_codMonoTipo TS_CM_PUNTI_INVALID.CODMONOTIPO%type;
p_numpercinvalidita cm_iscr_art1.numpercinv%type;
puntiInvalidita ts_cm_punti_invalid.decpunti%type;
checkPerc number;

begin
     puntiInvalidita := 0;

     select nvl(cia.numpercinv,0) into p_numpercinvalidita
     from cm_iscr_art1 cia
     where cia.prgiscrart1 = p_prgIscrArt1;

     if (p_numpercinvalidita is not null OR p_numpercinvalidita != '') then
        select count(pi.decpunti) into checkPerc
        from ts_cm_punti_invalid pi
        where pi.codmonotipo = 'P'
        and pi.declimiteinf <= p_numpercinvalidita
        and p_numpercinvalidita <= pi.declimitesup;

        if (checkPerc > 0) then
          select nvl(pi.decpunti,0) into puntiInvalidita
          from ts_cm_punti_invalid pi
          where pi.codmonotipo = 'P'
          and pi.declimiteinf <= p_numpercinvalidita
          and p_numpercinvalidita <= pi.declimitesup;
        end if;
     end if;

     return puntiInvalidita;

     exception
     when no_data_found then
          return 0;

end calcoloPunteggioInvaliditaArt1;

function checkNumPuntiPersCarico(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggio number;
begin

        select cl.num into punteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'PERS_CAR_MENO';

        return punteggio;

        exception
        when no_data_found then
               return 0;

end checkNumPuntiPersCarico;

function calcoloPunteggioPersCarico(p_cdnlavoratore number,
                                    tipoGraduatoria varchar2,
                                    out_p_numPersone OUT do_nominativo.numpersone%type,
                                    out_p_datdichcarico OUT do_nominativo.datdichcarico%type)
                                    RETURN NUMBER IS

p_numPersone cm_lav_carico.numpersone%type;
p_datdichcarico cm_lav_carico.datdichiarazione%type;
checkNumPersone number;
p_numPunteggioMeno number;
p_numPunteggioPersCar number;
begin

     select count(lc.numpersone)
            into checkNumPersone
     from cm_lav_carico lc
     where lc.cdnlavoratore = p_cdnlavoratore;

     if (checkNumPersone > 0) then
        p_numPunteggioMeno := checkNumPuntiPersCarico(tipoGraduatoria);

        select lc.numpersone, lc.datdichiarazione
            into p_numPersone, p_datdichcarico
        from cm_lav_carico lc
        where lc.cdnlavoratore = p_cdnlavoratore;

        p_numPunteggioPersCar := p_numPunteggioMeno * p_numPersone;

        out_p_numPersone := p_numPersone;
        out_p_datdichcarico := p_datdichcarico;

        return p_numPunteggioPersCar;

     else
        return 0;
     end if;

     exception
     when no_data_found then
          return 0;

end calcoloPunteggioPersCarico;

function incrementoNumPuntiAnzianita(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggio number;
begin

        select cl.num into punteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'MESE_ANZ_MENO';

        return punteggio;

        exception
        when no_data_found then
               return 0;

end incrementoNumPuntiAnzianita;

function checkNumPuntiMaxAnzianita(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggio number;
begin

        select cl.num into punteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'MESE_ANZ_MAX';

        return punteggio;

        exception
        when no_data_found then
               return 0;

end checkNumPuntiMaxAnzianita;

function calcoloPunteggioAnzianita(p_cdnlavoratore number,
                                   p_mesiAnzianita number)
                                    RETURN NUMBER IS
p_numPuntiMeno number;
p_numPuntiMax number;
p_numPunteggioAnzianita number;
begin

     p_numPuntiMeno := incrementoNumPuntiAnzianita('CM');
     p_numPuntiMax := checkNumPuntiMaxAnzianita('CM');

     -- se i mesi sono superiori al massimo (60)
     if (p_mesiAnzianita > p_numPuntiMax) then
        return p_numPuntiMax;
     else
        p_numPunteggioAnzianita := p_numPuntiMeno * p_mesiAnzianita;
        return p_numPunteggioAnzianita;
     end if;

     exception
     when no_data_found then
          return 0;

end calcoloPunteggioAnzianita;

function calcoloPunteggioAnzianitaArt1(p_cdnlavoratore number,
                                       p_prgIscrArt1 cm_iscr_art1.prgiscrart1%type)
                                    RETURN NUMBER IS

p_numPunti number;
p_mesiAnzArt1Iscr number;
p_mesiAnzArt1Reiscr number;
p_datiscrlistaprov varchar2(10);
p_datInizioAnz varchar2(10);
p_gap number;
p_mesiAnzianita number;
p_punteggioAnzianita number;
begin

     p_numPunti := incrementoNumPuntiAnzianita('CM');

     -- calcolo i mesi di anzianità
     /**
     metodo calcolo
     1) se la data è inferiore al 30/04/1988
        si verifica che se (30 - gg + 1) > 15 e se il gg del mese è il 15  allora si somma un mese in più
     2) se la data è superiore al 30/04/1988
        si verifica che se (30 - gg) = 15 si deve togliere un mese
     **/
     select
      case
           when cia.datiscrlistaprov < to_date('30/04/1988','dd/mm/yyyy')
                then
                     case
                          when (30 - to_number(nvl(to_char(cia.datiscrlistaprov, 'dd'),0))+1) > 15 and to_number(nvl(to_char(cia.datiscrlistaprov, 'dd'),0)) = 15
                          then
                               round(months_between(to_date('30/04/1988','dd/mm/yyyy'), cia.datiscrlistaprov)) + 1
                          else  round(months_between(to_date('30/04/1988','dd/mm/yyyy'), cia.datiscrlistaprov))
                     end
           else 0
      end
      as mesiAnzArt1Iscr,
      case
           when cia.datiscrlistaprov >= to_date('30/04/1988','dd/mm/yyyy')
                then
                     case
                          when (30 - to_number(nvl(to_char(cia.datiscrlistaprov, 'dd'),0))) = 15
                          then
                             round(months_between(cia.datiscrlistaprov, to_date('30/04/1988','dd/mm/yyyy'))) - 1
                          else  round(months_between(cia.datiscrlistaprov, to_date('30/04/1988','dd/mm/yyyy')))
                     end
           else 0
      end
      as mesiAnzArt1Reiscr,
      to_char(cia.datiscrlistaprov, 'dd/mm/yyyy') as datiscrlistaprov,
      to_char(to_date('30/04/1988', 'dd/mm/yyyy'), 'dd/mm/yyyy') as datInizioAnz
      into p_mesiAnzArt1Iscr, p_mesiAnzArt1Reiscr, p_datiscrlistaprov, p_datInizioAnz
      from cm_iscr_art1 cia
      where cia.cdnlavoratore = p_cdnlavoratore
      and cia.prgiscrart1 = p_prgIscrArt1;

      if (p_mesiAnzArt1Iscr = 0) then
      -- caso in cui ho una reiscrizione all'art1
      -- punteggioAnz = +1 * ogni mese successivo al 30/04/1988

         p_gap := ceil(p_mesiAnzArt1Reiscr) - p_mesiAnzArt1Reiscr;
         if (p_gap >= 0.5) then
            p_mesiAnzianita := p_mesiAnzArt1Reiscr;
         else
            p_mesiAnzianita := ceil(p_mesiAnzArt1Reiscr);
         end if;

         p_punteggioAnzianita := p_numPunti * p_mesiAnzianita;

      else
      -- caso di iscrizione pregresssa
      -- punteggioAnz = -1 * ogni mese fino al 30/04/1988

         p_gap := ceil(p_mesiAnzArt1Iscr) - p_mesiAnzArt1Iscr;
         if (p_gap >= 0.5) then
            p_mesiAnzianita := p_mesiAnzArt1Iscr;
         else
            p_mesiAnzianita := ceil(p_mesiAnzArt1Iscr);
         end if;

         p_punteggioAnzianita := -1 * p_numPunti * p_mesiAnzianita;

      end if;

      return p_punteggioAnzianita;

     exception
     when no_data_found then
          return 0;

end calcoloPunteggioAnzianitaArt1;

function checkNumPuntiRedditoMax(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggio number;
begin

        select cl.num into punteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'NUM_RED_MAX';

        return punteggio;

        exception
        when no_data_found then
               return 0;

end checkNumPuntiRedditoMax;

function checkEuroRedditoOgni(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggio number;
begin

        select cl.num into punteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'NUM_RED_OGNI';

        return punteggio;

        exception
        when no_data_found then
               return 0;

end checkEuroRedditoOgni;

function incrementoNumPuntiReddito(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggio number;
begin

        select cl.num into punteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'NUM_RED_PIU';

        return punteggio;

        exception
        when no_data_found then
               return 0;

end incrementoNumPuntiReddito;

function incrementoArt1PuntiReddito(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggio number;
begin

        select cl.num into punteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'ART1_RED_PIU';

        return punteggio;

        exception
        when no_data_found then
               return 0;

end incrementoArt1PuntiReddito;

function checkArt1EuroRedditoOgni(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggio number;
begin

        select cl.num into punteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'ART1_RED_OGNI';

        return punteggio;

        exception
        when no_data_found then
               return 0;

end checkArt1EuroRedditoOgni;

function punteggioRedditoGradNumerica(p_cdnlavoratore number,
                                      p_prgTipoIncrocio number,
                                      p_prgRichiestaAz number,
                                      tipoGraduatoria varchar2,
                                      out_p_numReddito OUT do_nominativo.numreddito%type)
                                      RETURN NUMBER IS

p_redditoCM ts_limite_reddito.numlimiteredditocm%type;
p_redditoLD ts_limite_reddito.numlimiteredditold%type;
p_maxReddito ts_limite_reddito.numlimiteredditold%type;
p_redditoLav cm_lav_reddito.numreddito%type;
checkReddito number;
p_numPuntiMaxReddito number;
p_euroOgni number;
p_incrPuntiOgni number;
punteggio number;
p_gapReddito number;
p_punteggioRedd number;
p_annoReddito number;
p_annoCM do_richiesta_az.numannoredditocm%type;
begin

        select raz.numannoredditocm into p_annoCM
        from do_richiesta_az raz
        where raz.prgrichiestaaz = p_prgRichiestaAz;


        select count(cmr.prglavreddito) into checkReddito
        from cm_lav_reddito cmr
        where cmr.cdnlavoratore = p_cdnlavoratore
        and cmr.numanno = p_annoCM
        and (cmr.datfineval is null or cmr.datfineval >= sysdate);

        if (checkReddito > 0) then
           select cmr.numreddito, cmr.numanno
           into p_redditoLav, p_annoReddito
           from cm_lav_reddito cmr
           where cmr.cdnlavoratore = p_cdnlavoratore
           and cmr.numanno = p_annoCM
           and (cmr.datfineval is null or cmr.datfineval >= sysdate);

           select lr.numlimiteredditocm, lr.numlimiteredditold
               into p_redditoCM, p_redditoLD
           from ts_limite_reddito lr
           where lr.numanno = p_annoReddito;

           if (p_prgTipoIncrocio = 11) then
              p_maxReddito := p_redditoLD;
           elsif (p_prgTipoIncrocio = 10) then
              p_maxReddito := p_redditoCM;
           end if;

           if (p_maxReddito >= p_redditoLav) then

              out_p_numreddito := p_redditoLav;

              return 0;
           else
              p_numPuntiMaxReddito := checkNumPuntiRedditoMax(tipoGraduatoria);
              p_euroOgni := checkEuroRedditoOgni(tipoGraduatoria);
              p_incrPuntiOgni := incrementoNumPuntiReddito(tipoGraduatoria);

              -- il valore di reddito che supera quello max
              p_gapReddito := p_redditoLav - p_maxReddito;

              -- calcolo il punteggio come 48 punti
              -- sommati a 12 punti ogni 700 euro
              p_punteggioRedd := p_numPuntiMaxReddito + (floor(p_gapReddito/p_euroOgni)*p_incrPuntiOgni);

              out_p_numreddito := p_redditoLav;

              return p_punteggioRedd;
           end if;

        else
           out_p_numreddito := 0;

           return 0;
        end if;

        exception
        when no_data_found then
               return 0;

end punteggioRedditoGradNumerica;

function punteggioRedditoGradArt1(p_cdnlavoratore number,
                                  p_prgIscrArt1 number,
                                  p_numAnnoRedditoCM number,
                                  tipoGraduatoria varchar2)
                                  RETURN NUMBER IS

p_redditoLav cm_lav_reddito.numreddito%type;
checkReddito number;
p_gapReddito number;
p_incrPuntiOgni number;
p_euroOgni number;
p_punteggioRedd number;
checkFasciaRed number;
p_maxPunti ts_cm_punti_invalid.decpunti%type;
p_maxReddito ts_cm_punti_invalid.declimitesup%type;
p_puntiFasciaRed ts_cm_punti_invalid.decpunti%type;
begin

        select count(cmr.prglavreddito) into checkReddito
        from cm_lav_reddito cmr
        where cmr.cdnlavoratore = p_cdnlavoratore
        and cmr.numanno = p_numAnnoRedditoCM
        and (cmr.datfineval is null or cmr.datfineval >= sysdate);

        if (checkReddito > 0) then
           select cmr.numreddito into p_redditoLav
           from cm_lav_reddito cmr
           where cmr.cdnlavoratore = p_cdnlavoratore
           and cmr.numanno = p_numAnnoRedditoCM
           and (cmr.datfineval is null or cmr.datfineval >= sysdate);

           p_incrPuntiOgni := incrementoNumPuntiReddito(tipoGraduatoria);
           p_euroOgni := checkArt1EuroRedditoOgni(tipoGraduatoria);

           select count(pi.decpunti) into checkFasciaRed
           from ts_cm_punti_invalid pi
           where pi.codmonotipo = 'R'
           and pi.declimiteinf <= p_redditoLav
           and p_redditoLav <= pi.declimitesup;

           if (checkFasciaRed > 0) then
              select pi.decpunti into p_puntiFasciaRed
              from ts_cm_punti_invalid pi
              where pi.codmonotipo = 'R'
              and pi.declimiteinf <= p_redditoLav
              and p_redditoLav <= pi.declimitesup;

              p_punteggioRedd := p_puntiFasciaRed;

           else
              select max(pi.decpunti), max(declimitesup)
                    into p_maxPunti, p_maxReddito
              from ts_cm_punti_invalid pi
              where pi.codmonotipo = 'R'
              and pi.declimitesup < p_redditoLav;

              p_gapReddito := p_redditoLav - p_maxReddito;

              p_punteggioRedd := p_maxPunti + (floor(p_gapReddito/p_euroOgni)*p_incrPuntiOgni);

           end if;

           return p_punteggioRedd;

        else
            return -1;
        end if;

        exception
        when no_data_found then
             return 0;

end punteggioRedditoGradArt1;


function calcolopunteggiodisocc(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggio number;
begin

        select cl.num into punteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'DISOCC_TI';

        return punteggio;

        exception
        when no_data_found then
               return 0;

end calcolopunteggiodisocc;

/*********************************************************************
* esegue l'inserimento o l'aggiornamento nella tabella CM_PUNTEGGIO  *
* dei singoli punteggi che danno il punteggio completo               *
**********************************************************************/
function CMUpdatePunteggio(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                           p_prgConfigPunteggio Ts_Config_Punteggio.Prgconfigpunteggio%TYPE,
                           p_punteggio number,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE
                           ) RETURN NUMBER IS

checkPunteggio number;
queryWhere VARCHAR2(255);
begin

  select count(ap.prgNominativo) into checkPunteggio from cm_punteggio ap
  where ap.prgnominativo = p_prgNominativo
  and ap.prgconfigpunteggio = p_prgConfigPunteggio;

  if (checkPunteggio = 0) then

     insert into cm_punteggio
     (prgnominativo, prgconfigpunteggio, decpunteggio, cdnutins, dtmins)
     values
     (p_prgNominativo, p_prgConfigPunteggio, p_punteggio, p_cdnUtente, sysdate);

  else

     -- storicizzazione nella tabella di LOG
     queryWhere :=  ' WHERE prgnominativo = ' || p_prgNominativo ||
             'AND prgconfigpunteggio = ' || p_prgConfigPunteggio || ' ';

     PG_LOG.doLog('U', 'CM_PUNTEGGIO', p_cdnUtente, queryWhere);

     update cm_punteggio
     set
     decpunteggio = p_punteggio,
     cdnutins = p_cdnUtente,
     dtmins = sysdate
     where
     prgnominativo = p_prgNominativo
     and prgconfigpunteggio = p_prgConfigPunteggio;

  end if;
 return 0;

 exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return -1;

end CMUpdatePunteggio;

/******************************************************************************************
* esegue l'aggiornamento del numOrdine di tutti i lavoratori per la graduatoria specifica *
*******************************************************************************************/
function CMCalcolaPosizioneOld(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                            p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                            p_key varchar2)
                             RETURN NUMBER IS

i number;
checkIscrArt1 number;

begin

  i := 0;

  if (p_prgTipoIncrocio = 10 OR p_prgTipoIncrocio = 11) then

    -- dona 19/10/2007 si annullano le posizioni per tutti poi verranno ricalcolate
    -- così facendo i lavoratori non iscritti verranno posizionati alla fine e senza numero posizione
    DECLARE
       CURSOR nominativiGradCursor IS
          select n.prgnominativo
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa;
    BEGIN
       FOR nominativiGrad IN nominativiGradCursor
       LOOP
          update do_nominativo
          set numordine = null,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativiGrad.prgnominativo;
       END LOOP;
    END;

    DECLARE
       CURSOR nominativiCursor IS
          select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, i.datdatainizio, i.DATANZIANITA68,
          ti.strdescrizione,
          decode (ti.codcmtipoiscr, 14, 0, 1) as ordinaVittime
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          inner join am_cm_iscr i on decrypt(i.cdnlavoratore, p_key) = n.cdnlavoratore
          inner join DE_CM_TIPO_ISCR ti on (i.codcmtipoiscr=ti.codcmtipoiscr)
          INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
          INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
          where rich.prgrichiestaaz = p_prgRichiestaAz
          AND DOC.CODSTATOATTO = 'PR' and DOC.cdnlavoratore = n.cdnlavoratore
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and i.datdatafine is null
          and a.prgalternativa = inc.prgalternativa
          and (
          (inc.prgtipoincrocio=10 and (ti.codmonotiporagg is null or ti.codmonotiporagg='D'))
          or
          (inc.prgtipoincrocio=11 and (ti.codmonotiporagg is null or ti.codmonotiporagg='A'))
          )
          order by prgalternativa, ordinaVittime, numpunteggio, decode(i.DATANZIANITA68, null, i.datdatainizio, DATANZIANITA68) asc, datnasc desc;
    BEGIN
       i := 0;
       FOR nominativi IN nominativiCursor
       LOOP
          i := i+1;

          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;
    END;

  else

    DECLARE
       CURSOR nominativiCursor IS
          select n.prgnominativo, n.numpunteggio, a.prgalternativa,
                 rich.codtipolista, l.datnasc, l.cdnlavoratore
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
    inner join cm_iscr_art1 ia on ia.cdnlavoratore = n.cdnlavoratore and ia.datfine is null
    inner join am_documento_coll dc on dc.strchiavetabella = ia.prgiscrart1
          inner join am_documento ad on ad.prgdocumento = dc.prgdocumento
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
          AND ad.codtipodocumento = 'ILS'
          AND ad.CODSTATOATTO != 'AN'
          and ia.codtipolista = rich.codtipolista
          order by prgalternativa, numpunteggio, datiscrlistaprov, datnasc desc;
    BEGIN
       i := 0;
       FOR nominativi IN nominativiCursor
       LOOP

          -- dona
          select count(ia.prgiscrart1) into checkIscrArt1
          from cm_iscr_art1 ia
          inner join am_documento_coll dc on dc.strchiavetabella = ia.prgiscrart1
          inner join am_documento ad on ad.prgdocumento = dc.prgdocumento
          where ia.cdnlavoratore = nominativi.cdnlavoratore
          and ia.datfine is null
          AND ad.codtipodocumento = 'ILS'
          AND ad.CODSTATOATTO != 'AN'
          and ia.codtipolista = nominativi.codtipolista;

          if(checkIscrArt1 = 0) then
            update do_nominativo
            set numordine = null,
                numklonominativo = numklonominativo+1
            where do_nominativo.prgnominativo = nominativi.prgnominativo;
          else
            i := i+1;

            update do_nominativo
            set numordine = i,
                numklonominativo = numklonominativo+1
            where do_nominativo.prgnominativo = nominativi.prgnominativo;
          end if;
       END LOOP;
    END;

  end if;

   commit;

   return 0;

   exception
   when others then
    dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
     rollback;
         return -1;

end CMCalcolaPosizioneOld;


/******************************************************************************************
* esegue l'aggiornamento del numOrdine di tutti i lavoratori per la graduatoria specifica *
*******************************************************************************************/
function CMCalcolaPosizione(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                            p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                            p_key varchar2)
                             RETURN NUMBER IS

i number;
checkIscrArt1 number;
p_codmonotipogradcm ts_generale.codmonotipogradcm%type;

begin

  
  select codmonotipogradcm into p_codmonotipogradcm from ts_generale;

  i := 0;

  if (p_prgTipoIncrocio = 10 OR p_prgTipoIncrocio = 11) then

    -- dona 19/10/2007 si annullano le posizioni per tutti poi verranno ricalcolate
    -- così facendo i lavoratori non iscritti verranno posizionati alla fine e senza numero posizione
    DECLARE
       CURSOR nominativiGradCursor IS
          select n.prgnominativo
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa;
    BEGIN
          FOR nominativi IN nominativiGradCursor
          LOOP
            update do_nominativo
            set numordine = null,
                numklonominativo = numklonominativo+1
            where do_nominativo.prgnominativo = nominativi.prgnominativo;

          END LOOP;

    END;

    if (p_codmonotipogradcm = 4) then
       -- VDA
       DECLARE
         CURSOR nominativiCursorVda IS
            select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, i.numpercinvalidita,
           -- ti.strdescrizione,
            decode (ti.codcmtipoiscr, '14', 0, 1) as ordinaVittime,
            n.cdnqualificato
            from do_richiesta_az rich
            inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
            inner join do_rosa r on r.prgincrocio = inc.prgincrocio
            inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
            inner join do_nominativo n on n.prgrosa = r.prgrosa
            inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
            inner join am_cm_iscr i on decrypt(i.cdnlavoratore, p_key) = n.cdnlavoratore
            inner join DE_CM_TIPO_ISCR ti on (i.codcmtipoiscr=ti.codcmtipoiscr)
            INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
            INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
            where rich.prgrichiestaaz = p_prgRichiestaAz
            AND DOC.CODSTATOATTO = 'PR' and DOC.cdnlavoratore = n.cdnlavoratore
            and inc.prgtipoincrocio = p_prgTipoIncrocio
            and r.prgrosafiglia is null
            and r.prgtiporosa != 3
            and i.datdatafine is null
            and a.prgalternativa = inc.prgalternativa
            and (
            (inc.prgtipoincrocio=10 and (ti.codmonotiporagg is null or ti.codmonotiporagg='D'))
            or
            (inc.prgtipoincrocio=11 and (ti.codmonotiporagg is null or ti.codmonotiporagg='A'))
            ) 
            and n. cdnqualificato <> 3
             
            
            order by cdnqualificato, prgalternativa, numpunteggio desc, decode(numpercinvalidita, null, 0, numpercinvalidita) desc, datnasc desc;
      BEGIN
            i := 0;
            FOR nominativi IN nominativiCursorVda
            LOOP
              i := i+1;
              update do_nominativo
              set numordine = decode(nominativi.cdnqualificato, null, null, i),
                numklonominativo = numklonominativo+1
              where do_nominativo.prgnominativo = nominativi.prgnominativo;
            END LOOP;
      END;
    elsif (p_codmonotipogradcm = 3) then

       DECLARE
         CURSOR nominativiCursorTrento IS
            select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, 
            n.numpercinvalidita,
            decode (n.codcmtipoiscr, '14', 0, 1) as ordinaVittime,
            decode (n.codcmannota, null, 0, 1) as ordinaAnnota
            from do_richiesta_az rich
            inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
            inner join do_rosa r on r.prgincrocio = inc.prgincrocio
            inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
            inner join do_nominativo n on n.prgrosa = r.prgrosa
            inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
            where rich.prgrichiestaaz = p_prgRichiestaAz          
            and inc.prgtipoincrocio = p_prgTipoIncrocio
            and r.prgrosafiglia is null
            and r.prgtiporosa != 3            
            and a.prgalternativa = inc.prgalternativa
            order by ordinaAnnota, prgalternativa, ordinaVittime, numpunteggio desc, decode(numpercinvalidita, null, 0, numpercinvalidita) desc, datnasc asc;

      BEGIN
            i := 0;
            FOR nominativi IN nominativiCursorTrento
            LOOP
              i := i+1;
              update do_nominativo
              set numordine = decode(nominativi.ordinaAnnota, 0, i, null),
                numklonominativo = numklonominativo+1
              where do_nominativo.prgnominativo = nominativi.prgnominativo;
            END LOOP;

      END;
    -- Umbria - Donisi 23/11/2010
    -- n va ordinatta com il campo ordinaVittime
    
    else if (p_codmonotipogradcm = 2) then 
       DECLARE
         CURSOR nominativiCursor IS
            select n.prgnominativo, n.numpunteggio, a.prgalternativa, 
            l.datnasc, to_date('31/12/2100', 'dd/mm/yyyy') as datdatainizio,
            n.DATANZIANITA68,           
            decode (n.codcmtipoiscr, '14', 0, 1) as ordinaVittime
            from do_richiesta_az rich
            inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
            inner join do_rosa r on r.prgincrocio = inc.prgincrocio
            inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
            inner join do_nominativo n on n.prgrosa = r.prgrosa
            inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore           
            where rich.prgrichiestaaz = p_prgRichiestaAz
            and inc.prgtipoincrocio = p_prgTipoIncrocio
            and r.prgrosafiglia is null
            and r.prgtiporosa != 3
            and a.prgalternativa = inc.prgalternativa          
            order by prgalternativa , numpunteggio, decode(DATANZIANITA68, null, datdatainizio, DATANZIANITA68) asc, datnasc desc;
      BEGIN
            i := 0;
            FOR nominativi IN nominativiCursor
            LOOP
              i := i+1;
              update do_nominativo
              set numordine = i,
                numklonominativo = numklonominativo+1
              where do_nominativo.prgnominativo = nominativi.prgnominativo;
            END LOOP;
      END;
    
    
    else

      DECLARE
         CURSOR nominativiCursor IS
            select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, 
             to_date('31/12/2100', 'dd/mm/yyyy') as datdatainizio, 
             n.DATANZIANITA68,           
            decode (n.codcmtipoiscr, '14', 0, 1) as ordinaVittime
            from do_richiesta_az rich
            inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
            inner join do_rosa r on r.prgincrocio = inc.prgincrocio
            inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
            inner join do_nominativo n on n.prgrosa = r.prgrosa
            inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
            where rich.prgrichiestaaz = p_prgRichiestaAz
            and inc.prgtipoincrocio = p_prgTipoIncrocio
            and r.prgrosafiglia is null
            and r.prgtiporosa != 3            
            and a.prgalternativa = inc.prgalternativa            
            order by prgalternativa, ordinaVittime, numpunteggio, decode(DATANZIANITA68, null, datdatainizio, DATANZIANITA68) asc, datnasc desc;
      BEGIN
            i := 0;
            FOR nominativi IN nominativiCursor
            LOOP
              i := i+1;
              update do_nominativo
              set numordine = i,
                numklonominativo = numklonominativo+1
              where do_nominativo.prgnominativo = nominativi.prgnominativo;
            END LOOP;
      END;
          end if;
    end if;
  else

    DECLARE
       CURSOR nominativiCursor IS
          select n.prgnominativo, n.numpunteggio, a.prgalternativa,
                 rich.codtipolista, l.datnasc, l.cdnlavoratore
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
    inner join cm_iscr_art1 ia on ia.cdnlavoratore = n.cdnlavoratore and ia.datfine is null
    inner join am_documento_coll dc on dc.strchiavetabella = ia.prgiscrart1
          inner join am_documento ad on ad.prgdocumento = dc.prgdocumento
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
          AND ad.codtipodocumento = 'ILS'
          AND ad.CODSTATOATTO != 'AN'
          and ia.codtipolista = rich.codtipolista
          order by prgalternativa, numpunteggio, datiscrlistaprov, datnasc desc;
    BEGIN
       i := 0;
       FOR nominativi IN nominativiCursor
       LOOP

          -- dona
          select count(ia.prgiscrart1) into checkIscrArt1
          from cm_iscr_art1 ia
          inner join am_documento_coll dc on dc.strchiavetabella = ia.prgiscrart1
          inner join am_documento ad on ad.prgdocumento = dc.prgdocumento
          where ia.cdnlavoratore = nominativi.cdnlavoratore
          and ia.datfine is null
          AND ad.codtipodocumento = 'ILS'
          AND ad.CODSTATOATTO != 'AN'
          and ia.codtipolista = nominativi.codtipolista;

          if(checkIscrArt1 = 0) then
            update do_nominativo
            set numordine = null,
                numklonominativo = numklonominativo+1
            where do_nominativo.prgnominativo = nominativi.prgnominativo;
          else
            i := i+1;

            update do_nominativo
            set numordine = i,
                numklonominativo = numklonominativo+1
            where do_nominativo.prgnominativo = nominativi.prgnominativo;
          end if;
       END LOOP;
    END;

  end if;

   commit;

   return 0;

   exception
   when others then
    --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
     rollback;
         return -1;

  
end CMCalcolaPosizione;

/***************************************************************************************************
* gestione dei dati dell'approvazione di una graduatoria                                           *
***************************************************************************************************/
function CMSalvaApprovazGrad(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                             p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                             p_prgapprovazionegrad as_approvazione_grad.prgapprovazionegrad%TYPE,
                             p_numDetermina varchar2,
                             p_datProtocollazione varchar2,
                             p_datPubblicazione varchar2,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                ) RETURN NUMBER is

new_prgapprovazionegrad as_approvazione_grad.prgapprovazionegrad%TYPE;

begin

     if(p_prgapprovazionegrad = 0) then
         -- caso di inserimento
         select s_as_approvazione_grad.nextVal into new_prgapprovazionegrad from dual;

         insert into as_approvazione_grad
         (prgapprovazionegrad,
          numdetermina, datpubblicazionegrad,
          datprotocollo, cdnutins, dtmins, cdnutmod, dtmmod)
          values
          (new_prgapprovazionegrad,
          p_numDetermina,
          to_date(p_datPubblicazione, 'dd/mm/yyyy'),
          to_date(p_datProtocollazione, 'dd/mm/yyyy'),
          p_cdnUtente, sysdate, p_cdnUtente, sysdate);

     else
         -- caso di aggiornamento
         new_prgapprovazionegrad := p_prgapprovazionegrad;

         update as_approvazione_grad
         set
         numdetermina = p_numDetermina,
         datpubblicazionegrad = to_date(p_datPubblicazione, 'dd/mm/yyyy'),
         datprotocollo = to_date(p_datProtocollazione, 'dd/mm/yyyy'),
         cdnutmod = p_cdnUtente,
         dtmmod = sysdate
         where prgapprovazionegrad = new_prgapprovazionegrad;

     end if;

     update do_rosa
     set
     prgapprovazionegrad = new_prgapprovazionegrad,
     numklorosa = numklorosa + 1
     where prgrosa IN
     (select r.prgrosa
      from do_richiesta_az rich
      inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
      inner join do_rosa r on r.prgincrocio = inc.prgincrocio
      inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
      where rich.prgrichiestaaz = p_prgRichiestaAz
      and inc.prgtipoincrocio = p_prgTipoIncrocio
      and r.prgrosafiglia is null
      and r.prgtiporosa = 3
      and a.prgalternativa = inc.prgalternativa);

  return 0;

  exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end CMSalvaApprovazGrad;

/**************************************************************************************
* Funzione per l'inserimento nominativo del lavoratore art 1                          *
***************************************************************************************/
function CMInsertLavArt1(p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
                         p_prgRosa do_rosa.prgrosa%type,
                         p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
                         p_errCode OUT number           -- Codice di Errore
                         ) RETURN NUMBER IS

p_out_prgNominativo DO_NOMINATIVO.Prgnominativo%TYPE;
p_prgRichiestaAz DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE;
p_prgincrocio DO_INCROCIO.Prgincrocio%TYPE;
p_prgAlternativa DO_INCROCIO.Prgalternativa%TYPE;
p_prgTipoIncrocio DO_INCROCIO.Prgtipoincrocio%TYPE;
statorich do_evasione.cdnstatorich%TYPE;
checkTipoInc number;
checkAdesione number;
p_codtipolista cm_iscr_art1.codtipolista%type;
p_numpunteggio cm_iscr_art1.numpunteggio%type;
p_annopunteggioArt1 cm_iscr_art1.numannopunteggio%type;
p_datiscrArt1 cm_iscr_art1.datiscralbo%type;
begin

  select i.prgtipoincrocio, i.prgincrocio, i.prgrichiestaaz, i.prgalternativa, i.prgtipoincrocio
         into checkTipoInc, p_prgincrocio, p_prgRichiestaAz, p_prgAlternativa, p_prgTipoIncrocio
  from do_rosa d
  inner join do_incrocio i on i.prgincrocio = d.prgincrocio
  WHERE d.PRGROSA = p_prgRosa;

  -- verifico che si è già inserito l'adesione per quella graduatoria in un proflo diverso
  select count(nom.prgnominativo) into checkAdesione
  from do_nominativo nom
  inner join do_rosa ros on ros.prgrosa = nom.prgrosa
  inner join do_incrocio inc on inc.prgincrocio = ros.prgincrocio
  inner join do_richiesta_az rich on rich.prgrichiestaaz = inc.prgrichiestaaz
  where nom.cdnlavoratore = p_cdnLavoratore
  and inc.prgtipoincrocio = p_prgTipoIncrocio
  and rich.prgrichiestaaz = p_prgRichiestaAz
  and ros.prgrosafiglia is null;

  -- errore non è possibile inserire due adesioni per la stesso tipo di graduatoria e profili diversi
  if (checkAdesione >= 1) then
     rollback;
     return 3;
  end if;

  select r.codtipolista into p_codtipolista
  from do_richiesta_az r
  where r.prgrichiestaaz = p_prgRichiestaAz;

  select ia.numpunteggio, ia.numannopunteggio, ia.datiscralbo
         into p_numpunteggio, p_annopunteggioArt1, p_datiscrArt1
  from cm_iscr_art1 ia
  inner join am_documento_coll dc on dc.strchiavetabella = ia.prgiscrart1
  inner join am_documento ad on ad.prgdocumento = dc.prgdocumento
  where ia.cdnlavoratore = p_cdnlavoratore
  and ia.datfine is null
  AND ad.codtipodocumento = 'ILS'
  AND ad.CODSTATOATTO != 'AN'
  and ia.codtipolista = p_codtipolista;

  -- Calcolo il progressivo per il nominativo
  select s_Do_Nominativo.nextVal into p_out_prgNominativo from dual;

  -- passo 1. inserisco la nuova adesione in do_nominativo per la rosa specifica
  insert into do_nominativo
  (PRGNOMINATIVO, CDNLAVORATORE, NUMPUNTEGGIO, NUMANNOPUNTART1, DATISCRART1,
  DTMINS, CDNUTINS, PRGROSA)
  values
  (p_out_prgNominativo, p_cdnLavoratore, p_numpunteggio, p_annopunteggioArt1, p_datiscrArt1,
  sysdate, p_cdnUtente, p_prgRosa);

   -- cambio lo stato della richiesta ad ELABORAZIONE MATCH solamente se lo stato precedente è "inserita"
   select DO_EVASIONE.CDNSTATORICH into statorich from DO_EVASIONE where DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;

   if (statorich = 1) then
     UPDATE DO_EVASIONE
         SET DO_EVASIONE.CDNSTATORICH = 2,
             DO_EVASIONE.DTMMOD = SYSDATE
         WHERE DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;
   end if;

   return 0;

   exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end CMInsertLavArt1;

function protocollaImportIscrCM(encrypterKey varchar2
                     ) return number  IS
nro number;
checkCM number;
p_cdnLavoratore varchar2(255);
p_prgcmiscr number;
p_datdatainizio varchar2(10);
parprgdoc number;
parprgdocblob number;
parprgdoccoll number;
p_numprotocollo number;
p_numannoprot number;
p_dataoraprot varchar2(100);
p_codCpi an_lav_storia_inf.codcpitit%type;

begin

  DECLARE
       CURSOR iscrCursor IS
          select decrypt(i.cdnlavoratore, encrypterKey) as cdnDec, i.prgcmiscr, i.datdatainizio
          from am_cm_iscr i
          where i.prgcmiscr not in (
          select coll.strchiavetabella from AM_DOCUMENTO_COLL coll
          INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
		  where encrypt(DOC.cdnlavoratore, encrypterKey) = i.cdnlavoratore
          );

      BEGIN
             FOR iscr IN iscrCursor
             LOOP
               p_cdnLavoratore := iscr.cdnDec;
               p_prgcmiscr := iscr.prgcmiscr;
               p_datdatainizio := to_char(iscr.datdatainizio,'DD/MM/YYYY');

               select tab.codcpitit
               into p_codCpi
               from an_lav_storia_inf tab, de_cpi tab1
               WHERE
               tab.CDNLAVORATORE = p_cdnLavoratore
               AND tab.codCpiTit  = tab1.codCpi
               AND tab.datFine is null;

               select(am_protocollo.numprotocollo + 1) numprotocollo,
               am_protocollo.numannoprot,
               TO_CHAR (SYSDATE, 'dd/mm/yyyy hh24:mi') AS dataoraprot
               into p_numprotocollo, p_numannoprot, p_dataoraprot
               from am_protocollo
               where numannoprot = 2007
               for update;

               checkCM := pg_gestamm.insertdocumento(parprgdoc => parprgdoc,
                            parcodcpi => p_codCpi,
                            parcdnlav => p_cdnLavoratore,
                            parprgazienda => '',
                            parprgunita => '',
                            parcodtipodoc => 'L68',
                            parflgautocertif => '',
                            parstrdesc => '',
                            parflgdocamm => '',
                            parflgdocidentifp => '',
                            pardatainizio => p_datdatainizio,
                            parstrnumdoc => '',
                            parenterilascio => p_codCpi,
                            parcodmonoio => 'I',
                            pardataacqril => p_datdatainizio,
                            parcodmodalitaacqri => '',
                            parcodtipofile => '',
                            parstrnomedoc => '',
                            pardatafine => '',
                            parnumannoprot => p_numannoprot,
                            parnumprot => p_numprotocollo,
                            parstrnote => '',
                            parcdnutins => 200,
                            parcdnutmod => 200,
                            pardataprotocollazione => p_dataoraprot,
                            parcodstatoatto => 'PR',
                            parprgdocblob => parprgdocblob,
                            parpagina => 'CMIscrizioniLavoratorePage',
                            parprgdoccoll => parprgdoccoll,
                            parstrchiavetabella => p_prgcmiscr);

                 if (checkCM = 0) then

                    update am_protocollo set
                    numprotocollo = p_numprotocollo,
                    numkloprotocollo = numkloprotocollo+1
                    where numannoprot = 2007;

                 end if;

             END LOOP;
       END;


  return 0;

  exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       return 0;

end protocollaImportIscrCM;

function setConfigTabProt(p_encryptKey varchar2) return number  IS

checkIscr number;
newCheckIscr number;
newCond varchar2(1);
p_cdnLavoratore number;
p_cdnCrypt am_cm_iscr.cdnlavoratore%type;

CURSOR cdnCursorProt IS
  SELECT i.cdnlavoratore
  FROM AM_CM_ISCR I
  INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
  INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
  WHERE DOC.CODSTATOATTO = 'PR' and encrypt(DOC.cdnlavoratore, p_encryptKey) = i.cdnlavoratore
  and i.datdatafine is null;

begin

  FOR cdn IN cdnCursorProt
    LOOP

      p_cdnCrypt := cdn.cdnlavoratore;

      p_cdnLavoratore := decrypt(p_cdnCrypt, p_encryptKey);


      SELECT count(1)
      INTO newCheckIscr
      FROM TS_CONFIG_TAB
      WHERE CDNCONFIGTAB = p_cdnLavoratore;

      newCond := 'S';

      if (newCheckIscr = 0) then
         INSERT INTO TS_CONFIG_TAB (CDNCONFIGTAB, FLGABILITA)
         VALUES (p_cdnLavoratore, newCond);
      else
         UPDATE TS_CONFIG_TAB
         SET FLGABILITA = newCond
         WHERE CDNCONFIGTAB = p_cdnLavoratore;
      end if;

  END LOOP;

  return 0;

end setConfigTabProt;

/**
calcolo giorni lavorativi (esclusi sabato, domenica, festività pattronali)
*/
function calcoloGiorniLavorativi(p_dataInizio varchar2,
                                 p_dataFine varchar2,
                                 p_codCPI number)
                                 return number IS

l_count number:= 0;
l_countAltriFestivi number:= 0;
l_range_date number:= 0;
l_data_inizio DATE;
l_data_fine DATE;
p_numgg number;
p_nummm number;
p_numaa number;
p_datFestivo DATE;
p_ddddd varchar2(10);
p_giorniLavorativi number := 0;

CURSOR giorniFestiviCursor IS
  Select numgg, nummm, numaaaa
  from ag_giornoNL
  where (codCPI = p_codCPI or codcpi is null)
  and (flgchiusuranonfestiva is null or flgchiusuranonfestiva = 'N')
  and numgsett is null
  and to_date(p_dataFine, 'dd/mm/yyyy') <= datfineval and to_date(p_dataInizio, 'dd/mm/yyyy') >= datinizioval
  and
  ((numaaaa = to_number(to_char(to_date(p_dataInizio, 'dd/mm/yyyy'),'YYYY')) or numaaaa is null)
  or
  (numaaaa = to_number(to_char(to_date(datfineval, 'dd/mm/yyyy'),'YYYY')) or numaaaa is null)
  );

BEGIN

  l_data_fine := to_date(p_dataFine, 'DD/MM/YYYY');
  l_data_inizio := to_date(p_dataInizio, 'DD/MM/YYYY');

  l_range_date := l_data_fine - l_data_inizio + 1;

  if (l_range_date > 0) then
      FOR x IN 0.. l_range_date-1 LOOP

          -- conto i giorni festivi sabato e domenica
          IF TRIM(TO_CHAR(l_data_inizio + x, 'DY', 'nls_date_language = english' ) ) IN('SAT', 'SUN') THEN
              l_count := l_count + 1;
              --DBMS_OUTPUT.PUT_LINE(l_count || ' - ' || TO_CHAR(l_data_inizio + x, 'DD/MON/YYYY DAY' ));
          END IF;

          FOR giorniFestivi IN giorniFestiviCursor
          LOOP
              p_numgg := giorniFestivi.numgg;
              p_nummm := giorniFestivi.nummm;
              p_numaa := giorniFestivi.numaaaa;

              if (p_numaa is null) then
                 -- prendo l'anno in corso
                 p_numaa := TO_CHAR(l_data_inizio + x, 'YYYY');
              end if;

              p_datFestivo := to_date(p_numgg || '/' || p_nummm || '/' || p_numaa, 'DD/MM/YYYY');

              if (TO_CHAR(l_data_inizio + x, 'DD/MM/YYYY') = to_char(p_datFestivo, 'DD/MM/YYYY')) then
                 IF TRIM(TO_CHAR(p_datFestivo, 'DY', 'nls_date_language = english' ) ) IN('SAT', 'SUN') THEN
                    -- gia considerato nel calcolo precedente
                    l_countAltriFestivi := l_countAltriFestivi +1;
                    --DBMS_OUTPUT.PUT_LINE(' DOPPIONE ' || TO_CHAR(p_datFestivo, 'DD/MON/YYYY DAY' ));
                 ELSE
                    l_count := l_count + 1;
                    --DBMS_OUTPUT.PUT_LINE(l_count || ' - ' || TO_CHAR(l_data_inizio + x, 'DD/MON/YYYY DAY' ));
                 END IF;
              end if;

          END LOOP;

      END LOOP;
  end if;
  --DBMS_OUTPUT.PUT_LINE('TOTALE GIORNI: ' || TO_CHAR(l_range_date));
  --DBMS_OUTPUT.PUT_LINE('TOTALE GIORNIFESTIVI: ' || TO_CHAR(l_count));
  p_giorniLavorativi := l_range_date - l_count;
  --DBMS_OUTPUT.PUT_LINE('TOTALE GIORNILAVORATIVI: ' || TO_CHAR(p_giorniLavorativi));

  return p_giorniLavorativi;

  exception
      when others then
       --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       return 0;

end calcoloGiorniLavorativi;

/***
check di integrità sulle date nella ts_congif_loc per il calcolo situazione esonero
***/
function checkTsConfigLocCalcSituazEson return number IS

type t_vettore_date is table of ts_config_loc.DATINIZIOVAL%type index by binary_integer;
l_date t_vettore_date;
i pls_integer := 0;
j pls_integer := 1;

CURSOR dateTsConfigLocCursor IS
  select datinizioval, datfineval
  from TS_CONFIG_LOC
  where CODTIPOCONFIG = 'CM_ES_EU'
  and strcodrif = (select codprovinciasil from ts_generale)
  order by datfineval asc;

begin

  FOR dateTsConfigLoc IN dateTsConfigLocCursor
  LOOP
    i := i + 1;
 l_date(i) := dateTsConfigLoc.datinizioval;
 i := i + 1;
 l_date(i) := dateTsConfigLoc.datfineval;
  END LOOP;

  while j < l_date.count loop
     if (l_date(j) > l_date(j+1)) then
     return -1;
   end if;
   if (j != l_date.last -1) then
    if (l_date(j+1) != (l_date(j+2) - 1)) then
      return -1;
    end if;
   end if;
   j := j + 2;
  end loop;

  return 0;

  exception
      when others then
        return -1;

end checkTsConfigLocCalcSituazEson;

/***
calcolo situazione esonero
***/
function getCalcoloSituazioneEsonero(p_prgrichesonero cm_rich_esonero.prgrichesonero%type,
                                     p_dataCalcolo varchar2,
                                     p_out_giorniLavorativi OUT varchar2,
                                     p_out_costoTotale OUT varchar2,
                                     p_out_costoVersato OUT varchar2)
                                     return number IS

p_codCPI number;
p_codprovincia number;
p_datFine cm_rich_esonero.datfine%type;
p_dataVerifica cm_rich_esonero.datfine%type;
p_numdisabilieff cm_rich_eson_disabili.numdisabilieffett%type;
pd_datInizioValidita cm_rich_eson_disabili.datInizioValidita%type;
pd_dataPrecMax cm_rich_eson_disabili.datInizioValidita%type;
p_datInizioValidita varchar2(10);
p_dataPrecMax varchar2(10);
p_dataFineCalcolo varchar2(10);
p_costo number := 0;
p_costoUnit number := 0;
p_costo_Val number := 0;
p_giorniTot number := 0;
p_giorniLavorativi number := 0;
p_costoVersato number := 0;
checkPagamento number;

BEGIN

  select p.codcpicapoluogo, p.codprovincia into p_codCPI, p_codprovincia
  from de_provincia p
  inner join ts_generale g on g.codprovinciasil = p.codprovincia;

  if (p_dataCalcolo is not null) then
     p_dataVerifica := to_date(p_dataCalcolo, 'DD/MM/YYYY');
  else
     p_dataVerifica := to_date('31/12/2100', 'DD/MM/YYYY');
  end if;

  select e.datfine into p_datFine
  from cm_rich_esonero e
  where e.prgrichesonero = p_prgrichesonero;

  if (p_datFine < p_dataVerifica) then
     p_dataVerifica := p_datFine;
  end if;

  p_dataFineCalcolo := to_char(p_dataVerifica, 'DD/MM/YYYY');

  DECLARE
  CURSOR disabiliCursor IS
      select ed.numdisabilieffett, ed.datiniziovalidita,
      (select min(ed2.datiniziovalidita)
      from cm_rich_eson_disabili ed2
      where ed2.prgrichesonero = p_prgrichesonero
      and  ed.datiniziovalidita < ed2.datiniziovalidita
      ) as p_dataPrecMax
      from cm_rich_eson_disabili ed
      where ed.prgrichesonero = p_prgrichesonero
      and ed.datiniziovalidita <= p_dataVerifica
      order by datiniziovalidita asc;

  CURSOR costiUnitariCursor IS
     select datinizioval, datfineval, decvalore
    from TS_CONFIG_LOC
     where CODTIPOCONFIG = 'CM_ES_EU'
     and strcodrif = p_codprovincia
   order by datfineval asc;

  BEGIN

         FOR disabili IN disabiliCursor
         LOOP
             p_numdisabilieff := disabili.numdisabilieffett;
             p_datInizioValidita := to_char(disabili.datiniziovalidita, 'DD/MM/YYYY');
             p_dataPrecMax := to_char(disabili.p_dataPrecMax, 'DD/MM/YYYY');
    pd_datInizioValidita := disabili.datiniziovalidita;
    pd_dataPrecMax := disabili.p_dataPrecMax;

    if (p_dataPrecMax is not null AND pd_dataPrecMax <= p_dataVerifica) then
           p_dataFineCalcolo := p_dataPrecMax;
          else
       pd_dataPrecMax := p_dataVerifica;
    p_dataPrecMax := to_char(p_dataVerifica, 'DD/MM/YYYY');
    end if;

             FOR costiUnitari IN costiUnitariCursor
    LOOP
      p_costo_Val := costiUnitari.decvalore;

     if (costiUnitari.datfineval < pd_dataPrecMax and costiUnitari.datfineval >= pd_datInizioValidita) then
        p_dataPrecMax := to_char(costiUnitari.datfineval, 'DD/MM/YYYY');
         p_dataFineCalcolo := to_char(costiUnitari.datfineval + 1, 'DD/MM/YYYY');
      elsif (pd_dataPrecMax <= costiUnitari.datfineval) then
        p_dataFineCalcolo := to_char(pd_dataPrecMax, 'DD/MM/YYYY');
           end if;

     if (to_date(p_dataPrecMax, 'DD/MM/YYYY') >= costiUnitari.datinizioval and to_date(p_dataPrecMax, 'DD/MM/YYYY') <= costiUnitari.datfineval) then
      -- record unitari
               p_giorniLavorativi := pg_coll_mirato.calcologiornilavorativi(p_datInizioValidita, p_dataFineCalcolo, p_codCPI);
               p_costoUnit := (p_giorniLavorativi * p_numdisabilieff * p_costo_Val);

               -- record totali
               p_costo :=  p_costo + p_costoUnit;
               p_giorniTot := p_giorniTot + p_giorniLavorativi;

      if (pd_dataPrecMax > to_date(p_dataFineCalcolo, 'DD/MM/YYYY')) then
       p_datInizioValidita := p_dataFineCalcolo;
      pd_datInizioValidita := to_date(p_dataFineCalcolo, 'DD/MM/YYYY');

      p_dataPrecMax := to_char(pd_dataPrecMax, 'DD/MM/YYYY');
      end if;

      end if;
    END LOOP;

         END LOOP;
  END;

  select count(pe.decimporto) into checkPagamento
  from cm_pagamento_eson pe
  where pe.prgrichesonero = p_prgrichesonero
  and pe.datiniziocomp <= p_dataVerifica;

  if (checkPagamento > 0) then
    select sum(nvl(pe.decimporto,0)) into p_costoVersato
    from cm_pagamento_eson pe
    where pe.prgrichesonero = p_prgrichesonero
    and pe.datiniziocomp <= p_dataVerifica;
  end if;

  if (p_costoVersato is null) then
     p_costoVersato := 0;
  end if;

  p_out_giorniLavorativi :=  to_char(nvl(p_giorniTot,0), '9999990.99');
  p_out_costoTotale :=  to_char(nvl(p_costo,0), '9999990.99');
  p_out_costoVersato :=  to_char(nvl(p_costoVersato,0), '9999990.99');

  return 0;

  exception
      when others then
       --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       return -1;

end getCalcoloSituazioneEsonero;

/***
Verifica se per quella richiesta di esonero l'azienda non è in regola con i pagamaneti

0 --> azienda in regola
1 --> azienda non in regola

***/
function checkSituazioneEsonero(p_prgrichesonero cm_rich_esonero.prgrichesonero%type)
                                return number IS

p_datacalcolo varchar2(10);
p_costototale varchar2(50);
p_costoversato varchar2(50);
p_giornilavorativi varchar2(50);
p_queryCalcoloDett varchar2(1000);
p_gapCosto number := 0;
checkOk number;
retval number;

BEGIN

  p_datacalcolo := to_char(sysdate,'DD/MM/YYYY');

  retval := pg_coll_mirato.getcalcolosituazioneesonero(p_prgrichesonero,
                                             p_datacalcolo,
                                             p_out_giornilavorativi => p_giornilavorativi,
                                             p_out_costototale => p_costototale,
                                             p_out_costoversato => p_costoversato);

  if (retval = 0) then
     p_gapCosto := to_number(p_costoversato, '9999990.99') - to_number(p_costototale, '9999990.99');

     if (p_gapCosto < 0) then
        checkOk := 1;
     else
        checkOk := 0;
     end if;

  end if;

  return checkOk;

  exception
      when others then
       --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       return 0;

end checkSituazioneEsonero;


function listaCalcoloSituazioneEsonero(p_prgrichesonero cm_rich_esonero.prgrichesonero%type,
                                     p_dataCalcolo varchar2)
                                     return typRefCurs IS

p_codCPI number;
p_codprovincia number;
p_datFine cm_rich_esonero.datfine%type;
p_dataVerifica cm_rich_esonero.datfine%type;
p_numdisabilieff cm_rich_eson_disabili.numdisabilieffett%type;
pd_datInizioValidita cm_rich_eson_disabili.datInizioValidita%type;
pd_dataPrecMax cm_rich_eson_disabili.datInizioValidita%type;
p_datInizioValidita varchar2(10);
p_dataPrecMax varchar2(10);
p_datFineValidita varchar2(10);
p_dataFineCalcolo varchar2(10);
p_costo number := 0;
p_costoUnit number := 0;
p_costo_Val number := 0;
p_giorniTot number := 0;
p_giorniLavorativi number := 0;

strQuery varchar2(32000);
strQueryTot varchar2(32000);
str varchar2(32000);
risultato typRefCurs;

BEGIN

  strQueryTot := '';

  select p.codcpicapoluogo, p.codprovincia into p_codCPI, p_codprovincia
  from de_provincia p
  inner join ts_generale g on g.codprovinciasil = p.codprovincia;

  if (p_dataCalcolo is not null) then
     p_dataVerifica := to_date(p_dataCalcolo, 'DD/MM/YYYY');
  else
     p_dataVerifica := to_date('31/12/2100', 'DD/MM/YYYY');
  end if;

  select e.datfine into p_datFine
  from cm_rich_esonero e
  where e.prgrichesonero = p_prgrichesonero;

  if (p_datFine < p_dataVerifica) then
     p_dataVerifica := p_datFine;
  end if;

  p_dataFineCalcolo := to_char(p_dataVerifica, 'DD/MM/YYYY');
  p_datFineValidita := to_char(p_dataVerifica - 1, 'DD/MM/YYYY');

  DECLARE
  CURSOR disabiliCursor IS
      select ed.numdisabilieffett, ed.datiniziovalidita,
      (select min(ed2.datiniziovalidita)
      from cm_rich_eson_disabili ed2
      where ed2.prgrichesonero = p_prgrichesonero
      and  ed.datiniziovalidita < ed2.datiniziovalidita
      ) as p_dataPrecMax
      from cm_rich_eson_disabili ed
      where ed.prgrichesonero = p_prgrichesonero
      and ed.datiniziovalidita <= p_dataVerifica
      order by datiniziovalidita asc;

  CURSOR costiUnitariCursor IS
     select datinizioval, datfineval, decvalore
    from TS_CONFIG_LOC
     where CODTIPOCONFIG = 'CM_ES_EU'
     and strcodrif = p_codprovincia
   order by datfineval asc;

  BEGIN
         FOR disabili IN disabiliCursor
         LOOP
             p_numdisabilieff := disabili.numdisabilieffett;
             p_datInizioValidita := to_char(disabili.datiniziovalidita, 'DD/MM/YYYY');
             p_dataPrecMax := to_char(disabili.p_dataPrecMax, 'DD/MM/YYYY');
    pd_datInizioValidita := disabili.datiniziovalidita;
    pd_dataPrecMax := disabili.p_dataPrecMax;

    if (p_dataPrecMax is not null AND pd_dataPrecMax <= p_dataVerifica) then
           p_dataFineCalcolo := p_dataPrecMax;
             p_datFineValidita := to_char(pd_dataPrecMax - 1, 'DD/MM/YYYY');
          else
       pd_dataPrecMax := p_dataVerifica;
    p_dataPrecMax := to_char(p_dataVerifica, 'DD/MM/YYYY');
    end if;

             FOR costiUnitari IN costiUnitariCursor
    LOOP
      p_costo_Val := costiUnitari.decvalore;

     if (costiUnitari.datfineval < pd_dataPrecMax and costiUnitari.datfineval >= pd_datInizioValidita) then
        p_dataPrecMax := to_char(costiUnitari.datfineval, 'DD/MM/YYYY');
         p_dataFineCalcolo := to_char(costiUnitari.datfineval + 1, 'DD/MM/YYYY');
                 p_datFineValidita := p_dataPrecMax;
      elsif (pd_dataPrecMax <= costiUnitari.datfineval) then
        p_dataFineCalcolo := to_char(pd_dataPrecMax, 'DD/MM/YYYY');
              p_datFineValidita := to_char(pd_dataPrecMax - 1, 'DD/MM/YYYY');
           end if;

     if (to_date(p_dataPrecMax, 'DD/MM/YYYY') >= costiUnitari.datinizioval and to_date(p_dataPrecMax, 'DD/MM/YYYY') <= costiUnitari.datfineval) then
      -- record unitari
               p_giorniLavorativi := pg_coll_mirato.calcologiornilavorativi(p_datInizioValidita, p_dataFineCalcolo, p_codCPI);
               p_costoUnit := (p_giorniLavorativi * p_numdisabilieff * p_costo_Val);

               -- li inserisco nella tabella temporeanea
               if (strQueryTot is not null) then
                   strQueryTot := strQueryTot || ' union ';
               end if;

               strQuery := ' (select ''' || trim(p_datInizioValidita) ||''' as dataInizioPeriodo, '''||
                             trim(p_datFineValidita) ||''' as dataFinePeriodo, '''||
                             trim(p_dataFineCalcolo) ||''' as dataCalcolo, '''||
                             trim(to_char(nvl(p_giorniLavorativi,0), '9999990.99')) ||''' as giorni, '''||
                             trim(p_numdisabilieff) ||''' as disabiliEff, '''||
                             trim(to_char(nvl(p_costo_Val,0), '9999990.99')) ||''' as costoUnit, '''||
           trim(to_char(nvl(p_costoUnit,0), '9999990.99')) ||''' as costo from dual) ';

               strQueryTot := strQueryTot || strQuery;

               -- record totali
               p_costo :=  p_costo + p_costoUnit;
               p_giorniTot := p_giorniTot + p_giorniLavorativi;

      if (pd_dataPrecMax > to_date(p_dataFineCalcolo, 'DD/MM/YYYY')) then
       p_datInizioValidita := p_dataFineCalcolo;
      pd_datInizioValidita := to_date(p_dataFineCalcolo, 'DD/MM/YYYY');

      p_dataPrecMax := to_char(pd_dataPrecMax, 'DD/MM/YYYY');
      end if;

      end if;
    END LOOP;

         END LOOP;
  END;

  str := 'select dataInizioPeriodo, dataFinePeriodo, dataCalcolo, giorni, disabiliEff, costoUnit, costo, '||
     'to_date(dataCalcolo,''DD/MM/YYYY'') as dataCalcoloDate, '||
     'to_number(giorni,''9999990.99'') as giorniNum from ('|| strQueryTot ||') order by dataCalcoloDate asc, giorniNum desc';

  --insert into log_temp (log_query,data_query) values (str, sysdate);
  --commit;

  open risultato for str;
  return risultato;


end listaCalcoloSituazioneEsonero;


function checkHistoryCM(p_cdnLavoratore An_Lavoratore.CDNLAVORATORE%type,
                     encrypterKey varchar2
                     ) return number  IS
nro number;
checkCM number;
cdnLavCrypt varchar2(255);
begin

  cdnLavCrypt := encrypt(p_cdnLavoratore,encrypterKey);

  SELECT count(I.PRGCMISCR) into nro
  FROM AM_CM_ISCR I
  INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
  INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
  WHERE DOC.CODSTATOATTO = 'PR' and DOC.cdnlavoratore = p_cdnLavoratore
  and I.Cdnlavoratore = cdnLavCrypt;

  if (nro > 0) then
    checkCM := 1;
  else
    checkCM := 0;
  end if;

  return checkCM;

  exception
      when others then
       return 0;

end checkHistoryCM;

-- Il parametro "p_prgMov" DEVE ESSERE il progressivo di un movimento di tipo "Avviamento"
function AggLavMovDispNew(p_prgMov Am_Movimento.Prgmovimento%TYPE,
                          p_prgProspettoInf cm_prospetto_inf.prgprospettoinf%type,
                          p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                          p_key varchar2,
                          p_errCode OUT number
                         ) RETURN NUMBER IS

p_cdnLavoratore an_lavoratore.cdnlavoratore%type;
p_strCognome an_lavoratore.strcognome%type;
p_strNome an_lavoratore.strnome%type;
p_strCodiceFiscale an_lavoratore.strcodicefiscale%type;
p_datInizioMov am_movimento.datiniziomov%type;
p_datFineMov am_movimento.datfinemov%type;
p_codMansione am_movimento.codmansione%type;
p_codContratto am_movimento.codcontratto%type;
p_numConvenzioni am_movimento.numconvenzione%type;
p_flgConvenzione cm_pi_lav_riserva.flgconvenzione%type;
p_codMonoTipo cm_pi_lav_riserva.codmonotipo%type;
p_codMonoCategoria cm_pi_lav_riserva.codmonocategoria%type;
p_percInvalidita am_cm_iscr.numpercinvalidita%type;
p_categoriaPro cm_prospetto_inf.codmonocategoria%type;
p_deccopertura cm_pi_lav_riserva.deccopertura%type;
p_oreLavorate cm_pi_lav_riserva.DECORELAVORATE%type;
p_oreTotali cm_pi_lav_riserva.DECORETOTALI%type;
p_prgLavRiserva cm_pi_lav_riserva.prglavriserva%type;

begin

  select nvl(pg_anagrafica_professionale_rp.GetCategoriaDaNullaOstaForRp(mov.cdnlavoratore,mov.prgazienda,mov.datiniziomov,30), cm_isc.codmonotiporagg) as codmonocategoria,
         decode(pg_anagrafica_professionale_rp.ExistsDatInizioComputoForRp(p_prgmov),'true','R',
          nvl(pg_anagrafica_professionale_rp.GetTipoDaNullaOstaForRp(mov.cdnlavoratore,mov.prgazienda,mov.datiniziomov,30), 'M')) as codmonotipo,
         nvl(cm_isc.numpercinvalidita,0), lav.cdnlavoratore,
       lav.strCognome, lav.strNome, lav.strCodiceFiscale,
         nvl(pg_anagrafica_professionale_rp.GetDatInizioComputoForRp(p_prgmov), mov.datIniziomov) as datIniziomov,
         pg_anagrafica_professionale_rp.getdatafinemoveffforrp(p_prgmov) as datFinemov, mov.codMansione,
         DECODE
     (pg_anagrafica_professionale_rp.getcodcontrattoforrp(p_prgmov),
   'LT', DECODE
     (pg_anagrafica_professionale_rp.getcodmonotempoforrp(p_prgmov), 'I', 'LP', 'LT'),
   'LP', DECODE
        (pg_anagrafica_professionale_rp.getcodmonotempoforrp(p_prgmov),'I', 'LP', 'LT'),
   pg_anagrafica_professionale_rp.getcodcontrattoforrp(p_prgmov)
   ) AS codContratto,
         mov.Numconvenzione,
   case
      when pg_anagrafica_professionale_rp.gettipoorarioforrp(p_prgmov) = 'P'
         then pg_anagrafica_professionale_rp.getorelavorateforrp(p_prgmov)
     else
         (select numoreccnl from cm_prospetto_inf where prgprospettoinf = p_prgProspettoInf)
   end
   AS oreLavorate,
   (select numoreccnl from cm_prospetto_inf where prgprospettoinf = p_prgProspettoInf) as oretotali,
   (select lr.prglavriserva
    from cm_pi_lav_riserva lr
    inner join cm_prospetto_inf pi on pi.prgprospettoinf = lr.prgprospettoinf
    where lr.strcodicefiscalelav = lav.strcodicefiscale
    and lr.datiniziorapp = nvl(pg_anagrafica_professionale_rp.GetDatInizioComputoForRp(p_prgmov), mov.datIniziomov)
    and pi.prgprospettoinf = p_prgProspettoInf) as prglavriserva
  into p_codMonoCategoria, p_codMonoTipo, p_percInvalidita, p_cdnlavoratore,
       p_strCognome, p_strNome, p_strCodiceFiscale,
       p_datIniziomov, p_datFinemov, p_codMansione,
       p_codContratto, p_numConvenzioni,
       p_oreLavorate, p_oreTotali, p_prglavriserva
  from
 (
  select deisc.codmonotiporagg, isc.cdnlavoratore, isc.numpercinvalidita,
  isc.datdatafine, isc.datdatainizio
  from am_cm_iscr isc, de_cm_tipo_iscr deisc, am_documento_coll coll, am_documento doc,
  AM_MOVIMENTO mov_cm
 where mov_cm.prgmovimento = p_prgmov and mov_cm.cdnlavoratore = decrypt(isc.cdnlavoratore(+),p_key)
  and isc.CODCMTIPOISCR = deisc.CODCMTIPOISCR
  and isc.PRGCMISCR = coll.STRCHIAVETABELLA
  and coll.PRGDOCUMENTO = doc.PRGDOCUMENTO
  and doc.cdnlavoratore = mov_cm.cdnlavoratore
  and doc.CODTIPODOCUMENTO = 'L68'
  and doc.CODSTATOATTO = 'PR'
  --and rownum = 1
  order by isc.datanzianita68 desc, deisc.codmonotiporagg desc
  ) cm_isc,
  AM_MOVIMENTO mov, AN_LAVORATORE lav
  where mov.cdnlavoratore = lav.cdnlavoratore
  and mov.prgmovimento = p_prgmov
  and cm_isc.cdnlavoratore(+) = encrypt(mov.cdnlavoratore,p_key) and rownum = 1
  order by cm_isc.datdatafine desc;

  select pro.codmonocategoria into p_categoriaPro
  from cm_prospetto_inf pro
  where pro.prgprospettoinf = p_prgProspettoInf;

  if (p_codMonoCategoria is null) then
     p_codMonoCategoria := 'D';
  end if;

  if (p_numConvenzioni is not null) then
     p_flgConvenzione := 'S';
  end if;

  p_deccopertura := null;

  if (p_categoriaPro = 'C') then
    if (p_percInvalidita > 50) then
       p_deccopertura := 1;
       p_oreLavorate := p_oreTotali;
    else
       p_deccopertura := round(p_oreLavorate / p_oreTotali,2);
    end if;
  else
   if (p_oreTotali != 0) then
    p_deccopertura := round(p_oreLavorate / p_oreTotali,2);
   end if;
  end if;

  if (p_deccopertura > 0.50 AND p_deccopertura < 1) then
    p_deccopertura := round(p_deccopertura);
  end if;

  if (p_prglavriserva is null) then

   INSERT INTO cm_pi_lav_riserva
   (prglavriserva,
   prgprospettoinf,
   cdnlavoratore,
   strcodicefiscalelav,
   strcognomelav,
   strnomelav,
   codmonocategoria,
   codmonotipo,
   codmansione,
   datiniziorapp,
   datfinerapp,
   codcontratto,
   flgconvenzione,
   deccopertura,
   decorelavorate,
   decoretotali,
   cdnutins,
   dtmins,
   cdnutmod,
   dtmmod)
   VALUES
   (s_cm_pi_lav_riserva.nextval,
   p_prgProspettoInf,
   p_cdnlavoratore,
   p_strcodicefiscale,
   p_strcognome,
   p_strnome,
   p_codmonocategoria,
   p_codmonotipo,
   p_codmansione,
   p_datiniziomov,
   p_datfinemov,
   p_codcontratto,
   p_flgconvenzione,
   p_deccopertura,
   p_oreLavorate,
   p_oreTotali,
   p_cdnutente,
   sysdate,
   p_cdnutente,
   sysdate);

  else

   UPDATE cm_pi_lav_riserva
   SET prgprospettoinf = p_prgProspettoInf,
      cdnlavoratore = p_cdnlavoratore,
    strcodicefiscalelav = p_strcodicefiscale,
    strcognomelav = p_strcognome,
    strnomelav = p_strnome,
    codmonocategoria = p_codmonocategoria,
    codmonotipo = p_codmonotipo,
    codmansione = p_codmansione,
    datiniziorapp = p_datiniziomov,
    datfinerapp = p_datfinemov,
    codcontratto = p_codcontratto,
    flgconvenzione = p_flgconvenzione,
    deccopertura = p_deccopertura,
    decorelavorate = p_oreLavorate,
    decoretotali = p_oreTotali,
    cdnutmod = p_cdnutente,
    dtmmod = sysdate,
    numklolavriserva = numklolavriserva + 1
   WHERE prglavriserva = p_prgLavRiserva;

  end if;

  return 0;

  exception
      when others then
         p_errCode := sqlcode;
         dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         return -1;

end AggLavMovDispNew;

-- Il nulla osta deve avere una convenzione associata e lo stato del documento associato deve essere protocollato
function AggLavInConvDaNO(p_prgNullaOsta cm_nulla_osta.prgnullaosta%TYPE) RETURN NUMBER is

p_prgconv cm_convenzione.prgconv%type;
p_codstatorichiesta cm_convenzione.codstatorichiesta%type;
p_cdnLavoratore an_lavoratore.cdnlavoratore%type;
p_prgAzienda an_azienda.prgazienda%type;
p_codmonocategoria cm_nulla_osta.codmonocategoria%type;
p_codmonotipo cm_nulla_osta.codmonotipo%type;
countconvdettlav number;
p_prgconvdettaglio cm_conv_dettaglio.prgconvdettaglio%type;
checkconvDett number;
begin

  select codstatorichiesta
  into p_codstatorichiesta
  from cm_convenzione
  where prgconv = (select prgconv from cm_nulla_osta where prgnullaosta = p_prgNullaOsta);

  if (p_codstatorichiesta = 'DE') then

   select cdnlavoratore, prgazienda, prgconv, codmonocategoria, codmonotipo
   into p_cdnLavoratore, p_prgAzienda, p_prgconv, p_codmonocategoria, p_codmonotipo
   from cm_nulla_osta
   where prgnullaosta = p_prgNullaOsta;

   select count(prgconvdettaglio)
   into countconvdettlav
   from cm_conv_dettaglio
   where prgconv = p_prgconv
   and cdnlavoratore = p_cdnLavoratore
   and codstato = 'PRE';

   if (countconvdettlav = 0) then

     select count(prgconvdettaglio) into checkconvDett
     from cm_conv_dettaglio
     where prgconv = p_prgconv
     and numlavoratori = 1
     and cdnlavoratore is null
     and codmonocategoria = p_codmonocategoria
     and codmonotipo = p_codmonotipo
     and codstato = 'PRE';

     if (checkconvDett > 0) then

       select prgconvdettaglio
       into p_prgconvdettaglio
       from (
       select prgconvdettaglio
       from cm_conv_dettaglio
       where prgconv = p_prgconv
       and numlavoratori = 1
       and cdnlavoratore is null
       and codmonocategoria = p_codmonocategoria
       and codmonotipo = p_codmonotipo
       and codstato = 'PRE'
       order by datscadenza asc
       )
       where rownum = 1;

       UPDATE cm_conv_dettaglio
       SET cdnlavoratore = p_cdnlavoratore
       WHERE prgconvdettaglio = p_prgconvdettaglio;

     end if;

   end if;

  end if;

  return 0;

  exception
      when others then
         return -1;

end AggLavInConvDaNO;


/*************************************************************
ricalcola il punteggio presunto sulla base delle informazioni
correnti del lavoratore
**************************************************************/
function CalcoloPuntPresLavIsc(p_DataRiferimento varchar2,
                                        p_Anno_Reddito number,
                                        tipoincrocio varchar2,
                                        tipoGraduatoria varchar2,
                                        p_mesianzianita number,
                                        p_cdnLavEncrypt varchar2,
                                        cdnLavoratoreDecrypt varchar2,
                                        prgiscr varchar2,
                                        out_p_numReddito OUT do_nominativo.numreddito%type,
                                        out_p_numPersone OUT do_nominativo.numpersone%type,
                                        out_p_datdichcarico OUT varchar2,
                                        out_p_codcmtipoiscr OUT do_nominativo.codcmtipoiscr%type,
                                        out_p_numpercinvalidita OUT do_nominativo.numpercinvalidita%type,
                                        out_p_datanzianita68 OUT varchar2,
                                        out_p_mesianzianita OUT do_nominativo.nummesianz%type,
                                        out_p_flgpatente OUT do_nominativo.flgpatente%type,
                                        out_p_codgradocapacitaloc OUT do_nominativo.codgradocapacitaloc%type,
                                        out_p_flgdisoccti OUT do_nominativo.flgdisoccti%type,
                                        out_p_codCmAnnota OUT do_nominativo.codcmannota%type,
                                        out_p_punt_iniziale OUT varchar2,
                                        out_p_punt_carico_fam OUT varchar2,
                                        out_p_punt_reddito OUT varchar2,
                                        out_p_punt_anzianita OUT varchar2,
                                        out_p_punt_invalidita OUT varchar2,
                                        out_p_punt_locomozione OUT varchar2,
                                        out_p_punt_patente OUT varchar2,
                                        out_p_punt_totale OUT varchar2,
                                        out_p_persone_carico OUT varchar2
                                        )
                                     RETURN NUMBER IS

p_punteggioIniziale number;
p_punteggioInvalidita number;
p_punteggioPersoneCarico number;
p_punteggioAnzianita number;
p_punteggioReddito number;
p_punteggio number;
p_punteggioAnnota number;
p_cdnLavoratore do_nominativo.cdnlavoratore%type;
p_prgTipoIncrocio do_incrocio.prgtipoincrocio%type;
p_codtipolista do_richiesta_az.codtipolista%type;
valueReturn number;
p_prgConfigPunteggio ts_config_punteggio.prgconfigpunteggio%type;
p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%type;
p_prgtiporosa do_rosa.prgtiporosa%type;
p_descrCMtipoIscr de_cm_tipo_iscr.strdescrizione%type;

p_numReddito do_nominativo.numreddito%type;
p_numPersone do_nominativo.numpersone%type;
p_datdichcarico do_nominativo.datdichcarico%type;
p_codcmtipoiscr do_nominativo.codcmtipoiscr%type;
p_numpercinvalidita do_nominativo.numpercinvalidita%type;
p_datanzianita68 do_nominativo.datanzianita68%type;

p_codmonotipogradcm ts_generale.codmonotipogradcm%type;
p_dataChiamatacm do_richiesta_az.datchiamatacm%type;
p_flgpatente do_nominativo.flgpatente%type;
p_codgradocapacitaloc do_nominativo.codgradocapacitaloc%type;
p_flgdisoccti do_nominativo.flgdisoccti%type;

p_punteggioLocomozione number;
p_punteggioPatente number;
p_prgcmiscr am_cm_iscr.prgcmiscr%type;
p_nummesianzianita number;
p_annoCM do_richiesta_az.numannoredditocm%type;

p_punteggioDisocc number;
checkDisocInoc number;
checkMovTI number;

p_codCmAnnota do_nominativo.codcmannota%type;

checkValoreISEE number;

-- ale
p_codMonoTipoRagg DE_CM_TIPO_ISCR.codMonoTipoRagg%type;
tipo number;
p_personecarico number;

begin

     valueReturn := 0;
     p_flgdisoccti := null;
     p_codCmAnnota := null;

     if(tipoincrocio = 'D')then
        p_prgTipoIncrocio :=  10;
     else
        p_prgTipoIncrocio :=  11;
     end if;

     -- questo caso  sempre rosa grezza
     p_prgtiporosa := 2;

     p_dataChiamatacm := to_date(p_DataRiferimento, 'DD/MM/YYYY');

     p_annoCM := p_Anno_Reddito;

     p_cdnLavoratore := cdnLavoratoreDecrypt;
     --selezione il tipo di calcolo della graduatoria dalla ts_generale
     select codmonotipogradcm into p_codmonotipogradcm from ts_generale;

     if(p_prgtiporosa = 2) then
       -- calcolo punteggio iniziale
       p_punteggioIniziale := pg_incrocio.calcolopunteggioiniziale('CM', 'INI');

       if (p_prgTipoIncrocio = 10 OR p_prgTipoIncrocio = 11) then

         -- calcolo punteggio in base all'invalidità
         p_punteggioInvalidita := calcoloPunteggioInvalidita(p_prgTipoIncrocio, p_cdnLavoratore, p_cdnLavEncrypt, p_dataChiamatacm, p_codcmtipoiscr, p_numpercinvalidita, p_datanzianita68);

         --calcolo punteggio persone a carico
         if (p_codmonotipogradcm != 4) then
            p_punteggioPersoneCarico := calcoloPunteggioPersCarico(p_cdnLavoratore, tipoGraduatoria, p_numPersone, p_datdichcarico);
         end if;
         
         if (p_codmonotipogradcm = 2) then

            p_prgcmiscr := prgiscr;

            p_punteggioAnzianita := calcoloPuntAnzianitaUmbria(p_cdnLavoratore, to_char(p_dataChiamatacm, 'dd/mm/yyyy'), p_cdnLavEncrypt, p_prgcmiscr, p_nummesianzianita);
            -- calcolo punteggio in base al reddito
            p_punteggioReddito := punteggioredditoGradUmbria(p_cdnLavoratore, p_annoCM, 'CM', p_numReddito);
            if (p_punteggioReddito = -1) then
               p_punteggioReddito := 0;
            end if;

         elsif (p_codmonotipogradcm = 3) then
           -- per la provincia di TRENTO

           -- calcolo punteggio mesi di anzianita
           p_punteggioAnzianita := calcoloPunteggioAnzianita(p_cdnLavoratore, p_mesianzianita);

           -- punteggio lavoratore disocc non precario
           p_punteggioDisocc := 0;

           select nvl(count(o.prgstatooccupaz),0) into checkDisocInoc
           from am_stato_occupaz  o
           inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
           where cdnLavoratore = p_cdnLavoratore
           and o.datfine is null
           and s.codstatooccupazragg in ('D', 'I')
           and s.codstatooccupaz not in ('A212', 'B2');

           if (checkDisocInoc > 0) then
              -- verifico se l'ultimo mov è TI
              select count(*)
              into checkMovTI
              from am_movimento mov
              where MOV.cdnLavoratore = p_cdnLavoratore
              AND MOV.PRGMOVIMENTOSUCC IS NULL
              and mov.codstatoatto = 'PR'
              AND MOV.CODTIPOMOV = 'AVV'
              AND MOV.CODMONOTEMPO = 'I'
              AND MOV.DATFINEMOVEFFETTIVA IS NULL;

              if (checkMovTI > 0) then
                 p_punteggioDisocc := calcolopunteggiodisocc('CM');
                 p_flgdisoccti := 'S';
              end if;

           end if;

           --calcolo punteggio cm_annota
           p_punteggioAnnota := calcoloPunteggioAnnota(p_cdnLavEncrypt, p_dataChiamatacm, tipoGraduatoria, p_codCmAnnota);

           -- ISEE solo dopo il 01/01/2011
         elsif (p_codmonotipogradcm = 4) then
           -- per la provincia di VDA

           -- calcolo punteggio mesi di anzianita
           p_punteggioAnzianita := calcoloPunteggioAnzianita(p_cdnLavoratore, p_mesianzianita);
           
           -- calcolo punteggio in base al reddito ISEE 
           select count(v.numvaloreisee) into checkValoreISEE
           from AS_VALORE_ISEE v
           where v.cdnlavoratore = p_cdnLavoratore           
           and v.datinizioval <= p_dataChiamatacm
           and v.datinizioval >= add_months(p_dataChiamatacm, -12)
           and (v.datfineval >= p_dataChiamatacm 
                or v.datfineval is null);
                            
           if (checkValoreISEE != 0) then
               select v.numvaloreisee into p_numReddito
               from AS_VALORE_ISEE v
               where v.cdnlavoratore = p_cdnLavoratore               
               and v.datinizioval <= p_dataChiamatacm
               and v.datinizioval >= add_months(p_dataChiamatacm, -12)
               and (v.datfineval >= p_dataChiamatacm 
                    or v.datfineval is null);
           else       
                p_numReddito := null;
           end if;
                                
           p_punteggioReddito := ROUND(0.005*p_numReddito, 1);
           
         else
            -- calcolo punteggio mesi di anzianita
            p_punteggioAnzianita := calcoloPunteggioAnzianita(p_cdnLavoratore, p_mesianzianita);

            -- calcolo punteggio in base al reddito
            p_punteggioReddito := punteggioredditogradnumerica(p_cdnLavoratore, p_prgtipoincrocio, p_prgRichiestaAz, 'CM', p_numReddito);
         end if;

         p_flgpatente := null;
         p_codgradocapacitaloc := null;

         if (p_codmonotipogradcm = 2) then
           --calcolo punteggio locomozione
           p_punteggioLocomozione := calcoloPunteggioLocomozione(p_cdnLavoratore, p_cdnLavEncrypt, tipoGraduatoria, p_dataChiamatacm, p_codgradocapacitaloc);

           --calcolo punteggio locomozione
           p_punteggioPatente := 0;
           if (p_punteggioLocomozione > 0) then
              p_punteggioPatente := calcoloPunteggioPatente(p_cdnLavoratore, tipoGraduatoria, p_flgpatente);
           end if;
           -- punteggio totale lavoratore graduatorie numeriche

           if (p_datanzianita68 < to_date('01/04/1988','dd/mm/yyyy')) then
                    p_punteggio := p_punteggioIniziale - p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita - p_punteggioLocomozione;

                    p_punteggioAnzianita := p_punteggioAnzianita * -1;
                    p_punteggioPersoneCarico := p_punteggioPersoneCarico * -1;
                    p_punteggioInvalidita :=  p_punteggioInvalidita * -1;
                    p_punteggioLocomozione :=  p_punteggioLocomozione * -1;
            else
                    p_punteggio := p_punteggioIniziale + p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita - p_punteggioLocomozione;

                    p_punteggioPersoneCarico := p_punteggioPersoneCarico * -1;
                    p_punteggioInvalidita :=  p_punteggioInvalidita * -1;
                    p_punteggioLocomozione :=  p_punteggioLocomozione * -1;


            end if;

           if (p_flgpatente = 'S') then
                    p_punteggio := p_punteggio + p_punteggioPatente;
                 else
                    p_punteggio := p_punteggio - p_punteggioPatente;
                    p_punteggioPatente := p_punteggioPatente * -1;
                 end if;

         elsif (p_codmonotipogradcm = 3) then
             -- punteggio totale lavoratore graduatorie numeriche
             p_punteggio := p_punteggioIniziale + p_punteggioAnzianita + p_punteggioInvalidita + p_punteggioDisocc;
         elsif (p_codmonotipogradcm = 4) then
             p_punteggio := p_punteggioIniziale + p_punteggioAnzianita + p_punteggioInvalidita - p_punteggioReddito;  
         else
             -- punteggio totale lavoratore graduatorie numeriche
             p_punteggio := p_punteggioIniziale - p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita;
         end if;
       end if;
     end if;

     out_p_numReddito := p_numReddito;
     out_p_numPersone := p_numPersone;
     out_p_datdichcarico := to_char(p_datdichcarico, 'DD/MM/YYYY');
     out_p_codcmtipoiscr := p_codcmtipoiscr;
     out_p_numpercinvalidita := p_numpercinvalidita;
     out_p_datanzianita68 := to_char(p_datanzianita68, 'DD/MM/YYYY');
     if (p_codmonotipogradcm = 2) then
       out_p_mesianzianita := p_nummesianzianita;
     else
       out_p_mesianzianita := p_mesianzianita;
     end if;
     out_p_codgradocapacitaloc := p_codgradocapacitaloc;
     out_p_flgpatente := p_flgpatente;
     out_p_flgdisoccti := p_flgdisoccti;
     out_p_codCmAnnota := p_codCmAnnota;

-- num persone a carico
     select count(lc.numpersone)
            into p_personecarico
     from cm_lav_carico lc
     where lc.cdnlavoratore = p_cdnlavoratore;
     
     if (p_personecarico  > 0) then
            select lc.numpersone
            into p_personecarico
            from cm_lav_carico lc
            where lc.cdnlavoratore = p_cdnlavoratore;
     end if;

     out_p_punt_iniziale          := p_punteggioIniziale;
     out_p_punt_carico_fam        := p_punteggioPersoneCarico;
     out_p_punt_reddito           := p_punteggioReddito;
     out_p_punt_anzianita         := p_punteggioAnzianita;
     out_p_punt_invalidita        := p_punteggioInvalidita;
     out_p_punt_locomozione       := p_punteggioLocomozione;
     out_p_punt_patente           := p_punteggioPatente;
     out_p_punt_totale            := p_punteggio;
     
     out_p_persone_carico         := p_personecarico;

     return valueReturn;

     exception
     when no_data_found then
          return -1;
     when others then
          return -1;

end CalcoloPuntPresLavIsc;








/*************************************************************
ricalcola il punteggio presunto sulla base delle informazioni
correnti del lavoratore
**************************************************************/
function calcoloPunteggioPresLavoratore(p_prgNominativo number,
                                        tipoGraduatoria varchar2,
                                        p_mesianzianita number,
                                        p_cdnLavEncrypt varchar2,
                                        out_p_numReddito OUT do_nominativo.numreddito%type,
                                        out_p_numPersone OUT do_nominativo.numpersone%type,
                                        out_p_datdichcarico OUT varchar2,
                                        out_p_codcmtipoiscr OUT do_nominativo.codcmtipoiscr%type,
                                        out_p_numpercinvalidita OUT do_nominativo.numpercinvalidita%type,
                                        out_p_datanzianita68 OUT varchar2,
                                        out_p_mesianzianita OUT do_nominativo.nummesianz%type,
                                        out_p_flgpatente OUT do_nominativo.flgpatente%type,
                                        out_p_codgradocapacitaloc OUT do_nominativo.codgradocapacitaloc%type,
                                        out_p_flgdisoccti OUT do_nominativo.flgdisoccti%type,
                                        out_p_codCmAnnota OUT do_nominativo.codcmannota%type
                                        )
                                     RETURN NUMBER IS

p_punteggioIniziale number;
p_punteggioInvalidita number;
p_punteggioPersoneCarico number;
p_punteggioAnzianita number;
p_punteggioReddito number;
p_punteggio number;
p_punteggioAnnota number;
p_cdnLavoratore do_nominativo.cdnlavoratore%type;
p_prgTipoIncrocio do_incrocio.prgtipoincrocio%type;
p_codtipolista do_richiesta_az.codtipolista%type;
valueReturn number;
p_prgConfigPunteggio ts_config_punteggio.prgconfigpunteggio%type;
p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%type;
p_prgtiporosa do_rosa.prgtiporosa%type;
p_descrCMtipoIscr de_cm_tipo_iscr.strdescrizione%type;

p_numReddito do_nominativo.numreddito%type;
p_numPersone do_nominativo.numpersone%type;
p_datdichcarico do_nominativo.datdichcarico%type;
p_codcmtipoiscr do_nominativo.codcmtipoiscr%type;
p_numpercinvalidita do_nominativo.numpercinvalidita%type;
p_datanzianita68 do_nominativo.datanzianita68%type;

p_codmonotipogradcm ts_generale.codmonotipogradcm%type;
p_dataChiamatacm do_richiesta_az.datchiamatacm%type;
p_flgpatente do_nominativo.flgpatente%type;
p_codgradocapacitaloc do_nominativo.codgradocapacitaloc%type;
p_flgdisoccti do_nominativo.flgdisoccti%type;

p_punteggioLocomozione number;
p_punteggioPatente number;
p_prgcmiscr am_cm_iscr.prgcmiscr%type;
p_nummesianzianita number;
p_annoCM do_richiesta_az.numannoredditocm%type;

p_punteggioDisocc number;
checkDisocInoc number;
checkMovTI number;

p_codCmAnnota do_nominativo.codcmannota%type;

checkValoreISEE number;
valoreISEE as_valore_isee.numvaloreisee%type;

begin

     valueReturn := 0;
     p_flgdisoccti := null;
     p_codCmAnnota := null;

     --selezione il tipo di calcolo della graduatoria dalla ts_generale
     -- 1: calcolo origiario
     -- 2: aggiunta del punteggio di locomozione e patente
     select codmonotipogradcm into p_codmonotipogradcm from ts_generale;

     select i.prgtipoincrocio, nom.cdnlavoratore, raz.codtipolista, raz.prgrichiestaaz, r.prgtiporosa, raz.datchiamatacm, raz.numannoredditocm
           into p_prgTipoIncrocio, p_cdnLavoratore, p_codtipolista, p_prgRichiestaAz, p_prgtiporosa, p_dataChiamatacm, p_annoCM
     from do_nominativo nom
     inner join do_rosa r on r.prgrosa = nom.prgrosa
     inner join do_incrocio i on i.prgincrocio = r.prgincrocio
     inner join do_richiesta_az raz on raz.prgrichiestaaz = i.prgrichiestaaz
     where nom.prgnominativo = p_prgNominativo;

     if(p_prgtiporosa = 2) then
       -- calcolo punteggio iniziale
       p_punteggioIniziale := pg_incrocio.calcolopunteggioiniziale('CM', 'INI');

       if (p_prgTipoIncrocio = 10 OR p_prgTipoIncrocio = 11) then

         -- calcolo punteggio in base all'invalidità
         p_punteggioInvalidita := calcoloPunteggioInvalidita(p_prgTipoIncrocio, p_cdnLavoratore, p_cdnLavEncrypt, p_dataChiamatacm, p_codcmtipoiscr, p_numpercinvalidita, p_datanzianita68);

         --calcolo punteggio persone a carico
         p_punteggioPersoneCarico := calcoloPunteggioPersCarico(p_cdnLavoratore, tipoGraduatoria, p_numPersone, p_datdichcarico);

         if (p_codmonotipogradcm = 2) then
            select prgcmiscr
            into p_prgcmiscr
            from (
            select ci.prgcmiscr
            from am_cm_iscr ci
            inner join de_cm_tipo_iscr deisc on deisc.codcmtipoiscr = ci.codcmtipoiscr
            INNER JOIN AM_DOCUMENTO_COLL COLL ON (CI.PRGCMISCR = COLL.STRCHIAVETABELLA)
            INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
            WHERE DOC.CODSTATOATTO = 'PR' and DOC.cdnlavoratore = p_cdnLavoratore
            and deisc.codmonotiporagg = DECODE(p_prgTipoIncrocio,
                                                        10, 'D', 11, 'A')
            and ci.cdnlavoratore = p_cdnLavEncrypt
            and decode(ci.datanzianita68, null, ci.datdatainizio, ci.datanzianita68) <= trunc(p_dataChiamatacm)
            and (ci.datdatafine is null OR trunc(ci.datdatafine) > trunc(p_dataChiamatacm))
            )
            where rownum = 1
            ;


            p_punteggioAnzianita := calcoloPuntAnzianitaUmbria(p_cdnLavoratore, to_char(p_dataChiamatacm, 'dd/mm/yyyy'), p_cdnLavEncrypt, p_prgcmiscr, p_nummesianzianita);
            -- calcolo punteggio in base al reddito
            p_punteggioReddito := punteggioredditoGradUmbria(p_cdnLavoratore, p_annoCM, 'CM', p_numReddito);

         elsif (p_codmonotipogradcm = 3) then
           -- per la provincia di TRENTO

           -- calcolo punteggio mesi di anzianita
           p_punteggioAnzianita := calcoloPunteggioAnzianita(p_cdnLavoratore, p_mesianzianita);

           -- punteggio lavoratore disocc non precario
           p_punteggioDisocc := 0;

           select count(o.prgstatooccupaz) into checkDisocInoc
           from am_stato_occupaz  o
           inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
           where cdnLavoratore = p_cdnLavoratore
           and o.datfine is null
           and s.codstatooccupazragg in ('D', 'I')
           and s.codstatooccupaz not in ('A212', 'B2');

           -- se non è precario allora ha sempre i 10 punti
           if (checkDisocInoc > 0) then

              p_punteggioDisocc := calcolopunteggiodisocc('CM');
              p_flgdisoccti := 'S';

           else
              -- se è precario allora
              -- verifico se l'ultimo mov non è TI
              select count(*)
              into checkMovTI
              from am_movimento mov
              where MOV.cdnLavoratore = p_cdnLavoratore
              AND MOV.PRGMOVIMENTOSUCC IS NULL
              and mov.codstatoatto = 'PR'
              AND MOV.CODTIPOMOV in ('AVV', 'TRA', 'PRO')
              AND MOV.CODMONOTEMPO = 'I'
              AND MOV.DATFINEMOVEFFETTIVA IS NULL;

              if (checkMovTI = 0) then
                 p_punteggioDisocc := calcolopunteggiodisocc('CM');
                 p_flgdisoccti := 'S';

              end if;

           end if;

           --calcolo punteggio cm_annota
           p_punteggioAnnota := calcoloPunteggioAnnota(p_cdnLavEncrypt, p_dataChiamatacm, tipoGraduatoria, p_codCmAnnota);

           -- ISEE solo dopo il 01/01/2011
         
         elsif (p_codmonotipogradcm = 4) then
           -- VDA
           -- calcolo punteggio mesi di anzianita MAX 60
           p_punteggioAnzianita := calcoloPunteggioAnzianita(p_cdnLavoratore, p_mesianzianita);
                     
           -- calcolo punteggio in base al reddito ISEE 
           select count(v.numvaloreisee) into checkValoreISEE
           from AS_VALORE_ISEE v
           where v.cdnlavoratore = p_cdnLavoratore           
           and v.datinizioval <= p_dataChiamatacm
           and v.datinizioval >= add_months(p_dataChiamatacm, -12)
           and (v.datfineval >= p_dataChiamatacm 
                or v.datfineval is null);
                            
           if (checkValoreISEE != 0) then
               select v.numvaloreisee into p_numReddito
               from AS_VALORE_ISEE v
               where v.cdnlavoratore = p_cdnLavoratore               
               and v.datinizioval <= p_dataChiamatacm
               and v.datinizioval >= add_months(p_dataChiamatacm, -12)
               and (v.datfineval >= p_dataChiamatacm 
                    or v.datfineval is null);
           else       
                p_numReddito := null;
           end if;
                                
           p_punteggioReddito := ROUND(0.005*p_numReddito);                                      
           
         else
            -- calcolo punteggio mesi di anzianita
            p_punteggioAnzianita := calcoloPunteggioAnzianita(p_cdnLavoratore, p_mesianzianita);

            -- calcolo punteggio in base al reddito
            p_punteggioReddito := punteggioredditogradnumerica(p_cdnLavoratore, p_prgtipoincrocio, p_prgRichiestaAz, 'CM', p_numReddito);
         end if;

         p_flgpatente := null;
         p_codgradocapacitaloc := null;

         if (p_codmonotipogradcm = 2) then
           --calcolo punteggio locomozione
           p_punteggioLocomozione := calcoloPunteggioLocomozione(p_cdnLavoratore, p_cdnLavEncrypt, tipoGraduatoria, p_dataChiamatacm, p_codgradocapacitaloc);

           --calcolo punteggio locomozione
           p_punteggioPatente := 0;
           if (p_punteggioLocomozione > 0) then
              p_punteggioPatente := calcoloPunteggioPatente(p_cdnLavoratore, tipoGraduatoria, p_flgpatente);
           end if;
           -- punteggio totale lavoratore graduatorie numeriche

           if (p_datanzianita68 < to_date('01/04/1988','dd/mm/yyyy')) then
                    p_punteggio := p_punteggioIniziale - p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita - p_punteggioLocomozione;
                 else
                    p_punteggio := p_punteggioIniziale + p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita - p_punteggioLocomozione;
                 end if;

           if (p_flgpatente = 'S') then
                    p_punteggio := p_punteggio + p_punteggioPatente;
                 else
                    p_punteggio := p_punteggio - p_punteggioPatente;
                 end if;

         elsif (p_codmonotipogradcm = 3) then
             -- punteggio totale lavoratore graduatorie numeriche
             p_punteggio := p_punteggioIniziale + p_punteggioAnzianita + p_punteggioInvalidita + p_punteggioDisocc;
         
         elsif (p_codmonotipogradcm = 4) then     
              p_punteggio := p_punteggioIniziale + p_punteggioAnzianita + p_punteggioInvalidita - p_punteggioReddito;
         else
             -- punteggio totale lavoratore graduatorie numeriche
             p_punteggio := p_punteggioIniziale - p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita;
         end if;

         valueReturn := cmupdatepunteggiopreslav(p_prgNominativo, p_punteggio);
       end if;
     end if;

     out_p_numReddito := p_numReddito;
     out_p_numPersone := p_numPersone;
     out_p_datdichcarico := to_char(p_datdichcarico, 'DD/MM/YYYY');
     out_p_codcmtipoiscr := p_codcmtipoiscr;
     out_p_numpercinvalidita := p_numpercinvalidita;
     out_p_datanzianita68 := to_char(p_datanzianita68, 'DD/MM/YYYY');
     if (p_codmonotipogradcm = 2) then
       out_p_mesianzianita := p_nummesianzianita;
     else
       out_p_mesianzianita := p_mesianzianita;
     end if;
     out_p_codgradocapacitaloc := p_codgradocapacitaloc;
     out_p_flgpatente := p_flgpatente;
     out_p_flgdisoccti := p_flgdisoccti;
     out_p_codCmAnnota := p_codCmAnnota;

     return valueReturn;

     exception
     when no_data_found then
          return 0;
     when others then
          return -1;

end calcoloPunteggioPresLavoratore;

/*************************************************************************************
* esegue l'aggiornamento del numpunteggio del lavoratore nella graduatoria specifica *
*************************************************************************************/
function CMUpdatePunteggioLavoratore(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                                     p_punteggio number,
                                     p_numReddito do_nominativo.numreddito%type,
                                     p_numPersone do_nominativo.numpersone%type,
                                     p_datdichcarico do_nominativo.datdichcarico%type,
                                     p_codcmtipoiscr do_nominativo.codcmtipoiscr%type,
                                     p_numpercinvalidita do_nominativo.numpercinvalidita%type,
                                     p_datanzianita68 do_nominativo.datanzianita68%type,
                                     p_mesianzianita do_nominativo.nummesianz%type,
                                     p_flagPatente do_nominativo.flgpatente%type,
                                     p_codgradocapacitaloc do_nominativo.codgradocapacitaloc%type,
                                     p_flagdisoccti do_nominativo.flgdisoccti%type,
                                     p_codCmAnnota do_nominativo.codcmannota%type
                                    ) RETURN NUMBER IS

checkPunteggio number;
begin

     update do_nominativo
     set
     numpunteggio = p_punteggio,
     numklonominativo = numklonominativo+1,
     NUMREDDITO = p_numReddito,
     NUMPERSONE = p_numPersone,
     DATDICHCARICO = p_datdichcarico,
     CODCMTIPOISCR = p_codcmtipoiscr,
     NUMPERCINVALIDITA = p_numpercinvalidita,
     DATANZIANITA68 = p_datanzianita68,
     NUMMESIANZ = p_mesianzianita,
     FLGPATENTE = p_flagpatente,
     CODGRADOCAPACITALOC = p_codgradocapacitaloc,
     flgdisoccti = p_flagdisoccti,
     codcmannota = p_codCmAnnota,
     DTMPUNTEGGIO = sysdate
     where
     prgnominativo = p_prgNominativo;

     return 0;

 exception
      when others then
       --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
             return -1;

end CMUpdatePunteggioLavoratore;

/**************************************************************************************
* esegue l'aggiornamento del numpunteggiopres del lavoratore nella graduatoria specifica *
**************************************************************************************/
function CMUpdatePunteggioPresLav(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                                     p_punteggiopres number
                                    ) RETURN NUMBER IS

checkPunteggio number;
begin

     update do_nominativo
     set
     numpunteggiopres = p_punteggiopres,
     numklonominativo = numklonominativo+1
     where
     prgnominativo = p_prgNominativo;

     return 0;

 exception
      when others then
         rollback;
             return -1;

end CMUpdatePunteggioPresLav;

function checkIscrLavCMSoloChiuse(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
        p_datDichiarazione varchar2,
               p_encryptKey varchar2) RETURN varchar2 IS

codstatooccupazragg varchar2(1);
nro number;
checkIscrChiuseCM varchar2(10);
cdnLavCrypt varchar2(255);

begin


 SELECT de_stato_occupaz_ragg.codstatooccupazragg INTO codstatooccupazragg
 FROM am_stato_occupaz
 INNER JOIN de_stato_occupaz ON (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
 INNER JOIN de_stato_occupaz_ragg ON (de_stato_occupaz.codstatooccupazragg = de_stato_occupaz_ragg.codstatooccupazragg)
 INNER JOIN an_lav_storia_inf inf ON (am_stato_occupaz.cdnlavoratore = inf.cdnlavoratore)
 WHERE am_stato_occupaz.datfine IS NULL
 AND am_stato_occupaz.cdnlavoratore = p_cdnLavoratore
 AND inf.datfine IS NULL;

 if (codstatooccupazragg = 'D' OR codstatooccupazragg = 'I') then

  cdnLavCrypt := encrypt(p_cdnLavoratore,p_encryptKey);

     SELECT count(i.prgcmiscr) into nro
  FROM am_cm_iscr i
  INNER JOIN de_cm_tipo_iscr tis ON (i.codcmtipoiscr = tis.codcmtipoiscr)
  INNER JOIN am_documento_coll coll ON (i.prgcmiscr = coll.strchiavetabella)
  INNER JOIN am_documento doc ON (coll.prgdocumento = doc.prgdocumento)
  WHERE i.cdnlavoratore = cdnLavCrypt
  AND i.datdatafine is not null
  AND i.datdatafine <= to_date(p_datDichiarazione,'DD/MM/YYYY')
  AND doc.codtipodocumento = 'L68' and doc.cdnlavoratore = p_cdnLavoratore
  AND doc.codstatoatto = 'PR'
  AND NOT EXISTS (SELECT 1
      FROM am_cm_iscr i1
      INNER JOIN de_cm_tipo_iscr tis1 ON (i1.codcmtipoiscr = tis1.codcmtipoiscr)
      INNER JOIN am_documento_coll coll1 ON (i1.prgcmiscr = coll1.strchiavetabella)
      INNER JOIN am_documento doc1 ON (coll1.prgdocumento = doc1.prgdocumento)
      WHERE i1.cdnlavoratore = cdnLavCrypt
      AND doc1.codtipodocumento = 'L68' and doc1.cdnlavoratore = p_cdnLavoratore
      AND doc1.codstatoatto = 'PR'
      AND i1.datdatainizio >= i.datdatainizio
      AND i1.prgcmiscr > i.prgcmiscr
      AND tis1.codmonotiporagg = tis.codmonotiporagg)
  ORDER BY i.datdatainizio DESC, i.datdatafine DESC;

  if (nro > 0) then
        checkIscrChiuseCM := 'true';
     else
     checkIscrChiuseCM := 'false';
  end if;

 else
     checkIscrChiuseCM := 'false';
   end if;

 return checkIscrChiuseCM;

exception
 when others then
     return 'false';

end checkIscrLavCMSoloChiuse;

function checkNumPunteggio(tipoGraduatoria varchar2,
                              flagDescr varchar2)
                              RETURN NUMBER IS

punteggio number;
begin

        select cl.num into punteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = flagDescr;

        return punteggio;

        exception
        when no_data_found then
        return 0;

end checkNumPunteggio;

function calcoloPunteggioLocomozione(p_cdnlavoratore number,
                                    p_cdnLavEncrypt varchar2,
                                    tipoGraduatoria varchar2,
                                    p_datachiamatacm do_richiesta_az.datchiamatacm%type,
                                    out_p_codgradocapacitaloc OUT do_nominativo.codgradocapacitaloc%type)
                                    RETURN NUMBER IS
p_numPunteggioLocomozione number;
checkDiagnosi number;
p_codgrado cm_capacita.codgradocapacita%type;
begin

    select nvl(count(df.prgdiagnosifunzionale),0) into checkDiagnosi
    from cm_diagnosi_funzionale df
    where df.datdiagnosi <= p_datachiamatacm
    and (df.datfine >= p_datachiamatacm or df.datfine is null)
    and df.cdnlavoratore = p_cdnLavEncrypt;

    if (checkDiagnosi > 0) then

       select cc.codgradocapacita into out_p_codgradocapacitaloc
       from cm_diagnosi_funzionale df
       left join cm_capacita cc on cc.prgdiagnosifunzionale = df.prgdiagnosifunzionale
       where df.cdnlavoratore = p_cdnLavEncrypt
       and df.datdiagnosi <= p_datachiamatacm
       and (df.datfine >= p_datachiamatacm or df.datfine is null)
       and cc.codcapacita = 'LOU';

       if (out_p_codgradocapacitaloc = 3) then
           p_numPunteggioLocomozione := checkNumPunteggio(tipoGraduatoria, 'LOCOMOZIONE_MIN');
       elsif (out_p_codgradocapacitaloc = 4) then
           p_numPunteggioLocomozione := checkNumPunteggio(tipoGraduatoria, 'LOCOMOZIONE_MED');
       elsif (out_p_codgradocapacitaloc = 5) then
           p_numPunteggioLocomozione := checkNumPunteggio(tipoGraduatoria, 'LOCOMOZIONE_MAX');
       else
           p_numPunteggioLocomozione := 0;
       end if;

       return p_numPunteggioLocomozione;
    else
       return 0;
    end if;

    exception
    when no_data_found then
         return 0;

end calcoloPunteggioLocomozione;

function calcoloPunteggioPatente(p_cdnlavoratore number,
                                 tipoGraduatoria varchar2,
                                 out_flgPatente OUT do_nominativo.flgpatente%type)
                                RETURN NUMBER IS
p_numPunteggioPatente number;
numPatenti number;
begin

     select nvl(count(ab.prgabilitazione),0) into numPatenti
     from pr_abilitazione ab
     where ab.codabilitazionegen like '%PG%'
     and ab.cdnlavoratore =  p_cdnlavoratore;

     if (numPatenti > 0) then
        out_flgPatente := 'S';
        p_numPunteggioPatente := checkNumPunteggio(tipoGraduatoria, 'PATENTE_OK');
     else
        out_flgPatente := 'N';
        p_numPunteggioPatente := checkNumPunteggio(tipoGraduatoria, 'PATENTE_NO');
     end if;

     return p_numPunteggioPatente;

     exception
     when no_data_found then
          return 0;

end calcoloPunteggioPatente;


function CMCreaGraduatoriaAnnuale(p_annoGraduatoria varchar2,
                                  p_dataRifGrad varchar2,
                                  p_annoRifReddito varchar2,
                                  p_codmonotipograd cm_graduatoria.codmonotipograd%type,
                                  p_strnota cm_graduatoria.strnota%type,
                                  encrypeterKey varchar2,
                                  p_cdnUtente TS_UTENTE.CDNUT%TYPE,
								  p_ambitoTerr varchar2,
                                  out_p_prggraduatoria OUT cm_graduatoria.prggraduatoria%type,
                                  p_errCode OUT number)
                                 RETURN NUMBER IS

p_newprggraduatoria cm_graduatoria.prggraduatoria%type;
checkGraduatoria number;
cdnLavCrypt am_cm_iscr.cdnlavoratore%type;
p_cdnLavoratore cm_grad_nominativo.cdnlavoratore%type;
p_codCpi an_lav_storia_inf.codcpitit%type;
checkCodCpi number;
checkDisocInoc number;
p_num number;
p_prgcmiscr am_cm_iscr.prgcmiscr%type;
p_prggradnominativo cm_grad_nominativo.prggradnominativo%type;
checkPunteggio number;
p_datdatainiziocm am_cm_iscr.datdatainizio%type;
p_delete number;
p_configGradDI number;

/*CURSOR iscrCMCursor IS
  select iscr.cdnlavoratore, count(1) as num
  from am_cm_iscr iscr
  inner join de_cm_tipo_iscr tiscr on tiscr.codcmtipoiscr = iscr.codcmtipoiscr
  where tiscr.codmonotiporagg = p_codmonotipograd
  and iscr.codstatoatto = 'PR'
  and decode(iscr.DATANZIANITA68,null,iscr.datdatainizio,'',iscr.datdatainizio,iscr.DATANZIANITA68) <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
  and (iscr.datdatafine is null OR iscr.datdatafine > to_date(p_dataRifGrad, 'dd/mm/yyyy'))
  group by iscr.cdnlavoratore
  order by num desc;*/

CURSOR iscrCMCursor IS
select count(1) as num, cdnlavoratore from
  (select iscr.cdnlavoratore, max(iscr.datdatainizio)
  from am_cm_iscr iscr
  inner join de_cm_tipo_iscr tiscr on tiscr.codcmtipoiscr = iscr.codcmtipoiscr
  inner join cm_verbale_accert verb on verb.cdnlavoratore = decrypt(iscr.cdnlavoratore, encrypeterKey)
             and verb.datverbaleprimaist <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
             and (verb.datverbalerevisionato is null OR verb.datverbalerevisionato >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
  where tiscr.codmonotiporagg = p_codmonotipograd
  and iscr.codstatoatto = 'PR'
  and decode(iscr.DATANZIANITA68,null,iscr.datdatainizio,'',iscr.datdatainizio,iscr.DATANZIANITA68) <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
  and (iscr.datdatafine is null OR iscr.datdatafine >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
  and iscr.codprovincia = p_ambitoTerr
  group by iscr.cdnlavoratore
  )
group by  cdnlavoratore;

CURSOR iscrCMArt18Cursor IS
select count(1) as num, cdnlavoratore from
  (select iscr.cdnlavoratore, max(iscr.datdatainizio)
  from am_cm_iscr iscr
  inner join de_cm_tipo_iscr tiscr on tiscr.codcmtipoiscr = iscr.codcmtipoiscr
  where tiscr.codmonotiporagg = p_codmonotipograd
  and iscr.codstatoatto = 'PR'
  and decode(iscr.DATANZIANITA68,null,iscr.datdatainizio,'',iscr.datdatainizio,iscr.DATANZIANITA68) <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
  and (iscr.datdatafine is null OR iscr.datdatafine >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
  and iscr.codprovincia = p_ambitoTerr
  group by iscr.cdnlavoratore
  )
group by  cdnlavoratore;


begin

     select count(g.prggraduatoria) into checkGraduatoria
     from cm_graduatoria g
     where g.numanno = p_annoGraduatoria
     and g.codmonotipograd = p_codmonotipograd
     and g.codprovincia = p_ambitoTerr
     and g.codstatograd IN ('1', '4');

     if (checkGraduatoria > 0) then
       -- errore: graduatoria corrente o storicizzata già presente
       return 1;
     else

       -- inserisco la graduatoria
       insert into cm_graduatoria
       (prggraduatoria, prggraduatoriaprec, numanno, codstatograd, dtmins, cdnutins,
        strnota, codmonotipograd, datriferimento, numannoreddito, codprovincia,
        DTMMOD, CDNUTMOD)
       values
       (s_cm_graduatoria.nextval, null, p_annoGraduatoria, '1', sysdate, p_cdnUtente,
        p_strnota, p_codmonotipograd, to_date(p_dataRifGrad, 'dd/mm/yyyy'), p_annoRifReddito, p_ambitoTerr,
        sysdate, p_cdnUtente);
        
        commit;
		
		select nvl( (select to_char(ts_config_loc.num) 
		from ts_config_loc
        where strcodrif=(select ts_generale.codprovinciasil from ts_generale) and codtipoconfig='CMGRADDI') , 0)
        into p_configGradDI
        from dual;
		
        select max(prggraduatoria) into p_newprggraduatoria
        from cm_graduatoria;
        
       -- recupero i nominativi da inserire
       if (p_codmonotipograd = 'D') then
       FOR iscrCM IN iscrCMCursor
       LOOP
        cdnLavCrypt := iscrCM.cdnlavoratore;
        p_cdnLavoratore := decrypt(cdnLavCrypt, encrypeterKey);
        p_num := iscrCM.num;

        if (p_num = 1) then
		 
		 if (p_configGradDI = 0) then
			 select count(o.prgstatooccupaz) into checkDisocInoc
			 from am_stato_occupaz o
			 inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
			 where cdnLavoratore = p_cdnLavoratore
			 and o.datfine is null
			 and s.codstatooccupazragg in ('D', 'I');
		 else
			select count(o.prgstatooccupaz) into checkDisocInoc
			 from am_stato_occupaz o
			 inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
			 where cdnLavoratore = p_cdnLavoratore
			 and to_date(p_dataRifGrad, 'dd/mm/yyyy') between trunc(o.datinizio) and trunc(nvl(o.datfine, to_date(p_dataRifGrad, 'dd/mm/yyyy')))
			 and s.codstatooccupazragg in ('D', 'I');
		 end if;

         if (checkDisocInoc > 0) then
           select count(tab.codcpitit) into checkCodCpi
           from an_lav_storia_inf tab, de_cpi tab1
           WHERE
           tab.CDNLAVORATORE = p_cdnLavoratore
           AND tab.codCpiTit  = tab1.codCpi
           AND tab.datFine is null;

           if (checkCodCpi > 0) then
             select tab.codcpitit
             into p_codCpi
             from an_lav_storia_inf tab, de_cpi tab1
             WHERE
             tab.CDNLAVORATORE = p_cdnLavoratore
             AND tab.codCpiTit  = tab1.codCpi
             AND tab.datFine is null;

             select prgcmiscr, datdatainizio
             into p_prgcmiscr, p_datdatainiziocm
             from (
             select isc.prgcmiscr, isc.datdatainizio
             from am_cm_iscr isc
             inner join de_cm_tipo_iscr tisc on tisc.codcmtipoiscr = isc.codcmtipoiscr
             inner join cm_verbale_accert verb on verb.cdnlavoratore = decrypt(isc.cdnlavoratore, encrypeterKey)
                         and verb.datverbaleprimaist <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
                         and (verb.datverbalerevisionato is null OR verb.datverbalerevisionato >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
             where tisc.codmonotiporagg = p_codmonotipograd
             and isc.codstatoatto = 'PR'
             and isc.cdnlavoratore = cdnLavCrypt
             and decode(isc.DATANZIANITA68,null,isc.datdatainizio,'',isc.datdatainizio,isc.DATANZIANITA68) <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
             and (isc.datdatafine is null OR isc.datdatafine >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
			 and isc.codprovincia = p_ambitoTerr
             order by isc.datdatainizio desc)
             where rownum = 1;
                
             p_prggradnominativo := InsertCmGradNominativo(p_newprggraduatoria, p_cdnLavoratore, p_codCpi, p_cdnUtente);
             if (p_prggradnominativo = -1) then
                -- errore inaspettato
                p_delete := DeleteCmGradNominativo(p_newprggraduatoria);                
                return -1;
             end if;
             -- calcolo punteggio per il lavoratore
             checkPunteggio := CMCalcPunteggioGradUmbria(p_newprggraduatoria,
                                   p_prggradnominativo,
                                   p_prgcmiscr,
                                   p_cdnLavoratore,
                                   p_annoGraduatoria,
                                   p_dataRifGrad,
                                   p_annoRifReddito,
                                   p_codmonotipograd,
                                   encrypeterKey,
                                   'N',
                                   p_cdnUtente,
                                   p_errCode);

           end if;
         end if;
        end if;
       END LOOP;

       elsif (p_codmonotipograd = 'A') then
       -- recupero i nominativi da inserire
       FOR iscrCM IN iscrCMArt18Cursor
       LOOP
        cdnLavCrypt := iscrCM.cdnlavoratore;
        p_cdnLavoratore := decrypt(cdnLavCrypt, encrypeterKey);
        p_num := iscrCM.num;

        if (p_num = 1) then
			
		 if (p_configGradDI = 0) then
			 select count(o.prgstatooccupaz) into checkDisocInoc
			 from am_stato_occupaz o
			 inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
			 where cdnLavoratore = p_cdnLavoratore
			 and o.datfine is null
			 and s.codstatooccupazragg in ('D', 'I');
		 else
			 select count(o.prgstatooccupaz) into checkDisocInoc
			 from am_stato_occupaz o
			 inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
			 where cdnLavoratore = p_cdnLavoratore
			 and to_date(p_dataRifGrad, 'dd/mm/yyyy') between trunc(o.datinizio) and trunc(nvl(o.datfine, to_date(p_dataRifGrad, 'dd/mm/yyyy')))
			 and s.codstatooccupazragg in ('D', 'I');
		 end if;
		 
         if (checkDisocInoc > 0) then
           select count(tab.codcpitit) into checkCodCpi
           from an_lav_storia_inf tab, de_cpi tab1
           WHERE
           tab.CDNLAVORATORE = p_cdnLavoratore
           AND tab.codCpiTit  = tab1.codCpi
           AND tab.datFine is null;

           if (checkCodCpi > 0) then
             select tab.codcpitit
             into p_codCpi
             from an_lav_storia_inf tab, de_cpi tab1
             WHERE
             tab.CDNLAVORATORE = p_cdnLavoratore
             AND tab.codCpiTit  = tab1.codCpi
             AND tab.datFine is null;

             select prgcmiscr, datdatainizio
             into p_prgcmiscr, p_datdatainiziocm
             from (
             select isc.prgcmiscr, isc.datdatainizio
             from am_cm_iscr isc
             inner join de_cm_tipo_iscr tisc on tisc.codcmtipoiscr = isc.codcmtipoiscr
             where tisc.codmonotiporagg = p_codmonotipograd
             and isc.codstatoatto = 'PR'
             and isc.cdnlavoratore = cdnLavCrypt
             and decode(isc.DATANZIANITA68,null,isc.datdatainizio,'',isc.datdatainizio,isc.DATANZIANITA68) <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
             and (isc.datdatafine is null OR isc.datdatafine >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
			 and isc.codprovincia = p_ambitoTerr
             order by isc.datdatainizio desc)
             where rownum = 1;
             
             p_prggradnominativo := InsertCmGradNominativo(p_newprggraduatoria, p_cdnLavoratore, p_codCpi, p_cdnUtente);              
             if (p_prggradnominativo = -1) then
                -- errore inaspettato
                p_delete := DeleteCmGradNominativo(p_newprggraduatoria);
                return -1;
             end if;
             -- calcolo punteggio per il lavoratore
             checkPunteggio := CMCalcPunteggioGradUmbria(p_newprggraduatoria,
                                   p_prggradnominativo,
                                   p_prgcmiscr,
                                   p_cdnLavoratore,
                                   p_annoGraduatoria,
                                   p_dataRifGrad,
                                   p_annoRifReddito,
                                   p_codmonotipograd,
                                   encrypeterKey,
                                   'N',
                                   p_cdnUtente,
                                   p_errCode);

           end if;
         end if;
        end if;
       END LOOP;

       end if;
     end if;

     out_p_prggraduatoria := p_newprggraduatoria;

     return 0;

     exception
     when others then
          --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
          rollback;
          return -1;

end CMCreaGraduatoriaAnnuale;

function InsertCmGradNominativo(p_newprggraduatoria cm_graduatoria.prggraduatoria%type,
                                p_cdnLavoratore an_lavoratore.cdnlavoratore%type, 
                                p_codCpi an_lav_storia_inf.codcpitit%type, 
                                p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                ) RETURN NUMBER IS

p_prggradnominativo number;
begin

  
     insert into cm_grad_nominativo 
             (prggradnominativo, prggraduatoria, cdnlavoratore,
              codcpitit, dtmins, cdnutins)
              values
              ( s_cm_grad_nominativo.nextval, p_newprggraduatoria, p_cdnLavoratore,
              p_codCpi, sysdate, p_cdnUtente);

     commit;
     
     select max(prggradnominativo) into p_prggradnominativo
     from cm_grad_nominativo;         

     return p_prggradnominativo;
     
 exception
      when others then
       --  dbms_output.put_line('Errore insert grad nomin= ' || sqlcode || ' ' || sqlerrm);
       --  rollback;
             return -1;

end InsertCmGradNominativo;

function DeleteCmGradNominativo(p_newprggraduatoria cm_graduatoria.prggraduatoria%type) RETURN NUMBER IS

begin
     delete from cm_punteggio_anno 
     where prggradnominativo in 
     (select prggradnominativo from cm_grad_nominativo where prggraduatoria = p_newprggraduatoria);
     
     delete from cm_grad_nominativo where prggraduatoria = p_newprggraduatoria;
     
     delete from cm_graduatoria where prggraduatoria = p_newprggraduatoria;
     
     commit;
         
     return 0;
     
 exception
      when others then
       --  dbms_output.put_line('Errore insert grad nomin= ' || sqlcode || ' ' || sqlerrm);
       --  rollback;
           return -1;

end DeleteCmGradNominativo;

function CMCalcPunteggioGradUmbria(p_prgGraduatoria number,
                                   p_prggradnominativo number,
                                   p_prgcmiscr number,
                                   p_cdnLavoratore number,
                                   p_annoGraduatoria varchar2,
                                   p_dataRifGrad varchar2,
                                   p_annoRifReddito varchar2,
                                   p_codmonotipograd cm_graduatoria.codmonotipograd%type,
                                   encrypeterKey varchar2,
                                   flgRigenera varchar2,
                                   p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                   p_errCode OUT number )
                                   RETURN NUMBER IS

valueReturn number;
p_prgConfigPunteggio ts_config_punteggio.prgconfigpunteggio%type;
p_punteggio number;
p_punteggioIniziale number;
p_punteggioInvalidita number;
p_punteggioPersoneCarico number;
p_punteggioAnzianita number;
p_punteggioReddito number;
p_punteggioLocomozione number;
p_punteggioPatente number;

p_codmonotipogradcm ts_generale.codmonotipogradcm%type;
p_numReddito number;
p_cdnLavEncrypt am_cm_iscr.cdnlavoratore%type;
p_codcmtipoiscr cm_grad_nominativo.codcmtipoiscr%type;
p_numpercinvalidita cm_grad_nominativo.numpercinvalidita%type;
p_datanzianita68 cm_grad_nominativo.datanzianita68%type;
p_prggradnominativoOld cm_grad_nominativo.prggradnominativo%type;
p_numPersone cm_grad_nominativo.numpersone%type;
p_datdichcarico cm_grad_nominativo.datdichcarico%type;
p_flgpatente cm_grad_nominativo.flgpatente%type;
p_codgradocapacitaloc cm_grad_nominativo.codgradocapacitaloc%type;
p_flgpatenteOld cm_grad_nominativo.flgpatente%type;
p_mesianzianita cm_grad_nominativo.nummesianz%type;


CURSOR nominativiCursor IS
select n.prggradnominativo, n.cdnlavoratore, n.nummesianz,
(select nomOld.Prggradnominativo
from cm_grad_nominativo nomOld
inner join cm_graduatoria grad on grad.prggraduatoriaprec = nomOld.Prggraduatoria
where nomOld.Cdnlavoratore = n.cdnlavoratore
and grad.Prggraduatoria = p_prgGraduatoria) as prgOld
from cm_grad_nominativo n
where n.prggraduatoria = p_prgGraduatoria
and n.prggradnominativo = p_prggradnominativo
order by prggradnominativo;

begin

FOR nominativi IN nominativiCursor
LOOP
   p_prggradnominativoOld := nominativi.prgOld;

   select codmonotipogradcm into p_codmonotipogradcm from ts_generale;
   p_cdnLavEncrypt := encrypt(p_cdnLavoratore, encrypeterKey);
   -- calcolo punteggio iniziale
   p_punteggioIniziale := pg_incrocio.calcolopunteggioiniziale('CM', 'INI');

   -- calcolo punteggio in base al reddito
   p_punteggioReddito := punteggioredditoGradUmbria(p_cdnLavoratore, p_annoRifReddito, 'CM', p_numReddito);

   if (p_punteggioReddito < 0) then
      -- punteggio nullo se reddito non presente

      -- caso di reddito nullo
      -- punteggio nullo e inserimento della nota
      update cm_grad_nominativo
      set
      NUMKLOGRADNOMINATIVO = NUMKLOGRADNOMINATIVO+1,
      STRNOTA = 'Il punteggio risulta nullo, verificare il reddito del lavoratore'
      where
      prggradnominativo = p_prgGradnominativo;

      valueReturn := 0;

   else

      -- salvo il punteggio iniziiale
      p_prgConfigPunteggio := checkprgconfigpunteggio('CM', 'INI');
      CMupdatepunteggioGradAnnuale(p_prgGradnominativo, p_prgConfigPunteggio, p_punteggioIniziale, p_cdnUtente);

      -- salvo il punteggio reddito
      p_prgConfigPunteggio := checkprgconfigpunteggio('CM', 'RED');
      CMupdatepunteggioGradAnnuale(p_prgGradnominativo, p_prgConfigPunteggio, p_punteggioReddito, p_cdnUtente);


      -- calcolo punteggio in base all'invalidità
      p_punteggioInvalidita := 0;
      p_punteggioInvalidita := calcPuntInvaliditaGradAnnuale(p_codmonotipograd, p_cdnLavoratore, p_cdnLavEncrypt, p_dataRifGrad, p_codcmtipoiscr, p_numpercinvalidita, p_datanzianita68);
      if (p_punteggioInvalidita < 0) then
        -- punteggio nullo se reddito non presente

        -- caso di reddito nullo
        -- punteggio nullo e inserimento della nota
        update cm_grad_nominativo
        set
        NUMKLOGRADNOMINATIVO = NUMKLOGRADNOMINATIVO+1,
        STRNOTA = 'Il punteggio risulta nullo, verificare iscrizione CM'
        where
        prggradnominativo = p_prgGradnominativo;

        valueReturn := 0;

      else
        -- se viene rigenerata la graduatoria annuale non si deve ricalcolare il punteggio di invalidità
        p_prgConfigPunteggio := checkprgconfigpunteggio('CM', 'INVAL');
        if (p_prggradnominativoOld is not null) then
           -- viene recuperato il vecchio punteggio di invalidità
           begin

           select pa.decpunteggio
           into p_punteggioInvalidita
           from cm_punteggio_anno pa
           where pa.prgconfigpunteggio = p_prgConfigPunteggio
           and pa.prggradnominativo = p_prggradnominativoOld;

           exception
           when no_data_found then
                p_punteggioInvalidita := 0;
           end;
        end if;
        -- salvo il punteggio
        CMupdatepunteggioGradAnnuale(p_prgGradnominativo, p_prgConfigPunteggio, p_punteggioInvalidita, p_cdnUtente);

        --calcolo punteggio persone a carico
        p_punteggioPersoneCarico := calcoloPunteggioPersCarico(p_cdnLavoratore, 'CM', p_numPersone, p_datdichcarico);
        -- salvo il punteggio
        p_prgConfigPunteggio := checkprgconfigpunteggio('CM', 'PERS_CAR');
        CMupdatepunteggioGradAnnuale(p_prgGradnominativo, p_prgConfigPunteggio, p_punteggioPersoneCarico, p_cdnUtente);

        -- calcolo punteggio mesi di anzianita
        -- calcolo punteggio mesi di anzianita PREGRESSA (-1*MESE) e REISCRIZIONE (+1*MESE) da APRILE 1988
        p_punteggioAnzianita := calcoloPuntAnzianitaUmbria(p_cdnLavoratore, p_dataRifGrad, p_cdnLavEncrypt, p_prgcmiscr, p_mesianzianita);

        -- salvo il punteggio
        p_prgConfigPunteggio := checkprgconfigpunteggio('CM', 'ANZ');
        CMupdatepunteggioGradAnnuale(p_prgGradnominativo, p_prgConfigPunteggio, p_punteggioAnzianita, p_cdnUtente);

        p_flgpatente := null;
        p_codgradocapacitaloc := null;

        if (p_codmonotipogradcm = 2 AND p_codmonotipograd = 'D') then
             --calcolo punteggio locomozione
             p_punteggioLocomozione := calcoloPunteggioLocomozione(p_cdnLavoratore, p_cdnLavEncrypt, 'CM', to_date(p_dataRifGrad, 'dd/mm/yyyy'), p_codgradocapacitaloc);
             -- salvo il punteggio
             p_prgConfigPunteggio := checkprgconfigpunteggio('CM', 'LOCOMOZIONE');
             CMupdatepunteggioGradAnnuale(p_prgGradnominativo, p_prgConfigPunteggio, p_punteggioLocomozione, p_cdnUtente);

             --calcolo punteggio locomozione
             p_punteggioPatente := 0;
             if (p_punteggioLocomozione > 0) then
                -- salvo il punteggio
                p_prgConfigPunteggio := checkprgconfigpunteggio('CM', 'PATENTE');
                if (p_prggradnominativoOld is not null) then
                   -- viene recuperato il vecchio punteggio di patente
                   begin
                   select pa.decpunteggio
                   into p_punteggioPatente
                   from cm_punteggio_anno pa
                   where pa.prgconfigpunteggio = p_prgConfigPunteggio
                   and pa.prggradnominativo = p_prggradnominativoOld;

                   exception
                   when no_data_found then
                        p_punteggioPatente := 0;
                   end;

                   begin
                   select cmgrad.flgpatente into p_flgpatenteOld
                   from cm_grad_nominativo cmgrad
                   where cmgrad.prggradnominativo = p_prggradnominativoOld;

                   exception
                   when no_data_found then
                        p_flgpatenteOld := null;
                   end;

                   p_flgpatente := p_flgpatenteOld;

                else
                   p_punteggioPatente := calcoloPunteggioPatente(p_cdnLavoratore, 'CM', p_flgpatente);
                end if;
             end if;

             CMupdatepunteggioGradAnnuale(p_prgGradnominativo, p_prgConfigPunteggio, p_punteggioPatente, p_cdnUtente);

             -- punteggio totale lavoratore graduatorie numeriche
             if (p_datanzianita68 < to_date('01/04/1988','dd/mm/yyyy')) then
                p_punteggio := p_punteggioIniziale - p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita - p_punteggioLocomozione;
             else
                p_punteggio := p_punteggioIniziale + p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita - p_punteggioLocomozione;
             end if;

             if (p_flgpatente = 'S') then
                p_punteggio := p_punteggio + p_punteggioPatente;
             else
                p_punteggio := p_punteggio - p_punteggioPatente;
             end if;
         else
           -- punteggio totale lavoratore graduatorie numeriche
           if (p_datanzianita68 < to_date('01/04/1988','dd/mm/yyyy')) then
                    p_punteggio := p_punteggioIniziale - p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita ;
           else
                    p_punteggio := p_punteggioIniziale + p_punteggioAnzianita - p_punteggioPersoneCarico + p_punteggioReddito - p_punteggioInvalidita ;
           end if;
         end if;

         -- inserisco il punteggio finale nella tabella do_nominativo
         valueReturn := CMupdatepuntlavGradAnnuale(p_prgGradnominativo, p_punteggio,
                                                 p_numReddito, p_numPersone,
                                                 p_datdichcarico, p_codcmtipoiscr,
                                                 p_numpercinvalidita, p_datanzianita68,
                                                 p_mesianzianita, p_flgpatente, p_codgradocapacitaloc);
       end if;
     end if;
END LOOP;

     return valueReturn;

     exception
     when no_data_found then
          return -1;
     when others then
           p_errCode := sqlcode;
           --dbms_output.put_line('cdnlav=' || p_cdnlavoratore ||' Errore= ' || sqlcode || ' ' || sqlerrm);
           rollback;
           return -1;

end CMCalcPunteggioGradUmbria;

procedure CMUpdatePunteggioGradAnnuale(p_prgGradnominativo cm_grad_nominativo.prggradnominativo%type,
                           p_prgConfigPunteggio Ts_Config_Punteggio.Prgconfigpunteggio%TYPE,
                           p_punteggio number,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE
                           ) IS

checkPunteggio number;
queryWhere VARCHAR2(255);
p_punti number;
begin

  select count(ap.prggradnominativo) into checkPunteggio from cm_punteggio_anno ap
  where ap.prggradnominativo = p_prgGradnominativo
  and ap.prgconfigpunteggio = p_prgConfigPunteggio;

  p_punti := p_punteggio;
  if (p_punti is null) then
     p_punti := 0;
  end if;

  if (checkPunteggio = 0) then

     insert into cm_punteggio_anno
     (prggradnominativo, prgconfigpunteggio, decpunteggio, cdnutins, dtmins)
     values
     (p_prgGradnominativo, p_prgConfigPunteggio, p_punti, p_cdnUtente, sysdate);

  else

     -- storicizzazione nella tabella di LOG
     queryWhere :=  ' WHERE prggradnominativo = ' || p_prgGradnominativo ||
             'AND prgconfigpunteggio = ' || p_prgConfigPunteggio || ' ';

     PG_LOG.doLog('U', 'CM_PUNTEGGIO_ANNO', p_cdnUtente, queryWhere);

     update cm_punteggio_anno
     set
     decpunteggio = p_punti,
     cdnutins = p_cdnUtente,
     dtmins = sysdate
     where
     prggradnominativo = p_prgGradnominativo
     and prgconfigpunteggio = p_prgConfigPunteggio;

  end if;

 exception
      when others then
       --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;

end CMUpdatePunteggioGradAnnuale;

function calcPuntInvaliditaGradAnnuale(p_codmonotipogradcm cm_graduatoria.codmonotipograd%type,
                                    p_cdnlavoratore number,
                                    p_cdnLavEncrypt varchar2,
                                    p_dataRifGrad varchar2,
                                    out_p_codcmtipoiscr OUT am_cm_iscr.codcmtipoiscr%type,
                                    out_p_numpercinvalidita OUT am_cm_iscr.numpercinvalidita%type,
                                    out_p_datanzianita68 OUT am_cm_iscr.datanzianita68%type)
                                    RETURN NUMBER IS

checkInvalidita number;
p_codMonoTipo TS_CM_PUNTI_INVALID.CODMONOTIPO%type;
p_codcmtipoiscr am_cm_iscr.codcmtipoiscr%type;
p_numpercinvalidita am_cm_iscr.numpercinvalidita%type;
puntiInvalidita ts_cm_punti_invalid.decpunti%type;
p_datanzianita68 am_cm_iscr.datanzianita68%type;
p_datdatainiziocm am_cm_iscr.datdatainizio%type;

begin
     puntiInvalidita := 0;

     if (p_codmonotipogradcm = 'D') then
        checkInvalidita := 1;
     elsif (p_codmonotipogradcm = 'A') then
        checkInvalidita := 0;
     end if;

     if (checkInvalidita = 1) then
         select codcmtipoiscr, numpercinvalidita, datanzianita68, datdatainizio
         into p_codcmtipoiscr, p_numpercinvalidita, p_datanzianita68, p_datdatainiziocm
         from (
         select i.codcmtipoiscr, i.numpercinvalidita,
         decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68) as datanzianita68, i.datdatainizio
         from am_cm_iscr i
         inner join de_cm_tipo_iscr t on t.codcmtipoiscr = i.codcmtipoiscr
         WHERE i.CODSTATOATTO = 'PR'
         and i.cdnlavoratore = p_cdnLavEncrypt
         and decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68) <= to_date(p_dataRifGrad,'dd/mm/yyyy')
         and (i.datdatafine is null OR i.datdatafine >= to_date(p_dataRifGrad,'dd/mm/yyyy'))
         and t.codmonotiporagg = 'D'
         order by i.datdatainizio desc)
         where rownum = 1;

       out_p_codcmtipoiscr := p_codcmtipoiscr;
       out_p_numpercinvalidita := p_numpercinvalidita;
       out_p_datanzianita68 := p_datanzianita68;

       if (p_codcmtipoiscr = '04' OR p_codcmtipoiscr = '08' OR p_codcmtipoiscr = '12' OR p_codcmtipoiscr = '13' OR p_codcmtipoiscr = '09' OR p_codcmtipoiscr = '11') then
          select pi.decpunti into puntiInvalidita
          from ts_cm_punti_invalid pi
          where pi.codmonotipo = 'P'
          and pi.declimiteinf <= p_numpercinvalidita
          and p_numpercinvalidita <= pi.declimitesup;
       elsif (p_codcmtipoiscr = '01' OR p_codcmtipoiscr = '02' OR p_codcmtipoiscr = '03') then
          select pi.decpunti into puntiInvalidita
          from ts_cm_punti_invalid pi
          where pi.codmonotipo = 'C'
          and pi.declimiteinf <= p_numpercinvalidita
          and p_numpercinvalidita <= pi.declimitesup;
       end if;

     else
       select codcmtipoiscr, numpercinvalidita, datanzianita68, datdatainizio
       into p_codcmtipoiscr, p_numpercinvalidita, p_datanzianita68, p_datdatainiziocm
       from (
       select i.codcmtipoiscr, i.numpercinvalidita,
       decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68) as datanzianita68 , i.datdatainizio
       from am_cm_iscr i
       inner join de_cm_tipo_iscr t on t.codcmtipoiscr = i.codcmtipoiscr
       WHERE i.CODSTATOATTO = 'PR'
       and i.cdnlavoratore = p_cdnLavEncrypt
       and decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68) <= to_date(p_dataRifGrad,'dd/mm/yyyy')
       and (i.datdatafine is null OR i.datdatafine >= to_date(p_dataRifGrad,'dd/mm/yyyy'))
       and t.codmonotiporagg = 'A'
       order by i.datdatainizio desc)
       where rownum = 1;

       out_p_codcmtipoiscr := p_codcmtipoiscr;
       out_p_numpercinvalidita := p_numpercinvalidita;
       out_p_datanzianita68 := p_datanzianita68;

     end if;

     return puntiInvalidita;

     exception
     when no_data_found then
          return 0;
     when TOO_MANY_ROWS then
          return -1;

end calcPuntInvaliditaGradAnnuale;

function punteggioRedditoGradUmbria(p_cdnlavoratore number,
                                      p_annoCM cm_graduatoria.numannoreddito%type,
                                      tipoGraduatoria varchar2,
                                      out_p_numReddito OUT do_nominativo.numreddito%type)
                                      RETURN NUMBER IS

p_redditoLav cm_lav_reddito.numreddito%type;
checkReddito number;
p_gapReddito number;
p_incrPuntiOgni number;
p_euroOgni number;
p_punteggioRedd number;
checkFasciaRed number;
p_maxPunti ts_cm_punti_invalid.decpunti%type;
p_maxReddito ts_cm_punti_invalid.declimitesup%type;
p_puntiFasciaRed ts_cm_punti_invalid.decpunti%type;
p_frazioneRedd number;
p_frazioneFinaleRed number;

begin

        select count(cmr.prglavreddito) into checkReddito
        from cm_lav_reddito cmr
        where cmr.cdnlavoratore = p_cdnlavoratore
        and cmr.numanno = p_annoCM
        and (cmr.datfineval is null or cmr.datfineval >= sysdate);

        if (checkReddito > 0) then
           select cmr.numreddito into p_redditoLav
           from cm_lav_reddito cmr
           where cmr.cdnlavoratore = p_cdnlavoratore
           and cmr.numanno = p_annoCM
           and (cmr.datfineval is null or cmr.datfineval >= sysdate);

           p_incrPuntiOgni := incrementoNumPuntiReddito(tipoGraduatoria);
           p_euroOgni := checkArt1EuroRedditoOgni(tipoGraduatoria);

           select count(pi.decpunti) into checkFasciaRed
           from ts_cm_punti_invalid pi
           where pi.codmonotipo = 'R'
           and pi.declimiteinf <= p_redditoLav
           and p_redditoLav <= pi.declimitesup;

           if (checkFasciaRed > 0) then
              select pi.decpunti into p_puntiFasciaRed
              from ts_cm_punti_invalid pi
              where pi.codmonotipo = 'R'
              and pi.declimiteinf <= p_redditoLav
              and p_redditoLav <= pi.declimitesup;

              p_punteggioRedd := p_puntiFasciaRed;

           else
              select max(pi.decpunti), max(declimitesup)
                    into p_maxPunti, p_maxReddito
              from ts_cm_punti_invalid pi
              where pi.codmonotipo = 'R'
              and pi.declimitesup < p_redditoLav;

              p_gapReddito := p_redditoLav - p_maxReddito;

              p_frazioneRedd := (p_gapReddito / p_euroOgni);
			  
			  p_frazioneFinaleRed := ceil(p_frazioneRedd);
			  
              p_punteggioRedd := p_maxPunti + (p_frazioneFinaleRed * p_incrPuntiOgni);

           end if;

           out_p_numreddito := p_redditoLav;

           return p_punteggioRedd;

        else
            out_p_numreddito := 0;
            return -1;
        end if;

        exception
        when no_data_found then
             return 0;

end punteggioRedditoGradUmbria;

function CMupdatepuntlavGradAnnuale(p_prgGradnominativo cm_grad_nominativo.prggradnominativo%type,
                                     p_punteggio number,
                                     p_numReddito cm_grad_nominativo.numreddito%type,
                                     p_numPersone cm_grad_nominativo.numpersone%type,
                                     p_datdichcarico cm_grad_nominativo.datdichcarico%type,
                                     p_codcmtipoiscr cm_grad_nominativo.codcmtipoiscr%type,
                                     p_numpercinvalidita cm_grad_nominativo.numpercinvalidita%type,
                                     p_datanzianita68 cm_grad_nominativo.datanzianita68%type,
                                     p_mesianzianita cm_grad_nominativo.nummesianz%type,
                                     p_flagPatente cm_grad_nominativo.flgpatente%type,
                                     p_codgradocapacitaloc cm_grad_nominativo.codgradocapacitaloc%type
                                    ) RETURN NUMBER IS

checkPunteggio number;
begin

     update cm_grad_nominativo
     set
     numpunteggio = p_punteggio,
     NUMREDDITO = p_numReddito,
     NUMPERSONE = p_numPersone,
     DATDICHCARICO = p_datdichcarico,
     CODCMTIPOISCR = p_codcmtipoiscr,
     NUMPERCINVALIDITA = p_numpercinvalidita,
     DATANZIANITA68 = p_datanzianita68,
     NUMMESIANZ = p_mesianzianita,
     FLGPATENTE = p_flagpatente,
     CODGRADOCAPACITALOC = p_codgradocapacitaloc,
     NUMKLOGRADNOMINATIVO = NUMKLOGRADNOMINATIVO+1
     where
     prggradnominativo = p_prgGradnominativo;

     return 0;

 exception
      when others then
       --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
             return -1;

end CMupdatepuntlavGradAnnuale;

function CMCalcPosizioneGradAnnuale(p_prgGraduatoria cm_graduatoria.prggraduatoria%type,
                                    p_key varchar2)
                                    RETURN NUMBER IS

i number;
checkIscrArt1 number;
begin

  i := 0;

    DECLARE
       CURSOR nominativiCursor IS
         select n.prggradnominativo, n.numpunteggio, l.datnasc,
         --i.datdatainizio,
         decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68),
         ti.strdescrizione,
         decode (ti.codcmtipoiscr, 14, 0, 1) as ordinaVittime,
         l.cdnlavoratore, max(i.datdatainizio) as maxDat
         from cm_grad_nominativo n
         inner join cm_graduatoria g on g.prggraduatoria = n.prggraduatoria
         inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
         inner join am_cm_iscr i on decrypt(i.cdnlavoratore, p_key) = n.cdnlavoratore
         inner join DE_CM_TIPO_ISCR ti on (i.codcmtipoiscr=ti.codcmtipoiscr)
         where n.prggraduatoria = p_prgGraduatoria
         and i.codstatoatto = 'PR'
         and decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68) <= g.datriferimento
         and (i.datdatafine is null OR trunc(i.datdatafine) >= trunc(g.datriferimento))
         and ti.codmonotiporagg=g.codmonotipograd
         and n.numpunteggio is not null
         group by n.prggradnominativo, n.numpunteggio, l.datnasc,
         --i.datdatainizio,
         decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68),
         ti.strdescrizione,
         decode (ti.codcmtipoiscr, 14, 0, 1),
         l.cdnlavoratore
         order by ordinaVittime, numpunteggio,
         --maxDat desc,
         decode(i.DATANZIANITA68, null, i.datdatainizio, i.DATANZIANITA68) asc,
         datnasc desc;
       BEGIN
       i := 0;
       FOR nominativi IN nominativiCursor
       LOOP
          i := i+1;

          update cm_grad_nominativo
          set numordine = i,
              NUMKLOGRADNOMINATIVO = NUMKLOGRADNOMINATIVO+1
          where cm_grad_nominativo.prggradnominativo = nominativi.prggradnominativo;

       END LOOP;
    END;

   --commit;

   return 0;

   exception
   when others then
    --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
     rollback;
         return -1;

end CMCalcPosizioneGradAnnuale;

function CMRigeneraGradAnnuale(p_prgGraduatoria number,
                              encrypeterKey varchar2,
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                              out_p_prggraduatoria OUT cm_graduatoria.prggraduatoria%type
                              )
                              RETURN NUMBER IS

p_newprggraduatoria cm_graduatoria.prggraduatoria%type;
checkNominativo number;
p_dataRifGrad varchar2(10);
p_codmonotipograd cm_graduatoria.codmonotipograd%type;
cdnLavCrypt am_cm_iscr.cdnlavoratore%type;
p_cdnLavoratore cm_grad_nominativo.cdnlavoratore%type;
p_codCpi an_lav_storia_inf.codcpitit%type;
p_oldCodCpi an_lav_storia_inf.codcpitit%type;
checkCodCpi number;
checkDisocInoc number;
p_num number;
p_prggradnominativo cm_grad_nominativo.prggradnominativo%type;
checkPunteggio number;
p_prgcmiscr am_cm_iscr.prgcmiscr%type;
p_numanno cm_graduatoria.numanno%type;
p_annoRifReddito cm_graduatoria.numannoreddito%type;
p_codprovinciaGrad cm_graduatoria.codprovincia%type;
p_errCode number;
p_configGradDI number;
begin

     -- aggiorno lo stato 'RIGENERATA' alla graduatoria di partenza
     update cm_graduatoria grad
     set grad.codstatograd = '2',
     grad.numklograduatoria = grad.numklograduatoria+1,
     grad.dtmmod = sysdate,
     grad.cdnutmod = p_cdnUtente
     where grad.prggraduatoria = p_prgGraduatoria;

     -- recupero i parametri per l'inserimento dei nominativi
     select to_char(gradOld.Datriferimento, 'dd/mm/yyyy'), gradOld.Codmonotipograd, numanno, numannoreddito, gradOld.codprovincia
     into p_dataRifGrad, p_codmonotipograd, p_numanno, p_annoRifReddito, p_codprovinciaGrad
     from cm_graduatoria gradOld
     where gradOld.prggraduatoria = p_prgGraduatoria;


     select s_cm_graduatoria.nextval into p_newprggraduatoria from dual;

     -- inserisco la graduatoria
     insert into cm_graduatoria
     (prggraduatoria, prggraduatoriaprec, numanno, codstatograd, dtmins, cdnutins,
     strnota, codmonotipograd, datriferimento, numannoreddito, codprovincia,
     dtmmod, cdnutmod)
     select
     p_newprggraduatoria, p_prgGraduatoria, g.numanno, '1', sysdate, p_cdnUtente,
     g.strnota, g.codmonotipograd, g.datriferimento, g.numannoreddito, g.codprovincia,
     sysdate, p_cdnUtente
     from cm_graduatoria g
     where g.prggraduatoria = p_prgGraduatoria;
	 
	 select nvl( (select to_char(ts_config_loc.num) 
	 from ts_config_loc
	 where strcodrif=(select ts_generale.codprovinciasil from ts_generale) and codtipoconfig='CMGRADDI') , 0)
	 into p_configGradDI
	 from dual;
	 
     if (p_codmonotipograd = 'D') then

       DECLARE
       CURSOR iscrCMCursor IS
          select count(1) as num, cdnlavoratore from
          (select iscr.cdnlavoratore, max(iscr.datdatainizio)
          from am_cm_iscr iscr
          inner join de_cm_tipo_iscr tiscr on tiscr.codcmtipoiscr = iscr.codcmtipoiscr
          inner join cm_verbale_accert verb on verb.cdnlavoratore = decrypt(iscr.cdnlavoratore, encrypeterKey)
               and verb.datverbaleprimaist <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
               and (verb.datverbalerevisionato is null OR verb.datverbalerevisionato >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
          where tiscr.codmonotiporagg = p_codmonotipograd
          and iscr.codstatoatto = 'PR'
          and decode(iscr.DATANZIANITA68,null,iscr.datdatainizio,'',iscr.datdatainizio,iscr.DATANZIANITA68) <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
          and (iscr.datdatafine is null OR iscr.datdatafine >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
		  and iscr.codprovincia = p_codprovinciaGrad
          group by iscr.cdnlavoratore
          )
          group by  cdnlavoratore;

       BEGIN
       -- recupero i nominativi da inserire
       FOR iscrCM IN iscrCMCursor
       LOOP

         cdnLavCrypt := iscrCM.cdnlavoratore;
         p_cdnLavoratore := decrypt(cdnLavCrypt, encrypeterKey);
         p_num := iscrCM.num;

         -- controllo se vi è una unica iscrizione al CM
         if (p_num = 1) then
          -- verifica stato occupazionale
		  if (p_configGradDI = 0) then
			 select count(o.prgstatooccupaz) into checkDisocInoc
			 from am_stato_occupaz o
			 inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
			 where cdnLavoratore = p_cdnLavoratore
			 and o.datfine is null
			 and s.codstatooccupazragg in ('D', 'I');
		  else
			 select count(o.prgstatooccupaz) into checkDisocInoc
			 from am_stato_occupaz o
			 inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
			 where cdnLavoratore = p_cdnLavoratore
			 and to_date(p_dataRifGrad, 'dd/mm/yyyy') between trunc(o.datinizio) and trunc(nvl(o.datfine, to_date(p_dataRifGrad, 'dd/mm/yyyy')))
			 and s.codstatooccupazragg in ('D', 'I');
		  end if;

          if (checkDisocInoc > 0) then

           select count(tab.codcpitit) into checkCodCpi
           from an_lav_storia_inf tab, de_cpi tab1
           WHERE
           tab.CDNLAVORATORE = p_cdnLavoratore
           AND tab.codCpiTit  = tab1.codCpi
           AND tab.datFine is null;


           if (checkCodCpi > 0) then
             select tab.codcpitit
             into p_codCpi
             from an_lav_storia_inf tab, de_cpi tab1
             WHERE
             tab.CDNLAVORATORE = p_cdnLavoratore
             AND tab.codCpiTit = tab1.codCpi
             AND tab.datFine is null;

             select prgcmiscr
             into p_prgcmiscr
             from (
             select isc.prgcmiscr
             from am_cm_iscr isc
             inner join de_cm_tipo_iscr tisc on tisc.codcmtipoiscr = isc.codcmtipoiscr
             inner join cm_verbale_accert verb on verb.cdnlavoratore = decrypt(isc.cdnlavoratore, encrypeterKey)
               and verb.datverbaleprimaist <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
               and (verb.datverbalerevisionato is null OR verb.datverbalerevisionato >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
             where tisc.codmonotiporagg = p_codmonotipograd
             and isc.codstatoatto = 'PR'
             and isc.cdnlavoratore = cdnLavCrypt
             and decode(isc.DATANZIANITA68,null,isc.datdatainizio,'',isc.datdatainizio,isc.DATANZIANITA68) <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
             and (isc.datdatafine is null OR isc.datdatafine >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
			 and isc.codprovincia = p_codprovinciaGrad
             order by isc.datdatainizio desc)
             where rownum = 1
             ;

             select s_cm_grad_nominativo.nextval into p_prggradnominativo from dual;

             insert into cm_grad_nominativo gradNom
             (prggradnominativo, prggraduatoria, cdnlavoratore,
              codcpitit, dtmins, cdnutins)
              values
              (p_prggradnominativo, p_newprggraduatoria, p_cdnLavoratore,
              p_codCpi, sysdate, p_cdnUtente);

              -- calcolo punteggio per il lavoratore
              checkPunteggio := CMCalcPunteggioGradUmbria(p_newprggraduatoria,
                                     p_prggradnominativo,
                                     p_prgcmiscr,
                                     p_cdnLavoratore,
                                     p_numanno,
                                     p_dataRifGrad,
                                     p_annoRifReddito,
                                     p_codmonotipograd,
                                     encrypeterKey,
                                     'S',
                                     p_cdnUtente,
                                     p_errCode);

           end if;
          end if;
         end if;

       END LOOP;
       END;
     elsif (p_codmonotipograd = 'A') then

       DECLARE
       CURSOR iscrCMArt18Cursor IS
          select count(1) as num, cdnlavoratore from
          (select iscr.cdnlavoratore, max(iscr.datdatainizio)
          from am_cm_iscr iscr
          inner join de_cm_tipo_iscr tiscr on tiscr.codcmtipoiscr = iscr.codcmtipoiscr
          where tiscr.codmonotiporagg = p_codmonotipograd
          and iscr.codstatoatto = 'PR'
          and decode(iscr.DATANZIANITA68,null,iscr.datdatainizio,'',iscr.datdatainizio,iscr.DATANZIANITA68) <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
          and (iscr.datdatafine is null OR iscr.datdatafine >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
		  and iscr.codprovincia = p_codprovinciaGrad
          group by iscr.cdnlavoratore
          )
          group by  cdnlavoratore;

       BEGIN
       -- recupero i nominativi da inserire
       FOR iscrCM IN iscrCMArt18Cursor
       LOOP

         cdnLavCrypt := iscrCM.cdnlavoratore;
         p_cdnLavoratore := decrypt(cdnLavCrypt, encrypeterKey);
         p_num := iscrCM.num;

         -- controllo se vi è una unica iscrizione al CM
         if (p_num = 1) then
          -- verifica stato occupazionale
		  if (p_configGradDI = 0) then
			 select count(o.prgstatooccupaz) into checkDisocInoc
			 from am_stato_occupaz o
			 inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
			 where cdnLavoratore = p_cdnLavoratore
			 and o.datfine is null
			 and s.codstatooccupazragg in ('D', 'I');
		  else
			 select count(o.prgstatooccupaz) into checkDisocInoc
			 from am_stato_occupaz o
			 inner join de_stato_occupaz s on s.codstatooccupaz = o.codstatooccupaz
			 where cdnLavoratore = p_cdnLavoratore
			 and to_date(p_dataRifGrad, 'dd/mm/yyyy') between trunc(o.datinizio) and trunc(nvl(o.datfine, to_date(p_dataRifGrad, 'dd/mm/yyyy')))
			 and s.codstatooccupazragg in ('D', 'I');
		  end if;
		  
          if (checkDisocInoc > 0) then

           select count(tab.codcpitit) into checkCodCpi
           from an_lav_storia_inf tab, de_cpi tab1
           WHERE
           tab.CDNLAVORATORE = p_cdnLavoratore
           AND tab.codCpiTit  = tab1.codCpi
           AND tab.datFine is null;


           if (checkCodCpi > 0) then
             select tab.codcpitit
             into p_codCpi
             from an_lav_storia_inf tab, de_cpi tab1
             WHERE
             tab.CDNLAVORATORE = p_cdnLavoratore
             AND tab.codCpiTit = tab1.codCpi
             AND tab.datFine is null;

             select prgcmiscr
             into p_prgcmiscr
             from (
             select isc.prgcmiscr
             from am_cm_iscr isc
             inner join de_cm_tipo_iscr tisc on tisc.codcmtipoiscr = isc.codcmtipoiscr
             where tisc.codmonotiporagg = p_codmonotipograd
             and isc.codstatoatto = 'PR'
             and isc.cdnlavoratore = cdnLavCrypt
             and decode(isc.DATANZIANITA68,null,isc.datdatainizio,'',isc.datdatainizio,isc.DATANZIANITA68) <= to_date(p_dataRifGrad, 'dd/mm/yyyy')
             and (isc.datdatafine is null OR isc.datdatafine >= to_date(p_dataRifGrad, 'dd/mm/yyyy'))
			 and isc.codprovincia = p_codprovinciaGrad
             order by isc.datdatainizio desc)
             where rownum = 1
             ;

             select s_cm_grad_nominativo.nextval into p_prggradnominativo from dual;

             insert into cm_grad_nominativo gradNom
             (prggradnominativo, prggraduatoria, cdnlavoratore,
              codcpitit, dtmins, cdnutins)
              values
              (p_prggradnominativo, p_newprggraduatoria, p_cdnLavoratore,
              p_codCpi, sysdate, p_cdnUtente);

              -- calcolo punteggio per il lavoratore
              checkPunteggio := CMCalcPunteggioGradUmbria(p_newprggraduatoria,
                                     p_prggradnominativo,
                                     p_prgcmiscr,
                                     p_cdnLavoratore,
                                     p_numanno,
                                     p_dataRifGrad,
                                     p_annoRifReddito,
                                     p_codmonotipograd,
                                     encrypeterKey,
                                     'S',
                                     p_cdnUtente,
                                     p_errCode);

           end if;
          end if;
         end if;

       END LOOP;
       END;

     end if;

     out_p_prggraduatoria := p_newprggraduatoria;

     return 0;

     exception
     when others then
          --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
          rollback;
          return -1;

end CMRigeneraGradAnnuale;


function CMAnnullaGradAnnuale(p_prgGraduatoria cm_graduatoria.prggraduatoria%type,
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE)
                              RETURN NUMBER IS

i number;
p_numanno cm_graduatoria.numanno%type;
p_oldGraduatoria cm_graduatoria.prggraduatoria%type;
checkGraduatoria number;
p_codmonotipograd cm_graduatoria.codmonotipograd%type;
p_prggraduatoriaprec cm_graduatoria.prggraduatoriaprec%type;

begin

     i := 0;

     -- annullo la graduatoria
     UPDATE CM_GRADUATORIA GRAD
     SET GRAD.CODSTATOGRAD = '3',
     GRAD.NUMKLOGRADUATORIA = GRAD.NUMKLOGRADUATORIA + 1,
     GRAD.CDNUTMOD = p_cdnUtente,
     GRAD.Dtmmod = sysdate
     WHERE GRAD.PRGGRADUATORIA = p_prgGraduatoria;

     select grad1.numanno, grad1.codmonotipograd, grad1.prggraduatoriaprec
     into p_numanno, p_codmonotipograd, p_prggraduatoriaprec
     from cm_graduatoria grad1
     where grad1.PRGGRADUATORIA = p_prgGraduatoria;

     -- se non esiste recupero quella rigenerata precedente (se esiste)
     if (p_prggraduatoriaprec > 0) then
        UPDATE CM_GRADUATORIA GRADOLD
             SET GRADOLD.CODSTATOGRAD = '1',
             GRADOLD.NUMKLOGRADUATORIA = GRADOLD.NUMKLOGRADUATORIA + 1,
             GRADOLD.CDNUTMOD = p_cdnUtente,
             GRADOLD.Dtmmod = sysdate
             WHERE GRADOLD.PRGGRADUATORIA = p_prggraduatoriaprec;
     end if;

    return 0;

   exception
   when others then
     dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
     rollback;
         return -1;

end CMAnnullaGradAnnuale;

function calcoloPuntAnzianitaUmbria(p_cdnlavoratore number,
                                    p_dataRifGrad varchar2,
                                    p_cdnLavEncrypt am_cm_iscr.cdnlavoratore%type,
                                    p_prgCMIscr am_cm_iscr.prgcmiscr%type,
                                    out_p_mesianzianita OUT cm_grad_nominativo.nummesianz%type)
                                    RETURN NUMBER IS

p_numPunti number;
p_mesiAnzIscr number;
p_mesiAnzReiscr number;
p_datanzianita68 varchar2(10);
p_datInizioAnz varchar2(10);
p_gap number;
p_mesiAnzianita number;
p_punteggioAnzianita number;
begin

     p_numPunti := incrementoNumPuntiAnzianita('CM');

     -- calcolo i mesi di anzianità
     /**
     metodo calcolo
     1) se la data è inferiore al 30/04/1988
        si verifica che se (30 - gg + 1) > 15 e se il gg del mese è il 15  allora si somma un mese in più
     2) se la data è superiore al 30/04/1988
        si verifica che se (30 - gg) = 15 si deve togliere un mese
     **/


     select
       case
           when decode(cia.datanzianita68, null, cia.datdatainizio, cia.datanzianita68) < to_date('01/04/1988','dd/mm/yyyy')
                then
                     round(months_between(to_date('01/04/1988','dd/mm/yyyy'), to_date('01/'||to_char(decode(cia.datanzianita68, null, cia.datdatainizio, cia.datanzianita68), 'mm/yyyy'),'dd/mm/yyyy')))
           else 0
      end
      as mesiAnzIscr,
      case
           when decode(cia.datanzianita68, null, cia.datdatainizio, cia.datanzianita68) >= to_date('30/04/1988','dd/mm/yyyy')
                then
                     round(months_between(to_date('01/'||to_char(decode(cia.datanzianita68, null, cia.datdatainizio, cia.datanzianita68), 'mm/yyyy'),'dd/mm/yyyy'), to_date('01/04/1988','dd/mm/yyyy')))
           else 0
      end
      as mesiAnzReiscr,
      to_char(decode(cia.datanzianita68, null, cia.datdatainizio, cia.datanzianita68), 'dd/mm/yyyy') as datanzianita68,
      to_char(to_date('30/04/1988', 'dd/mm/yyyy'), 'dd/mm/yyyy') as datInizioAnz
      into p_mesiAnzIscr, p_mesiAnzReiscr, p_datanzianita68, p_datInizioAnz
      from am_cm_iscr cia
      where cia.cdnlavoratore = p_cdnLavEncrypt
      and cia.prgcmiscr = p_prgCMIscr;

      if (p_mesiAnzIscr = 0) then
      -- caso in cui ho una reiscrizione all'art1
      -- punteggioAnz = +1 * ogni mese successivo al 30/04/1988

         p_gap := ceil(p_mesiAnzReiscr) - p_mesiAnzReiscr;
         if (p_gap >= 0.5) then
            p_mesiAnzianita := p_mesiAnzReiscr;
         else
            p_mesiAnzianita := ceil(p_mesiAnzReiscr);
         end if;

         p_punteggioAnzianita := p_numPunti * p_mesiAnzianita;

      else
      -- caso di iscrizione pregresssa
      -- punteggioAnz = -1 * ogni mese fino al 30/04/1988

         p_gap := ceil(p_mesiAnzIscr) - p_mesiAnzIscr;
         if (p_gap >= 0.5) then
            p_mesiAnzianita := p_mesiAnzIscr;
         else
            p_mesiAnzianita := ceil(p_mesiAnzIscr);
         end if;

         --p_punteggioAnzianita := -1 * p_numPunti * p_mesiAnzianita;
         p_punteggioAnzianita := p_numPunti * p_mesiAnzianita;

      end if;

      out_p_mesianzianita := p_mesiAnzianita;
      return p_punteggioAnzianita;

     exception
     when no_data_found then
          return 0;

end calcoloPuntAnzianitaUmbria;

procedure BatchChiusuraCmSuperamentoEta(p_result OUT Varchar2,
                      p_dataRifEta IN varchar2,
                     p_ut IN TS_UTENTE.CDNUT%TYPE,
                    p_key varchar2) IS
  maxEtaM number;
  maxEtaF number;
  maxEta number;
  dataRifEta date;
  conta number;
  dataChiusura date;

  CURSOR iscrCMCursor IS
    select cm.PRGCMISCR, l.DATNASC, l.STRSESSO
        from am_cm_iscr cm, an_lavoratore l
      where cm.CODSTATOATTO = 'PR'
         and cm.DATDATAFINE is null
        and encrypt(l.CDNLAVORATORE, p_key) = cm.CDNLAVORATORE
        and ( (l.STRSESSO = 'M' and (MONTHS_BETWEEN(dataRifEta,l.DATNASC)/12)>=maxEtaM) or
         (l.STRSESSO = 'F' and (MONTHS_BETWEEN(dataRifEta,l.DATNASC)/12)>=maxEtaF));
begin
   conta := 0;

   if (p_dataRifEta is null) Then
     dataRifEta := sysdate;
   else
     dataRifEta := to_date(p_dataRifEta,'dd/mm/yyyy');
   end if;

   select M.NUM, F.NUM
     into maxEtaM, maxEtaF
     from ts_config_loc M,
         ts_generale,
      ts_config_loc F
    where M.STRCODRIF = ts_generale.codprovinciasil
        and F.STRCODRIF = ts_generale.codprovinciasil
       and M.STRVALORE = 'M'
       and F.STRVALORE = 'F'
       and M.CODTIPOCONFIG = 'CMBATETA'
       and F.CODTIPOCONFIG = 'CMBATETA';

   if (maxEtaM = null Or maxEtaF = null) Then
     p_result := 'Batch non configurato correttamente per questa provincia';
    return;
   end if;

   FOR iscrCM IN iscrCMCursor LOOP

     conta := conta + 1;

     if(iscrCM.STRSESSO='M') Then
       maxEta := maxEtaM;
     else
       maxEta := maxEtaF;
     end if;

     PG_MOVIMENTI.logga_record('AM_CM_ISCR','PRGCMISCR',iscrCM.PRGCMISCR,'U',p_ut);

     if( (to_char(iscrCM.datnasc,'dd/mm')='29/02') and (to_char(ADD_MONTHS(iscrCM.DATNASC,12*maxEta),'dd/mm')<>'29/02'))then
       dataChiusura := to_date('01/03/'||to_char(ADD_MONTHS(iscrCM.DATNASC,12*maxEta),'yyyy'),'dd/mm/yyyy');
     else
  dataChiusura := ADD_MONTHS(iscrCM.DATNASC,12*maxEta);
     end if;

     update am_cm_iscr cm
       set cm.DATDATAFINE = dataChiusura,
        cm.CODMOTIVOFINEATTO = 'CM5',
        cm.CDNUTMOD = p_ut,
        cm.DTMMOD = sysdate,
        cm.NUMKLOCMISCR = cm.NUMKLOCMISCR + 1
      where cm.PRGCMISCR = iscrCM.PRGCMISCR;

    END LOOP;

   commit;
   p_result := 'Sono state chiuse '||conta||' iscrizioni al collocamento mirato';
   exception
     when others then
           p_result := 'Si è verificato un errore nella stored : ' || sqlcode;
           rollback;
           RAISE;
end BatchChiusuraCmSuperamentoEta;

function calcoloPunteggioAnnota(p_cdnLavEncrypt am_cm_iscr.cdnlavoratore%type,
                                p_dataChiamatacm do_richiesta_az.datchiamatacm%type,
                                 tipoGraduatoria varchar2,
                                 out_codCmAnnota OUT do_nominativo.codcmannota%type)
                                RETURN NUMBER IS
p_numPunteggioAnnota number;

begin
      select codcmannota
      into out_codCmAnnota
      from (
             select i.codcmannota
               from am_cm_iscr i
               inner join de_cm_tipo_iscr t on t.codcmtipoiscr = i.codcmtipoiscr
               WHERE i.CODSTATOATTO = 'PR'
               and i.cdnlavoratore = p_cdnLavEncrypt
               and decode(i.datanzianita68, null, i.datdatainizio, i.datanzianita68) <= trunc(p_dataChiamatacm)
               and (i.datdatafine is null OR i.datdatafine >= trunc(p_dataChiamatacm))
               and t.codmonotiporagg = 'D'
               order by i.datdatainizio desc)
      where rownum = 1;

      return 0;

      exception
      when no_data_found then
          out_codCmAnnota := null;
          return 0;

end calcoloPunteggioAnnota;

end PG_COLL_MIRATO;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_COOP.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE pg_coop
IS
   -- Author  : ROLFINI
   -- Created : 19/09/2005 15:14:18
   -- Purpose : Package per le attività della cooperazione applicativa

--*******************************************************
--* PUBLIC                                              *
--*******************************************************

   FUNCTION findanlavoratore (codicefiscale IN an_lavoratore.strcodicefiscale%TYPE)
      RETURN an_lavoratore.cdnlavoratore%TYPE;

   FUNCTION putnotificalavoratore (
      codicefiscale   IN an_lavoratore.strcodicefiscale%TYPE,
      messaggio       in VARCHAR2,
	  p_cdnut         IN VARCHAR2:=null,
	  p_data_scadenza IN VARCHAR2 :=null
   )
      RETURN INT;

   PROCEDURE presa_atto_trasferimento (
      p_cdnlavoratore          IN       an_lavoratore.cdnlavoratore%TYPE,
      p_strindirizzodom        IN       VARCHAR2,
      p_dattrasferimento       IN       VARCHAR2,
      p_codcpitit              IN       VARCHAR2,
      p_codcpiorig             IN       VARCHAR2,
      p_cdut                   IN       VARCHAR2,
      p_codcomdom              IN       VARCHAR2,
	  p_prgpresaatto           IN       VARCHAR2,
	  p_key_cifratura          IN       VARCHAR2,
      p_strcapdom              OUT      VARCHAR2,
      p_datdichiarazione       OUT      VARCHAR2,
      p_flg181                 OUT      VARCHAR2,
      p_data_anzianita_disoc   OUT      VARCHAR2,
      p_data_anzianita_disoc_storia   OUT VARCHAR2,
      p_data_inizio_s_occ      OUT      VARCHAR2,
      p_codstatooccupaz        OUT      VARCHAR2,
      p_data_nascita           OUT      VARCHAR2,
      p_cognome                OUT      VARCHAR2,
      p_nome                   OUT      VARCHAR2,
      p_num_mesi_sosp          OUT      VARCHAR2,
      p_num_mesi_anz           OUT      VARCHAR2,
      p_indirizzo_dom          OUT      VARCHAR2,
      p_desc_statooccup        OUT      VARCHAR2,
  	  p_desc_com_dom           OUT      varchar2,
	  p_desc_com_nasc          OUT      varchar2,
	  p_cod_com_dom            OUT      varchar2,
	  p_cod_cpi_loc            OUT      varchar2,
	  p_desc_cpi_loc           OUT      varchar2,
	  p_cod_cm_tipo_iscr_1     OUT      varchar2,
	  p_data_iscr_cm_1         OUT      varchar2,
	  p_data_anz_lista_68_1    OUT      varchar2,
	  p_cod_cm_tipo_iscr_2     OUT      varchar2,
	  p_data_iscr_cm_2         OUT      varchar2,
	  p_data_anz_lista_68_2    OUT      varchar2,
	  p_cdnlavoratore_encry    OUT      varchar2
   );
END pg_coop;
/
CREATE OR REPLACE package body PG_COOP is


 -------------------------------
  -- findAnLavoratore           -
  -- funzione per la ricerca di un lavoratore
  -- sia nello storico che in an_lavoratore
  -------------------------------
  function findAnLavoratore (CodiceFiscale in AN_LAVORATORE.STRCODICEFISCALE%type)
                               return AN_LAVORATORE.cdnLavoratore%type IS

        cdnLavoratore AN_LAVORATORE.cdnLavoratore%type;

       begin
            begin

              SELECT lav_s.cdnLavoratore
              into cdnLavoratore
              from an_lav_storia_inf lav_s
              where lav_s.strcodicefiscaleold=CodiceFiscale
              and lav_s.datFine is null;
              exception
                when no_data_found then null;
            end;


            -- se non l'abbiamo trovato nello storico
            -- facciamo una semplice ricerca su AN_LAVORATORE.
            -- Questo viene effettuato per mantenere la compatibilit`
            -- con l'attuale implementazione dei trigger su an_lav_storia_inf
            -- che verr` rivista in futuro
            if (cdnLavoratore is null) then
             begin
               SELECT lav.cdnLavoratore
               into cdnLavoratore
               from an_lavoratore lav
               where lav.strCodiceFiscale=CodiceFiscale;
              exception
                  when no_data_found then null;
             end;
            end if;

            return cdnLavoratore;
      end Findanlavoratore;


 function putNotificaLavoratore(
      CodiceFiscale    in AN_LAVORATORE.STRCODICEFISCALE%type,
      Messaggio        in VARCHAR2,
      p_cdnut          IN VARCHAR2 :=null,
      p_data_scadenza  IN VARCHAR2 :=null) return int IS

        cdnLav AN_LAVORATORE.cdnLavoratore%type;
        dataScadenza AN_EVIDENZA.Datdatascad%type;
        prgTipoev DE_TIPO_EVIDENZA.PRGTIPOEVIDENZA%type;
        cdn_ut  ts_utente.CDNUT%type;
        begin

             cdnLav:=findAnLavoratore(CodiceFiscale);
             if (p_data_scadenza is not null) then
			     dataScadenza := to_date(p_data_scadenza, 'dd/mm/yyyy');
			 else
			     dataScadenza:=sysdate+365;
			 end if;

             select prgTipoEvidenza
             into Prgtipoev
             from DE_TIPO_EVIDENZA te
             where te.codtipoevidenza='AV';


             if (cdnLav is not null) then
			    if (p_cdnut is null) then
				   cdn_ut := to_number('190');
				else
				   cdn_ut := to_number(p_cdnut);
				end if;
                begin
                     insert into AN_EVIDENZA
                     (PRGEVIDENZA, CDNLAVORATORE, DATDATASCAD,
                      STREVIDENZA, PRGTIPOEVIDENZA,
                      CDNUTINS, DTMINS, CDNUTMOD, DTMMOD)
        		   		     values
                       (S_AN_EVIDENZA.nextVal, cdnLav, dataScadenza,
                        Messaggio, Prgtipoev,
                        cdn_ut, sysdate, cdn_ut, sysdate);

                end;
               end if;

             return 0;
        end putNotificaLavoratore;

/* Formatted on 2006/08/04 17:56 (Formatter Plus v4.7.0) */
PROCEDURE presa_atto_trasferimento (
      p_cdnlavoratore          IN       an_lavoratore.cdnlavoratore%TYPE,
      p_strindirizzodom        IN       VARCHAR2,
      p_dattrasferimento       IN       VARCHAR2,
      p_codcpitit              IN       VARCHAR2,
      p_codcpiorig             IN       VARCHAR2,
      p_cdut                   IN       VARCHAR2,
      p_codcomdom              IN       VARCHAR2,
  	  p_prgpresaatto           IN       VARCHAR2,
  	  p_key_cifratura          IN       VARCHAR2,
      p_strcapdom              OUT      VARCHAR2,
      p_datdichiarazione       OUT      VARCHAR2,
      p_flg181                 OUT      VARCHAR2,
      p_data_anzianita_disoc   OUT      VARCHAR2,
      p_data_anzianita_disoc_storia   OUT      VARCHAR2,
      p_data_inizio_s_occ      OUT      VARCHAR2,
      p_codstatooccupaz        OUT      VARCHAR2,
      p_data_nascita           OUT      VARCHAR2,
      p_cognome                OUT      VARCHAR2,
      p_nome                   OUT      VARCHAR2,
      p_num_mesi_sosp          OUT      VARCHAR2,
      p_num_mesi_anz           OUT      VARCHAR2,
      p_indirizzo_dom          OUT      VARCHAR2,
      p_desc_statooccup        OUT      VARCHAR2,
	  p_desc_com_dom           OUT      varchar2,
  	  p_desc_com_nasc          OUT      varchar2,
	  p_cod_com_dom            OUT      varchar2,
	  p_cod_cpi_loc            OUT      varchar2,
	  p_desc_cpi_loc           OUT      varchar2,
	  p_cod_cm_tipo_iscr_1     OUT      varchar2,
	  p_data_iscr_cm_1         OUT      varchar2,
	  p_data_anz_lista_68_1    OUT      varchar2,
	  p_cod_cm_tipo_iscr_2     OUT      varchar2,
	  p_data_iscr_cm_2         OUT      varchar2,
	  p_data_anz_lista_68_2    OUT      varchar2,
	  p_cdnlavoratore_encry    OUT      varchar2
)
IS

   prg_dich_disponibilita   am_dich_disponibilita.prgdichdisponibilita%TYPE;
   num_klo_dich_disp        am_dich_disponibilita.numklodichdisp%TYPE;
   prg_stato_occupaz am_stato_occupaz.prgstatooccupaz%type;
   num_klo_statooccupaz am_stato_occupaz.NUMKLOSTATOOCCUPAZ%type;
   num_klo_lavoratore an_lavoratore.numklolavoratore%type;
   prg_elenco_anagrafico     am_elenco_anagrafico.prgelencoanagrafico%type;
   num_klo_elenco_anag am_elenco_anagrafico.numkloelencoanag%type;
   prg_patto_lavoratore am_patto_lavoratore.PRGPATTOLAVORATORE%type;
   num_klo_patto_lavoratore am_patto_lavoratore.numklopattolavoratore%type;

   num_mesi_anzianita number;
   num_mesi_anz_prec_297 number;
   num_mesi_sosp number;
   num_mesi_sosp_fornero number;
   num_mesi_sosp_fornero_completo varchar2(50);
   num_mesi_rischio_disocc_comp varchar2(50);
   giorniAnz number := 0;
   giorniSospRestanti number := 0;
   mesiAggiuntivi number := 0;
   meseDiffAnzianitaGiorni int;
   num_mesi_rischio_disocc number;
   num_mesi_sosp_prec_297 number;
   dat_calcolo_anzianita varchar2(11):='';
   dat_calcolo_mesi_sosp varchar2(11):='';
   cod_mono_calc_prec_297 varchar2(1):='';
   cod_cpi_orig de_cpi.CODCPI%type;
   -- 28/5/2007 il cdnlavoratore della tabella am_cm_iscr crittato
--   cdnlav_cm varchar2(255);

   prg_cm_iscr_1 number;
   prg_cm_iscr_2 number;

   totale_mesi_sosp number;
   totale_mesi_anz number;
   -- il codice operazione dell'ultimo statement di modifica (insert o update) eseguito
   cod_op number :=0;
   sql_app_err number;
   data150 ts_generale.dat150%type;

   cursor cur_cm_iscr is
	   SELECT c.codcmtipoiscr, TO_CHAR (c.datdatainizio, 'dd/mm/yyyy') AS datdatainizio, prgcmiscr,
		       TO_CHAR (c.datanzianita68, 'dd/mm/yyyy') AS datanzianita68, DE_CM_TIPO_ISCR.CODMONOTIPORAGG, c.cdnlavoratore
		  FROM am_cm_iscr c, DE_CM_TIPO_ISCR , am_documento d, am_documento_coll coll
		 WHERE p_cdnlavoratore = decrypt (c.cdnlavoratore, p_key_cifratura) and DE_CM_TIPO_ISCR.CODCMTIPOISCR = c.CODCMTIPOISCR
		 	 and d.CDNLAVORATORE = p_cdnlavoratore
	 		 and d.PRGDOCUMENTO = coll.PRGDOCUMENTO and coll.STRCHIAVETABELLA = c.PRGCMISCR
		 	 and c.DATDATAFINE is null and d.CODSTATOATTO = 'PR';

BEGIN
   prg_dich_disponibilita:=null;
   select trunc(dat150) 
   into data150
   from ts_generale;
   
   -- informazioni necessarie per la stampa, da inviare al polo mittente, etc.
   select
		    lav.STRCOGNOME, lav.STRNOME, lav.STRINDIRIZZODOM,
		    to_char(lav.DATNASC, 'dd/mm/yyyy') as datNasc,
			inf.flg181, inf.codcpitit,
			lav.CODCOMDOM,
			de_comune.STRDENOMINAZIONE || ' ('|| de_provincia.strTarga ||') - '|| de_comune.STRCAP as comDomicilio,
			(select de_comune.STRCAP from de_comune where de_comune.CODCOM = p_codComDom) as strcapdom,
			de_com_nasc.STRDENOMINAZIONE || ' ('|| de_pro_nasc.strTarga ||') - '|| de_com_nasc.STRCAP as comNascita,
			to_char(did.DATDICHIARAZIONE, 'dd/mm/yyyy') as datInizioDid,
			pl.prgpattolavoratore as prgpattolavoratore, pl.numklopattolavoratore as numklopattolavoratore,
			lav.NUMKLOLAVORATORE as NUMKLOLAVORATORE,
		    ea.prgelencoanagrafico as prgelencoanagrafico,
			ea.NUMKLOELENCOANAG as NUMKLOELENCOANAG,
			to_char(inf.DATANZIANITADISOC, 'dd/mm/yyyy') as DATANZIANITADISOC
		into  p_cognome, p_nome, p_indirizzo_dom,
			p_data_nascita,
			p_flg181, cod_cpi_orig,
			p_cod_com_dom, p_desc_com_dom, p_strcapdom ,
			p_desc_com_nasc,
			p_datdichiarazione,
			prg_patto_lavoratore, num_klo_patto_lavoratore,num_klo_lavoratore,
			prg_elenco_anagrafico, num_klo_elenco_anag,
			p_data_anzianita_disoc_storia
		from
			an_lavoratore lav left join am_elenco_anagrafico  ea on (lav.cdnlavoratore = ea.cdnlavoratore and ea.DATCAN is null)
			left join am_dich_disponibilita did
		       on (ea.PRGELENCOANAGRAFICO = did.prgElencoAnagrafico and did.DATFINE is null and did.codstatoatto='PR')
			inner join de_comune on (lav.CODCOMDOM = de_comune.CODCOM)
			inner join de_provincia on (de_comune.CODPROVINCIA = de_provincia.codProvincia )
			inner join de_comune de_com_nasc on (lav.CODCOMNAS = de_com_nasc.CODCOM)
			inner join de_provincia de_pro_nasc on (de_com_nasc.CODPROVINCIA = de_pro_nasc.codProvincia )
			left join am_patto_lavoratore pl on (lav.cdnlavoratore = pl.cdnlavoratore and pl.datfine is null)
			inner join an_lav_storia_inf inf on (lav.cdnlavoratore = inf.cdnlavoratore and inf.datfine is null)
		where
			lav.cdnlavoratore = p_cdnlavoratore;

	-- codcpi competente del lavoratore e sua descrizione (serve per la stampa e per la sezione provenienza del messaggio del servizio invio dati
		select codcpitit, de_cpi.STRDESCRIZIONE
		  into p_cod_cpi_loc, p_desc_cpi_loc
		  from an_lav_storia_inf, de_cpi
		 where cdnlavoratore = p_cdnlavoratore and codcpitit = de_cpi.CODCPI
		       and datfine is null and codmonotipocpi='C';

   begin
   -- lettura numero mesi sospensione, mesi anzianita ed altre info sullo stato occ.
   -- puo' accadere che il lavoratore non abbia lo stato occupazionale...
   -- query xml get_stato_occupaz
   SELECT   am_stato_occupaz.codstatooccupaz,
         TO_CHAR (am_stato_occupaz.datanzianitadisoc,'DD/MM/YYYY' ) datanzianitadisoc,
         case 
              when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I')
              then MESISOSPPRECFORNERO(p_cdnlavoratore, am_stato_occupaz.datcalcolomesisosp, null)
              when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG not in ('D','I') 
              then 0
         end
         NUMMESISOSP,
		 to_number(substr(pg_movimenti.MesiSospDecretoFornero2014(p_cdnLavoratore, null, null), 1,
				   instr(pg_movimenti.MesiSospDecretoFornero2014(p_cdnLavoratore, null, null), '-', 1)-1)) mesiSospFornero2014,
		 pg_movimenti.MesiSospDecretoFornero2014(p_cdnLavoratore, null, null) mesiSospFornero2014Completo,
         (case
    		 	   when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I')
        	   then
               (to_number(
							(to_char(sysdate,'yyyy')
                             - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
	  						 + to_char(sysdate,'mm')
		                    - to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1
						+ (case
	   	 	  				   when ((to_char(sysdate,'yyyy')
	                                  - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
	   		  	   			   	      + to_char(sysdate,'mm')
		                              - to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) > 1
							   then
										-(case when
											 trunc(am_stato_occupaz.datcalcoloanzianita) >= data150 
												then 2 - (trunc( (
													(case 
													  when to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd')) =
														   to_number(to_char(sysdate, 'dd'))
													  then 30
													  else to_number(to_char(sysdate, 'dd'))
													end) + (30 - 
															(case
															  when to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd')) < 31 
															  then to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd'))
															  else 30
															end) + 1
														  )) /30))
											 when
											 (30 - to_char(am_stato_occupaz.datcalcoloanzianita,'dd') + 1) < 16
											 then 1
											 when
											 (30 - to_char(am_stato_occupaz.datcalcoloanzianita,'dd') + 1) >= 15
											 then 0
									    end)
									    -(case when
											  trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and to_char(sysdate,'dd') < 16
											  then 1
											  when
											  trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and to_char(sysdate,'dd') >= 15
											  then 0
											  else 0
									    end)
			 				  when
			 	  			  	  ((to_char(sysdate,'yyyy')
	                                - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
	   		  	  			  	  	+ to_char(sysdate,'mm')
	                                - to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) = 1
			 				  then
								  -(case when
											trunc(am_stato_occupaz.datcalcoloanzianita) >= data150 and 
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) =
											 to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd'))
											 then 0
											 when
											 trunc(am_stato_occupaz.datcalcoloanzianita) >= data150 and 
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) <>
											 to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd'))
											 then 1
											 when trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) < 16 
											 then 1 
											 when trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) >= 15
											 then 0
								  end)
			 				  end)))
             when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG not in ('D','I')
             then
                  0
         end)
         mesi_anz,
		 (case 
			when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I')
			   then
					(case 
						when ((to_char(sysdate,'yyyy') 
							  - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
							  + to_char(sysdate,'mm') 
							  - to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) > 1
						then	  
							   (case when
								 trunc(am_stato_occupaz.datcalcoloanzianita) >= (select trunc(dat150) from ts_generale) 
									then mod(
									((case 
										  when to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd')) =
											   to_number(to_char(sysdate, 'dd'))
										  then 30
										  else to_number(to_char(sysdate, 'dd'))
										end) + 
										(30 - 
											(case
											  when to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd')) < 31 
											  then to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd'))
											  else 30
											end) + 1
										  )
									), 30)
								  else 0
								end)
						when
						  ((to_char(sysdate,'yyyy') 
							- to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
							+ to_char(sysdate,'mm') 
							- to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) = 1
							then
								(case when
									trunc(am_stato_occupaz.datcalcoloanzianita) >= (select trunc(dat150) from ts_generale) 
									  and (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) =
										   to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd'))
									then 0
									when
									  trunc(am_stato_occupaz.datcalcoloanzianita) >= (select trunc(dat150) from ts_generale) 
									  and (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) <>
										   to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd'))
									then (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1)
									else 0
								end)
						else 0
					end)			  	
			 when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG not in ('D','I')
			 then 0
		end)
		giorni_anz,
		 to_number(substr(PG_MOVIMENTI.MesiRischioDisoccupazione(p_cdnLavoratore, am_stato_occupaz.datcalcoloanzianita), 1,
				   instr(PG_MOVIMENTI.MesiRischioDisoccupazione(p_cdnLavoratore, am_stato_occupaz.datcalcoloanzianita), '-', 1)-1)) mesi_rischio_disocc,
		 PG_MOVIMENTI.MesiRischioDisoccupazione(p_cdnLavoratore, am_stato_occupaz.datcalcoloanzianita) mesi_rischio_disocc_completo,
         to_number(am_stato_occupaz.NUMANZIANITAPREC297) mesi_anz_prec,
		 AM_STATO_OCCUPAZ.CODMONOCALCOLOANZIANITAPREC297,
         to_number(am_stato_occupaz.NUMMESISOSP) NUMMESISOSPPREC,
         to_char(am_stato_occupaz.datcalcoloanzianita,'DD/MM/YYYY') datcalcoloanzianita,
         to_char(am_stato_occupaz.datcalcolomesisosp,'DD/MM/YYYY') datcalcolomesisosp,
		 to_char(am_stato_occupaz.datinizio,'DD/MM/YYYY') datinizio,
		 DECODE (de_stato_occupaz_ragg.codstatooccupazragg,
                 de_stato_occupaz.codstatooccupaz, de_stato_occupaz_ragg.strdescrizione,
                 (   de_stato_occupaz_ragg.strdescrizione
                  || ': '
                  || de_stato_occupaz.strdescrizione
                  ||decode(de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG,'D',PG_INFO_RIASS.stato_occ_mobil(p_cdnLavoratore),'I',PG_INFO_RIASS.stato_occ_mobil(p_cdnLavoratore),'')
                 )
                ) AS descrizionestato
	into p_codstatooccupaz, p_data_anzianita_disoc, num_mesi_sosp, num_mesi_sosp_fornero, num_mesi_sosp_fornero_completo,
	     num_mesi_anzianita, giorniAnz, num_mesi_rischio_disocc, num_mesi_rischio_disocc_comp, num_mesi_anz_prec_297,
	     cod_mono_calc_prec_297, num_mesi_sosp_prec_297, dat_calcolo_anzianita, dat_calcolo_mesi_sosp,
		 p_data_inizio_s_occ, p_desc_statooccup
    FROM am_stato_occupaz
         LEFT JOIN de_stato_atto ON (am_stato_occupaz.codstatoatto = de_stato_atto.codstatoatto)
         INNER JOIN de_stato_occupaz ON (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
         INNER JOIN de_stato_occupaz_ragg ON (de_stato_occupaz.codstatooccupazragg = de_stato_occupaz_ragg.codstatooccupazragg)
         INNER JOIN an_lav_storia_inf inf ON (am_stato_occupaz.cdnlavoratore = inf.cdnlavoratore)
    		 left JOIN de_cpi ON (de_cpi.codcpi = inf.codcpitit)
   WHERE am_stato_occupaz.datfine IS NULL
         AND am_stato_occupaz.cdnlavoratore = p_cdnLavoratore
         AND inf.datfine IS NULL
ORDER BY am_stato_occupaz.datinizio DESC; -- perche' l'order by ?


	  	 if (num_mesi_sosp is null )          then num_mesi_sosp := 0;          end if;
		 if (num_mesi_sosp_fornero is null )  then num_mesi_sosp_fornero := 0;  end if;
	  	 if (num_mesi_anzianita is null )     then num_mesi_anzianita := 0;     end if;
		 if (num_mesi_rischio_disocc is null ) then num_mesi_rischio_disocc := 0;  end if;
	  	 if (num_mesi_anz_prec_297 is null )  then num_mesi_anz_prec_297 := 0;  end if;
	  	 if (num_mesi_sosp_prec_297 is null ) then num_mesi_sosp_prec_297 := 0; end if;
		 if (giorniAnz is null) then giorniAnz := 0; end if;

   exception when no_data_found then
      -- puo' accadere che il lavoratore non abbia lo stato occupazionale
   	     p_codstatooccupaz      := null;
		 p_data_anzianita_disoc := null;
		 num_mesi_sosp_fornero_completo := null;
		 num_mesi_rischio_disocc_comp	:= null;
		 num_mesi_sosp          := 0;
		 num_mesi_anzianita     := 0;
		 num_mesi_anz_prec_297  := 0;
		 num_mesi_sosp_prec_297 := 0;
		 giorniAnz 				:= 0;
		 cod_mono_calc_prec_297 := null;
		 dat_calcolo_anzianita  := null;
		 dat_calcolo_mesi_sosp  := null;
		 p_data_inizio_s_occ    := null;
		 p_desc_statooccup      := '';
   end;
   
   
	giorniSospRestanti := 0;
	mesiAggiuntivi := 0;
	meseDiffAnzianitaGiorni := 0;
	
	if (num_mesi_rischio_disocc_comp is not null) then
		giorniSospRestanti := to_number(substr(num_mesi_rischio_disocc_comp, instr(num_mesi_rischio_disocc_comp, '-', 1, 1)+1));
	end if;
	
	if (num_mesi_sosp_fornero_completo is not null) then
		giorniSospRestanti := giorniSospRestanti + to_number(substr(num_mesi_sosp_fornero_completo, instr(num_mesi_sosp_fornero_completo, '-', 1, 3)+1));
	end if;
	
	mesiAggiuntivi := trunc(giorniSospRestanti/30);
	
	if (giorniAnz >= mod(giorniSospRestanti,30)) then
		giorniAnz := giorniAnz - mod(giorniSospRestanti,30);
	else
		if (mod(giorniSospRestanti,30) > 0) then
			giorniAnz := giorniAnz + (30 - (mod(giorniSospRestanti,30)));
			meseDiffAnzianitaGiorni := 1;
		end if;
	end if;
   
   -- calcolo totali mesi sospensione ed anzianita'
   totale_mesi_sosp := num_mesi_sosp_prec_297 + num_mesi_sosp + num_mesi_sosp_fornero + num_mesi_rischio_disocc + mesiAggiuntivi;
   totale_mesi_anz  := num_mesi_anz_prec_297 + num_mesi_anzianita - (num_mesi_sosp_prec_297 + num_mesi_sosp + num_mesi_sosp_fornero + num_mesi_rischio_disocc + 
																	 mesiAggiuntivi);
   															
   if (totale_mesi_anz > 0 and meseDiffAnzianitaGiorni > 0) then
	totale_mesi_anz := totale_mesi_anz - meseDiffAnzianitaGiorni;
   end if;
   
   p_num_mesi_sosp := to_char(totale_mesi_sosp);
   p_num_mesi_anz  := to_char(totale_mesi_anz);


   begin
   SELECT DISTINCT did.prgdichdisponibilita,
      TO_CHAR (did.datdichiarazione, 'dd/mm/yyyy') AS datdichiarazione,
      did.numklodichdisp
   INTO  prg_dich_disponibilita, p_datdichiarazione, num_klo_dich_disp
              FROM an_lavoratore lav, am_elenco_anagrafico ea, am_dich_disponibilita did
             WHERE ea.cdnlavoratore = p_cdnlavoratore
               AND lav.cdnlavoratore = ea.cdnlavoratore
               AND ea.prgelencoanagrafico = did.prgelencoanagrafico
               AND did.codstatoatto = 'PR'
               AND did.datfine IS NULL
               AND ROWNUM = 1;
   exception when no_data_found then
       p_datdichiarazione:='';
	   prg_dich_disponibilita:=null;
	   num_klo_dich_disp:='';
   end;

    -- 28/5/2007 aggiunte info collocamento mirato
    p_cod_cm_tipo_iscr_1  := null;
    p_data_iscr_cm_1      := null;
    p_data_anz_lista_68_1 := null;
    p_cod_cm_tipo_iscr_2  := null;
    p_data_iscr_cm_2      := null;
    p_data_anz_lista_68_2 := null;
    prg_cm_iscr_1         := null;
	prg_cm_iscr_2         := null;
    FOR rec IN cur_cm_iscr LOOP
		if (rec.codmonotiporagg = 'A') then
		   p_cod_cm_tipo_iscr_2  := rec.codcmtipoiscr;
		   p_data_iscr_cm_2      := rec.datdatainizio;
		   p_data_anz_lista_68_2 := rec.datanzianita68;
		   prg_cm_iscr_2         := rec.prgcmiscr;
		   p_cdnlavoratore_encry := rec.cdnlavoratore;
		else
		   p_cod_cm_tipo_iscr_1  := rec.codcmtipoiscr;
		   p_data_iscr_cm_1      := rec.datdatainizio;
		   p_data_anz_lista_68_1 := rec.datanzianita68;
		   prg_cm_iscr_1         := rec.prgcmiscr;
		   p_cdnlavoratore_encry := rec.cdnlavoratore;		   
		end if;
	END LOOP;

   -----------------------------------------------------------------------------------------
   -- inizio modifica dati: viene eseguita in un blocco transazionale specifico
   begin
   	   ---------------------------------------------
	   cod_op :=1; -- aggiornamento dati lavoratore
	   ---------------------------------------------
	   UPDATE an_lavoratore
	      SET strindirizzodom = p_strindirizzodom,
	          strlocalitadom = NULL,
	          codcomdom = p_codcomdom,
	          strcapdom = p_strcapdom,
	          cdnutmod = p_cdut,
	          dtmmod = SYSDATE,
	          numklolavoratore = num_klo_lavoratore + 1
	    WHERE cdnlavoratore = p_cdnlavoratore;
   	   ---------------------------------------------
	   cod_op :=2; -- aggiornamento storia lavoratore
	   ---------------------------------------------
		INSERT INTO AN_LAV_STORIA_INF (
					PRGLAVSTORIAINF, CDNLAVORATORE, DATINIZIO, CODCPITIT,
					CODMONOTIPOCPI, CODCOMDOM, STRCODICEFISCALEOLD, CDNUTMODSCHEDAANAGPROF,
					DTMMODSCHEDAANAGPROF, CODMONOTIPOORIG, DATTRASFERIMENTO, CODCPIORIG,
					DATDICHIARAZIONE, FLG181, DATANZIANITADISOC, NUMANZIANITAPREC297,
					NUMMESISOSP, CODSTATOOCCUPAZORIG, STRNOTE, CDNUTINS,
					DTMINS, CDNUTMOD, DTMMOD, CODMONOCALCOLOANZIANITAPREC297,
					DATCALCOLOANZIANITA, DATCALCOLOMESISOSP, flgStampaTrasf, flgStampaDoc
	        	   ) VALUES (
	        		S_AN_LAV_STORIA_INF.NEXTVAL, TO_NUMBER(p_cdnlavoratore), TO_DATE(p_dattrasferimento, 'DD/MM/YYYY'), cod_cpi_orig,
	        		'T', p_codcomdom,
					(SELECT STRCODICEFISCALE FROM AN_LAVORATORE WHERE CDNLAVORATORE = TO_NUMBER(p_cdnlavoratore)),
					p_cdut,
	        		SYSDATE, 'R', TO_DATE(p_dattrasferimento, 'DD/MM/YYYY'), p_codcpitit,
	        		TO_DATE(p_datdichiarazione, 'DD/MM/YYYY'), p_flg181, TO_DATE(p_data_anzianita_disoc, 'DD/MM/YYYY'),
					num_mesi_anz_prec_297, num_mesi_sosp_prec_297,
					p_codstatooccupaz, null, -- note da rivedere
					p_cdut, SYSDATE, p_cdut, SYSDATE,
					cod_mono_calc_prec_297,
	        		TO_DATE(dat_calcolo_anzianita, 'DD/MM/YYYY'),
					TO_DATE(dat_calcolo_mesi_sosp, 'DD/MM/YYYY'),
					null,
					'S' -- lo metto subito a S
	        	   );
   	   ---------------------------------------------
	   cod_op :=3; -- aggiornamento elenco anagrafico
	   ---------------------------------------------
		UPDATE AM_ELENCO_ANAGRAFICO SET
	        		DATCAN = (TO_DATE(p_dattrasferimento, 'DD/MM/YYYY') - 1),
	        		CODTIPOCAN = 'TD',
	        		CDNUTMOD = p_cdut,
	        		DTMMOD = SYSDATE,
	        		NUMKLOELENCOANAG = num_klo_elenco_anag+1
	        	   WHERE PRGELENCOANAGRAFICO = prg_elenco_anagrafico;
   	   ---------------------------------------------
	   cod_op :=4; -- aggiornamento did
	   ---------------------------------------------
		if (prg_dich_disponibilita is not null ) then
			update am_dich_disponibilita
			set   datFine= sysdate,
				  codMotivoFineAtto= 'TD',
				  numklodichdisp = num_klo_dich_disp+1,
			 	  dtmmod = sysdate,
			 	  cdnutmod = p_cdut
			where prgdichdisponibilita = prg_dich_disponibilita;
		end if;
   	   ---------------------------------------------
	   cod_op :=5; -- aggiornamento patto
	   ---------------------------------------------
		if (prg_patto_lavoratore is not null ) then
			UPDATE AM_PATTO_LAVORATORE SET
	        		DATFINE =
					(CASE
						WHEN (TO_DATE(p_dattrasferimento, 'DD/MM/YYYY') - 1) < TRUNC(DATSTIPULA) THEN DATSTIPULA
						ELSE (TO_DATE(p_dattrasferimento, 'DD/MM/YYYY') - 1)
					END),
	        		CODMOTIVOFINEATTO = 'TD',
	        		CDNUTMOD = p_cdut,
	        		DTMMOD = SYSDATE,
	        		NUMKLOPATTOLAVORATORE = num_klo_patto_lavoratore+1
	        	   WHERE PRGPATTOLAVORATORE = prg_patto_lavoratore;
		end if;
   	   ---------------------------------------------
	   cod_op :=6; -- aggiornamento stato occupazionale
	   ---------------------------------------------
		begin
		-- dalla classe java: Correzione anomalia che permetteva di avere due stati occ. alla stessa data
		-- in pratica si prendono tutti gli s.o. con data inizio = data trasferimento -1
			select *
			into prg_stato_occupaz, num_klo_statooccupaz
			from (
				SELECT   stocc.prgstatooccupaz, stocc.numklostatooccupaz
				    FROM am_stato_occupaz stocc,
				         de_stato_occupaz destocc,
				         de_stato_occupaz_ragg desoragg,
				         de_stato_atto destato
				   WHERE stocc.cdnlavoratore = p_cdnlavoratore
				     AND stocc.codstatoatto = destato.codstatoatto(+)
				     AND stocc.codstatooccupaz = destocc.codstatooccupaz
				     AND destocc.codstatooccupazragg = desoragg.codstatooccupazragg
					 /*
				     AND (   stocc.datfine IS NULL
				          OR (    stocc.datfine IS NOT NULL
				              --AND stocc.datinizio >= TO_DATE (NVL ('01/01/1900', TO_CHAR (SYSDATE, 'dd/mm/yyyy')), 'dd/mm/yyyy')
							  AND stocc.datinizio >= TO_DATE ('01/01/1900', 'dd/mm/yyyy')
				             )
				         )
					*/
					AND (stocc.datinizio = (to_date(p_dattrasferimento, 'dd/mm/yyyy')-1))
				ORDER BY /*stocc.datinizio DESC,*/ stocc.dtmins DESC, stocc.prgstatooccupaz DESC
			)
			where rownum=1;
			-- se esiste lo aggiorno
			UPDATE AM_STATO_OCCUPAZ SET
	                      CDNLAVORATORE = p_cdnlavoratore,
	                      CODSTATOOCCUPAZ = 'C',
	                      DATINIZIO = TO_DATE(p_dattrasferimento,'DD/MM/YYYY'),
	                      CODMONOPROVENIENZA = 'T',
	                      DTMINS = SYSDATE,
	                      DTMMOD = SYSDATE,
	                      CDNUTINS = p_cdut,
	                      CDNUTMOD = p_cdut,
	                      numklostatooccupaz = num_klo_statooccupaz +1
					WHERE PRGSTATOOCCUPAZ = prg_stato_occupaz;

		exception when no_data_found then
		    -- se non esiste inserisco un nuovo s. o.
			INSERT INTO am_stato_occupaz
			            (am_stato_occupaz.prgstatooccupaz, am_stato_occupaz.cdnlavoratore,
			             am_stato_occupaz.codstatooccupaz, am_stato_occupaz.datinizio,
			             am_stato_occupaz.codmonoprovenienza, am_stato_occupaz.dtmins, am_stato_occupaz.dtmmod,
			             am_stato_occupaz.cdnutins, am_stato_occupaz.cdnutmod
			            )
			     VALUES (s_am_stato_occupaz.NEXTVAL, p_cdnlavoratore,
			             'C', TO_DATE (p_dattrasferimento, 'DD/MM/YYYY'),
			             'T', SYSDATE, SYSDATE,
			             p_cdut, p_cdut
			            );
				end;

		-- chiusura richiesta presa atto se esistente
   	   ---------------------------------------------
	   cod_op :=7; -- aggiornamento richieste presa atto
	   ---------------------------------------------
		if p_prgpresaatto is not null then
		   update ca_presa_atto set codstatopresaatto='CH', numklopresaatto = numklopresaatto+1, dtmmod=sysdate,
		   cdnutmod=p_cdut where prgpresaatto = p_prgpresaatto;
		end if;
   	   ---------------------------------------------
	   cod_op :=8; -- aggiornamento iscrizione collocamento mirato
	   ---------------------------------------------
	   /* 15/6/2007 ATTENZIONE LA CHIUSURA DEL CM VIENE FATTA DALLA CLASSE DOPO LA GENERAZIONE DEL PDF DEL PERCORSO LAVORATORE

	   if prg_cm_iscr_1 is not null then
			update am_cm_iscr
			   set datdatafine = TO_DATE(p_dattrasferimento,'DD/MM/YYYY')-1, NUMKLOCMISCR = NUMKLOCMISCR + 1,
			   CODMOTIVOFINEATTO = 'TD',
			   CDNUTMOD = p_cdut, DTMMOD = SYSDATE
			 where prgcmiscr = prg_cm_iscr_1;
	   end if;
	   if prg_cm_iscr_2 is not null then
			update am_cm_iscr
			   set datdatafine = TO_DATE(p_dattrasferimento,'DD/MM/YYYY')-1, NUMKLOCMISCR = NUMKLOCMISCR + 1,
			   CODMOTIVOFINEATTO = 'TD',
			   CDNUTMOD = p_cdut, DTMMOD = SYSDATE
			 where prgcmiscr = prg_cm_iscr_2;
	   end if;
	   */
	exception when others then
		case
			 when cod_op=1 then sql_app_err := -20901;-- aggiornamento an_lavoratore
			 when cod_op=2 then sql_app_err := -20902;-- aggiornamento storia lavoratore
		  	 when cod_op=3 then sql_app_err := -20903;-- aggiornamento elenco anagrafico
		  	 when cod_op=4 then sql_app_err := -20904;-- aggiornamento did
		  	 when cod_op=5 then sql_app_err := -20905;-- aggiornamento patto
		  	 when cod_op=6 then sql_app_err := -20906;-- aggiornamento stato occupazionale
		  	 when cod_op=7 then sql_app_err := -20907;-- aggiornamento richieste presa atto
		  	 when cod_op=8 then sql_app_err := -20908;-- aggiornamento iscrizione collocamento mirato
			 else  		        sql_app_err := -20900;-- errore generico
		end case;
		raise_application_error(sql_app_err, 'Errore SQL in procedura presa_atto_trasferimento: SQLCODE ='||SQLCODE ||' :'||SQLERRM(SQLCODE));
	end;
END presa_atto_trasferimento;

end PG_COOP;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_DISACCORP.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_DISACCORP IS

	-- Author  : RICCARDI, PEGORARO e vabbè pure COTICONE
	-- Created : 20/01/2009 17.46.22

	FUNCTION getTableColsNoLog(nomeTabella IN VARCHAR2, tronclen NUMBER, adesso IN DATE)
                           RETURN VARCHAR2;


    PROCEDURE undeleteRifTestata(tgttable IN ALL_TAB_COLS.TABLE_NAME%TYPE,
                        campoAzi IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
                        prgAziVecchia IN AN_AZIENDA.PRGAZIENDA%TYPE,
                        dataAccorpamento IN DATE,
						adesso IN DATE);


	PROCEDURE unupdateRifTestataXLav(prgAziendaAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
                                 prgAziendaAccorpata  IN AN_AZIENDA.PRGAZIENDA%TYPE,
                                 dataAccorpamento IN DATE,
								 adesso IN DATE);


	PROCEDURE unupdateHistory(prgAziendaAccorpante  IN AN_AZIENDA.PRGAZIENDA%TYPE,
       						adesso IN DATE);


    PROCEDURE unupdateRifTestata(tgttable IN ALL_TAB_COLS.TABLE_NAME%TYPE,
			  			tgtprg IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
						prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE,
						nomeLock IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
                        dataAccorpamento IN DATE,
						adesso IN DATE);


	PROCEDURE unupdateRif(tgttable IN ALL_TAB_COLS.TABLE_NAME%TYPE,
			  			tgtprg IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
                        campoAzi IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
						campoUni IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
						prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE,
                        prgUniAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
						nomeLock IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
                        dataAccorpamento IN DATE,
						adesso IN DATE);


	PROCEDURE unupdateRifProspetto(prgAziAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
						prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE,
                        prgUniAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
						dataAccorpamento IN DATE,
						adesso IN DATE);
						
						
	PROCEDURE undeleteRif(tgtTable IN ALL_TAB_COLS.TABLE_NAME%TYPE,
                        campoAzi IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
						campoUni IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
                        prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE,
                        prgUniAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
                        dataAccorpamento IN DATE,
						adesso IN DATE);


	FUNCTION RecuperaAziendaAccorpata(codFiscAzAccorpante IN AN_AZIENDA.STRCODICEFISCALE%TYPE,
			 								codFiscAzAccorpata  IN AN_AZIENDA.STRCODICEFISCALE%TYPE,
											strDataAccorpamento IN varchar2) RETURN NUMBER;


END PG_DISACCORP;
/


CREATE OR REPLACE PACKAGE BODY PG_DISACCORP IS

	FUNCTION getTableColsNoLog(nomeTabella IN VARCHAR2, tronclen NUMBER, adesso IN DATE)
                           RETURN VARCHAR2
    IS
        CURSOR colCursor (nomeTabella IN VARCHAR2)
        IS
            SELECT COLUMN_NAME
            FROM COLS C
            WHERE C.TABLE_NAME = nomeTabella;
        strRet VARCHAR2(4096);
        colName VARCHAR2(100);
    BEGIN
        strRet := '';
        OPEN colCursor(nomeTabella);
        LOOP
            FETCH colCursor INTO colName;
            EXIT WHEN colCursor%NOTFOUND;
			if (tronclen = 2) then
				if (colName = 'CDNUTMOD') then
	               colName := '100';
				elsif (colName = 'DTMMOD') then
	               colName := 'TO_DATE(''' || TO_CHAR(adesso, 'DD/MM/YYYY HH24:MI') || ''', ''DD/MM/YYYY HH24:MI'')';		
				end if;				
				
				strRet := strRet || colName || ', ';
			else
				strRet := strRet || colName || ',';
			end if;
			
		END LOOP;
        CLOSE colCursor;
		
		RETURN substr(strRet,0,LENGTH(strRet)-tronclen);
		
	exception
			 when others then
			 	  dbms_output.put_line(SQLCODE || '--' || SQLERRM);	
		
	END getTableColsNoLog;


    PROCEDURE undeleteRifTestata(tgttable IN ALL_TAB_COLS.TABLE_NAME%TYPE,
                        campoAzi IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
                        prgAziVecchia IN AN_AZIENDA.PRGAZIENDA%TYPE,
                        dataAccorpamento IN DATE,
						adesso IN DATE)
    IS
        strquery       VARCHAR2(2048);
		strquerysel	VARCHAR2(2048);
        strqueryWhere  VARCHAR2(255);
		valoridareins VARCHAR2(2048);
    BEGIN
		
		strquerysel := 'select '||getTableColsNoLog(tgtTable,2,adesso)||' from  LG_'||tgtTable;
		
		strqueryWhere :=  ' WHERE '||campoAzi ||'='|| prgAziVecchia||' AND STRTIPOOP = ''D'' AND TO_DATE(DTMMODLOG,''DD/MM/YYYY'') = TO_DATE('''|| dataAccorpamento || ''',''DD/MM/YYYY'')';

		strquerysel := strquerysel || strqueryWhere; 
		
		strquery :='INSERT INTO '||tgtTable||' ('||getTableColsNoLog(tgtTable,1,adesso)||') ' || strquerysel;
		
		EXECUTE IMMEDIATE strquery;

		dbms_output.put_line(SQL%ROWCOUNT || ' tuple ripristinate dal log (''D'') per la tabella ' || tgtTable);

	    EXCEPTION
	        WHEN OTHERS THEN
	             dbms_output.put_line('errore per la tabella ' || tgtTable);

	END undeleteRifTestata;


	PROCEDURE unupdateRifTestataXLav(prgAziendaAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
                                 prgAziendaAccorpata  IN AN_AZIENDA.PRGAZIENDA%TYPE,
                                 dataAccorpamento IN DATE,
								 adesso IN DATE)
    IS

	totupdates	NUMBER := 0;

   	CURSOR rifTestata IS
    	   SELECT PRGINDISPONIBILITA
    	   FROM LG_PR_INDISPONIBILITA
    	   WHERE PRGAZIENDA = prgAziendaAccorpata
 		   AND STRTIPOOP = 'U'
 		   AND TO_DATE(DTMMODLOG,'DD/MM/YYYY') = TO_DATE(dataAccorpamento,'DD/MM/YYYY');
 	BEGIN
   		 FOR rifTestataRow IN rifTestata LOOP

		 	 UPDATE PR_INDISPONIBILITA
             SET PRGAZIENDA = prgAziendaAccorpata,
			 	 CDNUTMOD = 100,
				 DTMMOD = TO_DATE(TO_CHAR(adesso, 'DD/MM/YYYY HH24:MI'), 'DD/MM/YYYY HH24:MI')
			 WHERE PRGINDISPONIBILITA = rifTestataRow.PRGINDISPONIBILITA;

			 totupdates := totupdates + SQL%ROWCOUNT;

     	 END LOOP;

		 dbms_output.put_line(totupdates  ||' tuple ripristinate dal log (''U'') per la tabella PR_INDISPONIBILITA');

		 EXCEPTION
         	WHEN OTHERS THEN
         		 dbms_output.put_line('errore per la tabella PR_INDISPONIBILITA');

	END unupdateRifTestataXLav;


	PROCEDURE unupdateHistory(prgAziendaAccorpante  IN AN_AZIENDA.PRGAZIENDA%TYPE,
       						adesso IN DATE)
    IS
        newHistAccorpante  AN_AZIENDA.STRHISTORY%TYPE;
  		SEPARATORE  VARCHAR2(2) := CHR(10) || CHR(13);
    BEGIN

        SELECT SUBSTR(STRHISTORY,0,INSTR(STRHISTORY,DECODE(STRHISTORY,NULL, NULL, SEPARATORE)||'In data')-1)
        INTO   newHistAccorpante
        FROM  AN_AZIENDA
        WHERE PRGAZIENDA = prgAziendaAccorpante;

		UPDATE AN_AZIENDA
        SET STRHISTORY = newHistAccorpante,
            NUMKLOAZIENDA = NUMKLOAZIENDA + 1,
            CDNUTMOD = 100,
            DTMMOD = TO_DATE(TO_CHAR(adesso, 'DD/MM/YYYY HH24:MI'), 'DD/MM/YYYY HH24:MI')
        WHERE PRGAZIENDA = prgAziendaAccorpante;

		dbms_output.put_line('Ripristinato il campo strhistory in AN_AZIENDA');

   	    EXCEPTION
        	WHEN OTHERS THEN
            	 dbms_output.put_line('errore nell''aggiornamento del campo strhistory in AN_AZIENDA');

	END unupdateHistory;



    PROCEDURE unupdateRifTestata(tgttable IN ALL_TAB_COLS.TABLE_NAME%TYPE,
			  			tgtprg IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
						prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE,
						nomeLock IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
                        dataAccorpamento IN DATE,
						adesso IN DATE)
    IS
        strquery       VARCHAR2(2048);
        strqueryWhere  VARCHAR2(255);
		totupdates	NUMBER := 0;

		selectdettagli VARCHAR2(2048);

		TYPE dettagli_type IS REF CURSOR;
      	dettagli dettagli_type;
		valueprg number(38);

	BEGIN

		selectdettagli := 'SELECT '||tgtprg||' FROM LG_'||tgttable||' WHERE PRGAZIENDA ='||prgAziAccorpata
					   	  		  ||' AND STRTIPOOP = ''U'' AND TO_DATE(DTMMODLOG,''DD/MM/YYYY'') = TO_DATE('''|| dataAccorpamento || ''',''DD/MM/YYYY'')';

		OPEN dettagli FOR selectdettagli;

      	LOOP
        	FETCH dettagli INTO valueprg;

         	EXIT WHEN dettagli%NOTFOUND;

			strquery := 'UPDATE ' || tgttable ||
                 ' SET PRGAZIENDA =' || prgAziAccorpata || ', ' ||
				 ' cdnUtMod = 100,' ||
                 ' dtmmod = TO_DATE(''' || TO_CHAR(adesso, 'DD/MM/YYYY HH24:MI') || ''', ''DD/MM/YYYY HH24:MI'')';

			IF nomeLock IS NOT NULL THEN
               strquery := strquery || ', ' || nomeLock || '=' || nomeLock || '+1 ';
        	END IF;

			strqueryWhere := ' WHERE ' || tgtprg || '=' || valueprg;

			strquery := strquery || strqueryWhere;

			EXECUTE IMMEDIATE strquery;
			totupdates := totupdates + SQL%ROWCOUNT;

		END LOOP;
		CLOSE dettagli;

		dbms_output.put_line(totupdates  ||' tuple ripristinate dal log (''U'') per la tabella ' || tgttable);

   	    EXCEPTION
        	WHEN OTHERS THEN
            	 dbms_output.put_line('errore per la tabella ' || tgtTable);
				 dbms_output.put_line(SQLCODE || '--' || SQLERRM);

	END unupdateRifTestata;


	PROCEDURE unupdateRif(tgttable IN ALL_TAB_COLS.TABLE_NAME%TYPE,
			  			tgtprg IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
                        campoAzi IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
						campoUni IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
						prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE,
                        prgUniAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
						nomeLock IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
                        dataAccorpamento IN DATE,
						adesso IN DATE)
    IS
        strquery       VARCHAR2(2048);
        strqueryWhere  VARCHAR2(255);
		totupdates	NUMBER := 0;

		selectdettagli VARCHAR2(2048);

		TYPE dettagli_type IS REF CURSOR;
      	dettagli dettagli_type;

		valueprg number(38);

	BEGIN
		 /* Individua prg originari */
		selectdettagli := 'SELECT '||tgtprg||' FROM LG_'||tgttable||' WHERE '|| campoAzi ||' = '||prgAziAccorpata
					   	  		  ||' AND '|| campoUni ||' = '||prgUniAccorpata||' AND STRTIPOOP = ''U'' AND TO_DATE(DTMMODLOG,''DD/MM/YYYY'') = TO_DATE('''|| dataAccorpamento || ''',''DD/MM/YYYY'')';

		OPEN dettagli FOR selectdettagli;

      	LOOP
			
			FETCH dettagli INTO valueprg;
			   
			EXIT WHEN dettagli%NOTFOUND;
			/* Ripristina il prg originario */
			strquery := 'UPDATE ' || tgttable ||
                 ' SET ' || campoAzi || '=' || prgAziAccorpata || ', ' || campoUni || '=' || prgUniAccorpata;

			IF adesso IS NOT NULL THEN
	        	strquery := strquery ||
	                 ', cdnUtMod = 100,' ||
	                 ' dtmmod = TO_DATE(''' || TO_CHAR(adesso, 'DD/MM/YYYY HH24:MI') || ''', ''DD/MM/YYYY HH24:MI'') ';
        	END IF;

			IF nomeLock IS NOT NULL THEN
               strquery := strquery || ', ' || nomeLock || '=' || nomeLock || '+1 ';
        	END IF;

			strqueryWhere := ' WHERE ' || tgtprg || '=' || valueprg;

			strquery := strquery || strqueryWhere;

			EXECUTE IMMEDIATE strquery;
			totupdates := totupdates + SQL%ROWCOUNT;

		END LOOP;
		CLOSE dettagli;

		dbms_output.put_line(totupdates  ||' tuple ripristinate dal log (''U'') per la tabella ' || tgttable);

    	EXCEPTION
	        WHEN OTHERS THEN
	             dbms_output.put_line('errore per la tabella ' || tgtTable);
				 dbms_output.put_line(SQLCODE || '--' || SQLERRM);

	END unupdateRif;


	PROCEDURE unupdateRifProspetto(prgAziAccorpante IN AN_AZIENDA.PRGAZIENDA%TYPE,
						prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE,
                        prgUniAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
						dataAccorpamento IN DATE,
						adesso IN DATE)
    IS
        strquery       VARCHAR2(2048);
        strqueryWhere  VARCHAR2(255);
		totupdates	NUMBER := 0;

		selectdettagli VARCHAR2(2048);

		TYPE dettagli_type IS REF CURSOR;
      	dettagli dettagli_type;

		valueprg number(38);
		prgUniAccorpante AN_UNITA_AZIENDA.PRGUNITA%TYPE;
		strIndirizzoUnitaAz AN_UNITA_AZIENDA.STRINDIRIZZO%TYPE;
		codComUnitaAz AN_UNITA_AZIENDA.CODCOM%TYPE;

	BEGIN
		
		SELECT STRINDIRIZZO, CODCOM
        INTO strIndirizzoUnitaAz, codComUnitaAz
        FROM  LG_AN_UNITA_AZIENDA
        WHERE PRGAZIENDA = prgAziAccorpata 
		AND PRGUNITA = prgUniAccorpata
		AND STRTIPOOP = 'D'
 		AND TO_DATE(DTMMODLOG,'DD/MM/YYYY') = TO_DATE(dataAccorpamento,'DD/MM/YYYY');
		
		SELECT PRGUNITA
        INTO prgUniAccorpante 
        FROM  AN_UNITA_AZIENDA
        WHERE PRGAZIENDA = prgAziAccorpante 
		AND UPPER(TRIM(STRINDIRIZZO)) = UPPER(TRIM(strIndirizzoUnitaAz)) 
		AND CODCOM = codComUnitaAz;		
		
		
		 /* Individua prg originari */
		selectdettagli := 'SELECT PRGPROSPETTOINF FROM CM_PROSPETTO_INF WHERE PRGAZIENDA = '
					   	  ||prgAziAccorpante||' AND PRGUNITA = '||prgUniAccorpante;		

		OPEN dettagli FOR selectdettagli;

      	LOOP
			
			FETCH dettagli INTO valueprg;
			   
			EXIT WHEN dettagli%NOTFOUND;
			
			/* Ripristina il prg originario */
			strquery := 'UPDATE CM_PROSPETTO_INF' ||
                 ' SET PRGAZIENDA =' || prgAziAccorpata || ', PRGUNITA =' || prgUniAccorpata;

			IF adesso IS NOT NULL THEN
	        	strquery := strquery ||
	                 ', cdnUtMod = 100,' ||
	                 ' dtmmod = TO_DATE(''' || TO_CHAR(adesso, 'DD/MM/YYYY HH24:MI') || ''', ''DD/MM/YYYY HH24:MI'') ';
        	END IF;

			strquery := strquery || ', NUMKLOPROSPETTOINF = NUMKLOPROSPETTOINF + 1 ';

			strqueryWhere := ' WHERE PRGPROSPETTOINF =' || valueprg;

			strquery := strquery || strqueryWhere;

			EXECUTE IMMEDIATE strquery;
			totupdates := totupdates + SQL%ROWCOUNT;

		END LOOP;
		CLOSE dettagli;

		dbms_output.put_line(totupdates  ||' tuple ripristinate dal log (''U'') per la tabella CM_PROSPETTO_INF');

    	EXCEPTION
	        WHEN OTHERS THEN
	             dbms_output.put_line('errore per la tabella CM_PROSPETTO_INF');
				 dbms_output.put_line(SQLCODE || '--' || SQLERRM);

	END unupdateRifProspetto;
	

	PROCEDURE undeleteRif(tgtTable IN ALL_TAB_COLS.TABLE_NAME%TYPE,
                        campoAzi IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
						campoUni IN ALL_TAB_COLS.COLUMN_NAME%TYPE,
                        prgAziAccorpata IN AN_AZIENDA.PRGAZIENDA%TYPE,
                        prgUniAccorpata IN AN_UNITA_AZIENDA.PRGUNITA%TYPE,
                        dataAccorpamento IN DATE,
						adesso IN DATE)
    IS
        strquery      VARCHAR2(1024);
		strquerysel	VARCHAR2(2048);
        strqueryWhere VARCHAR2(255);
		valoridareins VARCHAR2(2048);
    BEGIN
		 /* recupera dal log tutti i campi eliminati ('D')*/
        strquerysel := 'select '||getTableColsNoLog(tgtTable,2,adesso)||' from  LG_'||tgtTable;

		strqueryWhere :=  ' WHERE '||campoAzi ||'='|| prgAziAccorpata||' AND '||campoUni||'='||prgUniAccorpata||' AND STRTIPOOP = ''D'' AND TO_DATE(DTMMODLOG,''DD/MM/YYYY'') = TO_DATE('''|| dataAccorpamento || ''',''DD/MM/YYYY'')';

		strquerysel := strquerysel || strqueryWhere;

		/* re-inseriscili nella tabella originaria con prgazienda e unità originari */
		strquery :='INSERT INTO '||tgtTable||' ('||getTableColsNoLog(tgtTable,1,adesso) ||') ' || strquerysel;

		EXECUTE IMMEDIATE strquery;

		dbms_output.put_line(SQL%ROWCOUNT ||' tuple ripristinate dal log (''D'') per la tabella ' || tgtTable);

		EXCEPTION
	        WHEN OTHERS THEN
	             dbms_output.put_line('errore per la tabella ' || tgtTable);

	END undeleteRif;

	/* Madre del disaccorpamento. Prima ripristina testata ed unità,
	   quindi sposta le informazioni precedentemente accorpate  nella tal data;
	   infine elimina le unità disaccorpate dall'origine (accorpante) */
	FUNCTION RecuperaAziendaAccorpata(codFiscAzAccorpante IN AN_AZIENDA.STRCODICEFISCALE%TYPE,
			 								codFiscAzAccorpata  IN AN_AZIENDA.STRCODICEFISCALE%TYPE,
											strDataAccorpamento IN varchar2)
	RETURN NUMBER
	IS
	  	 prgAziendaAccorpante AN_AZIENDA.PRGAZIENDA%TYPE;
	  	 prgAziendaAccorpata  AN_AZIENDA.PRGAZIENDA%TYPE;

		 unitcount 			  NUMBER := 0;
		 dataAccorpamento 	  DATE := to_date(strDataAccorpamento,'DD/MM/YYYY');
		 
		 prgUnitaAccorpata  AN_UNITA_AZIENDA.PRGUNITA%TYPE;

		 /* Selettore di tutte le unità accorpate */
		 CURSOR unitaAziendaCursor(prgAzAccorp IN AN_AZIENDA.PRGAZIENDA%TYPE) IS
		 		SELECT PRGUNITA
		    	FROM LG_AN_UNITA_AZIENDA
		    	WHERE PRGAZIENDA = prgAziendaAccorpata
				AND STRTIPOOP = 'D'
		 		AND TO_DATE(DTMMODLOG,'DD/MM/YYYY') = TO_DATE(dataAccorpamento,'DD/MM/YYYY');

		 adesso DATE := SYSDATE;

		BEGIN

		BEGIN--errori gravi
			 SELECT PRGAZIENDA
		     INTO prgAziendaAccorpata
		     FROM LG_AN_AZIENDA
		     WHERE STRCODICEFISCALE = codFiscAzAccorpata
			 AND STRTIPOOP = 'D'
			 AND TO_DATE(DTMMODLOG,'DD/MM/YYYY') = TO_DATE(dataAccorpamento,'DD/MM/YYYY');

			 SELECT PRGAZIENDA
			 INTO prgAziendaAccorpante
		     FROM AN_AZIENDA
		     WHERE STRCODICEFISCALE = codFiscAzAccorpante;

		EXCEPTION
				 WHEN OTHERS THEN -- Riscrivere gli esatti errori sollevati
				 dbms_output.put_line('Impossibile proseguire');
		END;

		 /* per prima cosa ripristino testate, unità e storia */
		 undeleteRifTestata('AN_AZIENDA', 'prgAzienda', prgAziendaAccorpata, dataAccorpamento, adesso);
		 undeleteRifTestata('AN_AZ_STORIA_INF', 'prgAzienda', prgAziendaAccorpata, dataAccorpamento, adesso);
		 unupdateHistory(prgAziendaAccorpante, adesso);
		 unupdateRifTestataXLav(prgAziendaAccorpante, prgAziendaAccorpata, dataAccorpamento, adesso);

		 /* Ripristino per ogni unità le info che erano state accorpate, in pratica eseguo PG_ACCORP.updateRif^-1 */
		 FOR unita2row IN unitaAziendaCursor(prgAziendaAccorpata) LOOP

		 	 prgUnitaAccorpata := unita2row.PRGUNITA;

			 undeleteRif('AN_UNITA_AZIENDA', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, dataAccorpamento, adesso);
			 undeleteRif('AN_UA_STORIA_INF', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, dataAccorpamento, adesso);

			 unupdateRifProspetto(prgAziendaAccorpante, prgAziendaAccorpata, prgUnitaAccorpata, dataAccorpamento, adesso);
			 unupdateRif('AN_AZ_REFERENTE', 'PRGAZREFERENTE', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, null, dataAccorpamento, adesso);
			 unupdateRif('AN_AZI_AUTORIZZAZIONE', 'PRGAZIAUTORIZZAZIONE', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLO', dataAccorpamento, adesso);
			 unupdateRif('DO_LAV_STORIA_ROSA', 'PRGDOLAVSTORIAROSA', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, NULL, dataAccorpamento, NULL);
			 unupdateRif('DO_RICHIESTA_AZ', 'PRGRICHIESTAAZ', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLORICHIESTAAZ', dataAccorpamento, adesso);
			 unupdateRif('AM_UA_PATTO', 'PRGPATTOUNITAAZIENDA', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLOPATTOUNITAAZIENDALE', dataAccorpamento, adesso);
			 unupdateRif('AM_UA_AUTORIZZAZIONE', 'PRGAUTORIZZAZIONE', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLOAUTORIZ', dataAccorpamento, adesso);
			 unupdateRif('AM_MOVIMENTO', 'PRGMOVIMENTO', 'prgAziendaDist', 'prgUnitaDist', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLOMOV', dataAccorpamento, adesso);
			 unupdateRif('AM_MOVIMENTO', 'PRGMOVIMENTO', 'prgAziendaUtiliz', 'prgUnitaUtiliz', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLOMOV', dataAccorpamento, adesso);
			 unupdateRif('AM_MOVIMENTO', 'PRGMOVIMENTO', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLOMOV', dataAccorpamento, adesso);
			 unupdateRif('AM_MOVIMENTO_MISSIONE', 'PRGMISSIONE', 'prgAziendaUtiliz', 'prgUnitaUtiliz', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLOMIS', dataAccorpamento, adesso);			 
			 unupdateRif('AM_MOBILITA_ISCR', 'PRGMOBILITAISCR', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLOMOBISCR', dataAccorpamento, adesso);		 
			 unupdateRif('AM_DOMANDA_REGISTRO_COM', 'PRGDOMREGCOM', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLODOMANDAREGCOMI', dataAccorpamento, adesso);
			 unupdateRif('AM_DOCUMENTO', 'PRGDOCUMENTO', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLODOCUMENTO', dataAccorpamento, adesso);
			 unupdateRifTestata('CM_RICH_SOSPENSIONE', 'PRGRICHSOSPENSIONE', prgAziendaAccorpata, 'NUMKLOSOSPENSIONE', dataAccorpamento, adesso);
			 unupdateRif('CM_UNITA_SOSPENSIONE', 'PRGRICHSOSPENSIONE', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, null, dataAccorpamento, null);
			 unupdateRifTestata('CM_RICH_GRADUALITA', 'PRGRICHGRADUALITA', prgAziendaAccorpata, 'NUMKLOGRADUALITA', dataAccorpamento, adesso);
			 unupdateRifTestata('CM_RICH_ESONERO', 'PRGRICHESONERO', prgAziendaAccorpata, 'NUMKLOESONERO', dataAccorpamento, adesso);
			 unupdateRifTestata('CM_RICH_COMP_TERR', 'PRGRICHCOMPTERR', prgAziendaAccorpata, 'NUMKLOCOMPTERR', dataAccorpamento, adesso);
			 unupdateRif('CM_NULLA_OSTA', 'PRGNULLAOSTA', 'prgAziendaUtiliz', 'prgUnitaUtiliz', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLONULLAOSTA', dataAccorpamento, adesso);
			 unupdateRif('CM_NULLA_OSTA', 'PRGNULLAOSTA', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLONULLAOSTA', dataAccorpamento, adesso);
			 unupdateRif('CM_RICH_COMPUTO', 'PRGRICHCOMPUTO', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLORICHCOMPUTO', dataAccorpamento, adesso);
			 unupdateRif('CM_CONVENZIONE', 'PRGCONV', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLOCONV', dataAccorpamento, adesso);
			 unupdateRif('AG_CONTATTO', 'PRGCONTATTO', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLOCONTATTO', dataAccorpamento, adesso);
			 unupdateRif('AG_AGENDA', 'PRGAPPUNTAMENTO', 'prgAzienda', 'prgUnita', prgAziendaAccorpata, prgUnitaAccorpata, 'NUMKLOAGENDA', dataAccorpamento, adesso);

			 unitcount := unitcount + 1;

		 END LOOP;
		 
		 DELETE FROM AN_UA_STORIA_INF 
		 WHERE PRGAZIENDA = prgAziendaAccorpante
		 AND TO_DATE(DTMINS,'DD/MM/YYYY') = TO_DATE(dataAccorpamento,'DD/MM/YYYY');		 

		 DELETE FROM AN_UNITA_AZIENDA
		 WHERE PRGAZIENDA = prgAziendaAccorpante
		 AND TO_DATE(DTMINS,'DD/MM/YYYY') = TO_DATE(dataAccorpamento,'DD/MM/YYYY');

		 IF (SQL%ROWCOUNT <> unitcount) THEN
		  	dbms_output.put_line('Attenzione! eliminate un numero differente di unità rispetto a quelle ripristinate');
		 END IF;

		 dbms_output.put_line(unitcount||' unità disaccorpate');
		 dbms_output.put_line('Disaccorpamento completato: ripristinata azienda con progressivo = '||prgAziendaAccorpata||' e codice fiscale = '|| codFiscAzAccorpata);

		 COMMIT;
		 RETURN 0;

         EXCEPTION
             WHEN OTHERS THEN
			 	  ROLLBACK;
                  RAISE;

	END RecuperaAziendaAccorpata;

END PG_DISACCORP;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_GESTAMM.sql
************************************************************************************** */


CREATE OR REPLACE package PG_GESTAMM is

procedure pdChiudiRecordPrec (codParLstTab in DE_LST_TAB.codLstTab%type,
		  					  cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
							  strParChiaveTabella  in varchar2,
							  datParInizio in date,
							  strParChiaveTabella2 in varchar2 := null);

procedure pdChiudiRecordPrecCM (codParLstTab in DE_LST_TAB.codLstTab%type,
		  					  	   cdnParLavoratore in AM_CM_ISCR.cdnLavoratore%TYPE,
							  	   strParChiaveTabella  in varchar2,
							  	   datParInizio in date,
							  	   strParChiaveTabella2 in varchar2 := null);
		-- la procedure pdChiudiRecordPrecCM è stata creata per gestire il cdnlavoratore criptato

procedure pdCollegaTab (codParLstTab in DE_LST_TAB.codLstTab%type,
		  			    cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
						strParChiaveTabella in varchar2,
						strParCampoTabella  varchar2,
						strParCampo1Tabella varchar2);

--
-- Controllo integrita' refenziale della tabella am_lav_patto_scelta
---
procedure pdIntegRefPattoScelta (codParLstTab in DE_LST_TAB.codLstTab%type,
		  						 prgParPattoLavoratore in AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE%TYPE,
								 strParChiaveTabella  in varchar2,
								 strParChiaveTabella2 in varchar2,
								 strParChiaveTabella3 in varchar2);


procedure pdModSchedaAnagProf (cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
		  					   cdnParUtMod in TS_UTENTE.CDNUTMOD%TYPE,
							   dtmParMod in date,
							   codParLstTab in DE_LST_TAB.codLstTab%type := null);

procedure pckProtocollazione (cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
		  					  codParTipoDocumento in AM_DOCUMENTO.CODTIPODOCUMENTO%TYPE,
							  parCodStatoAtto in AM_DOCUMENTO.CODSTATOATTO%TYPE);

procedure checkIntersezioneDate (cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
		  						 parDataInizio in AM_PATTO_LAVORATORE.DATFINE%TYPE,
								 codLstTab in DE_LST_TAB.CODLSTTAB%TYPE,
								 codParTipoRec in varchar2 := null,
								 prgParRecord integer := 0);
		-- il parametro "codParTipoRec in varchar2 := null" della procedura checkIntersezioneDate è opzionale
		-- (grazie al valore di default attribuito da subito; serve per 'AM_DOCUMENTO'
		-- il parametro prgParDocumento in integer : = 0 della procedura checkIntersezioneDate è opzionale
		-- (grazie al valore di default attribuito da subito; serve per 'AM_DOCUMENTO'

procedure checkIntersezioneDateNew (cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
		  						    parDataInizio in AM_MOBILITA_ISCR.DATINIZIO%TYPE,
								 	parDataFine in AM_MOBILITA_ISCR.DATFINE%TYPE,
									codLstTab in DE_LST_TAB.CODLSTTAB%TYPE);

procedure checkIntersezioneDateCM (cdnParLavoratore in AM_CM_ISCR.cdnLavoratore%TYPE,
		  						   parDataInizio in AM_CM_ISCR.DATDATAFINE%TYPE,
								   codLstTab in DE_LST_TAB.CODLSTTAB%TYPE,
								   codParTipoRec in varchar2 := null);
		-- la procedure checkIntersezioneDateCM è stata creata per gestire il cdnlavoratore criptato

FUNCTION pdAggSedeAzienda (prgParAzienda in AN_UNITA_AZIENDA.prgAzienda%type,
		  				   prgParUnita in AN_UNITA_AZIENDA.prgUnita%type,
						   cdnParUtMod in AN_UNITA_AZIENDA.cdnUtMod%type)
						   RETURN NUMBER;

PROCEDURE pdApriChiudiInfColl (codParLstTabMod in DE_LST_TAB.codLstTab%type,
		  				   	  codParLstTabRif in DE_LST_TAB.STRNOMETABELLA%type,
		  				   	  strParChiaveTabellaRif in varchar2, datParApriChiudi in date);

procedure tracciaModifichePatto (	parCodLstTab in DE_LST_TAB.codLstTab%type,
									parPrgPattoLavoratore in AM_PATTO_LAVORATORE.prgPattoLavoratore%TYPE,
									parStrChiaveTabella  in varchar2,
									parStrChiaveTabella2 in varchar2,
									parStrChiaveTabella3 in varchar2);

procedure tracciaModMansioniAssPattoLav(
									parCdnLavoratore in AM_PATTO_LAVORATORE.cdnLavoratore%TYPE,
									parFlgDisponibile in PR_MANSIONE.FLGDISPONIBILE%TYPE,
									parFlgDispFormazione in PR_MANSIONE.FLGDISPFORMAZIONE%TYPE,
									parPrgMansione in PR_MANSIONE.PRGMANSIONE%TYPE,
									parOldPrgMansione in pr_mansione.prgMansione%TYPE,
									parOldCodMansione  in pr_mansione.codMansione%TYPE,
									parOldFlgEsperienza  in pr_mansione.flgEsperienza%TYPE,
									parOldFlgEspForm  in pr_mansione.flgEspForm%TYPE,
									parOldFlgDisponibile  in pr_mansione.flgDisponibile%TYPE,
									parOldFlgDispFormazione  in pr_mansione.flgDispFormazione%TYPE,
									parOldFlgPip  in pr_mansione.flgPip%TYPE,
									parOldCodMonoTempo  in pr_mansione.codMonoTempo%TYPE,
									parCdnUtMod  in pr_mansione.cdnUtMod%TYPE,
									parDtmMod  in pr_mansione.dtmMod%TYPE);

procedure tracciaModAzioniAssPattoLav(
									parPrgColloquio in OR_PERCORSO_CONCORDATO.prgColloquio%TYPE,
									parPrgPercorso in OR_PERCORSO_CONCORDATO.prgPercorso%TYPE,
									parDatStimata in OR_PERCORSO_CONCORDATO.datStimata%TYPE,
									parPrgAzioni in OR_PERCORSO_CONCORDATO.prgAzioni%TYPE,
									parOldPrgColloquio in OR_PERCORSO_CONCORDATO.prgColloquio%TYPE,
									parOldPrgPercorso in OR_PERCORSO_CONCORDATO.prgPercorso%TYPE,
									parOldDatStimata in OR_PERCORSO_CONCORDATO.datStimata%TYPE,
									parOldDatEffettiva in OR_PERCORSO_CONCORDATO.datEffettiva%TYPE,
									parOldPrgAzioni in OR_PERCORSO_CONCORDATO.prgAzioni%TYPE,
									parOldCodEsito OR_PERCORSO_CONCORDATO.codEsito%TYPE,
									parOldStrNote OR_PERCORSO_CONCORDATO.strNote%TYPE,
									parOldStrNotePropostaOp OR_PERCORSO_CONCORDATO.strNotePropostaOp%TYPE,
									parCdnUtMod OR_PERCORSO_CONCORDATO.cdnUtMod%TYPE,
									parDtmMod OR_PERCORSO_CONCORDATO.dtmMod%TYPE);

PROCEDURE tracciaDelAssAzioniPattoLav(parCodLstTab in DE_LST_TAB.codLstTab%type,
									parPrgPattoLavoratore in AM_PATTO_LAVORATORE.prgPattoLavoratore%TYPE,
									parStrChiaveTabella  in varchar2,
									parStrChiaveTabella2 in varchar2,
									parStrChiaveTabella3 in varchar2,
									--parDtmUtMod in AM_PATTO_LAVORATORE.DTMMOD%TYPE,
									parCdnUtMod AM_PATTO_LAVORATORE.CDNUTMOD%TYPE);
procedure tracciaModAgendaAssPattoLav(
									parCodServizio in AG_AGENDA.CODSERVIZIO%TYPE,
									parDtmDataOra in AG_AGENDA.DTMDATAORA%TYPE,
									parCodCpi in AG_AGENDA.CODCPI%TYPE,
									parPrgAppuntamento in AG_AGENDA.PRGAPPUNTAMENTO%TYPE,
									parOldCODSERVIZIO ag_agenda.CODSERVIZIO%TYPE,
									parOldDTMDATAORA ag_agenda.DTMDATAORA%TYPE,
									parOldCODCPI ag_agenda.CODCPI%TYPE,
									parOldPRGAPPUNTAMENTO ag_agenda.PRGAPPUNTAMENTO%TYPE,
									parOldCODESITOAPPUNT  ag_agenda.CODESITOAPPUNT%TYPE,
									parOldNUMKLOAGENDA  ag_agenda.NUMKLOAGENDA%TYPE,
									parOldPRGAZIENDA  ag_agenda.PRGAZIENDA%TYPE,
									parOldPRGUNITA ag_agenda.PRGUNITA%TYPE,
									parOldNUMMINUTI ag_agenda.NUMMINUTI%TYPE,
									parOldPRGSPI ag_agenda.PRGSPI%TYPE,
									parOldTXTNOTE ag_agenda.TXTNOTE%TYPE,
									parOldPRGTIPOPRENOTAZIONE ag_agenda.PRGTIPOPRENOTAZIONE%TYPE,
									parOldSTRTELRIF ag_agenda.STRTELRIF%TYPE,
									parOldSTREMAILRIF ag_agenda.STREMAILRIF%TYPE,
									parOldSTRTELMOBILERIF ag_agenda.STRTELMOBILERIF%TYPE,
									parOldCODEFFETTOAPPUNT ag_agenda.CODEFFETTOAPPUNT%TYPE,
									parOldCODSTATOAPPUNTAMENTO ag_agenda.CODSTATOAPPUNTAMENTO%TYPE,
									parOldPRGAMBIENTE ag_agenda.PRGAPPUNTAMENTO%TYPE,
									parOldPRGSPIEFF ag_agenda.PRGSPIEFF%TYPE,
									parOldNUMORAFINEEFF ag_agenda.NUMORAFINEEFF%TYPE,
									parOldNUMORAINIZIOEFF ag_agenda.NUMORAINIZIOEFF%TYPE,
									parCdnUtMod pr_mansione.cdnUtMod%TYPE,
									parDtmMod pr_mansione.dtmMod%TYPE);

procedure checkIntervalloDate (datParDatInizio in AM_ELENCO_ANAGRAFICO.DATINIZIO%TYPE,
		  					   datParDatCan    in AM_ELENCO_ANAGRAFICO.DATCAN%TYPE);

/* RECUPERO IL SESSO E LA DATA DI NASCITA ELABORANDO IL CODICE FISCALE */
FUNCTION GET_SES_DA_CODFIS(inputCF IN VARCHAR2) RETURN VARCHAR2;
FUNCTION GET_DATNAS_DA_CODFIS(inputCF IN VARCHAR2) RETURN DATE;
FUNCTION GET_CODCPI_LAV(inputCndLavoratore IN AN_LAVORATORE.CDNLAVORATORE%TYPE,
						inputDatInizioMov  IN AM_MOVIMENTO.DATINIZIOMOV%TYPE,
						inputDatFineMov    IN AM_MOVIMENTO.DATFINEMOV%TYPE) RETURN VARCHAR2;

/* SCRIVO I MOVIMENTI NELLA TABELLA TEMP */
PROCEDURE SCRIVI_MOV_IN_APP(inputPrgMovimento IN INT_ARRAY,
							inputIdSessione IN VARCHAR2);

PROCEDURE CTRL_DOC_DOPPI(inputNumAnnoProt IN AM_DOCUMENTO.NUMANNOPROT%TYPE,
							inputnumProtocollo IN AM_DOCUMENTO.NUMPROTOCOLLO%TYPE,
							inputCdnUtIns AM_DOCUMENTO.CDNUTINS%TYPE);

PROCEDURE SET_INFO_PROTOCOLLO (inputIdSessione IN VARCHAR, inputPrgMovimento IN number);

--controlla se è possibile riaprire una Did
function checkSePossibileRiaperturaDid (pCdnLavoratore in an_lavoratore.CDNLAVORATORE%type,
		 							    pPrgDichDisponibilita in am_dich_disponibilita.PRGDICHDISPONIBILITA%type )
						   return varchar2;

procedure AggiornaCPICompetente(p_cdnUt varchar2,
		  						p_prgLavStoriaInf varchar2,
								p_newCodCpi varchar2);


function insertDocumento (parPrgDoc out am_documento.PRGDOCUMENTO%type,
		 				  parCodCpi in varchar2,
						  parCdnLav in am_documento.cdnlavoratore%type,
						  parPrgAzienda in am_documento.prgazienda%type,
						  parPrgUnita in am_documento.prgunita%type,
						  parCodTipodoc in varchar2,
						  parFlgAutoCertif in varchar2,
						  parStrDesc in varchar2,
						  parFlgDocamm in varchar2,
						  parFlgDocIdentifP in varchar2,
						  parDataInizio in varchar2,
						  parStrNumDoc in varchar2,
						  parEnteRilascio in varchar2,
						  parCodMonoIO in varchar2,
						  parDataAcqril in varchar2,
						  parCodModalitaAcqri in varchar2,
						  parCodTipoFile in varchar2,
						  parStrNomeDoc in varchar2,
						  parDataFine in varchar2,
						  parNumAnnoProt in am_documento.numannoprot%type,
						  parNumProt in am_documento.numprotocollo%type,
						  parStrNote in varchar2,
						  parCdnUtIns in am_documento.cdnutins%type,
						  parCdnUtMod in am_documento.cdnutmod%type,
						  parDataProtocollazione in varchar2,
						  parCodStatoAtto in varchar2,
						  parPrgDocBlob out am_documento_blob.prgdocumentoblob%type,
						  parPagina in varchar2,
						  parPrgDocColl out am_documento_coll.prgdocumentocoll%type,
						  parStrChiaveTabella in varchar2)
		 				  return number;
						  
					
FUNCTION AGGIORNASEDELEGALE (prgParAzienda in AN_UNITA_AZIENDA.prgAzienda%type,
		  				     prgParUnita in AN_UNITA_AZIENDA.prgUnita%type,
							 numkloPar in AN_UNITA_AZIENDA.numklounitaazienda%type,
						     cdnParUtMod in AN_UNITA_AZIENDA.cdnUtMod%type)
						   RETURN NUMBER;


procedure checkIntersezionePeriodi (codLstTab in DE_LST_TAB.CODLSTTAB%TYPE,
								    cdnParLavoratore in as_valore_isee.cdnLavoratore%TYPE,
									parDataInizio in as_valore_isee.datinizioval%TYPE,
									parDataFine in as_valore_isee.datfineval%TYPE);
									
						
procedure pdChiudiRecordPeriodoPrec (codParLstTab in DE_LST_TAB.CODLSTTAB%TYPE,
									 cdnParLavoratore in as_valore_isee.cdnLavoratore%TYPE,
								     datParInizio in as_valore_isee.datinizioval%TYPE);


end PG_GESTAMM;
/


CREATE OR REPLACE package BODY PG_GESTAMM is

procedure pdChiudiRecordPrec (codParLstTab in DE_LST_TAB.codLstTab%type,
           cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
         strParChiaveTabella in varchar2,
         datParInizio in date,
         strParChiaveTabella2 in varchar2 := null) is

  -- variabili
  strVarChiaveTabellaRecordPrec varchar2(100);
  numVarKlo                     integer;
  cdnVarLavoratore              AN_LAVORATORE.cdnLavoratore%TYPE;
  datVarDataInizio              AM_STATO_OCCUPAZ.DATINIZIO%TYPE;
  datVarDataFine                AM_STATO_OCCUPAZ.DATINIZIO%TYPE;
  strVarChiaveTabella2          varchar2(100);

begin
-- LA PROCEDURA SERVE PER CHIDERE UN RECORD A SEGUITO DI UN INSERIMENTO SUCCESSIVO

        strVarChiaveTabellaRecordPrec := '';
        numVarKlo                     := 0;

-- STORIA LAVORATORE
        if (codParLstTab = 'AN_LAV_S')
        then
        -- cerco la chiave del record precedente per la tabella AN_LAV_STORIA_INF (NON SI PUO' FARE QUESTA SELECT SUL
        --                                                                        TRIGGER DI BEFORE INSERT)
         begin

          select tab.prgLavStoriaInf, tab.numKloLavStoriaInf, tab.datInizio
            into strVarChiaveTabellaRecordPrec, numVarKlo, datVarDataInizio
            from AN_LAV_STORIA_INF tab
          where tab.cdnLavoratore    = cdnParLavoratore
             and tab.prgLavStoriaInf  != strParChiaveTabella
             and tab.datFine          is null
             and tab.datInizio    = (select max(tab1.datInizio)
                                         from AN_LAV_STORIA_INF tab1
                                        where tab.cdnLavoratore = tab1.cdnLavoratore
                                          and tab1.prgLavStoriaInf != strParChiaveTabella
                                          and tab1.datFine  is null);
          exception
            when no_data_found then
              null;
          end;

          if (datVarDataInizio = datParInizio)  then
      datVarDataFine := datParInizio;
    else
      datVarDataFine := datParInizio -1;
    end if;

          -- chiudo il record precedente a quello corrente nella tabella AN_LAV_STORIA_INF
          --if    not (strVarChiaveTabellaRecordPrec) is null  -- PERCHE' NON VA QUESTO IF (NON ENTRA)? RIVEDERE
          --  and strVarChiaveTabellaRecordPrec != ''
          --  and strVarChiaveTabellaRecordPrec != ' '
          --then

             update AN_LAV_STORIA_INF
               set datfine =
    (case
     when trunc(datVarDataFine) < trunc(datVarDataInizio) then datVarDataInizio
     else datVarDataFine
    end),
                numKloLavStoriaInf        =  numVarKlo + 1
              where cdnLavoratore            =  cdnParLavoratore
                and prgLavStoriaInf          != strParChiaveTabella
                and prgLavStoriaInf          =  strVarChiaveTabellaRecordPrec
                and datFine                  is null;

           --end if;


        end if;  -- chiude l'if sulla tabella da chiudere: AN_LAV_STORIA_INF


-- extracomunitari
        if (codParLstTab = 'AM_EX_PS')
        then
        -- cerco la chiave del record precedente per la tabella AM_EX_PERM_SOGG(NON SI PUO' FARE QUESTA SELECT SUL
        --                                                                        TRIGGER DI BEFORE INSERT)
         begin

          select tab.prgPermSogg, tab.numKloPermSogg
            into strVarChiaveTabellaRecordPrec, numVarKlo
            from AM_EX_PERM_SOGG tab
           where tab.cdnLavoratore    = cdnParLavoratore
             and tab.prgPermSogg  != strParChiaveTabella
             and tab.datFine          is null;
    /* Savino 01/02/2006: aggiornata la condizione selezione carta o permesso valido
             and NVL (tab.datscadenza,TO_DATE ('31/12/2100', 'dd/mm/yyyy')) > SYSDATE
             and NVL (tab.datfine,    TO_DATE ('31/12/2100', 'dd/mm/yyyy')) > SYSDATE;
    */

          exception
            when no_data_found then
              null;
          end;



          -- chiudo il record precedente a quello corrente nella tabella AM_EX_PERM_SOGG
          --if    not (strVarChiaveTabellaRecordPrec) is null  -- PERCHE' NON VA QUESTO IF (NON ENTRA)? RIVEDERE
          --  and strVarChiaveTabellaRecordPrec != ''
          --  and strVarChiaveTabellaRecordPrec != ' '
          --then

             update AM_EX_PERM_SOGG
     set datfine =
    (case
     when datScadenza is not null and trunc(nvl(datParInizio,sysdate) - 1) < trunc(datScadenza) then nvl(datParInizio,sysdate) - 1
     when datScadenza is not null then datScadenza
     else nvl(datParInizio,sysdate) - 1
    end),
      numKloPermSogg        =  numKloPermSogg + 1
              where cdnLavoratore        =  cdnParLavoratore
                and prgPermSogg         !=  strParChiaveTabella
                and prgPermSogg          =  strVarChiaveTabellaRecordPrec
                and datFine          is null;
    /* Savino 01/02/2006: aggiornata la condizione selezione carta o permesso valido
                and NVL (datscadenza,TO_DATE ('31/12/2100', 'dd/mm/yyyy')) > SYSDATE
                and NVL (datfine,    TO_DATE ('31/12/2100', 'dd/mm/yyyy')) > SYSDATE;
    */

           --end if;


        end if;  -- chiude l'if sulla tabella da chiudere: AM_EX_PERM_SOGG

-- STATO OCCUPAZIONALE
        if (codParLstTab = 'AM_S_OCC')
        then
        -- cerco la chiave del record precedente per la tabella AM_STATO_OCCUPAZ (NON SI PUO' FARE QUESTA SELECT SUL
        --                                                                        TRIGGER DI BEFORE INSERT)
         begin

          select tab.prgStatoOccupaz, tab.numKloStatoOccupaz, tab.datInizio
            into strVarChiaveTabellaRecordPrec, numVarKlo, datVarDataInizio
            from AM_STATO_OCCUPAZ tab
           where tab.cdnLavoratore    = cdnParLavoratore
             and tab.prgStatoOccupaz  != strParChiaveTabella
             and tab.datFine          is null
             and tab.datInizio    = (select max(tab1.datInizio)
                                         from AM_STATO_OCCUPAZ tab1
                                        where tab.cdnLavoratore = tab1.cdnLavoratore
                                          and tab1.prgStatoOccupaz != strParChiaveTabella
                                          and tab1.datFine  is null);
          exception
            when no_data_found then
              null;
          end;

          if (datVarDataInizio = datParInizio)  then
      datVarDataFine := datParInizio;
    else
      datVarDataFine := datParInizio -1;
    end if;

          -- chiudo il record precedente a quello corrente nella tabella AM_STATO_OCCUPAZ
          --if    not (strVarChiaveTabellaRecordPrec) is null  -- PERCHE' NON VA QUESTO IF (NON ENTRA)? RIVEDERE
          --  and strVarChiaveTabellaRecordPrec != ''
          --  and strVarChiaveTabellaRecordPrec != ' '
          --then

             update AM_STATO_OCCUPAZ
               set datFine                   =  datVarDataFine,
                   numKloStatoOccupaz        =  numVarKlo + 1
              where cdnLavoratore            =  cdnParLavoratore
                and prgStatoOccupaz          != strParChiaveTabella
                and prgStatoOccupaz          =  strVarChiaveTabellaRecordPrec
                and datFine                  is null;

           --end if;


        end if;  -- chiude l'if sulla tabella da chiudere: AM_STATO_OCCUPAZ



-- VALORE ISEE
        if (codParLstTab = 'AS_ISEE')
        then
        -- cerco la chiave del record precedente per la tabella AS_VALORE_ISEE (NON SI PUO' FARE QUESTA SELECT SUL
        --                                                                        TRIGGER DI BEFORE INSERT)
         begin

          select tab.prgvaloreisee, tab.numKloValoreIsee, tab.datinizioval
            into strVarChiaveTabellaRecordPrec, numVarKlo, datVarDataInizio
            from AS_VALORE_ISEE tab
           where tab.cdnLavoratore   = cdnParLavoratore
             and tab.prgvaloreisee  != strParChiaveTabella
             and (tab.datFineVal     is null
             or  tab.datFineVal  > datParInizio)
             and ( tab.datFineVal is null or
               tab.datFineVal    = (select max(tab1.datFineVal)
                                         from AS_VALORE_ISEE tab1
                    where tab.cdnLavoratore = tab1.cdnLavoratore
                    and tab1.prgvaloreisee   != strParChiaveTabella));

          exception
            when no_data_found then
              null;
          end;

        if (datVarDataInizio = datParInizio)  then
        datVarDataFine := datParInizio;
     else
        datVarDataFine := datParInizio -1;


    end if;

          -- chiudo il record precedente a quello corrente nella tabella AS_VALORE_ISEE
          --if    not (strVarChiaveTabellaRecordPrec) is null  -- PERCHE' NON VA QUESTO IF (NON ENTRA)? RIVEDERE
          --  and strVarChiaveTabellaRecordPrec != ''
          --  and strVarChiaveTabellaRecordPrec != ' '
          --then

             update AS_VALORE_ISEE
               set datFineVal                =  datVarDataFine,
                   numKloValoreIsee          =  numVarKlo + 1
              where prgvaloreisee = strVarChiaveTabellaRecordPrec;

           --end if;


        end if;  -- chiude l'if sulla tabella da chiudere: AS_VALORE_ISEE

-- MOBILITA''
        if (codParLstTab = 'AM_MB_IS')
        then
        -- cerco la chiave del record precedente per la tabella AM_MOBILITA_ISCR (NON SI PUO' FARE QUESTA SELECT SUL
        --                                                                  TRIGGER DI BEFORE INSERT)
         begin

          select tab.prgMobilitaIscr, tab.numKloMOBIscr, tab.DATINIZIO
            into strVarChiaveTabellaRecordPrec, numVarKlo, datVarDataInizio
            from AM_MOBILITA_ISCR tab
           where tab.cdnLavoratore    = cdnParLavoratore
             and tab.prgMobilitaIscr  != strParChiaveTabella
             and tab.datFine      is null
             and tab.datInizio    = (select max(tab1.datInizio)
                                         from AM_MOBILITA_ISCR tab1
                                        where tab.cdnLavoratore = tab1.cdnLavoratore
                                          and tab1.prgMobilitaIscr != strParChiaveTabella
                                          and tab1.datFine  is null);
          exception
            when no_data_found then
              null;
          end;

    if (datVarDataInizio = datParInizio)  then
      datVarDataFine := datParInizio;
    else
      datVarDataFine := datParInizio -1;
    end if;

          -- chiudo il record precedente a quello corrente nella tabella AM_MOBILITA_ICSR
             update AM_MOBILITA_ISCR
               set datFine               =  datVarDataFine,
                   numKloMOBIscr         =  numVarKlo + 1
              where cdnLavoratore            =  cdnParLavoratore
                and prgMobilitaIscr                != strParChiaveTabella
                and prgMobilitaIscr                =  strVarChiaveTabellaRecordPrec
                and datFine                  is null;



        end if;  -- chiude l'if sulla tabella da chiudere: AM_MOBILITA_ISCR

-- ELENCO ANAGRAFICO
        if (codParLstTab = 'EA')
        then
        -- cerco la chiave del record precedente per la tabella AM_ELENCO_ANAGRAFICO (NON SI PUO' FARE QUESTA SELECT SUL
        --                                                                            TRIGGER DI BEFORE INSERT)
         begin

          select tab.prgElencoAnagrafico, tab.numKloElencoAnag, tab.DATINIZIO
            into strVarChiaveTabellaRecordPrec, numVarKlo, datVarDataInizio
            from AM_ELENCO_ANAGRAFICO tab
           where tab.cdnLavoratore              = cdnParLavoratore
             and tab.prgElencoAnagrafico        != strParChiaveTabella
             and tab.datCan                     is null
             and tab.datInizio      = (select max(tab1.datInizio)
                                         from AM_ELENCO_ANAGRAFICO tab1
                                        where tab.cdnLavoratore         = tab1.cdnLavoratore
                                          and tab1.prgElencoAnagrafico != strParChiaveTabella
                                          and tab1.datCan  is null);
          exception
            when no_data_found then
              null;
          end;

    if (trunc(datVarDataInizio) = trunc(datParInizio))  then
      datVarDataFine := datParInizio;
    else
      datVarDataFine := datParInizio -1;
    end if;

          -- chiudo il record precedente a quello corrente nella tabella AM_ELENCO_ANAGRAFICO
             update AM_ELENCO_ANAGRAFICO
               set datCan                    =  datVarDataFine,
                   numKloElencoAnag          =  numVarKlo + 1
              where cdnLavoratore             = cdnParLavoratore
                and prgElencoAnagrafico      != strParChiaveTabella
                and prgElencoAnagrafico      =  strVarChiaveTabellaRecordPrec
                and datCan                   is null;



        end if;  -- chiude l'if sulla tabella da chiudere: AM_ELENCO_ANAGRAFICO

-- DICHIARAZIONE DI IMMEDIATA DISPONIBILITA'
        if (codParLstTab = 'AM_DIC_D')
        then
         -- cerco la chiave del record precedente per la tabella AM_DICH_DISPONIBILITA (NON SI PUO' FARE QUESTA SELECT SUL
         --                                                                             TRIGGER DI BEFORE INSERT)
         -- PRIMA PERO':
         -- NON C'E' IL cdnLavoratore direttamente nella dichiarazione dato che è sempre legata all'inserimento
         -- nell'elenco anagrafico: LO CERCO A PARTIRE DALL'ELENCO ANAGRAFICO (corrente per il soggetto) COLLEGATO ALLA DICHIARAZIONE
         -- CHE STO INSERENDO (informazione memorizzata in un campo della dich.) PER FILTRARE POI OPPORTUNAMENTE I DATI
         begin

          select ea.cdnLavoratore
            into cdnVarLavoratore
            from AM_ELENCO_ANAGRAFICO ea
           where ea.prgElencoAnagrafico         = cdnParLavoratore; -- utilizzato per il rif. all'elenco anagrafico in questo caso

          exception
            when no_data_found then
        raise; -- propago l'errore perchè il record deve esserci
          end;

         begin

          -- cerco la chiave del record precedente per la tabella AM_DICH_DISPONIBILITA (NON SI PUO' FARE QUESTA SELECT SUL
          --                                                                             TRIGGER DI BEFORE INSERT)
          select tab.prgDichDisponibilita, tab.numKloDichDisp, tab.datDichiarazione
            into strVarChiaveTabellaRecordPrec, numVarKlo, datVarDataInizio
            from AM_DICH_DISPONIBILITA tab, AM_ELENCO_ANAGRAFICO ea
           where -- NON C'E' IL cdnLavoratore direttamente nella dichiarazione dato che è sempre legata all'inserimento
                 -- nell'elenco anagrafico
                 ea.prgElencoAnagrafico         = tab.prgElencoAnagrafico
             and ea.cdnLavoratore               = cdnVarLavoratore
             and tab.prgDichDisponibilita       != strParChiaveTabella
             and tab.datFine                    is null and tab.codstatoatto = 'PR'
             and tab.datDichiarazione           = (select max(tab1.datDichiarazione)
                                                     from AM_DICH_DISPONIBILITA tab1, AM_ELENCO_ANAGRAFICO ea1
                                                    where ea1.prgElencoAnagrafico    = tab1.prgElencoAnagrafico
                                                      and ea1.cdnLavoratore          = ea.cdnLavoratore
                                                      and tab1.prgDichDisponibilita  != strParChiaveTabella
                                                      and tab1.datFine  is null and tab1.codstatoatto = 'PR');
          exception
            when no_data_found then
              null;
          end;

          if (datVarDataInizio = datParInizio)  then
      datVarDataFine := datParInizio;
    else
      datVarDataFine := datParInizio -1;
    end if;

          -- chiudo il record precedente a quello corrente nella tabella AM_DICH_DISPONIBILITA
             update AM_DICH_DISPONIBILITA
               set datFine                   =  datVarDataFine,
                   numKloDichDisp            =  numVarKlo + 1,
                   -- setto il motivo fine atto = "AV" solo se è null. Nel funzionamento corretto
                   -- prima di inserire una nuova did non ne posso avere una protocollata aperta
                   codMotivoFineAtto    =
     (case
      when codMotivoFineAtto is null then 'AV'
      else codMotivoFineAtto
     end)
              where -- NON C'E' IL cdnLavoratore la dichiarazione è sempre legata all'inserimento
                    -- nell'elenco anagrafico
                    prgDichDisponibilita     != strParChiaveTabella
                and prgDichDisponibilita     =  strVarChiaveTabellaRecordPrec
                and datFine                  is null;



        end if;  -- chiude l'if sulla tabella da chiudere: AM_DICH_DISPONIBILITA

-- PATTO
        if (codParLstTab = 'AM_PAT_L')
        then
        -- cerco la chiave del record precedente per la tabella AM_PATTO_LAVORATORE (NON SI PUO' FARE QUESTA SELECT SUL
        --                                                                           TRIGGER DI BEFORE INSERT)
         begin

    select tab.prgPattoLavoratore, tab.numKloPattoLavoratore, tab.DATSTIPULA
            into strVarChiaveTabellaRecordPrec, numVarKlo, datVarDataInizio
            from AM_PATTO_LAVORATORE tab
           where tab.cdnLavoratore              = cdnParLavoratore
             and tab.prgPattoLavoratore         != strParChiaveTabella
             and tab.datFine                    is null and (tab.codstatoatto = 'PR' or tab.codstatoatto = 'PP')
             and tab.datStipula     = (select max(tab1.datStipula)
                                         from AM_PATTO_LAVORATORE tab1
                                        where tab.cdnLavoratore         = tab1.cdnLavoratore
                                          and tab1.prgPattoLavoratore  != strParChiaveTabella
                                          and tab1.datFine  is null and (tab1.codstatoatto = 'PR' or tab1.codstatoatto = 'PP'));

          exception
            when no_data_found then
              null;
          end;

    if (datVarDataInizio = datParInizio)  then
      datVarDataFine := datParInizio;
    else
      datVarDataFine := datParInizio -1;
    end if;


          -- chiudo il record precedente a quello corrente nella tabella AM_PATTO_LAVORATORE
             update AM_PATTO_LAVORATORE
               set datFine                   =  datVarDataFine,
                   numKloPattoLavoratore     =  numVarKlo + 1
              where cdnLavoratore            = cdnParLavoratore
                and prgPattoLavoratore       != strParChiaveTabella
                and prgPattoLavoratore       =  strVarChiaveTabellaRecordPrec
                and datFine                  is null;



        end if;  -- chiude l'if sulla tabella da chiudere: AM_PATTO


-- DOCUMENTI
    if     (codParLstTab = 'AM_DOC')
   and  (strParChiaveTabella2 in ('IM', 'SAP', 'PT297', 'ACLA', 'SA', 'CUE', 'CUL', 'CUA', 'LTC', 'EROSER'))
                                  -- dichiarazione Immediata Disponibilità, Scheda Anagrafica Professionale,
          -- Patto 297, Accord generico Lavoratore, scheda anagrafica, curriculum europeo
          -- curriculum lavoratore, curriculum azienda, lettera di convocazione, erogazione di servizio calabria
        then
        -- cerco la chiave del record precedente per la tabella AM_DOCUMENTO (NON SI PUO' FARE QUESTA SELECT SUL
        --                                                                  TRIGGER DI BEFORE INSERT)
        -- non si può avere due dichiarazioni di immediata disponibilità, schede anagrafiche professionali, patti
   begin

          select tab.prgDocumento, tab.numKloDocumento, tab.datInizio
            into strVarChiaveTabellaRecordPrec, numVarKlo, datVarDataInizio
            from AM_DOCUMENTO tab
           where tab.cdnLavoratore    = cdnParLavoratore
             and tab.prgDocumento     != strParChiaveTabella
             and tab.datFine          is null and tab.codstatoatto = 'PR'
             and codTipoDocumento     =  strParChiaveTabella2
             and tab.datInizio        = (select max(tab1.datInizio)
                                         from AM_DOCUMENTO tab1
                                        where tab.cdnLavoratore = tab1.cdnLavoratore
                                          and tab1.prgDocumento != strParChiaveTabella
                                          and tab1.datFine      is null and tab1.codstatoAtto = 'PR'
                                          and codTipoDocumento  =  strParChiaveTabella2);
          exception
            when no_data_found then
              null;
          end;

          if (datVarDataInizio = datParInizio)  then
      datVarDataFine := datParInizio;
    else
      datVarDataFine := datParInizio -1;
    end if;


          -- chiudo il record precedente a quello corrente nella tabella AM_DOCUMENTO
             update AM_DOCUMENTO
               set datFine                   =  datVarDataFine,
                   numKloDocumento           =  numVarKlo + 1
              where cdnLavoratore            =  cdnParLavoratore
                and prgDocumento             != strParChiaveTabella
                and prgDocumento             =  strVarChiaveTabellaRecordPrec
    and codTipoDocumento         =  strParChiaveTabella2
                and datFine                  is null;

        end if;  -- chiude l'if sulla tabella da chiudere: AM_DOCUMENTO


--exception
--  when others then
--    raise_application_error (-20000, 'Fallito aggiornamento per chiusura automatica del record precedente.');
end; -- fine della procedura pdChiudiRecordPrec

procedure pdChiudiRecordPrecCM (codParLstTab in DE_LST_TAB.codLstTab%type,
             cdnParLavoratore in AM_CM_ISCR.cdnLavoratore%TYPE,
           strParChiaveTabella in varchar2,
           datParInizio in date,
           strParChiaveTabella2 in varchar2 := null) is

  -- variabili
  strVarChiaveTabellaRecordPrec varchar2(100);
  numVarKlo                     integer;
  datVarDataInizio              AM_CM_ISCR.DATDATAINIZIO%TYPE;
  datVarDataFine                AM_CM_ISCR.DATDATAFINE%TYPE;
  strVarChiaveTabella2          varchar2(100);

begin
-- LA PROCEDURA SERVE PER CHIDERE UN RECORD A SEGUITO DI UN INSERIMENTO SUCCESSIVO

        strVarChiaveTabellaRecordPrec := '';
        numVarKlo                     := 0;

        if (codParLstTab = 'AM_CM_IS')
        then

         begin

   select de.CODMONOTIPORAGG
     into strVarChiaveTabella2
     from DE_CM_TIPO_ISCR de
    where de.CODCMTIPOISCR = strParChiaveTabella2;

          select tab.prgCMIscr, tab.numKloCMIscr, tab.DATDATAINIZIO
            into strVarChiaveTabellaRecordPrec, numVarKlo, datVarDataInizio
            from AM_CM_ISCR tab, DE_CM_TIPO_ISCR de, AM_DOCUMENTO_COLL coll, AM_DOCUMENTO doc
           where tab.cdnLavoratore    = cdnParLavoratore
             and tab.prgCMIscr        != strParChiaveTabella
             and tab.datDataFine      is null
    and tab.CODCMTIPOISCR    = de.CODCMTIPOISCR
    and de.CODMONOTIPORAGG   = strVarChiaveTabella2
             and tab.datDataInizio    = (select max(tab1.datDataInizio)
                                         from AM_CM_ISCR tab1, DE_CM_TIPO_ISCR de1, am_documento_coll coll1, am_documento doc1
                                        where tab.cdnLavoratore = tab1.cdnLavoratore
                                          and tab1.prgCMIscr != strParChiaveTabella
                                          and tab1.datDataFine  is null
            and tab1.CODCMTIPOISCR    = de1.CODCMTIPOISCR
                                 and de1.CODMONOTIPORAGG   = strVarChiaveTabella2
            and tab1.prgCMIscr = coll.STRCHIAVETABELLA
            and coll1.PRGDOCUMENTO = doc1.PRGDOCUMENTO
            and doc1.CODTIPODOCUMENTO = 'L68'
            and doc1.CODSTATOATTO = 'PR'
			and coll1.cdncomponente = (select cdncomponente from ts_componente where upper(strpage) = 'CMISCRIZIONILAVORATOREPAGE'))
     and tab.prgCMIscr = coll.STRCHIAVETABELLA
    and coll.PRGDOCUMENTO = doc.PRGDOCUMENTO
    and doc.CODTIPODOCUMENTO = 'L68'
    and doc.CODSTATOATTO = 'PR'
	and coll.cdncomponente = (select cdncomponente from ts_componente where upper(strpage) = 'CMISCRIZIONILAVORATOREPAGE');

          exception
            when no_data_found then
              null;
          end;

   if (datVarDataInizio = datParInizio)  then
      datVarDataFine := datParInizio;
    else
      datVarDataFine := datParInizio -1;
    end if;

          -- chiudo il record precedente a quello corrente nella tabella AM_CM_ICSR
             update AM_CM_ISCR
               set datDataFine               =  datVarDataFine,
                   codMotivoFineAtto         =  'RE',
                   numKloCMIscr              =  numVarKlo + 1
              where cdnLavoratore            =  cdnParLavoratore
                and prgCMIscr                != strParChiaveTabella
                and prgCMIscr                =  strVarChiaveTabellaRecordPrec
                and datDataFine                  is null;



        end if;  -- chiude l'if sulla tabella da chiudere: AM_CM_ISCR

end; -- fine della procedura pdChiudiRecordPrecCM


procedure pdCollegaTab (codParLstTab in DE_LST_TAB.codLstTab%type,
      cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
      strParChiaveTabella in varchar2,
      strParCampoTabella  varchar2,
      strParCampo1Tabella varchar2) is

-- variabili
  prgVarLavStoriaInf AN_LAV_STORIA_INF.prgLavStoriaInf%TYPE;
  --codVarCPI          DE_CPI.codCPI%TYPE;
  prgVarDocumento    AM_DOCUMENTO_COLL.prgDocumento%TYPE;
  cdnVarLavoratore   AN_LAVORATORE.cdnLavoratore%TYPE;

begin
-- LA PROCEDURA ASSOCIA AD UN RECORD PRINCIPALE INFORMAZIONI DI COLLEGAMENTO

-- ALL'ELENCO ANAGRAFICO
   if codParLstTab = 'EA' then
     -- trovo il record di anagrafica storico-corrente per associarlo all'inserimento nell'elenco anagrafico
     begin
     select si.prgLavStoriaInf
       into prgVarLavStoriaInf
       from AN_LAV_STORIA_INF si
      where si.cdnLavoratore = cdnParLavoratore
        and si.datFine is null
        and si.datInizio = (select max(si1.datInizio)  -- RIVEDERE: A REGIME QUESTO CRITERIO NON DOVREBBE SERVIRE
                           from AN_LAV_STORIA_INF si1
                          where si.cdnLavoratore = si1.cdnLavoratore
                            and si1.datFine is null);
     exception
       when no_data_found then
         raise; --propago l'errore
     end;

     -- inserisco il collegamento nella tabella AN_LAV_STORIA_INF_COLL
     insert into AN_LAV_STORIA_INF_COLL
       (prgLavStoriaInfColl,
        prgLavStoriaInf,
        codLstTab,
        strChiaveTabella)
       values
        (S_AN_LAV_STORIA_INF_COLL.nextval,
        prgVarLavStoriaInf,
        codParLstTab,
        strParChiaveTabella);

   end if;

-- ALL'ANAGRAFICA
   if codParLstTab = 'AN_LAV' then

     -- trovo il cpi dell'operatore corrente per associare l'informazione alla tabella di inserimento nell'elenco anagrafico
     -- DA FINIRE PER IL DOMICILIO ...(PARAMETRI OPZIONALI DA UTILIZZARE)
     --begin
       --select distinct gr.strcodrif
       --  into codVarCPI
       --  from ts_profilatura_utente ts, ts_gruppo gr
       -- WHERE gr.cdngruppo = ts.cdngruppo
       --   AND gr.cdntipogruppo = '1'
       --   AND ts.cdnut         = strParCampoTabella; --cdnUtIns dell'anagrafica

      --exception
      -- when no_data_found then
      --   raise; --propago l'errore
      -- when others        then -- dati strani RIVEDERE
      --   raise; --propago l'errore
     --end;


    -- inserisco l'informazione corrente nella tabella di storicizzazione (succ. il record può diventare storico)
     insert into AN_LAV_STORIA_INF
       (prgLavStoriaInf,
        cdnLavoratore,
        codCpiTit,
        codComDom,
        datInizio,
        datFine,
        strNote,
        cdnUtIns,
        dtmIns,
        cdnUtMod,
        dtmMod,
        cdnUtModSchedaAnagProf,
        dtmModSchedaAnagProf,
        codMonoTipoCpi, -- il kloK è gestito dal trigger di before insert nella parte std di gestione dei lock
        codStatoOccupazOrig,
        codmonotipoorig)
   values
       (S_AN_LAV_STORIA_INF.nextval,
        cdnParLavoratore,
        null, --codVarCPI, -- attrinuito dalla videata degli indirizzi
        strParCampo1Tabella, -- codComDom  RIVEDERE: è NULLO IL COMUNE IN INSERIMENTO ELENCO ANAGRAFICO
        sysdate,
        null,
        null,
        strParCampoTabella, --codUtIns
        sysdate,
        strParCampoTabella, -- in inserimento l'utente di modifica è uguale a quello di inserimento
        Sysdate,
        strParCampoTabella, -- in inserimento l'utente di modifica/ultimo agg. scheda anagrafica-professionale è uguale a quello di inserimento
        Sysdate,
        'C', -- rivedere
        'C',-- altro: da rivedere
        'N');

  -- inserisco uno stato occupazionale di default per il nuovo soggetto
  insert into AM_STATO_OCCUPAZ
     (PRGSTATOOCCUPAZ,
  CDNLAVORATORE,
  CODSTATOOCCUPAZ,
  CODMONOPROVENIENZA,
  DATINIZIO,
  cdnUtIns,
        dtmIns,
        cdnUtMod,
        dtmMod
  )
   values (
     S_AM_STATO_OCCUPAZ.nextval,
  cdnParLavoratore,
  'C', -- altri
  'A', -- creato da inserimento anagrafica
  to_date(to_char(sysdate, 'dd/mm/yyyy'),'dd/mm/yyyy'),
  strParCampoTabella, --codUtIns
        sysdate,
        strParCampoTabella, -- in inserimento l'utente di modifica è uguale a quello di inserimento
        sysdate);

   end if;

 -- ALL'elenco anagrafico in base al cpi di competenza
   if codParLstTab = 'AN_LAV1' then
      -- inserisco il nuovo soggetto nell'elenco anagrafico DA RIVEDERE con l'indice regionale ....
      insert into AM_ELENCO_ANAGRAFICO
       (prgElencoAnagrafico,
        cdnLavoratore,
        datInizio,
        datCan,
        codTipoCan,
        cdnUtIns,
        dtmIns,
        cdnUtMod,
        dtmMod ) -- il klocK è gestito dal trigger di before insert nella parte std di gestione dei lock
      values
       (S_AM_ELENCO_ANAGRAFICO.nextval,
        cdnParLavoratore,
        sysdate,
        null,
        null,
        strParCampoTabella, --codUtIns
        sysdate,
        strParCampoTabella, -- in inserimento l'utente di modifica è uguale a quello di inserimento
        sysdate);

end if;

-- ALLA DICHIARAZIONE DI IMMEDIATA DISPONIBILITA'
   if codParLstTab = 'AM_DIC_D' then  -- 16/06/2004 da applicativo: tolto il trigger in aflter insert che chiamava questa procedura
                                      -- dalla did


     -- trovo il lavoratore della dichiarazione (dall'elenco anagrafico)
        begin
          select ea.cdnLavoratore
            into cdnVarLavoratore
            from AM_ELENCO_ANAGRAFICO ea
           where ea.prgElencoAnagrafico         = cdnParLavoratore; -- utilizzato per il rif. all'elenco anagrafico in questo caso

          exception
            when no_data_found then
              raise; -- propago l'errore perchè il record deve esserci
          end;

     -- trovo il record relativo al documento di identità principale per associarlo alla dichiarazione di immediata disponibilità
    begin
       prgVarDocumento := 0;

       select da.prgDocumento
         into prgVarDocumento
         from am_documento da
        where da.cdnLavoratore = cdnParLavoratore
          and da.flgdocidentifp = 'S';
     exception
       when no_data_found then
         null; --per ora non propago l'errore RIVEDERE
     end;

     if prgVarDocumento <> 0 then
     -- inserisco il collegamento nella tabella AM_DOCUMENTO_COLL
     insert into AM_DOCUMENTO_COLL
       (prgDocumentoColl,
        prgDocumento,
        cdnComponente, --codLstTab,
        strChiaveTabella)
       values
        (S_AM_DOCUMENTO_COLL.nextval,
        prgVarDocumento,
        25,--codParLstTab, 25
        strParChiaveTabella);
      end if;


   end if;


--exception
--  when others then
--    raise_application_error (-20000, 'Fallito collegamento tabelle.');
end; -- fine della procedura pdCollegaTab

--
-- Controllo integrita' refenziale della tabella am_lav_patto_scelta
---
procedure pdIntegRefPattoScelta (codParLstTab in DE_LST_TAB.codLstTab%type,
           prgParPattoLavoratore in AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE%TYPE,
           strParChiaveTabella  in varchar2,
           strParChiaveTabella2 in varchar2,
           strParChiaveTabella3 in varchar2) is
  -- variabili
  cdnVarLavoratore              AN_LAVORATORE.cdnLavoratore%TYPE;

begin

-- OBBLIGO FORMATIVO
        if (codParLstTab = 'AM_OBBFO')
        then
        -- cerco il record collegato al patto nella tabella AM_OBBLIGO_FORMATIVO
         begin

          select tab.CDNLAVORATORE
            into cdnVarLavoratore
            from AM_OBBLIGO_FORMATIVO tab, AM_PATTO_LAVORATORE apl
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.CDNLAVORATORE       = strParChiaveTabella       -- join con la tabella di dettaglio
                                                            -- (la chiave della tabella è il cdnLavoratore perchè la tabella dell'obbligo formativo non ha progressivo)
    and apl.cdnLavoratore       = tab.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio


          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Obbligo formativo.');

    end;



   --
   -- Permesso di soggiorno
   elsif (codParLstTab = 'AM_EX_PS')
        then
        -- cerco il record collegato al patto nella tabella AM_EX_PERM_SOGG
         begin

          select tab.CDNLAVORATORE
            into cdnVarLavoratore
            from AM_EX_PERM_SOGG tab, AM_PATTO_LAVORATORE apl
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.PRGPERMSOGG         = strParChiaveTabella       -- join con la tabella di dettaglio
    and apl.cdnLavoratore       = tab.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio


          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Permesso di soggiorno.');

    end;
   /************************************
   FAI CONTROLLARE DA EMANUELA
   ************************************/
      --
   -- PERCORSO CONCORDATO
      elsif (codParLstTab = 'OR_PER')
        then
        -- cerco il record collegato al patto nella tabella OR_PERCORSO_CONCORDATO
         begin
/* non deve piu' essere utilizzata la tabella ev_lavoratore
************************************************************
          select evl.CDNLAVORATORE
            into cdnVarLavoratore
            from OR_PERCORSO_CONCORDATO tab, AM_PATTO_LAVORATORE apl, OR_COLLOQUIO col, EV_LAVORATORE evl
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.PRGPERCORSO         = strParChiaveTabella       -- join con la tabella di dettaglio
    and tab.PRGCOLLOQUIO        = col.PRGCOLLOQUIO
    and col.PRGCONTATTO         = evl.PRGCONTATTO
    and apl.cdnLavoratore       = evl.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio
*/
        select col.CDNLAVORATORE
            into cdnVarLavoratore
            from VW_AM_PATTO_OR_PER tab, AM_PATTO_LAVORATORE apl, OR_COLLOQUIO col
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.PRGPERCORSO         = strParChiaveTabella       -- join con la tabella di dettaglio
    and tab.PRGCOLLOQUIO        = col.PRGCOLLOQUIO
    and apl.cdnLavoratore       = col.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio

          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Percorso Concordato.');

    end;
      --
   -- ISCRIZIONE MOBILITA
      elsif (codParLstTab = 'AM_MB_IS')
        then
        -- cerco il record collegato al patto nella tabella AM_MOBILITA_ISCR
         begin

          select tab.CDNLAVORATORE
            into cdnVarLavoratore
            from AM_MOBILITA_ISCR tab, AM_PATTO_LAVORATORE apl
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.PRGMOBILITAISCR     = strParChiaveTabella       -- join con la tabella di dettaglio
    and apl.cdnLavoratore       = tab.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio


          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Iscrizione Mobilita''.');

    end;

      --
   -- ISCRIZIONE COLLOCAMENTO MIRATO
      elsif (codParLstTab = 'AM_CM_IS')
        then
        -- cerco il record collegato al patto nella tabella AM_CM_ISCR
         begin

          select apl.CDNLAVORATORE
            into cdnVarLavoratore
            from AM_CM_ISCR tab, AM_PATTO_LAVORATORE apl
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.PRGCMISCR           = strParChiaveTabella;       -- join con la tabella di dettaglio
    --and apl.cdnLavoratore       = tab.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio


          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Iscrizione Collocamento Mirato.');

    end;

      --
   -- INDISPONIBILITA' TEMPORANEE
      elsif (codParLstTab = 'AM_IND_T')
        then
        -- cerco il record collegato al patto nella tabella AM_INDISP_TEMP
         begin

          select tab.CDNLAVORATORE
            into cdnVarLavoratore
            from AM_INDISP_TEMP tab, AM_PATTO_LAVORATORE apl
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.PRGINDISPTEMP       = strParChiaveTabella       -- join con la tabella di dettaglio
    and apl.cdnLavoratore       = tab.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio


          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Indisponibilita'' Temporanee.');

    end;
      --
   -- TITOLI DI STUDIO
      elsif (codParLstTab = 'PR_STU')
        then
        -- cerco il record collegato al patto nella PR_STUDIO
         begin

          select tab.CDNLAVORATORE
            into cdnVarLavoratore
            from PR_STUDIO tab, AM_PATTO_LAVORATORE apl
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.PRGSTUDIO           = strParChiaveTabella       -- join con la tabella di dettaglio
    and apl.cdnLavoratore       = tab.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio


          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Titoli di Studio.');

    end;

      --
   -- CORSI DI FORMAZIONE
      elsif (codParLstTab = 'PR_COR')
        then
        -- cerco il record collegato al patto nella PR_CORSO
         begin

          select tab.CDNLAVORATORE
            into cdnVarLavoratore
            from PR_CORSO tab, AM_PATTO_LAVORATORE apl
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.PRGCORSO            = strParChiaveTabella       -- join con la tabella di dettaglio
    and apl.cdnLavoratore       = tab.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio


          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Corsi di Formazione.');

    end;
   --
   -- MANSIONI
      elsif (codParLstTab = 'PR_MAN')
        then
        -- cerco il record collegato al patto nella PR_MANSIONE
         begin

          select tab.CDNLAVORATORE
            into cdnVarLavoratore
            from VW_AM_PATTO_PR_MANSIONE tab, AM_PATTO_LAVORATORE apl
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.PRGMANSIONE         = strParChiaveTabella       -- join con la tabella di dettaglio
    and apl.cdnLavoratore       = tab.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio

          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Mansioni.');

    end;
      --
   -- INDISPONIBILITA' PRESSO AZIENDE
      elsif (codParLstTab = 'PR_IND')
        then
        -- cerco il record collegato al patto nella PR_INDISPONIBILITA
         begin

          select tab.CDNLAVORATORE
            into cdnVarLavoratore
            from PR_INDISPONIBILITA tab, AM_PATTO_LAVORATORE apl
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.PRGINDISPONIBILITA  = strParChiaveTabella       -- join con la tabella di dettaglio
    and apl.cdnLavoratore       = tab.CDNLAVORATORE;         -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio


          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Indisponibilità presso aziende.');

    end;
   --
   -- ESPERIENZE LAVORATIVE
      elsif (codParLstTab = 'PR_ESP_L')
        then
        -- cerco il record collegato al patto nella PR_ESP_LAVORO
         begin

          select prs.CDNLAVORATORE
            into cdnVarLavoratore
            from PR_ESP_LAVORO tab, AM_PATTO_LAVORATORE apl, PR_MANSIONE prs
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
          and tab.PRGESPLAVORO        = strParChiaveTabella       -- join con la tabella di dettaglio
    and prs.PRGMANSIONE         = tab.PRGMANSIONE
    and apl.cdnLavoratore       = prs.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio


          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Esperienze Lavorative.');

    end;
      --
   -- AGENDA
      elsif (codParLstTab = 'AG_LAV')
        then
        -- cerco il record collegato al patto nella AG_AGENDA
         begin

          select agl.CDNLAVORATORE
            into cdnVarLavoratore
            from VW_AM_PATTO_AG_AGENDA tab, AM_PATTO_LAVORATORE apl, AG_LAVORATORE agl
           where apl.PRGPATTOLAVORATORE  = prgParPattoLavoratore     -- mi posiziono sulla riga della scelta da controllare
      and agl.CDNLAVORATORE       = strParChiaveTabella       -- in questo caso ho 3 chiavi
          and agl.CODCPI              = strParChiaveTabella2
    and agl.PRGAPPUNTAMENTO     = strParChiaveTabella3
    and agl.CODCPI              = tab.CODCPI                -- join con la tabella di dettaglio
    and agl.PRGAPPUNTAMENTO     = tab.PRGAPPUNTAMENTO
    and apl.cdnLavoratore       = agl.CDNLAVORATORE;        -- per sicurezza controlliamo anche che il lavoratore del patto sia lo stesso dell'inforamazione di dettaglio

          exception
            when no_data_found then
              raise_application_error (-20000, 'Fallito collegamento tabella Patto e tabella Agenda.');

    end;

     end if;

end;




--
-- Aggiorno utente/data ultimo aggiornamento della scheda professionale per estrarre/stampare l'informazione
-- (senza dover leggere tutte le tabelle coinvolte)
---
procedure pdModSchedaAnagProf (cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
            cdnParUtMod in TS_UTENTE.CDNUTMOD%TYPE,
            dtmParMod in date,
            codParLstTab in DE_LST_TAB.codLstTab%type := null) is

  -- variabili
  cdnVarLavoratore              AN_LAVORATORE.cdnLavoratore%TYPE;

begin

 cdnVarLavoratore  := cdnParLavoratore;

 -- cerco il lavoratore per le tabelle in cui il campo non compare direttamente (non si riesce
 -- a fare il join anche con la specifica tabella su cui scatta il trigger perchè
 -- Oracle non lo permette in AFTER ....)
 if not codParLstTab is null then
   if codParLstTab  in ('PR_D_CON', 'PR_D_TUR', 'PR_D_ORA', 'PR_D_COM', 'PR_D_REG', 'PR_D_STA', 'PR_D_PRO', 'PR_MO_GE') then
     select cdnLavoratore
    into cdnVarLavoratore
    from PR_MANSIONE pma
   where pma.PRGMANSIONE     = cdnParLavoratore;  -- parametro utilizzato per la chiave della tabella specifica  in questo caso
   end if;
 end if;

  update AN_LAV_STORIA_INF
    set  cdnUtModSchedaAnagProf =  cdnParUtMod ,
         dtmModSchedaAnagProf   =  dtmParMod   ,
   numKloLavStoriaInf     =  numKloLavStoriaInf + 1
   where cdnLavoratore          =  cdnVarLavoratore
     and datFine                is null;

exception
  when others then
    raise;  --propago l'errore
end;



--Procedura per "PROTOCOLLAZIONE": cambia il valore del campo codStatoAtto rendendolo 'PR'.
procedure pckProtocollazione (cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
           codParTipoDocumento in AM_DOCUMENTO.CODTIPODOCUMENTO%TYPE,
         parCodStatoAtto in AM_DOCUMENTO.CODSTATOATTO%TYPE) IS

  -- variabili
  strVarChiaveTabellaRecordPrec AM_DICH_DISPONIBILITA.prgDichDisponibilita%TYPE;
  numVarKlo                     AM_DICH_DISPONIBILITA.numKloDichDisp%TYPE;
  prgVarElencoAnagrafico        AM_ELENCO_ANAGRAFICO.prgElencoAnagrafico%TYPE;

begin
-- DICHIARAZIONE DI IMMEDIATA DISPONIBILITA'
        if (codParTipoDocumento = 'IM')
        then
         begin

          select ea.prgElencoAnagrafico
            into prgVarElencoAnagrafico
            from AM_ELENCO_ANAGRAFICO ea
           where ea.cdnLavoratore        = cdnParLavoratore -- utilizzato per il rif. all'elenco anagrafico in questo caso
       AND EA.DATCAN IS NULL;

          exception
            when no_data_found then
        raise; -- propago l'errore perchè il record deve esserci
          end;

         begin
		 
		 if (parCodStatoAtto = 'PR') then
			
			  select tab.prgDichDisponibilita, tab.numKloDichDisp
				into strVarChiaveTabellaRecordPrec, numVarKlo
				from AM_DICH_DISPONIBILITA tab, AM_ELENCO_ANAGRAFICO ea
			  where ea.prgElencoAnagrafico = tab.prgElencoAnagrafico
					and ea.cdnLavoratore  = cdnParLavoratore
					and tab.prgDichDisponibilita  = (select max(tab1.prgDichDisponibilita)
													 from  am_dich_disponibilita tab1, am_elenco_anagrafico ea1
													 where  ea1.prgElencoAnagrafico  = tab1.prgElencoAnagrafico
													 and  ea1.cdnLavoratore = cdnParLavoratore and tab1.codStatoAtto = 'PA' and tab1.datFine is null);
		 else
			
			  -- cerco la chiave del record precedente per la tabella AM_DICH_DISPONIBILITA (NON SI PUO' FARE QUESTA SELECT SUL
			  --                                                                             TRIGGER DI BEFORE INSERT)
			  select tab.prgDichDisponibilita, tab.numKloDichDisp
				into strVarChiaveTabellaRecordPrec, numVarKlo
				from AM_DICH_DISPONIBILITA tab, AM_ELENCO_ANAGRAFICO ea
			  where -- NON C'E' IL cdnLavoratore direttamente nella dichiarazione dato che è sempre legata all'inserimento
					 -- nell'elenco anagrafico
					 ea.prgElencoAnagrafico         = tab.prgElencoAnagrafico
					and ea.cdnLavoratore               = cdnParLavoratore
					-- 22/04/2005 Per poter inserire una DID vecchia (chiusa da subito dagli impatti)
					-- il controllo non va fatto sulla datFine nulla
					and tab.prgDichDisponibilita           = (select max(tab1.prgDichDisponibilita)
															from  am_dich_disponibilita tab1, am_elenco_anagrafico ea1
															  where  ea1.prgElencoAnagrafico  = tab1.prgElencoAnagrafico
															and  ea1.cdnLavoratore        = cdnParLavoratore);
					--and tab.datFine is null;
		 end if;

          exception
            when no_data_found then
              null;
          end;
		  
          -- tabella AM_DICH_DISPONIBILITA
             update AM_DICH_DISPONIBILITA
    -- Savino 23/09/05: al primo inserimento il codStatoAtto e' PA: se si e' scelto di salvare su db
    --                  e di non protocollare lo stato della did non deve cambiare
             --  set codStatoAtto              =  'PR',
     set codStatoAtto            = parCodStatoAtto,
                     numKloDichDisp          = numVarKlo + 1,
      dtmMod                  = sysdate
              where -- NON C'E' IL cdnLavoratore la dichiarazione è sempre legata all'inserimento
                    -- nell'elenco anagrafico
                prgDichDisponibilita     =  strVarChiaveTabellaRecordPrec
   -- Savino 23/09/05: aggiorno lo stato solo se cambiato (evito un aggiornamento che non modifica lo stato)
   -- E' imperativo che stato documento e stato did devono essere gli stessi
    and codStatoAtto <> parCodStatoAtto;
    -- 22/04/2005 Non serve questo criterio visto che c'è già sopra la chiave primaria
    -- Poi non permette di inserire DID vecchie da subito chiuse dagli impatti
                --and datFine                  is null;



        end if;  -- chiude l'if sulla tabella da chiudere: AM_DICH_DISPONIBILITA

-- PATTO
        if (codParTipoDocumento = 'PT297' or codParTipoDocumento = 'ACLA')
        then
        -- cerco la chiave del record precedente per la tabella AM_PATTO_LAVORATORE (NON SI PUO' FARE QUESTA SELECT SUL
        --                                                                           TRIGGER DI BEFORE INSERT)
         begin

          select tab.prgPattoLavoratore, tab.numKloPattoLavoratore
            into strVarChiaveTabellaRecordPrec, numVarKlo
            from AM_PATTO_LAVORATORE tab
           where tab.cdnLavoratore              = cdnParLavoratore
             and tab.datFine                    is null;

          exception
            when no_data_found then
              null;
          end;



          -- abella AM_PATTO_LAVORATORE
             update AM_PATTO_LAVORATORE
               set codStatoAtto              = parCodStatoAtto,
                   numKloPattoLavoratore     = numVarKlo + 1
              where cdnLavoratore            = cdnParLavoratore
                and prgPattoLavoratore       = strVarChiaveTabellaRecordPrec
    and codStatoAtto            <> parCodStatoAtto
                and datFine                  is null;



        end if;  -- chiude l'if sulla tabella da chiudere: AM_PATTO

end;

-- Procedura per il controllo della sequenzialità storica dei record: la data fine del record storicizzato deve essere
--     maggiore della data inizio del record che si inserisci o si aggiorna
procedure checkIntersezioneDate (cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
           parDataInizio in AM_PATTO_LAVORATORE.DATFINE%TYPE,
           codLstTab in DE_LST_TAB.CODLSTTAB%TYPE,
           codParTipoRec in varchar2 := null,
           prgParRecord integer := 0) IS
  -- il parametro "codParTipoRec in varchar2 := null" è opzionale
  -- (grazie al valore di default attribuito da subito; serve per AM_DOCUMENTO)
  -- il parametro prgParDocumento in integer : = 0 della procedura checkIntersezioneDate è opzionale
  -- (grazie al valore di default attribuito da subito; serve per 'AM_DOCUMENTO'

  varDataFineRecPrecedente date;

-- variabile aggiunta per il modulo ISEE
  varDataInizioRecPrecedente date;
----------------------------------------
  varCdnLavoratore AN_LAVORATORE.cdnLavoratore%TYPE;
  varcodTipoRec varchar2(50);
  varNummStatiOcc integer;
  varNumPattiAperti integer;

 begin
    if (codLstTab='AM_S_OCC') then
      --stato occupazionale : max(tab.DATINIZIO) = max(tab.DATFINE) + 1 quando ci sono più stati occupazionali per il lavoratore
	  select max(tab.DATINIZIO)
      into varDataFineRecPrecedente
      from am_stato_occupaz tab
      where tab.CDNLAVORATORE = cdnParLavoratore;
	
	else
       if (codLstTab='AM_MB_IS') then
        --mobilità
          select distinct max(tab.DATFINE)
      into varDataFineRecPrecedente
     from am_mobilita_iscr tab
     where tab.DATFINE is not null
     and  tab.CDNLAVORATORE = cdnParLavoratore;
     else
        if (codLstTab='EA') then
        --elenco anagrafico
         select distinct max(tab.DATCAN)
      into varDataFineRecPrecedente
      from am_elenco_anagrafico tab
      where tab.DATCAN is not null
      and  tab.CDNLAVORATORE = cdnParLavoratore;
     else
      if (codLstTab='AM_PAT_L') then
         --patto lavoratore
		  select count(*)
		  into varNumPattiAperti
		  from am_patto_lavoratore tab
		  where tab.CDNLAVORATORE = cdnParLavoratore
		  and tab.datfine is null;
		 
		  if (varNumPattiAperti >= 1) then
			select max(tab.DATSTIPULA)
			into varDataFineRecPrecedente
			from am_patto_lavoratore tab
			where tab.CDNLAVORATORE = cdnParLavoratore;
		  else
			select max(tab.DATFINE)
			into varDataFineRecPrecedente
			from am_patto_lavoratore tab
			where tab.DATFINE is not null
			and  tab.CDNLAVORATORE = cdnParLavoratore;
		  end if;
		 
      else
        if (codLstTab='AS_ISEE') then
          --Valore ISEE
           select distinct max(tab.DATINIZIOVAL)
        into varDataInizioRecPrecedente
        from AS_VALORE_ISEE tab
        where tab.CDNLAVORATORE = cdnParLavoratore;
       else
         if (codLstTab='AM_DIC_D') then
         --dichiarazione immediata disponibilità
        select ea.cdnLavoratore
                 into varCdnLavoratore
                 from AM_ELENCO_ANAGRAFICO ea
                 where ea.prgElencoAnagrafico = cdnParLavoratore;

           select distinct max(tab.DATFINE)
        into varDataFineRecPrecedente
                 from AM_DICH_DISPONIBILITA tab, AM_ELENCO_ANAGRAFICO ea
                 where ea.prgElencoAnagrafico = tab.prgElencoAnagrafico
                 and ea.cdnLavoratore = varCdnLavoratore
        and tab.CODSTATOATTO = 'PR'
                  and tab.datFine is not null;
           else
                             if     (codLstTab = 'AM_DOC')
                            and  (codParTipoRec in ('IM', 'SAP', 'PT297', 'ACLA', 'SA', 'CUE', 'CUL', 'CUA', 'LTC'))
                                      -- dichiarazione Immediata Disponibilità, Scheda Anagrafica Professionale,
              -- Patto 297, Accord generico Lavoratore, scheda anagrafica, curriculum europeo
              -- curriculum lavoratore, curriculum azienda, lettera di convocazione
                             then

                                select distinct max(nvl(tab.DATFINE,tab.DATINIZIO))
               into varDataFineRecPrecedente
               from am_documento tab
               where tab.CDNLAVORATORE    = cdnParLavoratore
           and   tab.codTipoDocumento = codParTipoRec
           and   tab.codstatoatto = 'PR'
           and   tab.prgDocumento     <> prgParRecord; -- chiave diversa da quella del record che si sta inserendo
           /* NOTA: NEI DOCUMENTI LA DATA FINE NON E' OBBLIGATORIA; */
                         end if;
                       end if;
      end if;
        end if;
      end if;
     end if;
      end if;

/*
   if (codLstTab='AM_PAT_L') then
     if (varDataFineRecPrecedente > parDataInizio) then
    raise_application_error (-20010, 'Data fine record storicizzato maggiore data inizio nuovo record.');
   end if;
   else
    if (varDataFineRecPrecedente = parDataInizio) then
      raise_application_error (-20011, 'Data fine record storicizzato maggiore o uguale data inizio nuovo record.');
    end if;
   end if;
*/

    if (varDataFineRecPrecedente IS NOT NULL) and (varDataFineRecPrecedente > parDataInizio) then
      raise_application_error (-20012, 'Il nuovo record non è successivo all''ultimo già inserito.');
    end if;

    if (varDataInizioRecPrecedente IS NOT NULL) and (varDataInizioRecPrecedente >= parDataInizio) then
      raise_application_error (-20012, 'Il nuovo record non è successivo all''ultimo già inserito.');
    end if;

   exception
        when no_data_found then
        null;


 end;


procedure checkIntersezioneDateNew (cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
                                    parDataInizio in AM_MOBILITA_ISCR.DATINIZIO%TYPE,
                                    parDataFine in AM_MOBILITA_ISCR.DATFINE%TYPE,
                                    codLstTab in DE_LST_TAB.CODLSTTAB%TYPE) IS

 CURSOR cursorMob IS SELECT am_mobilita_iscr.prgmobilitaiscr, am_mobilita_iscr.datInizio,
                                am_mobilita_iscr.datFine
                           FROM AM_MOBILITA_ISCR
                        WHERE AM_MOBILITA_ISCR.CDNLAVORATORE = cdnParLavoratore;

 rec_mob cursorMob%ROWTYPE;
 datVarInizio am_mobilita_iscr.DATINIZIO%type;
 datVarFine am_mobilita_iscr.DATFINE%type;
 ok boolean := TRUE;

 begin

 if (codLstTab='AM_MB_IS') then

     FOR rec_mob IN cursorMob LOOP
         datVarInizio := rec_mob.datInizio;
         datVarFine := rec_mob.datFine;
         if (datVarFine is not null) then
            if (parDataFine is null) then
               if (trunc(parDataInizio) <= trunc(datVarFine)) then
                     ok := FALSE;
               end if;
            else
            	if (trunc(parDataInizio) < trunc(datVarInizio) and trunc(parDataFine) >= trunc(datVarInizio)) then
            		ok := FALSE;
            	else
                	if (trunc(parDataInizio) >= trunc(datVarInizio) and trunc(parDataInizio) <= trunc(datVarFine)) then
                   		ok := FALSE;
                	else
                		if (trunc(parDataFine) >= trunc(datVarInizio) and trunc(parDataFine) <= trunc(datVarFine)) then
                   			ok := FALSE;
                		end if;
            		end if;
            	end if;
            end if;
         else
              if (parDataFine is null) then
                 ok := FALSE;
             else
                  if (trunc(parDataFine) >= trunc(datVarInizio)) then
                     ok := FALSE;
                 end if;
             end if;
         end if;
         
    end loop;

 end if;

 if (not ok) then
     raise_application_error (-20010, 'Il nuovo record si interseca con un periodo di mobilità già inserito.');
 end if;

 exception
   when no_data_found then null;

 end;


-- Procedura per il controllo della sequenzialità storica dei record (Collocamento Mirato):
-- la data fine del record storicizzato deve essere
-- maggiore della data inizio del record che si inserisci o si aggiorna
procedure checkIntersezioneDateCM (cdnParLavoratore in AM_CM_ISCR.cdnLavoratore%TYPE,
           parDataInizio in AM_CM_ISCR.DATDATAFINE%TYPE,
           codLstTab in DE_LST_TAB.CODLSTTAB%TYPE,
           codParTipoRec in varchar2 := null) IS

  varDataFineRecPrecedente AM_CM_ISCR.DATDATAFINE%TYPE;
  varDataInizioRecPrecedente AM_CM_ISCR.DATDATAINIZIO%TYPE;
  varcodTipoRec varchar2(50);
  varNumIscrizioni integer;
  varNumIscrizioniNP integer;
 begin
    if (codLstTab='AM_CM_IS') then

     begin

     -- Cerco il tipo del record (D o A)
      select de.CODMONOTIPORAGG
        into varcodTipoRec
        from DE_CM_TIPO_ISCR de
       where de.CODCMTIPOISCR = codParTipoRec;

      select count(1)
    into varNumIscrizioni
    from am_cm_iscr tab, de_cm_tipo_iscr tip, am_documento_coll coll, am_documento doc
    where tab.CODCMTIPOISCR = tip.CODCMTIPOISCR
    and  tab.CDNLAVORATORE = cdnParLavoratore
    and tip.CODMONOTIPORAGG = varcodTipoRec
    and tab.PRGCMISCR = coll.STRCHIAVETABELLA
    and coll.PRGDOCUMENTO = doc.PRGDOCUMENTO
    and doc.CODTIPODOCUMENTO = 'L68'
    and doc.CODSTATOATTO != 'AN'
	and coll.cdncomponente = (select cdncomponente from ts_componente where upper(strpage) = 'CMISCRIZIONILAVORATOREPAGE');

      if (varNumIscrizioni > 0) then

       select count(1)
     into varNumIscrizioniNP
     from am_cm_iscr tab, de_cm_tipo_iscr tip, am_documento_coll coll, am_documento doc
     where tab.CODCMTIPOISCR = tip.CODCMTIPOISCR
     and  tab.CDNLAVORATORE = cdnParLavoratore
     and tip.CODMONOTIPORAGG = varcodTipoRec
     and tab.PRGCMISCR = coll.STRCHIAVETABELLA
     and coll.PRGDOCUMENTO = doc.PRGDOCUMENTO
     and doc.CODTIPODOCUMENTO = 'L68'
     and doc.CODSTATOATTO = 'NP'
	 and coll.cdncomponente = (select cdncomponente from ts_componente where upper(strpage) = 'CMISCRIZIONILAVORATOREPAGE');

     if (varNumIscrizioniNP > 0) then
      raise_application_error (-20014, 'Esiste già un''iscrizione non protocollata.');
     end if;

       select distinct max(tab.DATDATAFINE)
     into varDataFineRecPrecedente
     from am_cm_iscr tab, de_cm_tipo_iscr tip, am_documento_coll coll, am_documento doc
     where tab.CODCMTIPOISCR = tip.CODCMTIPOISCR
     and tab.DATDATAFINE is not null
     and  tab.CDNLAVORATORE = cdnParLavoratore
     and tip.CODMONOTIPORAGG = varcodTipoRec
     and tab.PRGCMISCR = coll.STRCHIAVETABELLA
     and coll.PRGDOCUMENTO = doc.PRGDOCUMENTO
     and doc.CODTIPODOCUMENTO = 'L68'
     and doc.CODSTATOATTO = 'PR'
	 and coll.cdncomponente = (select cdncomponente from ts_componente where upper(strpage) = 'CMISCRIZIONILAVORATOREPAGE');

       select distinct max(tab.DATDATAINIZIO)
     into varDataInizioRecPrecedente
     from am_cm_iscr tab, de_cm_tipo_iscr tip, am_documento_coll coll, am_documento doc
     where tab.CODCMTIPOISCR = tip.CODCMTIPOISCR
     and tab.DATDATAFINE is null
     and  tab.CDNLAVORATORE = cdnParLavoratore
     and tip.CODMONOTIPORAGG = varcodTipoRec
     and tab.PRGCMISCR = coll.STRCHIAVETABELLA
     and coll.PRGDOCUMENTO = doc.PRGDOCUMENTO
     and doc.CODTIPODOCUMENTO = 'L68'
     and doc.CODSTATOATTO = 'PR'
	 and coll.cdncomponente = (select cdncomponente from ts_componente where upper(strpage) = 'CMISCRIZIONILAVORATOREPAGE');

    else
     varDataFineRecPrecedente:= null;
     varDataInizioRecPrecedente:= null;
    end if;
   end;

    end if;

       if (varDataFineRecPrecedente IS NOT NULL) and (varDataFineRecPrecedente > parDataInizio) then
      raise_application_error (-20012, 'Il nuovo record non è successivo all''ultimo già inserito.');
    end if;

    if (varDataInizioRecPrecedente IS NOT NULL) and (varDataInizioRecPrecedente >= parDataInizio) then
       raise_application_error (-20012, 'Il nuovo record non è successivo all''ultimo già inserito.');
    end if;

   exception
        when no_data_found then
        null;


 end;


FUNCTION pdAggSedeAzienda (prgParAzienda in AN_UNITA_AZIENDA.prgAzienda%type,
           prgParUnita in AN_UNITA_AZIENDA.prgUnita%type,
         cdnParUtMod in AN_UNITA_AZIENDA.cdnUtMod%type)
         RETURN NUMBER
IS
BEGIN
	
 UPDATE AN_UNITA_AZIENDA
 set flgsede  = 'S',
  CDNUTMOD = cdnParUtMod,
  DTMMOD   = SYSDATE,
  NUMKLOUNITAAZIENDA = NUMKLOUNITAAZIENDA + 1
 where prgazienda = prgparazienda
 AND   PRGUNITA  = PrgParUnita;

 UPDATE AN_UNITA_AZIENDA
 SET FLGSEDE  = 'N',
   CDNUTMOD = cdnParUtMod,
  DTMMOD   = SYSDATE,
  NUMKLOUNITAAZIENDA = NUMKLOUNITAAZIENDA + 1
 WHERE PRGAZIENDA = PrgParAzienda
 AND   PRGUNITA  <> PrgParUnita
    AND   NVL(FLGSEDE,'S') = 'S';

 RETURN SQL%ROWCOUNT;

EXCEPTION
   WHEN OTHERS THEN
    RAISE;
END pdAggSedeAzienda;


FUNCTION AGGIORNASEDELEGALE (prgParAzienda in AN_UNITA_AZIENDA.prgAzienda%type,
           prgParUnita in AN_UNITA_AZIENDA.prgUnita%type, numkloPar in AN_UNITA_AZIENDA.numklounitaazienda%type,
		   cdnParUtMod in AN_UNITA_AZIENDA.cdnUtMod%type)
         RETURN NUMBER
IS
BEGIN
	
 UPDATE AN_UNITA_AZIENDA
 set flgsede  = 'S',
  CDNUTMOD = cdnParUtMod,
  DTMMOD   = SYSDATE,
  NUMKLOUNITAAZIENDA = numkloPar + 1
 where prgazienda = prgParAzienda
 AND   prgunita  = prgParUnita;

 UPDATE AN_UNITA_AZIENDA
 SET FLGSEDE  = 'N',
   CDNUTMOD = cdnParUtMod,
  DTMMOD   = SYSDATE,
  NUMKLOUNITAAZIENDA = NUMKLOUNITAAZIENDA + 1
 WHERE prgazienda = prgParAzienda
 AND   prgunita  <> prgParUnita;

 RETURN 0;

EXCEPTION
   WHEN OTHERS THEN
    RETURN -1;
END AGGIORNASEDELEGALE;


--RIAPERTURA CHIUSURA (ad es. DOCUMENTO ASSOCIATO ALLA DID)
PROCEDURE pdApriChiudiInfColl (codParLstTabMod in DE_LST_TAB.codLstTab%type,
              codParLstTabRif in DE_LST_TAB.STRNOMETABELLA%type,
              strParChiaveTabellaRif in varchar2, datParApriChiudi in date) is


--variabili
strVarChiaveTabella varchar2(100);
numVarProt AM_DOCUMENTO.numProtocollo%TYPE;
numVarKlo  AM_DOCUMENTO.numKloDocumento%TYPE;
datVarProtocollo AM_DOCUMENTO.DATPROTOCOLLO%TYPE;

begin
  if codParLstTabMod = 'AM_DOC'
  then
    begin
      if codParLstTabRif = 'AM_DIC_D' --DID CHIUSA O RIAPERTA
     THEN
        begin
          Select AMD.prgDocumento,    AMD.numProtocollo, AMD.numKloDocumento, AMD.DATPROTOCOLLO
        INTO   strVarChiaveTabella, numVarProt,    numVarKlo,    datVarProtocollo
        from AM_DOCUMENTO AMD, AM_DOCUMENTO_COLL AMDC
        WHERE AMD.PRGDOCUMENTO = AMDC.PRGDOCUMENTO
           AND AMDC.STRCHIAVETABELLA = strParChiaveTabellaRif
           AND AMDC.CDNCOMPONENTE = 25
        AND AMD.CODTIPODOCUMENTO = 'IM' and AMD.CODSTATOATTO = 'PR';

        /*
           Chiusura doc associato alla DID sempre, riapertura doc associato alla DID
        solo se la DID risulta protocollata
         */
        if strVarChiaveTabella is not null and not (datParApriChiudi is null and datVarProtocollo is null) --strparModo = 'A'
        then

           UPDATE AM_DOCUMENTO
             SET DATFINE = datParApriChiudi,
          numKloDocumento = numVarKlo + 1
          where prgDocumento = strVarChiaveTabella;

        end if;

      end;
      end if;

      --CHIUSURA/RIAPERTURA PATTO
      if codParLstTabRif = 'AM_PAT_L'
      then
       begin
           Select AMD.prgDocumento,    AMD.NUMPROTOCOLLO, AMD.numKloDocumento
        INTO   strVarChiaveTabella, numVarProt,        numVarKlo
        from AM_DOCUMENTO AMD, AM_DOCUMENTO_COLL AMDC
        WHERE AMD.PRGDOCUMENTO = AMDC.PRGDOCUMENTO
           AND AMDC.STRCHIAVETABELLA = strParChiaveTabellaRif
           AND AMDC.CDNCOMPONENTE = 14
        AND AMD.CODTIPODOCUMENTO in ('PT297', 'ACLA') and AMD.CODSTATOATTO = 'PR';

        /*
           Chiusura doc associato al Patto sempre, riapertura doc associato al Patto
        solo se il Patto risulta protocollata
         */
        if strVarChiaveTabella is not null and not (datParApriChiudi is null and numVarProt is null)
        then

           UPDATE AM_DOCUMENTO
             SET DATFINE = datParApriChiudi,
          numKloDocumento = numVarKlo + 1
          where prgDocumento = strVarChiaveTabella;
        end if;
        END;
      end if;

    end;
     end if;

exception
 when no_data_found
 then null;

end;

-- tracciamento delle modifiche apportate alle mansioni in data successiva la protocollazione del patto:
-- solo inserimenti nuove mansioni
procedure tracciaModifichePatto ( parCodLstTab in DE_LST_TAB.codLstTab%type,
         parPrgPattoLavoratore in AM_PATTO_LAVORATORE.prgPattoLavoratore%TYPE,
         parStrChiaveTabella in varchar2,
         parStrChiaveTabella2 in varchar2,
         parStrChiaveTabella3 in varchar2
         ) is
 --
 --
  varPrgMansione pr_mansione.prgMansione%TYPE;
  varCodMansione pr_mansione.codMansione%TYPE;
  varFlgEsperienza pr_mansione.flgEsperienza%TYPE;
  varFlgEspForm pr_mansione.flgEspForm%TYPE;
  varFlgDisponibile pr_mansione.flgDisponibile%TYPE;
  varFlgDispFormazione pr_mansione.flgDispFormazione%TYPE;
  varFlgPip pr_mansione.flgPip%TYPE;
  varCodMonoTempo pr_mansione.codMonoTempo%TYPE;
  varCdnUtMod pr_mansione.cdnUtMod%TYPE;
  varDtmMod pr_mansione.dtmMod%TYPE;
  varCdnLavoratore an_lavoratore.cdnLavoratore%TYPE;
  varStrTipoOp md_am_patto_lav_pr_mans.STRTIPOOP%TYPE;
  varPrgPattoLavoratore am_patto_lavoratore.prgPattoLavoratore%TYPE;
  varDatStimata or_percorso_concordato.DATSTIMATA%TYPE;
  varPrgAzioni or_percorso_concordato.PRGAZIONI%TYPE;
  varCodEsito or_percorso_concordato.CODESITO%TYPE;
  varDatEffettiva or_percorso_concordato.DATEFFETTIVA%TYPE;
  varStrNotePropostaOp or_percorso_concordato.STRNOTEPROPOSTAOP%TYPE;
  varStrNote or_percorso_concordato.STRNOTE%TYPE;
  varPrgPercorso or_percorso_concordato.PrgPercorso%TYPE;
  varPrgColloquio or_percorso_concordato.prgColloquio%TYPE;
  --
  varCODESITOAPPUNT  ag_agenda.CODESITOAPPUNT%TYPE;
  --varCDNUTMOD  ag_agenda.CDNUTMOD%TYPE;
  --varDTMMOD  ag_agenda.DTMMOD%TYPE;
  varNUMKLOAGENDA  ag_agenda.NUMKLOAGENDA%TYPE;
  varPRGAZIENDA  ag_agenda.PRGAZIENDA%TYPE;
  varPRGUNITA ag_agenda.PRGUNITA%TYPE;
  varCODCPI ag_agenda.CODCPI%TYPE;
  varPRGAPPUNTAMENTO ag_agenda.PRGAPPUNTAMENTO%TYPE;
  varDTMDATAORA ag_agenda.DTMDATAORA%TYPE;
  varNUMMINUTI ag_agenda.NUMMINUTI%TYPE;
  varCODSERVIZIO ag_agenda.CODSERVIZIO%TYPE;
  varPRGSPI ag_agenda.PRGSPI%TYPE;
  varTXTNOTE ag_agenda.TXTNOTE%TYPE;
  varPRGTIPOPRENOTAZIONE ag_agenda.PRGTIPOPRENOTAZIONE%TYPE;
  varSTRTELRIF ag_agenda.STRTELRIF%TYPE;
  varSTREMAILRIF ag_agenda.STREMAILRIF%TYPE;
  varSTRTELMOBILERIF ag_agenda.STRTELMOBILERIF%TYPE;
  varCODEFFETTOAPPUNT ag_agenda.CODEFFETTOAPPUNT%TYPE;
  varCODSTATOAPPUNTAMENTO ag_agenda.CODSTATOAPPUNTAMENTO%TYPE;
  varPRGAMBIENTE ag_agenda.PRGAPPUNTAMENTO%TYPE;
  varPRGSPIEFF ag_agenda.PRGSPIEFF%TYPE;
  varNUMORAFINEEFF ag_agenda.NUMORAFINEEFF%TYPE;
  varNUMORAINIZIOEFF ag_agenda.NUMORAINIZIOEFF%TYPE;
  --
 begin
 -- controllo che il patto al quale si sta associando una informazione sia protocollato
 select apl.prgPattoLavoratore
        into varPrgPattoLavoratore
  from am_patto_lavoratore apl
  where apl.codStatoAtto = 'PR'
  and apl.prgPattoLavoratore = parPrgPattoLavoratore
  and apl.datFine is null;
 --
 if (parCodLstTab = 'PR_MAN') then
  varStrTipoOp  := 'I'; -- inserimento nuova mansione in data successiva a quella di stipula di un patto protocollato
  select man.prgMansione, man.codMansione, man.codMonoTempo, man.flgDispFormazione, man.flgDisponibile, man.flgEsperienza,
   man.flgEspForm, man.flgPip, man.cdnUtMod, man.dtmMod, man.cdnLavoratore
  into varPrgMansione, varCodMansione, varCodMonoTempo, varFlgDispFormazione, varFlgDisponibile, varFlgEsperienza,
   varFlgEspForm, varFlgPip, varCdnUtMod, varDtmMod, varCdnLavoratore
  from pr_mansione man
  where man.prgMansione = parStrChiaveTabella;
  --
  insert into md_am_patto_lav_pr_mans
   (prgMod,
   strTipoOp,
   prgMansione,
   cdnLavoratore,
   codMansione,
   flgEsperienza,
   flgEspForm,
   flgDisponibile,
   flgDispFormazione,
   flgPip,
   codMonoTempo,
   cdnUtMod,
   dtmMod
    )
  values (s_md_am_patto_lav_pr_mans.nextVal,
   varStrTipoOp,
   varPrgMansione,
   varCdnLavoratore,
   varCodMansione,
   varFlgEsperienza,
   varFlgEspForm,
   varFlgDisponibile,
   varFlgDispFormazione,
   varFlgPip,
   varCodMonoTempo,
   1,
   sysdate
  );
 end if;
 if (parCodLstTab = 'OR_PER') then
  select per.datStimata, per.prgAzioni, per.PRGPERCORSO, per.PRGCOLLOQUIO, per.codEsito, per.DATEFFETTIVA, per.strNote, per.strNotePropostaOp,
   per.cdnUtMod, per.dtmMod
  into varDatStimata, varPrgAzioni, varPrgPercorso, varPrgColloquio, varCodEsito, varDatEffettiva, varStrNote, varStrNotePropostaOp,
   varCdnUtMod, varDtmMod
  from or_percorso_concordato per
  where per.prgPercorso = parStrChiaveTabella;
  --
  varStrTipoOp := 'A';
  insert into md_am_patto_lav_or_perc
   (prgMod,
   strTipoOp,
   prgColloquio,
   prgPercorso,
   datStimata,
   datEffettiva,
   prgAzioni,
   codEsito,
   strNote,
   strNotePropostaOp,
   cdnUtMod,
   dtmMod
    )
  values (s_md_am_patto_lav_or_perc.nextVal,
   varStrTipoOp,
   varPrgColloquio,
   varPrgPercorso,
   varDatStimata,
   varDatEffettiva,
   varPrgAzioni,
   varCodEsito,
   varStrNote,
   varStrNotePropostaOp,
   1,
   sysdate
  );
 end if;
 if (parCodLstTab = 'AG_LAV') then
    SELECT ag.CODCPI, ag.PRGAPPUNTAMENTO, ag.DTMDATAORA,
        ag.NUMMINUTI, ag.CODSERVIZIO, ag.PRGSPI, PRGSPIEFF,NUMORAFINEEFF,NUMORAINIZIOEFF,
        ag.TXTNOTE, ag.PRGTIPOPRENOTAZIONE, ag.STRTELRIF,
        ag.STREMAILRIF, ag.STRTELMOBILERIF, ag.CODEFFETTOAPPUNT,
     CODSTATOAPPUNTAMENTO, PRGAMBIENTE,
        ag.CODESITOAPPUNT, ag.CDNUTMOD, ag.DTMMOD,
        ag.NUMKLOAGENDA, ag.PRGAZIENDA, ag.PRGUNITA
  into varCODCPI, varPRGAPPUNTAMENTO, varDTMDATAORA,
        varNUMMINUTI, varCODSERVIZIO, varPRGSPI, varPRGSPIEFF,varNUMORAFINEEFF,varNUMORAINIZIOEFF,
        varTXTNOTE, varPRGTIPOPRENOTAZIONE, varSTRTELRIF,
        varSTREMAILRIF, varSTRTELMOBILERIF, varCODEFFETTOAPPUNT,
     varCODSTATOAPPUNTAMENTO,varPRGAMBIENTE,
        varCODESITOAPPUNT, varCDNUTMOD, varDTMMOD,
        varNUMKLOAGENDA, varPRGAZIENDA, varPRGUNITA
  FROM AG_AGENDA ag, ag_lavoratore agl
  where
   agl.cdnlavoratore = parStrChiaveTabella
   and agl.codCpi = parStrChiaveTabella2
   and agl.prgAppuntamento = parStrChiaveTabella3
   and agl.prgAppuntamento = ag.prgAppuntamento
   and agl.codCPI = ag.codCpi;
     --
  varStrTipoOp := 'AP';
  --
  INSERT INTO MD_AM_PATTO_LAV_AG_AGENDA (
    prgMod,strTipoOp,
             CODCPI, PRGAPPUNTAMENTO, DTMDATAORA,
             NUMMINUTI, NUMORAINIZIOEFF, NUMORAFINEEFF,
             CODSERVIZIO, PRGSPI, PRGSPIEFF, PRGAMBIENTE,
             TXTNOTE, PRGTIPOPRENOTAZIONE, STRTELRIF,
             STREMAILRIF, STRTELMOBILERIF, CODEFFETTOAPPUNT,
             CODESITOAPPUNT, CODSTATOAPPUNTAMENTO, CDNUTMOD, DTMMOD)
        VALUES ( s_md_am_patto_lav_ag_agenda.nextVal,
   varStrTipoOp,
   varCODCPI, varPRGAPPUNTAMENTO, varDTMDATAORA,
            varNUMMINUTI, varNUMORAINIZIOEFF, varNUMORAFINEEFF,
            varCODSERVIZIO, varPRGSPI, varPRGSPIEFF, varPRGAMBIENTE,
            varTXTNOTE, varPRGTIPOPRENOTAZIONE, varSTRTELRIF,
            varSTREMAILRIF, varSTRTELMOBILERIF, varCODEFFETTOAPPUNT,
            varCODESITOAPPUNT, varCODSTATOAPPUNTAMENTO, 1, sysdate);
 end if;
exception
 -- il patto non e' stato ancora protocollato
 when no_data_found then
  null;
end;




procedure tracciaModMansioniAssPattoLav(
         parCdnLavoratore in AM_PATTO_LAVORATORE.cdnLavoratore%TYPE,
         parFlgDisponibile in PR_MANSIONE.FLGDISPONIBILE%TYPE,
         parFlgDispFormazione in PR_MANSIONE.FLGDISPFORMAZIONE%TYPE,
         parPrgMansione in PR_MANSIONE.PRGMANSIONE%TYPE,
         parOldPrgMansione in pr_mansione.prgMansione%TYPE,
         parOldCodMansione  in pr_mansione.codMansione%TYPE,
         parOldFlgEsperienza  in pr_mansione.flgEsperienza%TYPE,
         parOldFlgEspForm  in pr_mansione.flgEspForm%TYPE,
         parOldFlgDisponibile  in pr_mansione.flgDisponibile%TYPE,
         parOldFlgDispFormazione  in pr_mansione.flgDispFormazione%TYPE,
         parOldFlgPip  in pr_mansione.flgPip%TYPE,
         parOldCodMonoTempo  in pr_mansione.codMonoTempo%TYPE,
         parCdnUtMod  in pr_mansione.cdnUtMod%TYPE,
         parDtmMod  in pr_mansione.dtmMod%TYPE
         ) is

-- variabili
 varPrgPattoLavoratore am_patto_lavoratore.prgPattoLavoratore%TYPE;
 varCdnLavoratore an_lavoratore.cdnLavoratore%TYPE;
 varStrTipoOp md_am_patto_lav_pr_mans.STRTIPOOP%TYPE;
 varPrgLavPattoScelta am_lav_patto_scelta.prgLavPattoScelta%TYPE;

begin
 -- se esiste un patto aperto e protocollato bisogna tracciare le modifiche
 select apl.prgPattoLavoratore
  into varPrgPattoLavoratore
  from am_patto_lavoratore apl
  where apl.cdnLavoratore = parCdnLavoratore
   and apl.datFine is null
   and apl.codStatoAtto = 'PR';
 -- controllo che esista la associazione per questa mansione
 select apl.prgLavPattoScelta
 into varPrgLavPattoScelta
 from am_lav_patto_scelta apl
 where apl.prgPattoLavoratore = varPrgPattoLavoratore
  and apl.strChiaveTabella = parPrgMansione
  and apl.codLstTab = 'PR_MAN';
 --
 if (nvl(parFlgDisponibile, ' ') <> nvl(parOldFlgDisponibile, ' ') or nvl(parFlgDispFormazione, ' ') <> nvl(parOldFlgDispFormazione, ' ')) then
 -- si devono tracciare le modifiche
 -- si suppone che in precedenza vi fossero o la disponibilita' al lavoro o alla formazione, condizioni necessarie
 -- per la associazione di una mansione al patto
  if (((parFlgDisponibile is null or parFlgDisponibile='N') and  parOldFlgDisponibile='S' )
   or((parOldFlgDisponibile is null or parOldFlgDisponibile='N') and  parFlgDisponibile='S')) then
   if ((parFlgDisponibile is null or parFlgDisponibile='N') and  parOldFlgDisponibile='S' ) then
    varStrTipoOp := 'ULN';
   else
     if ((parOldFlgDisponibile is null or parOldFlgDisponibile='N') and  parFlgDisponibile='S') then
      varStrTipoOp := 'ULS';
     end if;
      end if;
   insert into md_am_patto_lav_pr_mans
    (prgMod,
    strTipoOp,
    prgMansione,
    cdnLavoratore,
    codMansione,
    flgEsperienza,
    flgEspForm,
    flgDisponibile,
    flgDispFormazione,
    flgPip,
    codMonoTempo,
    cdnUtMod,
    dtmMod
     )
   values ( s_md_am_patto_lav_pr_mans.nextVal,
    varStrTipoOp,
    parOldPrgMansione,
    parCdnLavoratore,
    parOldCodMansione,
    parOldFlgEsperienza,
    parOldFlgEspForm,
    parOldFlgDisponibile,
    parOldFlgDispFormazione,
    parOldFlgPip,
    parOldCodMonoTempo,
    parCdnUtMod,
    parDtmMod
   );
  end if;
  if (((parFlgDispFormazione is null or parFlgDispFormazione='N') and  parOldFlgDispFormazione='S' )
   or((parOldFlgDispFormazione is null or parOldFlgDispFormazione='N') and  parFlgDispFormazione='S')) then
   if ((parFlgDispFormazione is null or parFlgDispFormazione='N') and  parOldFlgDispFormazione='S' ) then
    varStrTipoOp := 'UFN';
   else
       if ((parOldFlgDispFormazione is null or parOldFlgDispFormazione='N') and  parFlgDispFormazione='S') then
       varStrTipoOp := 'UFS';
        end if;
   end if;
   insert into md_am_patto_lav_pr_mans
    (prgMod,
    strTipoOp,
    prgMansione,
    cdnLavoratore,
    codMansione,
    flgEsperienza,
    flgEspForm,
    flgDisponibile,
    flgDispFormazione,
    flgPip,
    codMonoTempo,
    cdnUtMod,
    dtmMod
     )
   values (s_md_am_patto_lav_pr_mans.nextVal,
    varStrTipoOp,
    parOldPrgMansione,
    parCdnLavoratore,
    parOldCodMansione,
    parOldFlgEsperienza,
    parOldFlgEspForm,
    parOldFlgDisponibile,
    parOldFlgDispFormazione,
    parOldFlgPip,
    parOldCodMonoTempo,
    parCdnUtMod,
    parDtmMod
   );
  end if;
  -- aggiorno il campo am_lav_patto_scelta.datProtocollo a null
  update am_lav_patto_scelta alps
  set alps.DATPROTOCOLLO = null
  where alps.PRGLAVPATTOSCELTA = varPrgLavPattoScelta;

 end if;
 exception
     when no_data_found then
    null;
end;


procedure tracciaModAzioniAssPattoLav(
         parPrgColloquio in OR_PERCORSO_CONCORDATO.prgColloquio%TYPE,
         parPrgPercorso in OR_PERCORSO_CONCORDATO.prgPercorso%TYPE,
         parDatStimata in OR_PERCORSO_CONCORDATO.datStimata%TYPE,
         parPrgAzioni in OR_PERCORSO_CONCORDATO.prgAzioni%TYPE,
         parOldPrgColloquio in OR_PERCORSO_CONCORDATO.prgColloquio%TYPE,
         parOldPrgPercorso in OR_PERCORSO_CONCORDATO.prgPercorso%TYPE,
         parOldDatStimata in OR_PERCORSO_CONCORDATO.datStimata%TYPE,
         parOldDatEffettiva in OR_PERCORSO_CONCORDATO.datEffettiva%TYPE,
         parOldPrgAzioni in OR_PERCORSO_CONCORDATO.prgAzioni%TYPE,
         parOldCodEsito OR_PERCORSO_CONCORDATO.codEsito%TYPE,
         parOldStrNote OR_PERCORSO_CONCORDATO.strNote%TYPE,
         parOldStrNotePropostaOp OR_PERCORSO_CONCORDATO.strNotePropostaOp%TYPE,
         parCdnUtMod OR_PERCORSO_CONCORDATO.cdnUtMod%TYPE,
         parDtmMod OR_PERCORSO_CONCORDATO.dtmMod%TYPE
  ) is

 varPrgPattoLavoratore am_patto_lavoratore.prgPattoLavoratore%TYPE;
 varPrgLavPattoScelta am_lav_patto_scelta.prgLavPattoScelta%TYPE;
 varCdnLavoratore an_lavoratore.cdnLavoratore%TYPE;
 varStrTipoOp md_am_patto_lav_or_perc.STRTIPOOP%TYPE;
begin
 
 if (parDatStimata <> parOldDatStimata or parPrgAzioni <> parOldPrgAzioni) then
	-- se esiste un patto aperto e protocollato bisogna tracciare le modifiche
	-- cerco il cdnlavoratore
	select cdnLavoratore
	into varCdnLavoratore
	from or_colloquio
	where prgColloquio = parPrgColloquio;
	-- cerco il patto
	select apl.prgPattoLavoratore
	into varPrgPattoLavoratore
	from am_patto_lavoratore apl
	where apl.cdnLavoratore = varCdnLavoratore
	and apl.datFine is null
	and apl.codStatoAtto = 'PR';
	-- controllo che esista la associazione per questa azione
	select apl.prgLavPattoScelta
	into varPrgLavPattoScelta
	from am_lav_patto_scelta apl
	where apl.prgPattoLavoratore = varPrgPattoLavoratore
	and apl.strChiaveTabella = parPrgPercorso
	and apl.codLstTab = 'OR_PER';
 
	if (parDatStimata <> parOldDatStimata) then
		-- si devono tracciare le modifiche
		varStrTipoOp := 'UD';
		insert into md_am_patto_lav_or_perc
		(prgMod,
		strTipoOp,
		prgColloquio,
		prgPercorso,
		datStimata,
		datEffettiva,
		prgAzioni,
		codEsito,
		strNote,
		strNotePropostaOp,
		cdnUtMod,
		dtmMod
		 )
		values (s_md_am_patto_lav_or_perc.nextVal,
		varStrTipoOp,
		parOldPrgColloquio,
		parOldPrgPercorso,
		parOldDatStimata,
		parOldDatEffettiva,
		parOldPrgAzioni,
		parOldCodEsito,
		parOldStrNote,
		parOldStrNotePropostaOp,
		parCdnUtMod,
		parDtmMod
	   );
	end if;
	if (parPrgAzioni <> parOldPrgAzioni) then
		-- si devono tracciare le modifiche
		varStrTipoOp := 'UA';
		insert into md_am_patto_lav_or_perc
		(prgMod,
		strTipoOp,
		prgColloquio,
		prgPercorso,
		datStimata,
		datEffettiva,
		prgAzioni,
		codEsito,
		strNote,
		strNotePropostaOp,
		cdnUtMod,
		dtmMod
		 )
		values (s_md_am_patto_lav_or_perc.nextVal,
		varStrTipoOp,
		parOldPrgColloquio,
		parOldPrgPercorso,
		parOldDatStimata,
		parOldDatEffettiva,
		parOldPrgAzioni,
		parOldCodEsito,
		parOldStrNote,
		parOldStrNotePropostaOp,
		parCdnUtMod,
		parDtmMod
	   );
	end if;
	-- aggiorno il campo am_lav_patto_scelta.datProtocollo a null
	update am_lav_patto_scelta alps
	set alps.DATPROTOCOLLO = null
	where alps.PRGLAVPATTOSCELTA = varPrgLavPattoScelta;
 end if;
exception
	when no_data_found then
    null;
end;


PROCEDURE tracciaDelAssAzioniPattoLav(parCodLstTab in DE_LST_TAB.codLstTab%type,
         parPrgPattoLavoratore in AM_PATTO_LAVORATORE.prgPattoLavoratore%TYPE,
         parStrChiaveTabella in varchar2,
         parStrChiaveTabella2 in varchar2,
         parStrChiaveTabella3 in varchar2,
         --parDtmUtMod in AM_PATTO_LAVORATORE.DTMMOD%TYPE,
         parCdnUtMod AM_PATTO_LAVORATORE.CDNUTMOD%TYPE) IS
--
  parDtmUtMod  AM_PATTO_LAVORATORE.DTMMOD%TYPE;
  --
  varPrgMansione pr_mansione.prgMansione%TYPE;
  varCodMansione pr_mansione.codMansione%TYPE;
  varFlgEsperienza pr_mansione.flgEsperienza%TYPE;
  varFlgEspForm pr_mansione.flgEspForm%TYPE;
  varFlgDisponibile pr_mansione.flgDisponibile%TYPE;
  varFlgDispFormazione pr_mansione.flgDispFormazione%TYPE;
  varFlgPip pr_mansione.flgPip%TYPE;
  varCodMonoTempo pr_mansione.codMonoTempo%TYPE;
  varCdnUtMod pr_mansione.cdnUtMod%TYPE;
  varDtmMod pr_mansione.dtmMod%TYPE;
  varCdnLavoratore an_lavoratore.cdnLavoratore%TYPE;
  varStrTipoOp md_am_patto_lav_pr_mans.STRTIPOOP%TYPE;
  varPrgPattoLavoratore am_patto_lavoratore.prgPattoLavoratore%TYPE;
  varDatStimata or_percorso_concordato.DATSTIMATA%TYPE;
  varDatEffettiva or_percorso_concordato.DATEFFETTIVA%TYPE;
  varPrgAzioni or_percorso_concordato.PRGAZIONI%TYPE;
  varCodEsito or_percorso_concordato.CODESITO%TYPE;
  varStrNotePropostaOp or_percorso_concordato.STRNOTEPROPOSTAOP%TYPE;
  varStrNote or_percorso_concordato.STRNOTE%TYPE;
  varPrgPercorso or_percorso_concordato.PrgPercorso%TYPE;
  varPrgColloquio or_percorso_concordato.prgColloquio%TYPE;
  --
  varCODESITOAPPUNT  ag_agenda.CODESITOAPPUNT%TYPE;
  --varCDNUTMOD  ag_agenda.CDNUTMOD%TYPE;
  --varDTMMOD  ag_agenda.DTMMOD%TYPE;
  varNUMKLOAGENDA  ag_agenda.NUMKLOAGENDA%TYPE;
  varPRGAZIENDA  ag_agenda.PRGAZIENDA%TYPE;
  varPRGUNITA ag_agenda.PRGUNITA%TYPE;
  varCODCPI ag_agenda.CODCPI%TYPE;
  varPRGAPPUNTAMENTO ag_agenda.PRGAPPUNTAMENTO%TYPE;
  varDTMDATAORA ag_agenda.DTMDATAORA%TYPE;
  varNUMMINUTI ag_agenda.NUMMINUTI%TYPE;
  varCODSERVIZIO ag_agenda.CODSERVIZIO%TYPE;
  varPRGSPI ag_agenda.PRGSPI%TYPE;
  varTXTNOTE ag_agenda.TXTNOTE%TYPE;
  varPRGTIPOPRENOTAZIONE ag_agenda.PRGTIPOPRENOTAZIONE%TYPE;
  varSTRTELRIF ag_agenda.STRTELRIF%TYPE;
  varSTREMAILRIF ag_agenda.STREMAILRIF%TYPE;
  varSTRTELMOBILERIF ag_agenda.STRTELMOBILERIF%TYPE;
  varCODEFFETTOAPPUNT ag_agenda.CODEFFETTOAPPUNT%TYPE;
  varCODSTATOAPPUNTAMENTO ag_agenda.CODSTATOAPPUNTAMENTO%TYPE;
  varPRGAMBIENTE ag_agenda.PRGAPPUNTAMENTO%TYPE;
  varPRGSPIEFF ag_agenda.PRGSPIEFF%TYPE;
  varNUMORAFINEEFF ag_agenda.NUMORAFINEEFF%TYPE;
  varNUMORAINIZIOEFF ag_agenda.NUMORAINIZIOEFF%TYPE;
--
begin
  --
  parDtmUtMod := sysdate;
  --
 select apl.prgPattoLavoratore
 into varPrgPattoLavoratore
 from am_patto_lavoratore apl
 where apl.prgPattoLavoratore = parPrgPattoLavoratore
  and apl.codStatoAtto = 'PR'
  and apl.datFine is null;
 if (parCodLstTab = 'PR_MAN') then
  varStrTipoOp  := 'D';
  select man.prgMansione, man.codMansione, man.codMonoTempo, man.flgDispFormazione, man.flgDisponibile, man.flgEsperienza,
   man.flgEspForm, man.flgPip, man.cdnUtMod, man.dtmMod, man.cdnLavoratore
  into varPrgMansione, varCodMansione, varCodMonoTempo, varFlgDispFormazione, varFlgDisponibile, varFlgEsperienza,
   varFlgEspForm, varFlgPip, varCdnUtMod, varDtmMod, varCdnLavoratore
  from pr_mansione man
  where man.prgMansione = parStrChiaveTabella;
  --
  insert into md_am_patto_lav_pr_mans
   (prgMod,
   strTipoOp,
   prgMansione,
   cdnLavoratore,
   codMansione,
   flgEsperienza,
   flgEspForm,
   flgDisponibile,
   flgDispFormazione,
   flgPip,
   codMonoTempo,
   cdnUtMod,
   dtmMod
    )
  values (s_md_am_patto_lav_pr_mans.nextVal,
   varStrTipoOp,
   varPrgMansione,
   varCdnLavoratore,
   varCodMansione,
   varFlgEsperienza,
   varFlgEspForm,
   varFlgDisponibile,
   varFlgDispFormazione,
   varFlgPip,
   varCodMonoTempo,
   parCdnUtMod,
   parDtmUtMod
  );
 end if;
 if (parCodLstTab = 'OR_PER') then
  select per.datStimata, per.prgAzioni, per.PRGPERCORSO, per.PRGCOLLOQUIO, per.codEsito, per.DATEFFETTIVA, per.strNote, per.strNotePropostaOp,
   per.cdnUtMod, per.dtmMod
  into varDatStimata, varPrgAzioni, varPrgPercorso, varPrgColloquio, varCodEsito, varDatEffettiva ,varStrNote, varStrNotePropostaOp,
   varCdnUtMod, varDtmMod
  from or_percorso_concordato per
  where per.prgPercorso = parStrChiaveTabella;
  --
  varStrTipoOp := 'D';
  insert into md_am_patto_lav_or_perc
   (prgMod,
   strTipoOp,
   prgColloquio,
   prgPercorso,
   datStimata,
   prgAzioni,
   codEsito,
   datEffettiva,
   strNote,
   strNotePropostaOp,
   cdnUtMod,
   dtmMod
    )
  values (s_md_am_patto_lav_or_perc.nextVal,
   varStrTipoOp,
   varPrgColloquio,
   varPrgPercorso,
   varDatStimata,
   varPrgAzioni,
   varCodEsito,
   varDatEffettiva,
   varStrNote,
   varStrNotePropostaOp,
   parCdnUtMod,
   parDtmUtMod
  );

 end if;
 if (parCodLstTab = 'AG_LAV') then
  SELECT ag.CODCPI, ag.PRGAPPUNTAMENTO, ag.DTMDATAORA,
        ag.NUMMINUTI, ag.CODSERVIZIO, ag.PRGSPI, PRGSPIEFF,NUMORAFINEEFF,NUMORAINIZIOEFF,
        ag.TXTNOTE, ag.PRGTIPOPRENOTAZIONE, ag.STRTELRIF,
        ag.STREMAILRIF, ag.STRTELMOBILERIF, ag.CODEFFETTOAPPUNT,
     CODSTATOAPPUNTAMENTO, PRGAMBIENTE,
        ag.CODESITOAPPUNT, ag.CDNUTMOD, ag.DTMMOD,
        ag.NUMKLOAGENDA, ag.PRGAZIENDA, ag.PRGUNITA
  into varCODCPI, varPRGAPPUNTAMENTO, varDTMDATAORA,
        varNUMMINUTI, varCODSERVIZIO, varPRGSPI, varPRGSPIEFF,varNUMORAFINEEFF,varNUMORAINIZIOEFF,
        varTXTNOTE, varPRGTIPOPRENOTAZIONE, varSTRTELRIF,
        varSTREMAILRIF, varSTRTELMOBILERIF, varCODEFFETTOAPPUNT,
     varCODSTATOAPPUNTAMENTO,varPRGAMBIENTE,
        varCODESITOAPPUNT, varCDNUTMOD, varDTMMOD,
        varNUMKLOAGENDA, varPRGAZIENDA, varPRGUNITA
  FROM AG_AGENDA ag, ag_lavoratore agl
  where
   agl.cdnlavoratore = parStrChiaveTabella
   and agl.codCpi = parStrChiaveTabella2
   and agl.prgAppuntamento = parStrChiaveTabella3
   and agl.prgAppuntamento = ag.prgAppuntamento
   and agl.codCPI = ag.codCpi;
     --
  varStrTipoOp := 'D';
  --
  INSERT INTO MD_AM_PATTO_LAV_AG_AGENDA (
    prgMod,strTipoOp,
             CODCPI, PRGAPPUNTAMENTO, DTMDATAORA,
             NUMMINUTI, NUMORAINIZIOEFF, NUMORAFINEEFF,
             CODSERVIZIO, PRGSPI, PRGSPIEFF, PRGAMBIENTE,
             TXTNOTE, PRGTIPOPRENOTAZIONE, STRTELRIF,
             STREMAILRIF, STRTELMOBILERIF, CODEFFETTOAPPUNT,
             CODESITOAPPUNT, CODSTATOAPPUNTAMENTO, CDNUTMOD, DTMMOD)
        VALUES ( s_md_am_patto_lav_ag_agenda.nextVal,
   varStrTipoOp,
   varCODCPI, varPRGAPPUNTAMENTO, varDTMDATAORA,
            varNUMMINUTI, varNUMORAINIZIOEFF, varNUMORAFINEEFF,
            varCODSERVIZIO, varPRGSPI, varPRGSPIEFF, varPRGAMBIENTE,
            varTXTNOTE, varPRGTIPOPRENOTAZIONE, varSTRTELRIF,
            varSTREMAILRIF, varSTRTELMOBILERIF, varCODEFFETTOAPPUNT,
            varCODESITOAPPUNT, varCODSTATOAPPUNTAMENTO, parCdnUtMod,parDtmUtMod);
 end if;

exception
 when no_data_found then
  null;
end;


procedure tracciaModAgendaAssPattoLav(
         parCodServizio in AG_AGENDA.CODSERVIZIO%TYPE,
         parDtmDataOra in AG_AGENDA.DTMDATAORA%TYPE,
         parCodCpi in AG_AGENDA.CODCPI%TYPE,
         parPrgAppuntamento in AG_AGENDA.PRGAPPUNTAMENTO%TYPE,
         parOldCODSERVIZIO ag_agenda.CODSERVIZIO%TYPE,
         parOldDTMDATAORA ag_agenda.DTMDATAORA%TYPE,
         parOldCODCPI ag_agenda.CODCPI%TYPE,
         parOldPRGAPPUNTAMENTO ag_agenda.PRGAPPUNTAMENTO%TYPE,
         parOldCODESITOAPPUNT  ag_agenda.CODESITOAPPUNT%TYPE,
         parOldNUMKLOAGENDA  ag_agenda.NUMKLOAGENDA%TYPE,
         parOldPRGAZIENDA  ag_agenda.PRGAZIENDA%TYPE,
         parOldPRGUNITA ag_agenda.PRGUNITA%TYPE,
         parOldNUMMINUTI ag_agenda.NUMMINUTI%TYPE,
         parOldPRGSPI ag_agenda.PRGSPI%TYPE,
         parOldTXTNOTE ag_agenda.TXTNOTE%TYPE,
         parOldPRGTIPOPRENOTAZIONE ag_agenda.PRGTIPOPRENOTAZIONE%TYPE,
         parOldSTRTELRIF ag_agenda.STRTELRIF%TYPE,
         parOldSTREMAILRIF ag_agenda.STREMAILRIF%TYPE,
         parOldSTRTELMOBILERIF ag_agenda.STRTELMOBILERIF%TYPE,
         parOldCODEFFETTOAPPUNT ag_agenda.CODEFFETTOAPPUNT%TYPE,
         parOldCODSTATOAPPUNTAMENTO ag_agenda.CODSTATOAPPUNTAMENTO%TYPE,
         parOldPRGAMBIENTE ag_agenda.PRGAPPUNTAMENTO%TYPE,
         parOldPRGSPIEFF ag_agenda.PRGSPIEFF%TYPE,
         parOldNUMORAFINEEFF ag_agenda.NUMORAFINEEFF%TYPE,
         parOldNUMORAINIZIOEFF ag_agenda.NUMORAINIZIOEFF%TYPE,
         parCdnUtMod pr_mansione.cdnUtMod%TYPE,
         parDtmMod pr_mansione.dtmMod%TYPE
 ) is

 varStrTipoOp md_am_patto_lav_pr_mans.STRTIPOOP%TYPE;
 varPrgLavPattoScelta am_lav_patto_scelta.prgLavPattoScelta%TYPE;
 begin
    -- se viene trovato un record si controlla che siano cambiati i valori
 if (parCodServizio<>parOldCODSERVIZIO or parDtmDataOra<>parOldDTMDATAORA) then
    if (parCodServizio <> parOldCodServizio ) then
        varStrTipoOp := 'US';
     --
            INSERT INTO MD_AM_PATTO_LAV_AG_AGENDA (
     prgMod,strTipoOp,
              CODCPI, PRGAPPUNTAMENTO, DTMDATAORA,
              NUMMINUTI, NUMORAINIZIOEFF, NUMORAFINEEFF,
              CODSERVIZIO, PRGSPI, PRGSPIEFF, PRGAMBIENTE,
              TXTNOTE, PRGTIPOPRENOTAZIONE, STRTELRIF,
              STREMAILRIF, STRTELMOBILERIF, CODEFFETTOAPPUNT,
              CODESITOAPPUNT, CODSTATOAPPUNTAMENTO, CDNUTMOD, DTMMOD)
         VALUES ( s_md_am_patto_lav_ag_agenda.nextVal,
    varStrTipoOp,
    parOldCODCPI, parOldPRGAPPUNTAMENTO, parOldDTMDATAORA,
             parOldNUMMINUTI, parOldNUMORAINIZIOEFF, parOldNUMORAFINEEFF,
             parOldCODSERVIZIO, parOldPRGSPI, parOldPRGSPIEFF, parOldPRGAMBIENTE,
             parOldTXTNOTE, parOldPRGTIPOPRENOTAZIONE, parOldSTRTELRIF,
             parOldSTREMAILRIF, parOldSTRTELMOBILERIF, parOldCODEFFETTOAPPUNT,
             parOldCODESITOAPPUNT, parOldCODSTATOAPPUNTAMENTO, parCdnUtMod, parDtmMod);
    end if;
    if (parDtmDataOra <> parOldDtmDataOra ) then
        varStrTipoOp := 'UD';
     --
            INSERT INTO MD_AM_PATTO_LAV_AG_AGENDA (
     prgMod,strTipoOp,
              CODCPI, PRGAPPUNTAMENTO, DTMDATAORA,
              NUMMINUTI, NUMORAINIZIOEFF, NUMORAFINEEFF,
              CODSERVIZIO, PRGSPI, PRGSPIEFF, PRGAMBIENTE,
              TXTNOTE, PRGTIPOPRENOTAZIONE, STRTELRIF,
              STREMAILRIF, STRTELMOBILERIF, CODEFFETTOAPPUNT,
              CODESITOAPPUNT, CODSTATOAPPUNTAMENTO, CDNUTMOD, DTMMOD)
         VALUES ( s_md_am_patto_lav_ag_agenda.nextVal,
    varStrTipoOp,
    parOldCODCPI, parOldPRGAPPUNTAMENTO, parOldDTMDATAORA,
             parOldNUMMINUTI, parOldNUMORAINIZIOEFF, parOldNUMORAFINEEFF,
             parOldCODSERVIZIO, parOldPRGSPI, parOldPRGSPIEFF, parOldPRGAMBIENTE,
             parOldTXTNOTE, parOldPRGTIPOPRENOTAZIONE, parOldSTRTELRIF,
             parOldSTREMAILRIF, parOldSTRTELMOBILERIF, parOldCODEFFETTOAPPUNT,
             parOldCODESITOAPPUNT, parOldCODSTATOAPPUNTAMENTO, parCdnUtMod, parDtmMod);
    end if;
    -- aggiorno il campo am_lav_patto_scelta.datProtocollo a null
       update am_lav_patto_scelta alps
    set alps.DATPROTOCOLLO = null
    where alps.PRGLAVPATTOSCELTA in (
	 SELECT distinct alps.PRGLAVPATTOSCELTA
	 FROM ag_lavoratore agl, am_lav_patto_scelta alps, am_patto_lavoratore apl
	 where
	  alps.codLstTab = 'AG_LAV'
	  and agl.cdnlavoratore = alps.strChiaveTabella
	  and agl.codCpi = alps.strChiaveTabella2
	  and agl.prgAppuntamento = alps.strChiaveTabella3
	  and agl.codCPI = parCodCpi
	  and agl.prgAppuntamento = parPrgAppuntamento
	  and apl.prgPattoLavoratore = alps.prgPattoLavoratore
	  and apl.datFine is null
	  and apl.codStatoAtto = 'PR');

 end if;
exception
    when no_data_found then
     null;
end;

procedure checkIntervalloDate (datParDatInizio in AM_ELENCO_ANAGRAFICO.DATINIZIO%TYPE, datParDatCan in AM_ELENCO_ANAGRAFICO.DATCAN%TYPE)
IS
begin
--   if ((datParDatInizio is not null) and  (datParDatCan is not null) and ( datParDatInizio > datParDatCan ))
   if ((datParDatInizio is not null) and  (datParDatCan is not null) and (trunc(datParDatInizio) > trunc (datParDatCan)))
   then
     begin
    raise_application_error (-20013, 'Data fine maggiore della data inizio.');
     end;
   end if;
end;

FUNCTION GET_SES_DA_CODFIS(inputCF IN VARCHAR2) RETURN VARCHAR2
IS
BEGIN
 IF inputCF IS NULL THEN
    RETURN NULL;
 ELSIF GREATEST( TO_NUMBER(SUBSTR(inputCF,10,1)) ,3) = 3 THEN
    RETURN 'M';
 ELSE
    RETURN 'F';
 END IF;

 EXCEPTION
  WHEN OTHERS THEN
   RETURN NULL;
END GET_SES_DA_CODFIS;


FUNCTION GET_CODCPI_LAV(inputCndLavoratore IN AN_LAVORATORE.CDNLAVORATORE%TYPE,
      inputDatInizioMov IN AM_MOVIMENTO.DATINIZIOMOV%TYPE,
      inputDatFineMov IN AM_MOVIMENTO.DATFINEMOV%TYPE) RETURN VARCHAR2
IS
   codCpi VARCHAR2(20);
BEGIN
 BEGIN
  SELECT DECODE(LAVSTO.CODMONOTIPOCPI,'C',LAVSTO.CODCPITIT,'E',LAVSTO.CODCPITIT,'T',LAVSTO.CODCPIORIG) into codCpi
  FROM AN_LAV_STORIA_INF LAVSTO
  WHERE LAVSTO.CDNLAVORATORE   = inputCndLavoratore
     AND  inputDatInizioMov >=  LAVSTO.DATINIZIO
  AND  (DECODE(LAVSTO.DATFINE, NULL, 'S','N') = 'S' OR
     inputDatFineMov <=  LAVSTO.DATFINE);
    exception
      when no_data_found then
     codCpi := null;
 END;
 RETURN codCpi;
END GET_CODCPI_LAV;


FUNCTION GET_DATNAS_DA_CODFIS(inputCF IN VARCHAR2) RETURN DATE
IS
    dataStr VARCHAR2(20) := '';
    data    DATE;
    tmpGio  NUMBER;
    tmpMese VARCHAR2(2);
 tmpAnno VARCHAR2(4);
BEGIN
 IF inputCF IS NULL THEN
    RETURN NULL;
 ELSE
  -- A) recupero il giorno (con controllo sul sesso)
  tmpGio := TO_NUMBER(SUBSTR(inputCF,10,2));
  IF tmpGio >= 40 THEN
     tmpGio := tmpGio - 40;
  END IF;
  dataStr := dataStr || TO_CHAR(tmpGio, '09') || '/';

  -- B) recupero il mese
  tmpMese := SUBSTR(inputCF,9,1);
  IF    tmpMese = 'A' THEN tmpMese := '01';
  ELSIF tmpMese = 'B' THEN tmpMese := '02';
  ELSIF tmpMese = 'C' THEN tmpMese := '03';
  ELSIF tmpMese = 'D' THEN tmpMese := '04';
  ELSIF tmpMese = 'E' THEN tmpMese := '05';
  ELSIF tmpMese = 'H' THEN tmpMese := '06';
  ELSIF tmpMese = 'L' THEN tmpMese := '07';
  ELSIF tmpMese = 'M' THEN tmpMese := '08';
  ELSIF tmpMese = 'P' THEN tmpMese := '09';
  ELSIF tmpMese = 'R' THEN tmpMese := '10';
  ELSIF tmpMese = 'S' THEN tmpMese := '11';
  ELSIF tmpMese = 'T' THEN tmpMese := '12';
  ELSE                     tmpMese := '01';
  END IF;
  dataStr := dataStr || tmpMese || '/';

  -- C) recupero l'anno
  tmpAnno := SUBSTR(inputCF,7,2);
  /* FORSE DEVO DISTINGUERE, MA ORA NO:
  IF TO_NUMBER(tmpAnno) < 20 THEN
   tmpAnno := '20' || tmpAnno;
  ELSE
   tmpAnno := '19' || tmpAnno;
  END IF;
  */
  tmpAnno := '19' || tmpAnno;
  dataStr := dataStr || tmpAnno;

  -- D) converto la stringa in una data e la rendo.
  data := TO_DATE(dataStr, 'DD/MM/YYYY');
  RETURN data;
 END IF;

 EXCEPTION
  WHEN OTHERS THEN
   RETURN NULL;
END GET_DATNAS_DA_CODFIS;



/* PRIVATA */
PROCEDURE DECODIFICA_CODICI_STAMPA(inputIdSessione IN VARCHAR)
IS
BEGIN
 UPDATE AM_REP_MOVIMENTI_APPOGGIO X
 SET
        /* CPI */
            REFID             = DECODE(X.REFID,   NULL,NULL, (SELECT C.CODCPI FROM DE_COMUNE C WHERE C.CODCOM = X.REFID) ),
     /* COMUNI */
         AZIUNICOM_DESC    = DECODE(X.AZIUNICOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.AZIUNICOM) ),
      AZISEDCOM_DESC    = DECODE(X.AZISEDCOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.AZISEDCOM) ),
      LAVNASCOM_DESC    = DECODE(X.LAVNASCOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.LAVNASCOM) ),
         LAVRESCOM_DESC    = DECODE(X.LAVRESCOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.LAVRESCOM) ),
   LAVDOMCOM_DESC    = DECODE(X.LAVDOMCOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.LAVDOMCOM) ),
   AZIUTICOM_DESC    = DECODE(X.AZIUTICOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.AZIUTICOM) ),
   AZIUTISEDCOM_DESC = DECODE(X.AZIUTISEDCOM,NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.AZIUTISEDCOM) ),
     /* PROVINCE */
         AZIUNICOM_PROV    = DECODE(X.AZIUNICOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.AZIUNICOM) ),
      AZISEDCOM_PROV    = DECODE(X.AZISEDCOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.AZISEDCOM) ),
      LAVNASCOM_PROV    = DECODE(X.LAVNASCOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.LAVNASCOM) ),
         LAVRESCOM_PROV    = DECODE(X.LAVRESCOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.LAVRESCOM) ),
   LAVDOMCOM_PROV    = DECODE(X.LAVDOMCOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.LAVDOMCOM) ),
      AZIUTICOM_PROV    = DECODE(X.AZIUTICOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.AZIUTICOM) ),
   AZIUTISEDCOM_PROV = DECODE(X.AZIUTISEDCOM,NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.AZIUTISEDCOM) ),
     /* QUALIFICHE */
   AVVQUA_DESC       = DECODE(X.AVVQUA,     NULL,NULL, (SELECT Q.STRDESCRIZIONE FROM DE_MANSIONE Q WHERE Q.CODMANSIONE = X.AVVQUA) ),
   CESQUA_DESC       = DECODE(X.CESQUA,     NULL,NULL, (SELECT Q.STRDESCRIZIONE FROM DE_MANSIONE Q WHERE Q.CODMANSIONE = X.CESQUA) ),
   PTRNUOQUA_DESC    = DECODE(X.PTRNUOQUA,  NULL,NULL, (SELECT Q.STRDESCRIZIONE FROM DE_MANSIONE Q WHERE Q.CODMANSIONE = X.PTRNUOQUA) ),
   APPTUTQUA_DESC    = DECODE(X.APPTUTQUA,  NULL,NULL, (SELECT Q.STRDESCRIZIONE FROM DE_MANSIONE Q WHERE Q.CODMANSIONE = X.APPTUTQUA) ),
     /* GRADI */
   AVVGRA_DESC       = DECODE(X.AVVGRA,     NULL,NULL, (SELECT G.STRDESCRIZIONE FROM DE_MV_GRADO G WHERE G.CODGRADO = X.AVVGRA) ),
   CESGRA_DESC       = DECODE(X.CESGRA,     NULL,NULL, (SELECT G.STRDESCRIZIONE FROM DE_MV_GRADO G WHERE G.CODGRADO = X.CESGRA) ),
   PTRNUOGRA_DESC    = DECODE(X.PTRNUOGRA,  NULL,NULL, (SELECT G.STRDESCRIZIONE FROM DE_MV_GRADO G WHERE G.CODGRADO = X.PTRNUOGRA) ),
     /* TIPO DI ASSUNZIONE  */
   AVVTIPASS_DESC    = DECODE(X.AVVTIPASS,  NULL,NULL, (SELECT A.STRDESCRIZIONE FROM DE_TIPO_CONTRATTO A WHERE A.CODTIPOCONTRATTO = X.AVVTIPASS) ),
   TRATIPASS_DESC    = DECODE(X.TRATIPASS,  NULL,NULL, (SELECT A.STRDESCRIZIONE FROM DE_TIPO_CONTRATTO A WHERE A.CODTIPOCONTRATTO = X.TRATIPASS) ),
   /* TIPO TRASFORMAZIONE */
   AVVTIPOTRASF_DESC = DECODE(X.AVVTIPOTRASF,  NULL,NULL, (SELECT T.STRDESCRIZIONE FROM DE_TIPO_TRASF T WHERE T.CODTIPOTRASF = X.AVVTIPOTRASF) ),
     /* TIPO DI ORARIO DI LAVORO */
   AVVTIPORA_DESC    = DECODE(X.AVVTIPORA,  NULL,NULL, (SELECT O.STRDESCRIZIONE FROM DE_ORARIO O WHERE O.CODORARIO = X.AVVTIPORA) ),
   TRATIPORA_DESC    = DECODE(X.TRATIPORA,  NULL,NULL, (SELECT O.STRDESCRIZIONE FROM DE_ORARIO O WHERE O.CODORARIO = X.TRATIPORA) ),
     /* AGEVOLAZIONE */
   AVVBEN_DESC       = DECODE(X.AVVBEN,     NULL,NULL, (SELECT B.STRDESCRIZIONE FROM DE_AGEVOLAZIONE B WHERE B.CODAGEVOLAZIONE = X.AVVBEN) ),
   PTRNUOBEN_DESC    = DECODE(X.PTRNUOBEN,  NULL,NULL, (SELECT B.STRDESCRIZIONE FROM DE_AGEVOLAZIONE B WHERE B.CODAGEVOLAZIONE = X.PTRNUOBEN) ),
     /* CCNL */
   AZIUNICCNL_DESC   = DECODE(X.AZIUNICCNL, NULL,NULL, (SELECT C.STRDESCRIZIONE FROM DE_CONTRATTO_COLLETTIVO C WHERE C.CODCCNL = X.AZIUNICCNL) ),
   AVVCCNL_DESC      = DECODE(X.AVVCCNL,    NULL,NULL, (SELECT C.STRDESCRIZIONE FROM DE_CONTRATTO_COLLETTIVO C WHERE C.CODCCNL = X.AVVCCNL) ),
   PTRNUOCCNL_DESC   = DECODE(X.PTRNUOCCNL, NULL,NULL, (SELECT C.STRDESCRIZIONE FROM DE_CONTRATTO_COLLETTIVO C WHERE C.CODCCNL = X.PTRNUOCCNL) ),
     /* ALTRE DECODIFICHE */
   CODTIPOMOV_DESC   = DECODE(X.CODTIPOMOV, NULL,NULL, (SELECT M.STRDESCRIZIONE FROM DE_MV_TIPO_MOV M WHERE M.CODTIPOMOV= X.CODTIPOMOV) ),
   LAVTITSTUD_DESC = DECODE(X.PRGMOVIMENTO, NULL,NULL, (SELECT T.DESCRIZIONE FROM MN_TITOLO_L1 T, AM_MOVIMENTO AM WHERE T.CODICE = AM.CODTITOLO and AM.PRGMOVIMENTO = X.PRGMOVIMENTO) ),
   LAVCIT_DESC       = DECODE(X.LAVCIT,     NULL,NULL, (SELECT C.STRDESCRIZIONE FROM DE_CITTADINANZA C WHERE C.CODCITTADINANZA = X.LAVCIT) ),
   AVVNOR_DESC       = DECODE(X.AVVNOR,     NULL,NULL, (SELECT N.STRDESCRIZIONE FROM DE_NORMATIVA N WHERE N.CODNORMATIVA = X.AVVNOR) ),
   CESMOT_DESC       = DECODE(X.CESMOT,     NULL,NULL, (SELECT M.STRDESCRIZIONE FROM DE_MV_CESSAZIONE M WHERE M.CODMVCESSAZIONE = X.CESMOT) ),
   LAVPSMOT_DESC     = DECODE(X.LAVPSMOT,   NULL,NULL, (SELECT E.STRDESCRIZIONE FROM DE_EX_MOTIVO_RIL E WHERE E.CODMOTIVORIL = X.LAVPSMOT) ),
   PRORIF_DESC       = DECODE(X.PRORIF,     NULL,NULL, (SELECT D.STRDESCRIZIONE FROM DE_DOC_TIPO D WHERE D.CODTIPODOCUMENTO = X.PRORIF) ),
  /* CODICE ATECO'02: se il codice ateco NON e' scaduto stampa la stringa 'ATE02', altrimenti mette NULL */
   AZIUNICODATT_ATE02 = (SELECT DECODE(SIGN(A.DATFINEVAL - TRUNC(SYSDATE)), -1, NULL, 'ATE02') FROM DE_ATTIVITA A WHERE A.CODATECO = X.AZIUNICODATT),
   LAVEXCODSTATUS_DESC = DECODE(X.LAVEXCODSTATUS, NULL, NULL, (SELECT S.STRDESCRIZIONE FROM DE_STATUS_STRANIERO S WHERE S.CODSTATUS = X.LAVEXCODSTATUS)),
     /* DECODIFICHE VIA SOFTWARE */
   APPTUTSES         = GET_SES_DA_CODFIS(X.APPTUTCODFIS),
   APPTUTNASDAT      = GET_DATNAS_DA_CODFIS(X.APPTUTCODFIS)
 WHERE TRIM(X.IDSESSIONE) = TRIM(inputIdSessione);

 EXCEPTION
 WHEN OTHERS THEN
  DBMS_OUTPUT.PUT_LINE('Error code: ' || SQLCODE);
  DBMS_OUTPUT.PUT_LINE('Error mesg: ' || SUBSTR(SQLERRM,1,100));

END DECODIFICA_CODICI_STAMPA;


FUNCTION RECUPERA_MOV_AVV_PREC(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
            RETURN AM_MOVIMENTO%ROWTYPE
IS
 rowMov AM_MOVIMENTO%ROWTYPE;
 prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
BEGIN

 -- Continuo a recuperare il record del movimento precedente finche' non trovo quello con 'AVV' (o non ce l'ho).
 prgMovCiclo := prgMov;
 LOOP

  IF prgMovCiclo IS NULL THEN
     EXIT;
  END IF;

  -- Recupero il record relativo al prgMovimento in ingresso
  SELECT MOV.*
  INTO rowMov
  FROM AM_MOVIMENTO MOV
  WHERE MOV.PRGMOVIMENTO = prgMovCiclo;

  -- Se non trovato, esco dal ciclo
  EXIT WHEN SQL%NOTFOUND;

  -- Se ho trovato il movimento con 'AVV', rendo il record
  IF rowMov.CODTIPOMOV = 'AVV' THEN
   RETURN rowMov;
  END IF;

  -- Continuo a ciclare (passo al movimento precedente)
  prgMovCiclo := rowMov.PRGMOVIMENTOPREC;

 END LOOP;

 RETURN NULL;

END RECUPERA_MOV_AVV_PREC;


/* PRIVATA */
PROCEDURE AGGIORNA_MOV_APP_NON_AVV(inputIdSessione IN VARCHAR)
IS
    CURSOR movInAppNonAvvCursor IS
        SELECT X.PRGMOVIMENTO, X.PRGMOVIMENTOPREC
        FROM AM_REP_MOVIMENTI_APPOGGIO X
        WHERE trim(X.Idsessione) = trim(inputIdSessione)
  AND   X.CODTIPOMOV <> 'AVV';

 prgMov     AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
 prgMovPrec AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
 rowMovAvv  AM_MOVIMENTO%ROWTYPE;
BEGIN

 FOR movInAppNonAvv IN movInAppNonAvvCursor LOOP

  -- a) ottengo il progressivo del movimento precedente (dal record nella tabella di appoggio).
  prgMov     := movInAppNonAvv.PRGMOVIMENTO;
  prgMovPrec := movInAppNonAvv.PRGMOVIMENTOPREC;

  -- b) ottengo l'intero record del movimento di 'AVV' precedente (se esiste).
  rowMovAvv := RECUPERA_MOV_AVV_PREC(prgMovPrec);

  -- c) aggiorno i campi della tab. di appoggio relativi della parte di "avviamento" del record in esame.
  --    nota: se non ho trovato il record di avviamento (che è possibile), i campi verranno "sbiancati".
  --    per questo motivo faccio due 'update': quella condizionata permette di non sbiancare i campi
  --    che so essere INVARIANTI tra movimenti successivi.
  UPDATE AM_REP_MOVIMENTI_APPOGGIO X
  SET
    PRGMOVIMENTOAVV = rowMovAvv.PRGMOVIMENTO,
   /* avviamento */
     AVVTEM = rowMovAvv.CODMONOTEMPO,
    AVVTIPORA = rowMovAvv.CODORARIO,
    AVVTIPORA_FP = DECODE(rowMovAvv.CODORARIO, NULL,NULL, 'F','F', 'P'),
    AVVTEMINDETDATAVV = DECODE(rowMovAvv.CODMONOTEMPO, 'I', rowMovAvv.DATINIZIOAVV, NULL),
    AVVTEMDETDATAVV   = DECODE(rowMovAvv.CODMONOTEMPO, 'D', rowMovAvv.DATINIZIOAVV, NULL),
    AVVLUO = rowMovAvv.STRLUOGODILAVORO,
    AVVNOR = rowMovAvv.CODNORMATIVA,
    AVVCOM = DECODE(rowMovAvv.FLGLEGGE68, 'S', 'X',NULL),
    AVVFT = DECODE(rowMovAvv.CODORARIO, 'F', 'X',NULL),
    AVVPT = DECODE(rowMovAvv.CODORARIO, 'M', 'X', 'V', 'X', 'P', 'X', NULL),
    AVVTEMDETDATCES = rowMovAvv.DATFINEMOV,
    AVVGIOAGRPRE = rowMovAvv.NUMGGPREVISTIAGR,
    AVVGIOAGREFF = rowMovAvv.NUMGGEFFETTUATIAGR,
    AVVPTORAMEDSET = rowMovAvv.NUMORESETT,
    AVVQUA = rowMovAvv.CODMANSIONE,
    AVVGRA = rowMovAvv.CODGRADO,
    AVVLIV = rowMovAvv.NUMLIVELLO,
    AVVRETLORMEN = rowMovAvv.DECRETRIBUZIONEMEN,
    AVVBEN = rowMovAvv.CODAGEVOLAZIONE
  WHERE X.PRGMOVIMENTO = prgMov
  AND   trim(X.Idsessione) = trim(inputidsessione);    /* questo AND lo aggiungo solo per sicurezza */

  IF rowMovAvv.PRGMOVIMENTO IS NOT NULL THEN
   UPDATE AM_REP_MOVIMENTI_APPOGGIO  X
   SET
    AVVNUMMAT = rowMovAvv.STRMATRICOLA,
    AVVDATAVV = rowMovAvv.DATINIZIOAVV,
    AVVTIPASS = rowMovAvv.CODTIPOCONTRATTO,
    AVVCCNL   = rowMovAvv.CODCCNL
   WHERE X.PRGMOVIMENTO = prgMov
   AND   trim(X.Idsessione) = trim(inputidsessione);
  END IF;

 END LOOP;

END AGGIORNA_MOV_APP_NON_AVV;


PROCEDURE SET_INFO_PROTOCOLLO (inputIdSessione IN VARCHAR, inputPrgMovimento IN number)
IS
  prgDoc NUMBER;
BEGIN
  BEGIN
  SELECT DOC.Prgdocumento into prgDoc
  FROM AM_DOCUMENTO DOC
  WHERE (DOC.NUMPROTOCOLLO,DOC.Prgdocumento) in
    (SELECT MAX(DOC2.NUMPROTOCOLLO),MAX(DOC2.PRGDOCUMENTO)
    FROM AM_DOCUMENTO_COLL COLL , AM_DOCUMENTO DOC2
    WHERE     COLL.PRGDOCUMENTO = DOC2.PRGDOCUMENTO
          AND COLL.STRCHIAVETABELLA IS NOT NULL
          AND COLL.STRCHIAVETABELLA = TO_CHAR(inputPrgMovimento)
          AND COLL.CDNCOMPONENTE = 236);
  EXCEPTION
  when no_data_found then
    null;
  when others then
    raise;
  END;

  if (prgDoc is not null) then
    BEGIN
    UPDATE AM_REP_MOVIMENTI_APPOGGIO APP
    SET (APP.PROANNO,APP.PRONUM,APP.PRODATA,APP.PRORIF,APP.PRODOC) =
         (SELECT  NUMANNOPROT, NUMPROTOCOLLO, DATPROTOCOLLO,
                 CODTIPODOCUMENTO, DECODE (CODMONOIO,'I','Input','O','Output')
         FROM  AM_REP_MOVIMENTI_APPOGGIO APP2, AM_DOCUMENTO DOC
         WHERE     APP2.PRGMOVIMENTO = inputprgmovimento
               AND TRIM(APP2.IDSESSIONE) = TRIM(inputIdSessione)
               AND DOC.PRGDOCUMENTO = prgDoc)
    WHERE     TRIM(APP.IDSESSIONE) = TRIM(inputIdSessione)
          AND APP.PRGMOVIMENTO = inputprgmovimento;
    EXCEPTION
    when others then
      raise; --propago l'errore
    END;
  END IF;
END SET_INFO_PROTOCOLLO;


PROCEDURE SCRIVI_MOV_IN_APP(inputPrgMovimento IN INT_ARRAY,
       inputIdSessione IN VARCHAR2)
IS
 numScritti NUMBER;
BEGIN

  /* PASSO 1: IMPORTO I RECORD (SENZA DECODIFICA DEI CODICI) NELLA TABELLA DI APPOGGIO */

  for i in 1 .. inputPrgMovimento.count
    loop

 INSERT INTO AM_REP_MOVIMENTI_APPOGGIO
          (
        CODCPI,
      PRGMOVIMENTO,
      CODTIPOMOV,
      PRGMOVIMENTOPREC,
      PRGMOVIMENTOAVV,
      DTMINSMOD,
      CODMONOTIPOCPI,
      REFID,
      REFDATINV,
      REFMIT,
      EVECOD,
      EVEDAT,
      AZICODFISC,
      AZIUNIPARIVA,
      AZIUNIRAGSOC,
      AZIUNIIND,
      AZIUNICAP,
      AZIUNICOM,
      AZIUNITEL,
      AZIUNIFAX,
      AZIUNIMAIL,
      AZIUNICODATT,
      AZIUNICCNL,
      AZIUNINUMDIP,
      AZIUNIINPS,
      AZIUNINUMREGCODDOM,
      AZIUNINUMALBINT,
      AZIINAIL,
      AZITIPOAZIENDA,
      AZISEDRAGSOC,
      AZISEDIND,
      AZISEDCAP,
      AZISEDCOM,
      AZISEDTEL,
      AZISEDFAX,
      AZISEDMAIL,
      LAVCODFIS,
      LAVCOGNOME,
      LAVNOME,
      LAVDATNAS,
      LAVSES,
      LAVNASCOM,
      LAVCIT,
      LAVRESCOM,
      LAVRESIND,
      LAVRESCAP,
      LAVDOMCOM,
      LAVDOMIND,
      LAVDOMCAP,
      LAVPSSCAD,
      LAVPSMOT,
      LAVEXCODSTATUS,
      LAVTITSTUD,
      LAVCONIUG,
      LAVSCICA,
      AZIUTICODFISC,
      AZIUTIPARIVA,
      AZIUTIRAGSOC,
      AZIUTICODTIP,
      AZIUTIARTIGIANA,
      AZIUTIIND,
      AZIUTICAP,
      AZIUTICOM,
      AZIUTICODATT,
      AZIUTINUMDIP,
      AZIUTICNTNUM,
      AZIUTICNTDATINI,
      AZIUTICNTDATFIN,
      AZIUTITOTSOGINT,
      AZIUTIINPS,
      AZIUTIINAIL,
      AZIUTISEDIND,
      AZIUTISEDCAP,
      AZIUTISEDCOM,
      AZIUTISEDTEL,
      AZIUTISEDFAX,
      AZIUTISEDMAIL,
      AVVNUMMAT,
      AVVDATAVV,
      AVVTEM,
      AVVTEMINDETDATAVV,
      AVVTEMDETDATAVV,
      AVVLUO,
      AVVTIPASS,
      AVVINTPRO,
      AVVTIPOTRASF,
      AVVNOR,
      AVVCOM,
      AVVNUMCONV,
      AVVDATACONV,
      AVVTIPORA,
      AVVTIPORA_FP,
      AVVFT,
      AVVPT,
      AVVTEMDETDATCES,
      AVVGIOAGRPRE,
      AVVGIOAGREFF,
      AVVPTORAMEDSET,
      AVVQUA,
      AVVGRA,
      AVVLIV,
      AVVCCNL,
      AVVRETLORMEN,
      AVVRETLORSAN,
      AVVBEN,
      AVVTIPOLOGIA,
      CESDAT,
      CESMOT,
      CESQUA,
      CESGRA,
      CESLIV,
      PTRNUOQUA,
      PTRNUOGRA,
      PTRNUOLIV,
      PTRNUOCCNL,
      PTRNUOBEN,
      PRODATINI,
      PRODATFIN,
      TRADAT,
      TRANUOTEM,
      TRANUOTEMINDET,
      TRANUOTEMDET,
      TRANUOPTORAMEDSET,
      TRATIPASS,
      TRATIPORA,
      TRATIPORA_FP,
      APPNUMMESI,
      APPTUTCODFIS,
      APPTUTCOGNOME,
      APPTUTNOME,
      APPTUTESPLAVANNI,
      APPTUTTITIMP,
      APPTUTLIVINQ,
      APPTUTQUA,
      APPARTIG,
      IDSESSIONE,
      IDRIGA,
      CODSTATOATTO,
      DATFINEPF,
	  FLGLAVOROINMOBILITA,
	  FLGLAVOROSTAGIONALE,
	  FLGLAVOROAGR,
	  FLGPROSECUZIONE,
	  CODVARIAZIONE)
    SELECT /* codice cpi */
            CODCPI,
     /* chiave del record in esame */
      PRGMOVIMENTO,
      CODTIPOMOV,
     /* riferimento al movimento temporalmente precedente */
      PRGMOVIMENTOPREC,
      PRGMOVIMENTOAVV,
     /* vari */
      DTMINSMOD,
      CODMONOTIPOCPI, -- Questo campo non viene utilizzato nella stampa
     /* referente / invio */
      REFID,
      REFDATINV,
      REFMIT,
     /* evento */
      EVECOD,
      EVEDAT,
     /* unita produttiva */
      AZICODFISC,
      AZIUNIPARIVA,
      AZIUNIRAGSOC,
      AZIUNIIND,
      AZIUNICAP,
      AZIUNICOM,
      AZIUNITEL,
      AZIUNIFAX,
      AZIUNIMAIL,
      AZIUNICODATT,
      AZIUNICCNL,
      AZIUNINUMDIP,
      AZIUNIINPS,
      AZIUNINUMREGCODDOM,
      AZIUNINUMALBINT,
      AZIINAIL,
      AZITIPOAZIENDA,
     /* sede legale (se presente) */
      AZISEDRAGSOC,
      AZISEDIND,
      AZISEDCAP,
      AZISEDCOM,
      AZISEDTEL,
      AZISEDFAX,
      AZISEDMAIL,
     /* lavoratore */
      LAVCODFIS,
      LAVCOGNOME,
      LAVNOME,
      LAVDATNAS,
      LAVSES,
      LAVNASCOM,
      LAVCIT,
      LAVRESCOM,
      LAVRESIND,
      LAVRESCAP,
      LAVDOMCOM,
      LAVDOMIND,
      LAVDOMCAP,
      LAVPSSCAD,
      LAVPSMOT,
      LAVEXCODSTATUS,
      LAVTITSTUD,
      LAVCONIUG,
      LAVSCICA,
     /* azienda utilizz. */
      AZIUTICODFISC,
      AZIUTIPARIVA,
      AZIUTIRAGSOC,
      AZIUTICODTIP,
      AZIUTIARTIGIANA,
      AZIUTIIND,
      AZIUTICAP,
      AZIUTICOM,
      AZIUTICODATT,
      AZIUTINUMDIP,
      AZIUTICNTNUM,
      AZIUTICNTDATINI,
      AZIUTICNTDATFIN,
      AZIUTITOTSOGINT,
      AZIUTIINPS,
      AZIUTIINAIL,
      AZIUTISEDIND,
      AZIUTISEDCAP,
      AZIUTISEDCOM,
      AZIUTISEDTEL,
      AZIUTISEDFAX,
      AZIUTISEDMAIL,
     /* avviamento */
      AVVNUMMAT,
      AVVDATAVV,
      AVVTEM,
      AVVTEMINDETDATAVV,
      AVVTEMDETDATAVV,
      AVVLUO,
      AVVTIPASS,
      AVVINTPRO,
      AVVTIPOTRASF,
      AVVNOR,
      AVVCOM,
      AVVNUMCONV,
      AVVDATACONV,
      AVVTIPORA,
      AVVTIPORA_FP,
      AVVFT,
      AVVPT,
      AVVTEMDETDATCES,
      AVVGIOAGRPRE,
      AVVGIOAGREFF,
      AVVPTORAMEDSET,
      AVVQUA,
      AVVGRA,
      AVVLIV,
      AVVCCNL,
      AVVRETLORMEN,
      AVVRETLORSAN,
      AVVBEN,
      AVVTIPOLOGIA,
     /* cessazione */
      CESDAT,
      CESMOT,
      CESQUA,
      CESGRA,
      CESLIV,
     /* proroga/trasformazione */
      PTRNUOQUA,
      PTRNUOGRA,
      PTRNUOLIV,
      PTRNUOCCNL,
      PTRNUOBEN,
     /* proroga */
      PRODATINI,
      PRODATFIN,
     /* trasformazione */
      TRADAT,
      TRANUOTEM,
      TRANUOTEMINDET,
      TRANUOTEMDET,
      TRANUOPTORAMEDSET,
      TRATIPASS,
      TRATIPORA,
      TRATIPORA_FP,
     /* apprendista */
         APPNUMMESI,
      APPTUTCODFIS,
      APPTUTCOGNOME,
      APPTUTNOME,
      APPTUTESPLAVANNI,
      APPTUTTITIMP,
      APPTUTLIVINQ,
      APPTUTQUA,
      APPARTIG,
      IDSESSIONE,
      IDRIGA,
      CODSTATOATTO,
      /*DECRETO gennaio 2013*/
      DATFINEPF,
	  FLGLAVOROINMOBILITA,
	  FLGLAVOROSTAGIONALE,
	  FLGLAVOROAGR,
	  FLGPROSECUZIONE,
	  CODVARIAZIONE
    FROM (
          SELECT
        /* codice cpi */
            NVL (GET_CODCPI_LAV (MOV.CDNLAVORATORE,MOV.DATINIZIOMOV,MOV.DATFINEMOV),MOV.CODCPILAV) AS CODCPI,
     /* chiave del record in esame */
      MOV.PRGMOVIMENTO AS PRGMOVIMENTO,
      MOV.CODTIPOMOV AS CODTIPOMOV,
     /* riferimento al movimento temporalmente precedente */
      MOV.PRGMOVIMENTOPREC AS PRGMOVIMENTOPREC,
      DECODE(MOV.CODTIPOMOV,'AVV', MOV.PRGMOVIMENTO, NULL) AS PRGMOVIMENTOAVV,
     /* vari */
      NVL(MOV.DTMMOD, MOV.DTMINS) AS DTMINSMOD,
      null AS CODMONOTIPOCPI, -- Questo campo non viene utilizzato nella stampa
     /* referente / invio */
      AZIUNI.CODCOM AS REFID,
      MOV.DATCOMUNICAZ AS REFDATINV,
      MOV.STRREFERENTE AS REFMIT,
     /* evento */
      MOV.CODTIPOMOV AS EVECOD,
      MOV.DATINIZIOMOV AS EVEDAT,
     /* unita produttiva */
      AZI.STRCODICEFISCALE AS AZICODFISC,
      AZI.STRPARTITAIVA AS AZIUNIPARIVA,
      AZI.STRRAGIONESOCIALE AS AZIUNIRAGSOC,
      AZIUNI.STRINDIRIZZO AS AZIUNIIND,
      AZIUNI.STRCAP AS AZIUNICAP,
      AZIUNI.CODCOM AS AZIUNICOM,
      AZIUNI.STRTEL AS AZIUNITEL,
      AZIUNI.STRFAX AS AZIUNIFAX,
      AZIUNI.STREMAIL AS AZIUNIMAIL,
      AZIUNI.CODATECO AS AZIUNICODATT,
      AZIUNI.CODCCNL AS AZIUNICCNL,
      AZI.NUMDIPENDENTI AS AZIUNINUMDIP,
      AZIUNI.STRNUMEROINPS AS AZIUNIINPS,
      AZIUNI.STRNUMREGISTROCOMMITT AS AZIUNINUMREGCODDOM,
      AZI.STRNUMALBOINTERINALI AS AZIUNINUMALBINT,
      AZI.STRPATINAIL AS AZIINAIL,
      AZI.CODTIPOAZIENDA AS AZITIPOAZIENDA,
     /* sede legale (se presente) */
      AZI.STRRAGIONESOCIALE AS AZISEDRAGSOC,
      AZISED.STRINDIRIZZO AS AZISEDIND,
      AZISED.STRCAP AS AZISEDCAP,
      AZISED.CODCOM AS AZISEDCOM,
      AZISED.STRTEL AS AZISEDTEL,
      AZISED.STRFAX AS AZISEDFAX,
      AZISED.STREMAIL AS AZISEDMAIL,
     /* lavoratore */
      LAV.STRCODICEFISCALE AS LAVCODFIS,
      LAV.STRCOGNOME AS LAVCOGNOME,
      LAV.STRNOME AS LAVNOME,
      LAV.DATNASC AS LAVDATNAS,
      LAV.STRSESSO AS LAVSES,
      LAV.CODCOMNAS AS LAVNASCOM,
      LAV.CODCITTADINANZA AS LAVCIT,
      LAV.CODCOMRES AS LAVRESCOM,
      LAV.STRINDIRIZZORES AS LAVRESIND,
      LAV.STRCAPRES AS LAVRESCAP,
      LAV.CODCOMDOM AS LAVDOMCOM,
      LAV.STRINDIRIZZODOM AS LAVDOMIND,
      LAV.STRCAPDOM AS LAVDOMCAP,
      (CASE
        WHEN (LAVEXC.CDNLAVORATORE IS NOT NULL AND LAVEXC.DATFINE IS NULL) THEN LAVEXC.DATSCADENZA
        WHEN (LAVEXC.CDNLAVORATORE IS NOT NULL AND LAVEXC.DATFINE IS NOT NULL AND LAVEXC.DATFINE > SYSDATE) THEN LAVEXC.DATSCADENZA
        ELSE NULL
         END) AS LAVPSSCAD, LAVEXC.CODMOTIVORIL AS LAVPSMOT,
      LAVEXC.CODSTATUS AS LAVEXCODSTATUS,
      (SELECT lavstu.codtitolo
                             FROM pr_studio lavstu
                            WHERE lavstu.cdnlavoratore(+) =
                                              lav.cdnlavoratore
                              AND lavstu.flgprincipale(+) = 'S'
                              AND ROWNUM = 1) AS lavtitstud,
      DECODE(LAV.CODSTATOCIVILE,'C', 'X',NULL) AS LAVCONIUG,
      MOV.CODCPILAV AS LAVSCICA,
     /* azienda utilizz. */
     /* Se il tipo di trasformazione è 'DL' (distacco lavoratore) 
        prendiamo i dati dall'azienda distaccataria, altrimenti 
        dall' azienda utilizzatrice */
      DECODE(MOV.CODTIPOTRASF, 'DL', MOV.DATFINEDISTACCO, MOV.DATFINERAPLAV) AS AZIUTICNTDATFIN,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.STRCODICEFISCALE, AZIUTI.STRCODICEFISCALE) AS AZIUTICODFISC,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.STRPARTITAIVA, AZIUTI.STRPARTITAIVA) AS AZIUTIPARIVA,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.STRRAGIONESOCIALE, AZIUTI.STRRAGIONESOCIALE) AS AZIUTIRAGSOC,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.CODTIPOAZIENDA, AZIUTI.CODTIPOAZIENDA) AS AZIUTICODTIP,
      DECODE(MOV.CODTIPOTRASF, 'DL', DECODE(AZIDIST.CODTIPOAZIENDA,'ART', 'X',NULL), DECODE(AZIUTI.CODTIPOAZIENDA,'ART', 'X',NULL)) AS AZIUTIARTIGIANA,
     /* il seg. campo non viene gestito:
      null AS AZIUTILEGRAP,
     */
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTUNI.STRINDIRIZZO, AZIUTIUNI.STRINDIRIZZO) AS AZIUTIIND,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTUNI.STRCAP, AZIUTIUNI.STRCAP) AS AZIUTICAP,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTUNI.CODCOM, AZIUTIUNI.CODCOM) AS AZIUTICOM,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTUNI.CODATECO, AZIUTIUNI.CODATECO) AS AZIUTICODATT,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.NUMDIPENDENTI, AZIUTI.NUMDIPENDENTI) AS AZIUTINUMDIP,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTUNI.STRNUMEROINPS, AZIUTIUNI.STRNUMEROINPS) AS AZIUTIINPS,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.STRPATINAIL, AZIUTI.STRPATINAIL) AS AZIUTIINAIL,
      /*
        12/1/05: analogamente a AZISED e AZIUNI, si lascia il campo originale:
        non piu': DECODE(AZIUTISED.PRGAZIENDA, NULL, AZIUTIUNI.xxx, AZIUTISED.xxx) AS AZIUTISEDxxx,
       */
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.STRINDIRIZZO, AZIUTISED.STRINDIRIZZO) AS AZIUTISEDIND,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.STRCAP, AZIUTISED.STRCAP) AS AZIUTISEDCAP,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.CODCOM, AZIUTISED.CODCOM) AS AZIUTISEDCOM,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.STRTEL, AZIUTISED.STRTEL) AS AZIUTISEDTEL,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.STRFAX, AZIUTISED.STRFAX) AS AZIUTISEDFAX,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.STREMAIL, AZIUTISED.STREMAIL) AS AZIUTISEDMAIL,
      MOV.STRAZINTNUMCONTRATTO AS AZIUTICNTNUM,
      MOV.DATINIZIORAPLAV AS AZIUTICNTDATINI,
      MOV.NUMAZINTSOGGETTI AS AZIUTITOTSOGINT,
     /* avviamento */
      MOV.STRMATRICOLA AS AVVNUMMAT,
      MOV.DATINIZIOAVV AS AVVDATAVV,
      MOV.CODMONOTEMPO AS AVVTEM,
      DECODE(MOV.CODMONOTEMPO, 'I', MOV.DATINIZIOAVV, NULL) AS AVVTEMINDETDATAVV,
      DECODE(MOV.CODMONOTEMPO, 'D', MOV.DATINIZIOAVV, NULL) AS AVVTEMDETDATAVV,
      MOV.STRLUOGODILAVORO AS AVVLUO,
      MOV.CODTIPOCONTRATTO AS AVVTIPASS,
      --MOV.FLGINTERASSPROPRIA AS AVVINTPRO,
      NVL(MOV.FLGINTERASSPROPRIA,'N') AS AVVINTPRO,
      MOV.CODNORMATIVA AS AVVNOR,
      MOV.CODTIPOTRASF AS AVVTIPOTRASF,
      DECODE(MOV.FLGLEGGE68, 'S', 'X',NULL) AS AVVCOM,
      MOV.NUMCONVENZIONE AS AVVNUMCONV,
      MOV.DATCONVENZIONE AS AVVDATACONV,
      MOV.CODORARIO AS AVVTIPORA,
      DECODE(MOV.CODORARIO, NULL,NULL, 'F','F', 'P')  AS AVVTIPORA_FP,
      DECODE(MOV.CODORARIO, 'F', 'X',NULL) AS AVVFT,
      DECODE(MOV.CODORARIO, 'M', 'X','V', 'X', 'P', 'X', NULL) AS AVVPT,
      MOV.DATFINEMOV AS AVVTEMDETDATCES,
      MOV.NUMGGPREVISTIAGR AS AVVGIOAGRPRE,
      MOV.NUMGGEFFETTUATIAGR AS AVVGIOAGREFF,
      MOV.NUMORESETT AS AVVPTORAMEDSET,
      MOV.CODMANSIONE AS AVVQUA,
      MOV.CODGRADO AS AVVGRA,
      MOV.NUMLIVELLO AS AVVLIV,
      MOV.CODCCNL AS AVVCCNL,
      MOV.DECRETRIBUZIONEMEN AS AVVRETLORMEN,
      MOV.DECRETRIBUZIONEMENSANATA AS AVVRETLORSAN,
      MOV.CODAGEVOLAZIONE AS AVVBEN,
      DECODE(MOVAPP.NUMMESIAPPRENDISTATO, NULL, NULL, 'N. mesi apprendistato: ' || MOVAPP.NUMMESIAPPRENDISTATO) AS AVVTIPOLOGIA,
     /* cessazione */
      DECODE(MOV.CODTIPOMOV,'CES', MOV.DATINIZIOMOV,    NULL) AS CESDAT,
      DECODE(MOV.CODTIPOMOV,'CES', MOV.CODMVCESSAZIONE, NULL) AS CESMOT,
      DECODE(MOV.CODTIPOMOV,'CES', MOV.CODMANSIONE, NULL) AS CESQUA,
      DECODE(MOV.CODTIPOMOV,'CES', MOV.CODGRADO, NULL) AS CESGRA,
      DECODE(MOV.CODTIPOMOV,'CES', MOV.NUMLIVELLO, NULL) AS CESLIV,
     /* proroga/trasformazione */
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.CODMANSIONE,
                            'TRA', MOV.CODMANSIONE, NULL) AS PTRNUOQUA,
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.CODGRADO,
                            'TRA', MOV.CODGRADO, NULL) AS PTRNUOGRA,
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.NUMLIVELLO,
                            'TRA', MOV.NUMLIVELLO, NULL) AS PTRNUOLIV,
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.CODCCNL,
                            'TRA', MOV.CODCCNL, NULL) AS PTRNUOCCNL,
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.CODAGEVOLAZIONE,
                            'TRA', MOV.CODAGEVOLAZIONE, NULL) AS PTRNUOBEN,
     /* proroga */
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.DATINIZIOMOV, NULL) AS PRODATINI,
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.DATFINEMOV, NULL) AS PRODATFIN,
     /* trasformazione */
      DECODE(MOV.CODTIPOMOV,'TRA', MOV.DATINIZIOMOV, NULL) AS TRADAT,
      DECODE(MOV.CODTIPOMOV,'TRA', MOV.CODMONOTEMPO, NULL) AS TRANUOTEM,
      DECODE(MOV.CODTIPOMOV,'TRA',
        DECODE(MOV.CODMONOTEMPO, 'I', 'X', NULL),
        NULL) AS TRANUOTEMINDET,
      DECODE(MOV.CODTIPOMOV,'TRA',
        DECODE(MOV.CODMONOTEMPO, 'D', 'X', NULL),
        NULL) AS TRANUOTEMDET,
      DECODE(MOV.CODTIPOMOV,'TRA', MOV.NUMORESETT, NULL) AS TRANUOPTORAMEDSET,
      DECODE(MOV.CODTIPOMOV,'TRA', MOV.CODTIPOCONTRATTO, NULL) AS TRATIPASS,
      DECODE(MOV.CODTIPOMOV,'TRA', MOV.CODORARIO,  NULL) AS TRATIPORA,
      DECODE(MOV.CODTIPOMOV,'TRA', DECODE(MOV.CODORARIO, NULL,NULL, 'F','F', 'P'), NULL) AS TRATIPORA_FP,
     /* apprendista */
         MOVAPP.NUMMESIAPPRENDISTATO AS APPNUMMESI,
      MOVAPP.STRCODICEFISCALETUTORE AS APPTUTCODFIS,
      MOVAPP.STRCOGNOMETUTORE AS APPTUTCOGNOME,
      MOVAPP.STRNOMETUTORE AS APPTUTNOME,
      MOVAPP.NUMANNIESPTUTORE AS APPTUTESPLAVANNI,
      MOVAPP.FLGTITOLARETUTORE AS APPTUTTITIMP,
      DECODE(MOVAPP.FLGTITOLARETUTORE,NULL, MOVAPP.STRLIVELLOTUTORE,  NULL) AS APPTUTLIVINQ,
      DECODE(MOVAPP.FLGTITOLARETUTORE,NULL, MOVAPP.CODMANSIONETUTORE, NULL) AS APPTUTQUA,
      MOVAPP.FLGARTIGIANA AS APPARTIG,
      inputIdSessione AS IDSESSIONE,
      i AS IDRIGA,
            MOV.CODSTATOATTO AS CODSTATOATTO,
      MOV.DATFINEPF,
      DECODE(MOV.FLGLAVOROINMOBILITA, 'S', 'X',NULL) AS FLGLAVOROINMOBILITA,
      DECODE(MOV.FLGLAVOROSTAGIONALE, 'S', 'X',NULL) AS FLGLAVOROSTAGIONALE,
      DECODE(MOV.FLGLAVOROAGR, 'S', 'X',NULL) AS FLGLAVOROAGR,
      DECODE(MOV.FLGPROSECUZIONE, 'S', 'X',NULL) AS FLGPROSECUZIONE,
	  MOV.CODVARIAZIONE
  		 FROM am_movimento mov LEFT OUTER JOIN an_unita_azienda azised
                  ON azised.prgazienda = mov.prgazienda
                AND azised.flgsede = 'S'
                  LEFT OUTER JOIN an_azienda aziuti
                  ON aziuti.prgazienda = mov.prgaziendautiliz
                  LEFT OUTER JOIN am_movimento_apprendist movapp
                  ON movapp.prgmovimento = mov.prgmovimento
                  LEFT OUTER JOIN an_unita_azienda aziutised
                  ON aziutised.prgazienda = mov.prgaziendautiliz
                AND aziutised.flgsede = 'S'
                  LEFT OUTER JOIN an_unita_azienda aziutiuni
                  ON aziutiuni.prgazienda = mov.prgaziendautiliz
                AND aziutiuni.prgunita = mov.prgunitautiliz
                  LEFT OUTER JOIN an_azienda azidist
                  ON azidist.prgazienda = mov.prgaziendadist
                  LEFT OUTER JOIN an_unita_azienda azidistsed
                  ON azidistsed.prgazienda = mov.prgaziendadist
                AND azidistsed.flgsede = 'S'
                  LEFT OUTER JOIN an_unita_azienda azidistuni
                  ON azidistuni.prgazienda = mov.prgaziendadist
                AND azidistuni.prgunita = mov.prgunitadist
                  , an_lavoratore lav LEFT OUTER JOIN am_ex_perm_sogg lavexc
                  ON lavexc.cdnlavoratore = lav.cdnlavoratore
                AND lavexc.codstatus <> '2'
                AND lavexc.codstatus <> '5'
                  , an_azienda azi, an_unita_azienda aziuni
            WHERE mov.prgmovimento = inputprgmovimento (i)
              AND lav.cdnlavoratore = mov.cdnlavoratore
              AND azi.prgazienda = mov.prgazienda
              AND aziuni.prgazienda = mov.prgazienda
              AND aziuni.prgunita = mov.prgunita
         ORDER BY lavexc.datfine DESC, lavexc.datscadenza DESC
         )
      WHERE ROWNUM = 1;


 /* IMPOSTO LE INFORMAZIONI RELATIVE ALLA PROTOCOLLAZIONE */
    SET_INFO_PROTOCOLLO (inputIdSessione, inputPrgMovimento(i));

    end loop;

 /* PASSO 2: PER I MOVIMENTI CHE NON SONO 'AVV' SCORRO I PRECEDENTI FINO AL PRIMO 'AVV' E USO I SUOI DATI */
    AGGIORNA_MOV_APP_NON_AVV(inputIdSessione);

 /* PASSO 3: DECODIFICO I CODICI DIRETTAMENTE SULLA TABELLA DI APPOGGIO */
    DECODIFICA_CODICI_STAMPA(inputIdSessione);
    EXCEPTION
     WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Error code: ' || SQLCODE);
      DBMS_OUTPUT.PUT_LINE('Error mesg: ' || SUBSTR(SQLERRM,1,100));

END SCRIVI_MOV_IN_APP;

PROCEDURE CTRL_DOC_DOPPI(inputNumAnnoProt IN AM_DOCUMENTO.NUMANNOPROT%TYPE,
       inputnumProtocollo IN AM_DOCUMENTO.NUMPROTOCOLLO%TYPE,
       inputCdnUtIns AM_DOCUMENTO.CDNUTINS%TYPE)
IS
Sok char(1);
Numqta number;
BEGIN
  IF inputCdnUtIns <> 200 and inputNumAnnoProt is not null and inputnumProtocollo is not null THEN
   select count(*)
    into Numqta
    from AM_DOCUMENTO
   where NUMANNOPROT = inputNumAnnoProt
     and NUMPROTOCOLLO = inputnumProtocollo
   ;
   if Numqta = 0 then
     Sok :='S';
   else
    Sok := 'N';
   end if;
  ELSE
    sOk:= 'S';
  END IF;

  if (sOk='N') then
  raise_application_error (-20012, 'Anno e numero protocollo già in uso');
  end if;

END CTRL_DOC_DOPPI;

function checkSePossibileRiaperturaDid (pCdnLavoratore in an_lavoratore.CDNLAVORATORE%type,
              pPrgDichDisponibilita in am_dich_disponibilita.PRGDICHDISPONIBILITA%type )
         return Varchar2 is

cursor didCursor   is
    select did.PRGDICHDISPONIBILITA prgDid, did.DATDICHIARAZIONE, did.DATFINE dataFine
        from
          am_dich_disponibilita did, an_lavoratore lav,am_elenco_anagrafico ele
     where
         did.PRGELENCOANAGRAFICO  = ele.PRGELENCOANAGRAFICO and
         did.CODSTATOATTO != 'AU' and
     lav.CDNLAVORATORE = ele.CDNLAVORATORE and
       lav.CDNLAVORATORE = pCdnLavoratore
       order by did.DATDICHIARAZIONE desc, did.PRGDICHDISPONIBILITA desc;

rowDid didCursor%rowtype;

valueReturn Varchar2(10) := 'false';

begin
  for rowDid in didCursor loop
    if(rowDid.prgDid = pPrgDichDisponibilita and rowDid.dataFine is not null) then
     valueReturn :=  'true';
   else
     valueReturn :=  'false';
   end if;
    exit;
  end loop;
  return valueReturn;
end;

procedure AggiornaCPICompetente(p_cdnUt VARCHAR2,
          p_prgLavStoriaInf VARCHAR2,
        p_newCodCpi VARCHAR2)
IS
  v_prgLavStoriaInf AN_LAV_STORIA_INF.PRGLAVSTORIAINF%type;
  v_newCodCpi DE_CPI.CODCPI%type;
  v_cdnut TS_UTENTE.CDNUT%type;

  v_provinciaSIL DE_PROVINCIA.CODPROVINCIA%type;
  v_codCpiCapoluogo DE_PROVINCIA.CODCPICAPOLUOGO%type;
  v_provinciaCPI DE_PROVINCIA.CODPROVINCIA%type;
  v_numKlo AN_LAV_STORIA_INF.NUMKLOLAVSTORIAINF%type;
BEGIN
   v_prgLavStoriaInf := p_prgLavStoriaInf;
  v_newCodCpi := p_newCodCpi;
  v_cdnut := p_cdnut;

   select TS_GENERALE.CODPROVINCIASIL into v_provinciaSIL from TS_GENERALE;
  select DE_CPI.CODPROVINCIA into v_provinciaCPI from DE_CPI where DE_CPI.CODCPI=v_newCodCpi;
  select AN_LAV_STORIA_INF.NUMKLOLAVSTORIAINF into v_numKlo from AN_LAV_STORIA_INF where prgLavStoriaInf=v_prgLavStoriaInf;
  select DE_PROVINCIA.CODCPICAPOLUOGO into v_codCpiCapoluogo from DE_PROVINCIA where codProvincia=v_provinciaSIL;

  if(v_provinciaCPI=v_provinciaSIL) then
   update an_lav_storia_inf
   set
    codcpitit = v_newCodCpi,
    codMonoTipoCpi = 'C',
    codCpiOrig = null,
    dtmmod = sysdate,
    cdnutmod = v_cdnUt,
    numklolavstoriainf = v_numKlo + 1
   where prglavstoriainf = v_prgLavStoriaInf;
  else
   update an_lav_storia_inf
   set
    codcpitit = v_codCpiCapoluogo,
    codMonoTipoCpi = 'T',
    codCpiOrig = v_newCodCpi,
    dtmmod = sysdate,
    cdnutmod = v_cdnUt,
    numklolavstoriainf = v_numKlo + 1
   where prglavstoriainf = v_prgLavStoriaInf;
  end if;
  --dbms_output.PUT_LINE('tutto ok');
  exception when others then
      null;
      --dbms_output.PUT_LINE('errore');
      --dbms_output.put_line(substr(sqlcode || ' ' || sqlerrm,1,255));
END AggiornaCPICompetente;


function insertDocumento (parPrgDoc out am_documento.PRGDOCUMENTO%type,
         parCodCpi in varchar2,
        parCdnLav in am_documento.cdnlavoratore%type,
        parPrgAzienda in am_documento.prgazienda%type,
        parPrgUnita in am_documento.prgunita%type,
        parCodTipodoc in varchar2,
        parFlgAutoCertif in varchar2,
        parStrDesc in varchar2,
        parFlgDocamm in varchar2,
        parFlgDocIdentifP in varchar2,
        parDataInizio in varchar2,
        parStrNumDoc in varchar2,
        parEnteRilascio in varchar2,
        parCodMonoIO in varchar2,
        parDataAcqril in varchar2,
        parCodModalitaAcqri in varchar2,
        parCodTipoFile in varchar2,
        parStrNomeDoc in varchar2,
        parDataFine in varchar2,
        parNumAnnoProt in am_documento.numannoprot%type,
        parNumProt in am_documento.numprotocollo%type,
        parStrNote in varchar2,
        parCdnUtIns in am_documento.cdnutins%type,
        parCdnUtMod in am_documento.cdnutmod%type,
        parDataProtocollazione in varchar2,
        parCodStatoAtto in varchar2,
        parPrgDocBlob out am_documento_blob.prgdocumentoblob%type,
        parPagina in varchar2,
        parPrgDocColl out am_documento_coll.prgdocumentocoll%type,
        parStrChiaveTabella in varchar2)
         return number
IS

  varCdnComponente TS_COMPONENTE.CDNCOMPONENTE%TYPE;

BEGIN

  SELECT S_AM_DOCUMENTO.NEXTVAL
  INTO parPrgDoc
  FROM DUAL;

  insert into am_documento
   (prgdocumento, codcpi, cdnlavoratore, prgazienda, prgunita, codtipodocumento, flgautocertificazione, strdescrizione,
    flgdocamm, flgdocidentifp, datinizio, strnumdoc, strenterilascio, codmonoio, datacqril, codmodalitaacqril, codtipofile,
    strnomedoc, datfine, numannoprot, numprotocollo, strnote, cdnutins, dtmins, cdnutmod, dtmmod,DATPROTOCOLLO, codStatoAtto)
  values
   (
    parPrgDoc, parCodCpi, parCdnLav, parPrgAzienda, parPrgUnita, parCodTipodoc, parFlgAutoCertif, parStrDesc,
    parFlgDocamm, parFlgDocIdentifP, TO_DATE(parDataInizio,'DD/MM/YYYY') , parStrNumDoc, parEnteRilascio, parCodMonoIO, TO_DATE(parDataAcqril,'DD/MM/YYYY'), parCodModalitaAcqri, parCodTipoFile,
    parStrNomeDoc, TO_DATE(parDataFine,'DD/MM/YYYY'), parNumAnnoProt, parNumProt, parStrNote, parCdnUtIns, SYSDATE, parCdnUtMod, SYSDATE,  TO_DATE(parDataProtocollazione,'DD/MM/YYYY HH24:MI'), parCodStatoAtto
   );

   SELECT S_AM_DOCUMENTO_BLOB.NEXTVAL
   INTO parPrgDocBlob
   FROM DUAL;

   insert into am_documento_blob
    (prgdocumentoblob, prgdocumento, blbfile)
   values
    (parPrgDocBlob, parPrgDoc, empty_blob());

  IF (parPagina is not null) THEN

     SELECT TS_COMPONENTE.CDNCOMPONENTE
   INTO varCdnComponente
         FROM TS_COMPONENTE
         WHERE UPPER(TS_COMPONENTE.STRPAGE) LIKE UPPER(parPagina);

   SELECT S_AM_DOCUMENTO_COLL.NEXTVAL
   INTO parPrgDocColl
   FROM DUAL;

   insert into am_documento_coll
     (prgdocumentocoll, prgdocumento, cdncomponente, strchiavetabella)
   values
     (parPrgDocColl, parPrgDoc, varCdnComponente, parStrChiaveTabella);

  END IF;
  RETURN 0;
END insertDocumento;


procedure checkIntersezionePeriodi (codLstTab in DE_LST_TAB.CODLSTTAB%TYPE,
									cdnParLavoratore in as_valore_isee.cdnLavoratore%TYPE,
									parDataInizio in as_valore_isee.datinizioval%TYPE,
									parDataFine in as_valore_isee.datfineval%TYPE)
is
	
	varCountIntersezioni int;

begin
	
	if (codLstTab = 'AS_ISEE') then
		
		if (parDataFine is null) then
		
			select count(*)
			into varCountIntersezioni
			from as_valore_isee isee
			where isee.cdnlavoratore = cdnParLavoratore
			and trunc(parDataInizio) <= trunc(isee.datinizioval);
			
			if (varCountIntersezioni > 0) then
			  raise_application_error (-20016, 'Non è possibile effettuare l''operazione in quanto esistono periodi che si sovrappongono a quello che si è provato ad inserire.');
			end if;
		
		else
		
			select count(*)
			into varCountIntersezioni
			from as_valore_isee isee
			where isee.cdnlavoratore = cdnParLavoratore and isee.datfineval is not null
			and ( (trunc(parDataInizio) between trunc(isee.datinizioval) and trunc(isee.datfineval)) or 
			      (trunc(parDataFine) between trunc(isee.datinizioval) and trunc(isee.datfineval)) or
				  (trunc(parDataInizio) < trunc(isee.datinizioval) and trunc(parDataFine) >= trunc(isee.datinizioval)) );
			
			if (varCountIntersezioni > 0) then
			  raise_application_error (-20016, 'Il nuovo record non è successivo all''ultimo già inserito.');
			end if;
			
			select count(*)
			into varCountIntersezioni
			from as_valore_isee isee
			where isee.cdnlavoratore = cdnParLavoratore and isee.datfineval is null
			and trunc(isee.datinizioval) between trunc(parDataInizio) and trunc(parDataFine);
			
			if (varCountIntersezioni > 0) then
			  raise_application_error (-20016, 'Non è possibile effettuare l''operazione in quanto esistono periodi che si sovrappongono a quello che si è provato ad inserire.');
			end if;
			
		end if;
		
	end if;
	
exception
	when no_data_found then
		raise_application_error (-20016, 'Non è possibile effettuare l''operazione in quanto esistono periodi che si sovrappongono a quello che si è provato ad inserire.');

end checkIntersezionePeriodi;


procedure pdChiudiRecordPeriodoPrec (codParLstTab in DE_LST_TAB.CODLSTTAB%TYPE,
									 cdnParLavoratore in as_valore_isee.cdnLavoratore%TYPE,
								     datParInizio in as_valore_isee.datinizioval%TYPE)
is
	
	prgVarChiaveTabellaRecordPrec as_valore_isee.prgvaloreisee%TYPE;
	numVarKlo                     as_valore_isee.numKloValoreIsee%TYPE;
	cdnVarLavoratore              as_valore_isee.cdnLavoratore%TYPE;
	datVarDataInizio              as_valore_isee.datinizioval%TYPE;
	datVarDataFine                as_valore_isee.datfineval%TYPE;

begin
	
	if (codParLstTab = 'AS_ISEE') then
		-- cerco la chiave del record precedente per la tabella AS_VALORE_ISEE
        begin
			select tab1.prgvaloreisee, tab1.numKloValoreIsee, tab1.datinizioval
			into prgVarChiaveTabellaRecordPrec, numVarKlo, datVarDataInizio
			from (
			select tab.prgvaloreisee, tab.numKloValoreIsee, trunc(tab.datinizioval) datinizioval
            from AS_VALORE_ISEE tab
			where tab.cdnLavoratore = cdnParLavoratore
			and trunc(tab.datinizioval) < trunc(datParInizio)
			and (tab.datfineval is null or trunc(tab.datfineval) >= trunc(datParInizio))
			order by tab.datinizioval desc) tab1
			where rownum = 1;
									 
		exception
			when no_data_found then datVarDataInizio := null;
		end;
									 
		if (datVarDataInizio is not null) then				 
			datVarDataFine := trunc(datParInizio) -1;

			update AS_VALORE_ISEE
			   set datFineVal = datVarDataFine,
				   numKloValoreIsee =  numVarKlo + 1
			  where prgvaloreisee = prgVarChiaveTabellaRecordPrec;
		end if;
	
	end if;

end pdChiudiRecordPeriodoPrec;


end PG_GESTAMM;
/



/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_GESTIONE_CIG.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_GESTIONE_CIG AS

 --Author : Antonio Esposito, Rodi Alessandro
 --Date : 26/03/2010
 FUNCTION annullaDomanda(pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE, pCdnUt IN NUMBER) RETURN NUMBER;
 FUNCTION rettificaLavoratore(pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE, pCodTipoAccordo in ci_accordo.codtipoaccordo% TYPE, pStrCodiceFiscale IN AN_LAVORATORE.STRCODICEFISCALE%TYPE, pPrgAccordo IN CI_ACCORDO.PRGACCORDO%TYPE,pDataInizio IN Varchar2, pDataFine IN Varchar2,pCodStato IN AM_ALTRA_ISCR.CODSTATO%TYPE, pCodStatoIscr IN AM_ALTRA_ISCR.CODSTATO%TYPE, pCdnUt IN NUMBER, pPrgUnita in AM_ALTRA_ISCR.PRGUNITA% TYPE, pDatLicenziamento in Varchar2,pFlgDirittoDO in AM_ALTRA_ISCR.FLGDIRITTODO%TYPE,pCodMotivoNotDo in AM_ALTRA_ISCR.CODMOTIVONOTDO%TYPE) RETURN NUMBER;
 FUNCTION annullaLavoratori(pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE, pCodStato IN AM_ALTRA_ISCR.CODSTATO%TYPE, pCdnUt IN NUMBER) RETURN NUMBER;
 FUNCTION rettificaDomanda(pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE, pCodStato IN CI_ACCORDO.CODSTATOATTO%TYPE,pPrgAccordoSucc IN CI_ACCORDO.PRGACCORDO%TYPE, pCdnUt IN NUMBER) RETURN NUMBER;
 FUNCTION variaDomanda(pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE, pCodStato IN CI_ACCORDO.CODSTATOATTO%TYPE,pPrgAccordoSucc IN CI_ACCORDO.PRGACCORDO%TYPE, pCdnUt IN NUMBER) RETURN NUMBER;
 FUNCTION existsAzioni2pos1neg(pPrgColloquio IN OR_PERCORSO_CONCORDATO.PRGCOLLOQUIO%TYPE, pPrgAzioni IN OR_PERCORSO_CONCORDATO.PRGAZIONI%TYPE) RETURN VARCHAR2;
 FUNCTION pdAggFlgSedeLegaleAzienda (prgParAzienda in AN_UNITA_AZIENDA.prgAzienda%type, prgParUnita in AN_UNITA_AZIENDA.prgUnita%type, pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE, pCdnUt IN NUMBER) RETURN NUMBER;
 FUNCTION concatenaPic(parPrgAltraIscr in AM_ALTRA_ISCR.PRGALTRAISCR%TYPE) return varchar2;
END PG_GESTIONE_CIG;
/


CREATE OR REPLACE PACKAGE BODY PG_GESTIONE_CIG AS

 FUNCTION annullaDomanda(pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE, 
 		  			     pCdnUt IN NUMBER) RETURN NUMBER IS
 
    varPrgAccordo CI_ACCORDO.PRGACCORDO%TYPE;

 BEGIN
 
 	  UPDATE CI_ACCORDO ACC 
	     SET ACC.CODSTATOATTO = 'AN',
		 	 ACC.NUMKLOACCORDO = ACC.NUMKLOACCORDO + 1,
			 ACC.CDNUTMOD = pCdnUt,
			 ACC.DTMMOD = sysdate
	   WHERE ACC.CODACCORDO = pCodAccordo
	     AND ACC.CODSTATOATTO = 'VA'
   RETURNING ACC.PRGACCORDO
   	    INTO varPrgAccordo;
	   
	   IF (SQL%ROWCOUNT = 0)
	       THEN
		   	   raise_application_error
	           (-20001,
	            'L''accordo da annullare non e'' stato trovato'
			   );
	   END IF;
	   
	  UPDATE AM_ALTRA_ISCR ISC
	     SET ISC.CODSTATO = 'AD',
		 	 ISC.NUMKLOALTRAISCR = ISC.NUMKLOALTRAISCR + 1,
			 ISC.CDNUTMOD = pCdnUt,
			 ISC.DTMMOD = sysdate
	   WHERE ISC.PRGACCORDO = varPrgAccordo;
	     
	   RETURN 0;
	   
	   EXCEPTION
	    	WHEN TOO_MANY_ROWS THEN
            	return -20002;
	   		WHEN OTHERS THEN
				return SQLCODE;
  
 END annullaDomanda;
 
 
 FUNCTION rettificaLavoratore(pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE, 
  						  pCodTipoAccordo in ci_accordo.codtipoaccordo% TYPE,
 		  				  pStrCodiceFiscale IN AN_LAVORATORE.STRCODICEFISCALE%TYPE, 
 						  pPrgAccordo IN CI_ACCORDO.PRGACCORDO%TYPE,
						  pDataInizio IN Varchar2,
						  pDataFine IN Varchar2,
						  pCodStato IN AM_ALTRA_ISCR.CODSTATO%TYPE,
						  pCodStatoIscr IN AM_ALTRA_ISCR.CODSTATO%TYPE,						  
						  pCdnUt IN NUMBER,
						  pPrgUnita in AM_ALTRA_ISCR.PRGUNITA%TYPE,
						  pDatLicenziamento in Varchar2,
						  pFlgDirittoDO in AM_ALTRA_ISCR.FLGDIRITTODO%TYPE,
						  pCodMotivoNotDo in AM_ALTRA_ISCR.CODMOTIVONOTDO%TYPE) RETURN NUMBER IS
 
    varPrgAccordo CI_ACCORDO.PRGACCORDO%TYPE;
	varPrgAltraIscr AM_ALTRA_ISCR.PRGALTRAISCR%TYPE;
 BEGIN
 	  
	  SELECT ISC.PRGALTRAISCR, ISC.PRGACCORDO
	    INTO varPrgAltraIscr, varPrgAccordo
	    FROM AM_ALTRA_ISCR ISC, CI_ACCORDO ACC, AN_LAVORATORE LAV
	   WHERE ACC.CODACCORDO = pCodAccordo
	     AND ACC.PRGACCORDO = ISC.PRGACCORDO
		 AND ACC.CODSTATOATTO = pCodStato
		 AND ISC.CDNLAVORATORE = LAV.CDNLAVORATORE
		 AND LAV.STRCODICEFISCALE = pStrCodiceFiscale;
	  
	  --nel caso in cui il parametro pCodStatoIscr sia uguale a 0, devo lasciare
	  --inalterato lo stato della richiesta
	  
	  UPDATE AM_ALTRA_ISCR ISC
	     SET ISC.PRGACCORDO = pPrgAccordo,
		 	 ISC.DATINIZIO = decode(pDataInizio,null,ISC.DATINIZIO,to_date(pDataInizio,'dd/mm/yyyy')),
			 ISC.DATFINE = decode(pDataFine,null,ISC.DATFINE,to_date(pDataFine,'dd/mm/yyyy')),
			 ISC.DTMMOD = sysdate,
			 ISC.CODTIPOISCR = pCodTipoAccordo,
			 ISC.PRGUNITA = pPrgUnita,
			 ISC.CODSTATO = DECODE(pCodStatoIscr,'0',ISC.CODSTATO,pCodStatoIscr),
			 ISC.DATLICENZIAMENTO = decode(pDatLicenziamento,null,ISC.DATLICENZIAMENTO,to_date(pDatLicenziamento,'dd/mm/yyyy')),
			 ISC.FLGDIRITTODO = decode(pFlgDirittoDO,'0',ISC.FLGDIRITTODO,pFlgDirittoDO),
			 ISC.CODMOTIVONOTDO = decode(pCodMotivoNotDo,'0',ISC.CODMOTIVONOTDO,pCodMotivoNotDo),
			 ISC.CDNUTMOD = pCdnUt,
			 ISC.NUMKLOALTRAISCR = ISC.NUMKLOALTRAISCR + 1
       WHERE ISC.PRGALTRAISCR = varPrgAltraIscr;
		 
		IF (SQL%ROWCOUNT = 0)
	       THEN
		   	   raise_application_error
	           (-20003,
	            'Impossibile trovare l''iscrizione da variare/rettificare'
			   );
	   END IF; 
		 
	  RETURN 0;
 
 	  EXCEPTION
	  		   --il lavoratore da variare/rettificare non è presente nella vecchia iscrizione,
	     	   --questo vuol dire che dobbiamo inserire il nuovo lavoratore. Restituisco 1
		 	   --e da Java invoco l'inserimento del lavoratore
	  		   WHEN NO_DATA_FOUND THEN 
			   		return 1; 
			   
	  		   WHEN OTHERS THEN RETURN SQLCODE;
  
 END rettificaLavoratore;
 
 FUNCTION rettificaDomanda(pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE,
 		  				   pCodStato IN CI_ACCORDO.CODSTATOATTO%TYPE,
						   pPrgAccordoSucc IN CI_ACCORDO.PRGACCORDO%TYPE,
 		  			   	   pCdnUt IN NUMBER) RETURN NUMBER IS

 BEGIN
 
 	  UPDATE CI_ACCORDO ACC 
	     SET ACC.CODSTATOATTO = pCodStato,
		 	 ACC.NUMKLOACCORDO = ACC.NUMKLOACCORDO + 1,
			 ACC.PRGACCORDOSUCC = pPrgAccordoSucc,
			 ACC.CDNUTMOD = pCdnUt,
			 ACC.DTMMOD = sysdate
	   WHERE ACC.CODACCORDO = pCodAccordo;
	     --AND ACC.CODSTATOATTO = 'VA'
      
	   IF (SQL%ROWCOUNT = 0)
	       THEN
		   	   raise_application_error
	           (-20004,
	            'L''accordo da variare non e'' stato trovato'
			   );
	   END IF;
	   
	   RETURN 0;
	   
	   EXCEPTION
	   			WHEN OTHERS THEN
					 return SQLCODE;
  
 END rettificaDomanda;
 
 FUNCTION variaDomanda(pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE,
 		  				   pCodStato IN CI_ACCORDO.CODSTATOATTO%TYPE,
						   pPrgAccordoSucc IN CI_ACCORDO.PRGACCORDO%TYPE,
 		  			   	   pCdnUt IN NUMBER) RETURN NUMBER IS

 BEGIN
 
 	  UPDATE CI_ACCORDO ACC 
	     SET ACC.CODSTATOATTO = pCodStato,
		 	 ACC.NUMKLOACCORDO = ACC.NUMKLOACCORDO + 1,
			 ACC.PRGACCORDOSUCC = pPrgAccordoSucc,
			 ACC.CDNUTMOD = pCdnUt,
			 ACC.DTMMOD = sysdate
	   WHERE ACC.CODACCORDO = pCodAccordo
	     AND ACC.PRGACCORDO <> pPrgAccordoSucc;
      
	   IF (SQL%ROWCOUNT = 0)
	       THEN
		   	   raise_application_error
	           (-20004,
	            'L''accordo da variare non e'' stato trovato'
			   );
	   END IF;
	   
	   RETURN 0;
	   
	   EXCEPTION
	   			WHEN OTHERS THEN
					 return SQLCODE;
  
 END variaDomanda;
 
 FUNCTION annullaLavoratori(pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE,
 		  					pCodStato IN AM_ALTRA_ISCR.CODSTATO%TYPE,
						    pCdnUt IN NUMBER) RETURN NUMBER IS
 
 BEGIN
 	  
	  UPDATE AM_ALTRA_ISCR ISC
	     SET ISC.CODSTATO = pCodStato,
		 	 ISC.DTMMOD = sysdate,
			 ISC.CDNUTMOD = pCdnUt,
			 ISC.NUMKLOALTRAISCR = ISC.NUMKLOALTRAISCR + 1 
	   WHERE ISC.PRGACCORDO = (SELECT min(ACC.PRGACCORDO) 
	   		 				  	 FROM CI_ACCORDO ACC
								WHERE ACC.CODACCORDO = pCodAccordo); 
		 
	  RETURN 0;
 
 	  EXCEPTION
	  		   WHEN OTHERS THEN RETURN SQLCODE;
  
 END annullaLavoratori; 
 
 --questa funzione estrae 2 azioni negative ed una positiva
 FUNCTION existsAzioni2pos1neg(pPrgColloquio IN OR_PERCORSO_CONCORDATO.PRGCOLLOQUIO%TYPE, 
 		  				  pPrgAzioni IN OR_PERCORSO_CONCORDATO.PRGAZIONI%TYPE) RETURN VARCHAR2 IS
 
    varDatStimata OR_PERCORSO_CONCORDATO.DATSTIMATA%TYPE;
	countAzioni int;
 BEGIN
 	  
	select max(per.datstimata) 
	into varDatStimata
	from or_percorso_concordato per 	
	where per.prgcolloquio = pPrgColloquio  
	and per.prgazioni = pPrgAzioni  
	and per.codesitorendicont = 'A'
	group by per.prgazioni 
	having count(per.prgazioni) = 2; 
	 
	select count(per1.prgazioni) 
	into countAzioni
	from or_percorso_concordato per1 	 
	where per1.prgcolloquio = pPrgColloquio 
		  and per1.datstimata > varDatStimata
		  and per1.codesitorendicont != 'A';

	if(countAzioni > 0) then 
   		return 'false';
	else 
   		return 'true';
	end if;
	
	EXCEPTION
		   WHEN NO_DATA_FOUND THEN 
   		   		return 'false'; 
   
		   WHEN OTHERS THEN RETURN 'false';
  
 END existsAzioni2pos1neg;
 
 FUNCTION pdAggFlgSedeLegaleAzienda (prgParAzienda in AN_UNITA_AZIENDA.prgAzienda%type, 
 		  							prgParUnita in AN_UNITA_AZIENDA.prgUnita%type, 
									pCodAccordo IN CI_ACCORDO.CODACCORDO%TYPE, 
									pCdnUt IN NUMBER) RETURN NUMBER IS

	varFlgSedeLegale AN_UNITA_AZIENDA.FLGSEDE%TYPE;
	varNoteSedeLegale AN_UNITA_AZIENDA.STRNOTE%TYPE;
	varNewNoteSedeLegale AN_UNITA_AZIENDA.STRNOTE%TYPE;
	vardataOggi VARCHAR2(10);
	ret NUMBER;
 BEGIN
 	  
	  SELECT uniAz.flgSede, uniAz.strNote
	  INTO varFlgSedeLegale, varNoteSedeLegale
	  FROM AN_UNITA_AZIENDA uniAz
	  WHERE uniAz.PRGAZIENDA = prgParAzienda
	  AND uniAz.PRGUNITA = prgParUnita;
	  
	  if(varFlgSedeLegale = 'N') then 
	  
		  select to_char(sysdate,'DD/MM/YYYY') into vardataOggi from dual;
		  varNewNoteSedeLegale := pg_utils.TRUNC_DESC_OTTIMIZZATA(vardataOggi || ' impostata come sede legale a seguito di domanda CIG ' || pCodAccordo || '. ', 1000, varNoteSedeLegale);
		  
		  UPDATE AN_UNITA_AZIENDA uniAz
	      SET uniAz.FLGSEDE = 'S',
		  	  uniAz.STRNOTE = varNewNoteSedeLegale,
			  uniAz.DTMMOD = sysdate,
			  uniAz.CDNUTMOD = pCdnUt,
			  uniAz.NUMKLOUNITAAZIENDA = uniAz.NUMKLOUNITAAZIENDA + 1
		  WHERE uniAz.PRGAZIENDA = prgParAzienda
		  AND uniAz.PRGUNITA = prgParUnita;
		  
		  ret := PG_GESTAMM.pdAggSedeAzienda(prgParAzienda,prgParUnita,pCdnUt);
			 
	  end if;
		 
	  RETURN 0;
 
 	  EXCEPTION
	  	WHEN NO_DATA_FOUND THEN 
			 return 1; 
			   
	  	WHEN OTHERS THEN 
			 return SQLCODE;
			   
 END pdAggFlgSedeLegaleAzienda;
 
 FUNCTION concatenaPic(parPrgAltraIscr in AM_ALTRA_ISCR.PRGALTRAISCR%TYPE) return varchar2 IS
    
    CURSOR curPic IS SELECT to_char(orp.datstimata, 'dd/mm/yyyy') || ' ' || es.strdescrizione as pic
           FROM or_percorso_concordato orp
           inner join or_colloquio coll on coll.prgcolloquio = orp.prgcolloquio
           left join de_esito es on es.codesito = orp.codesito
           WHERE orp.prgazioni = 151
           and coll.prgaltraiscr = parPrgAltraIscr;
    
    strPic varchar2(2000) := '';
  
  BEGIN
    FOR rec in curPic LOOP
        if(length(strPic)>0) then
            strPic := strPic || '<br>';
        end if;
  
        strPic := strPic || rec.pic;
    END LOOP;
    
    return strPic;
    exception
        when others then
            return '';

 END concatenaPic;
 
END PG_GESTIONE_CIG;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_GESTIONE_VOUCHER.sql
************************************************************************************** */


/**************************************************************************
Gestione dei Titoli Di Acquisto
Descrizione: "Gestione Contabile" 
             Procedure: - controllaResiduoCPI. Verifica l'importo residuo per il CPI in un determinato anno
                        - presenzaBudgetCPI.Verifica la presenza di un budget per il cpi in un determianto anno
                        - aggiornaBudgetCPI. Aggiorna la disponibilità del budget di un cpi sia in postivo che in negativo
                        - insertBudgetCPI. Inserimneto Budget (VCH_BUDGET_CPI)
                        - insertOperazioneBudgetCPI. Inserimento operazione (VCH_OPERAZIONI_BUDGET)
                        - operazioneBudgetCPI. Gestione delle operazioni sul budget 
                        - attivaBudgetCPI. Attivazione di un budget per un CPI in un determinato anno
Descrizione: "Gestione Enti" 
             Procedure: - insertEnte. Inserimento di un ente accreditato
                        - updateEnte. aggiornamento informazioni di un ente accreditato
                        - insertAccreditamento. Inserimento di una misura collegata ad un ente
                        - deleteAccreditamento. Eliminazione di una misura collegata ad un ente
                        - updateAccreditamento. Aggiornamento delle informazioni di una misura collegata ad un ente             
***************************************************************************/

create or replace package PG_GESTIONE_VOUCHER is

PROCEDURE attivaBudgetCPI (
  PAR_NUMANNOBUDGET  in VCH_BUDGET_CPI.Numannobudget%type,
  PAR_CODCPI         in VCH_BUDGET_CPI.Codcpi%type,
  PAR_DECTOTBUDGET   in VCH_BUDGET_CPI.Dectotbudget%type,
  PAR_cdnUtente      in VCH_BUDGET_CPI.Cdnutins%TYPE,
  errCodeOut         out number,
	messaggioErr       out varchar2);
  
PROCEDURE operazioneBudgetCPI (
  PAR_CODCPIDESTINAZIONE   in VCH_OPERAZIONI_BUDGET.CODCPIDESTINAZIONE%type, 
  PAR_NUMANNOBUDGET        in VCH_OPERAZIONI_BUDGET.NUMANNOBUDGET%type, 
  PAR_DATOPERAZIONE        in VCH_OPERAZIONI_BUDGET.DATOPERAZIONE%type,
  PAR_DECIMPORTO           in VCH_OPERAZIONI_BUDGET.DECIMPORTO%type,
  PAR_CODOPERAZIONE        in VCH_OPERAZIONI_BUDGET.CODOPERAZIONE%type,
  PAR_CODCPIALTRO          in VCH_OPERAZIONI_BUDGET.CODCPIDESTINAZIONE%type ,
  PAR_cdnUtente            in VCH_BUDGET_CPI.Cdnutins%TYPE,
  errCodeOut               out number,
  messaggioErr             out varchar2);
  
PROCEDURE insertEnte (
  PAR_STRCODICEFISCALE     in AN_VCH_ENTE.STRCODICEFISCALE%type, 
  PAR_CODSEDE              in AN_VCH_ENTE.CODSEDE%type,   
  PAR_STRDENOMINAZIONE     in AN_VCH_ENTE.STRDENOMINAZIONE%type, 
  PAR_STRINDIRIZZO         in AN_VCH_ENTE.STRINDIRIZZO%type,  
  PAR_CODCOM               in AN_VCH_ENTE.CODCOM%type,      
  PAR_STRNOTESTAMPE        in AN_VCH_ENTE.STRNOTESTAMPE%type, 
  PAR_cdnUtente            in AN_VCH_ENTE.Cdnutins%TYPE,
  errCodeOut               out number,
  messaggioErr             out varchar2);
  
PROCEDURE updateEnte (
  PAR_STRCODICEFISCALE     in AN_VCH_ENTE.STRCODICEFISCALE%type, 
  PAR_CODSEDE              in AN_VCH_ENTE.CODSEDE%type,   
  PAR_STRDENOMINAZIONE     in AN_VCH_ENTE.STRDENOMINAZIONE%type, 
  PAR_STRINDIRIZZO         in AN_VCH_ENTE.STRINDIRIZZO%type,  
  PAR_CODCOM               in AN_VCH_ENTE.CODCOM%type,      
  PAR_STRNOTESTAMPE        in AN_VCH_ENTE.STRNOTESTAMPE%type, 
  PAR_cdnUtente            in AN_VCH_ENTE.Cdnutins%TYPE,
  errCodeOut               out number,
  messaggioErr             out varchar2) ;

PROCEDURE insertAccreditamento (
  PAR_STRCODICEFISCALE  in VCH_ENTE_ACCREDITATO.STRCODICEFISCALE%type,                     
  PAR_CODSEDE           in VCH_ENTE_ACCREDITATO.CODSEDE%type,
  PAR_PRGAZIONI         in VCH_ENTE_ACCREDITATO.PRGAZIONI%type,          
  PAR_DATINIZIOVAL      in VCH_ENTE_ACCREDITATO.DATINIZIOVAL%type,                      
  PAR_DATFINEVAL        in VCH_ENTE_ACCREDITATO.DATFINEVAL%type,                      
  PAR_CDNUTINS          in VCH_ENTE_ACCREDITATO.CDNUTINS%type,
  errCodeOut               out number,
  messaggioErr             out varchar2);
  
PROCEDURE deleteAccreditamento (
  PAR_PRGENTEACCREDITATO  in VCH_ENTE_ACCREDITATO.PRGENTEACCREDITATO%type,                     
  errCodeOut              out number,
  messaggioErr            out varchar2);
  
PROCEDURE updateAccreditamento (
  PAR_PRGENTEACCREDITATO  in VCH_ENTE_ACCREDITATO.PRGENTEACCREDITATO%type,
  PAR_DATINIZIOVAL        in VCH_ENTE_ACCREDITATO.DATINIZIOVAL%type,                      
  PAR_DATFINEVAL          in VCH_ENTE_ACCREDITATO.DATFINEVAL%type,                      
  PAR_CDNUTMOD            in VCH_ENTE_ACCREDITATO.CDNUTMOD%type,
  errCodeOut               out number,
  messaggioErr             out varchar2);
      
FUNCTION inserisciModelloTda (
	prgAzioniVar in VCH_MODELLO_VOUCHER.PRGAZIONI%type, 
	flagCMVar in VCH_MODELLO_VOUCHER.FLGCM%type,
	codSelModalitaVar in VCH_MODELLO_VOUCHER.CODSELEZMODALITA%type,
	numGGAttVar in VCH_MODELLO_VOUCHER.NUMNGMAXATTVCH%type,
	numGGErogVar in VCH_MODELLO_VOUCHER.NUMNGMAXEROGVCH%type,
	valTotVar in VCH_MODELLO_VOUCHER.DECVALTOT%type,
	cdnParUtenteVar in VCH_MODELLO_VOUCHER.CDNUTINS%TYPE) RETURN NUMBER;
	
FUNCTION aggiornaModelloTda (
	prgModelloTdaVar in VCH_MODELLO_VOUCHER.PRGMODVOUCHER%type,
	numKLockVar in VCH_MODELLO_VOUCHER.NUMKLOMODVOUCHER%type, 
	flagCMVar in VCH_MODELLO_VOUCHER.FLGCM%type,
	codSelModalitaVar in VCH_MODELLO_VOUCHER.CODSELEZMODALITA%type,
	numGGAttVar in VCH_MODELLO_VOUCHER.NUMNGMAXATTVCH%type,
	numGGErogVar in VCH_MODELLO_VOUCHER.NUMNGMAXEROGVCH%type,
	valTotVar in VCH_MODELLO_VOUCHER.DECVALTOT%type,
	cdnParUtenteVar in VCH_MODELLO_VOUCHER.CDNUTINS%TYPE) RETURN NUMBER;
	
FUNCTION gestioneModalitaModTda (
	tipoOperazioneVar in varchar,
	prgModelloTdaVar in VCH_MODELLO_VOUCHER.PRGMODVOUCHER%type,
	prgModalitaTdaVar in VCH_MODELLO_MODALITA.PRGMODMODALITA%type,
	numKLockVar in VCH_MODELLO_MODALITA.NUMKLOMODMODALITA%type, 
 	codModalitaErogVar in VCH_MODELLO_MODALITA.codvchmoderog%type, 
	tipoDurataVar in VCH_MODELLO_MODALITA.codtipologiadurata%type,
	durataMinvar in VCH_MODELLO_MODALITA.numduratamin%type,
	durataMaxvar in VCH_MODELLO_MODALITA.numduratamax%type,
	percentualeVar in VCH_MODELLO_MODALITA.NUMPERCPARCOMPLET%type,
	tipoRimborsoVar in VCH_MODELLO_MODALITA.codmonotiprimborso%type,
	valUnitVar in VCH_MODELLO_MODALITA.decValUnitario%type,
	valTotVar in VCH_MODELLO_MODALITA.decValTotale%type,
	cdnParUtenteVar in VCH_MODELLO_MODALITA.CDNUTINS%TYPE) RETURN NUMBER;
	
FUNCTION deleteModalitaModelloTDA (
	prgModalitaTdaVar in VCH_MODELLO_MODALITA.PRGMODMODALITA%type,
 	cdnParUtenteVar in VCH_MODELLO_MODALITA.CDNUTINS%TYPE) RETURN NUMBER;
 	
FUNCTION aggiornaValoreTotaleModelloTDA (
	prgModelloTdaVar in VCH_MODELLO_VOUCHER.PRGMODVOUCHER%type,
 	cdnParUtenteVar in VCH_MODELLO_VOUCHER.CDNUTMOD%TYPE) RETURN NUMBER;
 	
FUNCTION controllaCoerenzaModello (
	prgModelloTdaVar in VCH_MODELLO_VOUCHER.PRGMODVOUCHER%type) RETURN NUMBER;
	
FUNCTION attivaDisattivaModello (
	prgModelloTdaVar in VCH_MODELLO_VOUCHER.PRGMODVOUCHER%type,
	cdnParUtenteVar in VCH_MODELLO_VOUCHER.CDNUTINS%TYPE,
	flgAttivoVar in VCH_MODELLO_VOUCHER.FLGATTIVO%TYPE) RETURN NUMBER;
	
end PG_GESTIONE_VOUCHER;
/
create or replace package body PG_GESTIONE_VOUCHER is

FUNCTION getValoLockTable (PAR_nomecampolock    in varchar2,
                           PAR_nometabella      in varchar2,
                           PAR_strClausolaWhere IN VARCHAR2) RETURN   NUMBER   IS
                   
VAR_query       VARCHAR2(8192);
var_valorecampolock   number;
                   
BEGIN

 VAR_query :='SELECT '||PAR_nomecampolock||'  FROM '||PAR_nometabella||' WHERE '|| par_strClausolaWhere;
  
 EXECUTE IMMEDIATE VAR_query INTO var_valorecampolock;
 
 RETURN(var_valorecampolock);
EXCEPTION
	WHEN OTHERS THEN   
		    RETURN -1;
END;      
      
FUNCTION controllaResiduoCPI (
  PAR_NUMANNOBUDGET  in VCH_BUDGET_CPI.Numannobudget%type,
  PAR_CODCPI         in VCH_BUDGET_CPI.Codcpi%type,
  PAR_DECIMPORTO     in VCH_OPERAZIONI_BUDGET.DECIMPORTO%type) RETURN   NUMBER   IS
  
  VAR_DECTOTRESIDUO    VCH_BUDGET_CPI.Dectotresiduo%type; 
BEGIN
  SELECT (dectotresiduo - PAR_DECIMPORTO)
    INTO VAR_DECTOTRESIDUO
    FROM VCH_BUDGET_CPI
   WHERE codcpi        = PAR_CODCPI
     AND numannobudget = PAR_NUMANNOBUDGET;
  
      RETURN (VAR_DECTOTRESIDUO);  
EXCEPTION
	WHEN OTHERS THEN
		    RETURN -1;
END; 


FUNCTION presenzaBudgetCPI (
  PAR_NUMANNOBUDGET  in VCH_BUDGET_CPI.Numannobudget%type,
  PAR_CODCPI         in VCH_BUDGET_CPI.Codcpi%type) RETURN   BOOLEAN   IS
  
  VAR_FLGATTIVO  varchar2(1) :='N';
    
BEGIN
  select 'S' 
    into VAR_FLGATTIVO
    from VCH_BUDGET_CPI
   where CODCPI = PAR_CODCPI
     and NUMANNOBUDGET =PAR_NUMANNOBUDGET;
 
    RETURN (TRUE);
    
EXCEPTION
	WHEN OTHERS THEN
		    RETURN (FALSE);
END; 

FUNCTION aggiornaBudgetCPI (
  PAR_CODCPI           in VCH_BUDGET_CPI.Codcpi%type,
  PAR_NUMANNOBUDGET    in VCH_BUDGET_CPI.Numannobudget%type, 
  PAR_DECIMPORTO       in VCH_OPERAZIONI_BUDGET.DECIMPORTO%type,
  PAR_CODOPERAZIONE    in VCH_OPERAZIONI_BUDGET.CODOPERAZIONE%type, 
  PAR_cdnUtente        in VCH_BUDGET_CPI.Cdnutmod%TYPE,
  PAR_NUMKLOBUDGET     in VCH_BUDGET_CPI.NUMKLOBUDGET%type) RETURN   BOOLEAN   IS  
BEGIN
     IF PAR_CODOPERAZIONE ='U' --decremento
     THEN
       UPDATE VCH_BUDGET_CPI SET DECTOTBUDGET  = DECTOTBUDGET - PAR_DECIMPORTO,
                                 DECTOTRESIDUO = (DECTOTBUDGET - PAR_DECIMPORTO)-DECTOTIMPEGNATO-DECTOTSPESO,
                                 CDNUTMOD      = PAR_cdnUtente,                                             
                                 DTMMOD        = sysdate,                                                  
                                 NUMKLOBUDGET  = PAR_NUMKLOBUDGET+1
        WHERE  CODCPI        = PAR_CODCPI
          AND  NUMANNOBUDGET = PAR_NUMANNOBUDGET;     
     ELSIF PAR_CODOPERAZIONE ='E' --Incremento
     THEN
       UPDATE VCH_BUDGET_CPI SET DECTOTBUDGET  = DECTOTBUDGET + PAR_DECIMPORTO,
                                 DECTOTRESIDUO = (DECTOTBUDGET + PAR_DECIMPORTO)-DECTOTIMPEGNATO-DECTOTSPESO,
                                 CDNUTMOD      = PAR_cdnUtente,                                            
                                 DTMMOD        = sysdate,                                                  
                                 NUMKLOBUDGET  = PAR_NUMKLOBUDGET+1
        WHERE  CODCPI        = PAR_CODCPI
          AND  NUMANNOBUDGET = PAR_NUMANNOBUDGET;     
     END IF;

    RETURN (TRUE);
    
EXCEPTION
	WHEN OTHERS THEN
		    RETURN (FALSE);
END; 

FUNCTION insertBudgetCPI (
  PAR_CODCPI           in VCH_BUDGET_CPI.Codcpi%type,
  PAR_NUMANNOBUDGET    in VCH_BUDGET_CPI.Numannobudget%type,  
  PAR_DECTOTBUDGET     in VCH_BUDGET_CPI.Dectotbudget%type,
  PAR_DECTOTIMPEGNATO  in VCH_BUDGET_CPI.DECTOTIMPEGNATO%type,                           
  PAR_DECTOTSPESO      in VCH_BUDGET_CPI.DECTOTSPESO%type, 
  PAR_DECTOTRESIDUO    in VCH_BUDGET_CPI.DECTOTRESIDUO%type, 
  PAR_cdnUtente        in VCH_BUDGET_CPI.Cdnutins%TYPE) RETURN   BOOLEAN   IS  
 -- VAR_DECTOTRESIDUO    VCH_BUDGET_CPI.Dectotresiduo%type; 
BEGIN 
 INSERT INTO  VCH_BUDGET_CPI (CODCPI,                                                                                  
                              NUMANNOBUDGET,                                                            
                              DECTOTBUDGET ,                                                      
                              DECTOTIMPEGNATO ,                           
                              DECTOTSPESO     , 
                              DECTOTRESIDUO,                                                                         
                              CDNUTINS      ,                                                   
                              DTMINS        ,                                                        
                              CDNUTMOD      ,                                               
                              DTMMOD        ,                                                    
                              NUMKLOBUDGET  )
                      VALUES (PAR_CODCPI,
                              PAR_NUMANNOBUDGET,
                              PAR_DECTOTBUDGET,
                              PAR_DECTOTIMPEGNATO,
                              PAR_DECTOTSPESO,
                              PAR_DECTOTRESIDUO,
                              PAR_cdnUtente,
                              sysdate,
                              PAR_cdnUtente,
                              sysdate,
                              null /*GESTITO DA TRIGGER*/);
                                 
    RETURN (TRUE);

EXCEPTION
	WHEN OTHERS THEN
		    RETURN (FALSE);
END; 

FUNCTION insertOperazioneBudgetCPI (                                    
  PAR_NUMANNOBUDGET          in VCH_OPERAZIONI_BUDGET.NUMANNOBUDGET%type,                         
  PAR_DECIMPORTO             in VCH_OPERAZIONI_BUDGET.DECIMPORTO%type,                                
  PAR_DATOPERAZIONE          in VCH_OPERAZIONI_BUDGET.Datoperazione%type,                                   
  PAR_CODCPIDESTINAZIONE     in VCH_OPERAZIONI_BUDGET.Codcpidestinazione%type, 
  PAR_CDNUTINS               in VCH_OPERAZIONI_BUDGET.Cdnutins%type,             
  PAR_DTMINS                 in VCH_OPERAZIONI_BUDGET.Dtmins%type,                            
  PAR_NUMKLOOPERAZIONIBUDGET in VCH_OPERAZIONI_BUDGET.Numklooperazionibudget%type,                                
  PAR_CODOPERAZIONE          in VCH_OPERAZIONI_BUDGET.CODOPERAZIONE%type
 ) RETURN   BOOLEAN   IS  
BEGIN
 INSERT INTO  VCH_OPERAZIONI_BUDGET ( PRGOPERAZIONE,                                         
                                      NUMANNOBUDGET ,                         
                                      DECIMPORTO    ,                                
                                      DATOPERAZIONE  ,                                   
                                      CODCPIDESTINAZIONE, 
                                      CDNUTINS          ,             
                                      DTMINS            ,                  
                                      CDNUTMOD          ,         
                                      DTMMOD            ,              
                                      NUMKLOOPERAZIONIBUDGET,                                
                                      CODOPERAZIONE       )
                              VALUES (s_vch_operazioni_budget.nextval,
                                      PAR_NUMANNOBUDGET,
                                      PAR_DECIMPORTO,
                                      PAR_DATOPERAZIONE,
                                      PAR_CODCPIDESTINAZIONE,
                                      PAR_CDNUTINS,
                                      PAR_DTMINS,
                                      PAR_CDNUTINS,
                                      PAR_DTMINS,
                                      PAR_NUMKLOOPERAZIONIBUDGET,/*GESTITO DA TRIGGER*/
                                      PAR_CODOPERAZIONE );                                                                           
    RETURN (TRUE);

EXCEPTION
	WHEN OTHERS THEN
		    RETURN (FALSE);
END; 

PROCEDURE operazioneBudgetCPI (
  PAR_CODCPIDESTINAZIONE   in VCH_OPERAZIONI_BUDGET.CODCPIDESTINAZIONE%type, 
  PAR_NUMANNOBUDGET        in VCH_OPERAZIONI_BUDGET.NUMANNOBUDGET%type, 
  PAR_DATOPERAZIONE        in VCH_OPERAZIONI_BUDGET.DATOPERAZIONE%type,
  PAR_DECIMPORTO           in VCH_OPERAZIONI_BUDGET.DECIMPORTO%type,
  PAR_CODOPERAZIONE        in VCH_OPERAZIONI_BUDGET.CODOPERAZIONE%type,
  PAR_CODCPIALTRO          in VCH_OPERAZIONI_BUDGET.CODCPIDESTINAZIONE%type ,
  PAR_cdnUtente            in VCH_BUDGET_CPI.Cdnutins%TYPE,
  errCodeOut               out number,
  messaggioErr             out varchar2) IS
    
  VAR_NUMKLOBUDGETDEST   VCH_BUDGET_CPI.NUMKLOBUDGET%type;
  VAR_NUMKLOBUDGETALTRO  VCH_BUDGET_CPI.NUMKLOBUDGET%type;
  
BEGIN
 --CONTROLLO 1. presenza di tutti i parametri obbligatori di INPUT
 IF   PAR_CODCPIDESTINAZIONE is not null 
  and PAR_NUMANNOBUDGET is not null 
  and PAR_DATOPERAZIONE is not null  
  and PAR_DECIMPORTO is not null 
  and PAR_CODOPERAZIONE is not null
  and PAR_cdnUtente is not null
 THEN     
   IF PAR_CODOPERAZIONE  in ('U','E') -- operazioni gestite
   THEN
    IF PAR_CODCPIALTRO is not null
     AND presenzaBudgetCPI(PAR_NUMANNOBUDGET,PAR_CODCPIALTRO)=FALSE
     THEN
	  	errCodeOut := 30;
		  messaggioErr := 'Il budget nell''anno indicato dell''altro CPI coinvolto non esiste a sistema';      
     ELSE
       -- memorizzo il lock ottimistico tabelle
       VAR_NUMKLOBUDGETDEST := getValoLockTable ('NUMKLOBUDGET','VCH_BUDGET_CPI',' codcpi ='''||PAR_CODCPIDESTINAZIONE||''' and numannobudget ='||PAR_NUMANNOBUDGET);
       -- VAR_NUMKLOBUDGETDEST := getLockVchBudgetCpi(PAR_NUMANNOBUDGET,PAR_CODCPIDESTINAZIONE);
        IF PAR_CODCPIALTRO is not null  THEN
          VAR_NUMKLOBUDGETALTRO  :=  getValoLockTable ('NUMKLOBUDGET','VCH_BUDGET_CPI',' codcpi ='''||PAR_CODCPIALTRO||''' and numannobudget ='||PAR_NUMANNOBUDGET); 
          -- VAR_NUMKLOBUDGETALTRO  := getLockVchBudgetCpi(PAR_NUMANNOBUDGET,PAR_CODCPIALTRO);
        END IF;
         --*********************************
         -- operazioni primo CPI
         --*********************************
       IF PAR_CODOPERAZIONE ='U' --decremento
       THEN
         IF ControllaResiduoCPI (PAR_NUMANNOBUDGET,PAR_CODCPIDESTINAZIONE,PAR_DECIMPORTO ) >=0 --residuo CPI OK
         THEN
           -- decremento update PAR_CODCPIDESTINAZIONE
           -- insert operazione PAR_CODCPIDESTINAZIONE
           IF AggiornaBudgetCPI (PAR_CODCPIDESTINAZIONE,PAR_NUMANNOBUDGET,PAR_DECIMPORTO,'U',PAR_cdnUtente,VAR_NUMKLOBUDGETDEST) =TRUE
           AND InsertOperazioneBudgetCPI (PAR_NUMANNOBUDGET,PAR_DECIMPORTO,PAR_DATOPERAZIONE,PAR_CODCPIDESTINAZIONE,PAR_cdnUtente,sysdate,null,'U')=TRUE       
           THEN
              errCodeOut   := 00;
              messaggioErr := 'Operazione completata con successo'; 
           ELSE
              Rollback;
              errCodeOut := 90;
              messaggioErr := 'Errore modifica Budget CPI';
           END IF;         
         ELSE
          errCodeOut   := 10;
          messaggioErr := 'Il residuo del budget nell''anno indicato del CPI principale coinvolto non è sufficiente a comprire l''importo dell''operazione';   
         END IF;     
       ELSIF PAR_CODOPERAZIONE = 'E' --Incremento
       THEN
          IF PAR_CODCPIALTRO is not null
           AND ControllaResiduoCPI (PAR_NUMANNOBUDGET,PAR_CODCPIALTRO,PAR_DECIMPORTO ) < 0 --residuo CPI coinvolto non sufficiente
          THEN
            errCodeOut := 20;
            messaggioErr := 'Il residuo del budget nell''anno indicato dell''altro CPI coinvolto non è sufficiente a comprire l''importo dell''operazione.';    
          ELSE
           IF AggiornaBudgetCPI (PAR_CODCPIDESTINAZIONE,PAR_NUMANNOBUDGET,PAR_DECIMPORTO,'E',PAR_cdnUtente,VAR_NUMKLOBUDGETDEST) =TRUE
           AND InsertOperazioneBudgetCPI (PAR_NUMANNOBUDGET,PAR_DECIMPORTO,PAR_DATOPERAZIONE,PAR_CODCPIDESTINAZIONE,PAR_cdnUtente,sysdate,null,'E')=TRUE       
           THEN
              errCodeOut   := 00;
              messaggioErr := 'Operazione completata con successo'; 
           ELSE
              Rollback;
              errCodeOut := 90;
              messaggioErr := 'Errore modifica Budget CPI';
           END IF; 
          END IF;        
        END IF;        
     --*********************************       
     -- operazioni CPI coinvolto
     --*********************************
      IF PAR_CODCPIALTRO is not null -- è presente CPI coinvolto
      AND errCodeOut   = 00          -- non ci sono stati errori
      THEN
       IF PAR_CODOPERAZIONE ='U' --decremento
       THEN
           -- incremento update PAR_CODCPIALTRO
           -- insert operazione PAR_CODCPIALTRO 
         IF AggiornaBudgetCPI (PAR_CODCPIALTRO,PAR_NUMANNOBUDGET,PAR_DECIMPORTO,'E',PAR_cdnUtente,VAR_NUMKLOBUDGETALTRO) =TRUE
          AND InsertOperazioneBudgetCPI (PAR_NUMANNOBUDGET,PAR_DECIMPORTO,PAR_DATOPERAZIONE,PAR_CODCPIALTRO,PAR_cdnUtente,sysdate,null,'E')=TRUE       
          THEN
            errCodeOut   := 00;
            messaggioErr := 'Operazione completata con successo';  
          ELSE
            Rollback;
            errCodeOut := 90;
            messaggioErr := 'Errore modifica Budget CPI';
          END IF;
       ELSIF PAR_CODOPERAZIONE = 'E' --Incremento
       THEN
         -- NOTA disponibilità del decremente già verificata nello step del primo cpi
         -- decremento update PAR_CODCPIALTRO
         -- insert operazione PAR_CODCPIALTRO 
         IF AggiornaBudgetCPI (PAR_CODCPIALTRO,PAR_NUMANNOBUDGET,PAR_DECIMPORTO,'U',PAR_cdnUtente,VAR_NUMKLOBUDGETALTRO) =TRUE
          AND InsertOperazioneBudgetCPI (PAR_NUMANNOBUDGET,PAR_DECIMPORTO,PAR_DATOPERAZIONE,PAR_CODCPIALTRO,PAR_cdnUtente,sysdate,null,'U')=TRUE       
          THEN
            errCodeOut   := 00;
            messaggioErr := 'Operazione completata con successo';  
          ELSE
            Rollback;
            errCodeOut := 90;
            messaggioErr := 'Errore modifica Budget CPI';
          END IF;         
       END IF;
      END IF; 
     END IF;
   ELSE
       errCodeOut := 50;
       messaggioErr := 'Tipologia di operazione non gestita';
   END IF;
 ELSE
  errCodeOut := 40;
  messaggioErr := 'Parametri obbligatori di input incompleti';
 END IF; 
EXCEPTION
	WHEN OTHERS THEN
		errCodeOut := 99;
		messaggioErr := 'Errore durante la procedura di conferma operazione sul Budget';
END; 
  
PROCEDURE attivaBudgetCPI (
  PAR_NUMANNOBUDGET  in VCH_BUDGET_CPI.Numannobudget%type,
  PAR_CODCPI         in VCH_BUDGET_CPI.Codcpi%type,
  PAR_DECTOTBUDGET   in VCH_BUDGET_CPI.Dectotbudget%type,
  PAR_cdnUtente      in VCH_BUDGET_CPI.Cdnutins%TYPE,
	errCodeOut         out number,
	messaggioErr       out varchar2) IS
    
 BEGIN  
 --CONTROLLO 1. presenza di tutti i parametri di INPUT
 IF    PAR_NUMANNOBUDGET is not null 
  and  PAR_CODCPI is not null   
  and  PAR_DECTOTBUDGET is not null
  and  PAR_cdnUtente is not null 
 THEN
 --CONTROLLO 2. che il budget che si va a creare non esista già
  IF presenzaBudgetCPI(PAR_NUMANNOBUDGET,PAR_CODCPI)
  THEN
		errCodeOut := 10;
		messaggioErr := 'Il budget che si è richiesto di creare esiste già';
	ELSE
   BEGIN
    -- gestione insert
    IF InsertBudgetCPI (PAR_CODCPI,PAR_NUMANNOBUDGET,PAR_DECTOTBUDGET,0,0,PAR_DECTOTBUDGET,PAR_cdnUtente)=TRUE
     AND InsertOperazioneBudgetCPI (PAR_NUMANNOBUDGET,PAR_DECTOTBUDGET,trunc(sysdate),PAR_CODCPI,PAR_cdnUtente,sysdate,null,'E')=TRUE   
    THEN
      errCodeOut   := 00;
      messaggioErr := 'Operazione completata con successo';  
    ELSE
      Rollback;
      errCodeOut   := 90;
      messaggioErr := 'Errore Inserimento di un nuovo Budget per un CPI';
    END IF;
--  errCodeOut   := 00;
--  messaggioErr := 'Operazione completata con successo';                                 
   EXCEPTION
      WHEN OTHERS THEN
          Rollback;
          errCodeOut := 90;
          messaggioErr := 'Errore Inserimento di un nuovo Budget per un CPI';
   END;
  END IF;
 ELSE
  errCodeOut := 40;
  messaggioErr := 'Parametri obbligatori di input incompleti';
 END IF;
 
 EXCEPTION
	WHEN OTHERS THEN
		errCodeOut := 99;
		messaggioErr := 'Errore durante la procedura di creazione di un nuovo Budget per un CPI';
END; 

PROCEDURE insertEnte (
  PAR_STRCODICEFISCALE     in AN_VCH_ENTE.STRCODICEFISCALE%type, 
  PAR_CODSEDE              in AN_VCH_ENTE.CODSEDE%type,   
  PAR_STRDENOMINAZIONE     in AN_VCH_ENTE.STRDENOMINAZIONE%type, 
  PAR_STRINDIRIZZO         in AN_VCH_ENTE.STRINDIRIZZO%type,  
  PAR_CODCOM               in AN_VCH_ENTE.CODCOM%type,      
  PAR_STRNOTESTAMPE        in AN_VCH_ENTE.STRNOTESTAMPE%type, 
  PAR_cdnUtente            in AN_VCH_ENTE.Cdnutins%TYPE,
  errCodeOut               out number,
  messaggioErr             out varchar2) IS
  
BEGIN
 --CONTROLLO 1. presenza di tutti i parametri obbligatori di INPUT
 IF   PAR_STRCODICEFISCALE is not null 
  and PAR_CODSEDE is not null 
 THEN  
   BEGIN
     
    INSERT INTO  AN_VCH_ENTE (STRCODICEFISCALE,
                            CODSEDE           ,
                            STRDENOMINAZIONE  ,
                            STRINDIRIZZO      ,
                            CODCOM            ,
                            STRNOTESTAMPE     ,
                            DTMINS            ,
                            CDNUTINS          ,
                            DTMMOD            ,
                            CDNUTMOD          )
                    VALUES (PAR_STRCODICEFISCALE,
                            upper(PAR_CODSEDE)         ,
                            PAR_STRDENOMINAZIONE,
                            PAR_STRINDIRIZZO    ,
                            PAR_CODCOM          ,
                            PAR_STRNOTESTAMPE   ,
                            sysdate             ,
                            PAR_cdnUtente       ,
                            sysdate             ,
                            PAR_cdnUtente       );

     errCodeOut   := 00;
     messaggioErr := 'Operazione completata con successo';  
   Exception
    when DUP_VAL_ON_INDEX then
      Rollback;
      errCodeOut   := 90;
      messaggioErr := 'Errore Inserimento di un nuovo ente';               
   END;
 ELSE
  errCodeOut := 40;
  messaggioErr := 'Parametri obbligatori di input incompleti';
 END IF; 
EXCEPTION
	WHEN OTHERS THEN
		errCodeOut := 99;
		messaggioErr := 'Errore durante la procedura di accreditamento ente';
END; 

PROCEDURE updateEnte (
  PAR_STRCODICEFISCALE     in AN_VCH_ENTE.STRCODICEFISCALE%type, 
  PAR_CODSEDE              in AN_VCH_ENTE.CODSEDE%type,   
  PAR_STRDENOMINAZIONE     in AN_VCH_ENTE.STRDENOMINAZIONE%type, 
  PAR_STRINDIRIZZO         in AN_VCH_ENTE.STRINDIRIZZO%type,  
  PAR_CODCOM               in AN_VCH_ENTE.CODCOM%type,      
  PAR_STRNOTESTAMPE        in AN_VCH_ENTE.STRNOTESTAMPE%type, 
  PAR_cdnUtente            in AN_VCH_ENTE.Cdnutins%TYPE,
  errCodeOut               out number,
  messaggioErr             out varchar2) IS
  
BEGIN
 --CONTROLLO 1. presenza di tutti i parametri obbligatori di INPUT
 IF   PAR_STRCODICEFISCALE is not null 
  and PAR_CODSEDE is not null 
 THEN  
   BEGIN
    UPDATE AN_VCH_ENTE SET STRDENOMINAZIONE  = PAR_STRDENOMINAZIONE,
                           STRINDIRIZZO      = PAR_STRINDIRIZZO,
                           CODCOM            = PAR_CODCOM,
                           STRNOTESTAMPE     = PAR_STRNOTESTAMPE,
                           DTMMOD            = sysdate,
                           CDNUTMOD          = PAR_cdnUtente
    WHERE STRCODICEFISCALE = PAR_STRCODICEFISCALE
      AND CODSEDE          = PAR_CODSEDE;
      
     errCodeOut   := 00;
     messaggioErr := 'Operazione completata con successo';  
   Exception
    when others then
      Rollback;
      errCodeOut   := 91;
      messaggioErr := 'Errore aggiornamento Ente';                       
   END;
 ELSE
  errCodeOut := 40;
  messaggioErr := 'Parametri obbligatori di input incompleti';
 END IF; 
EXCEPTION
	WHEN OTHERS THEN
		errCodeOut := 99;
		messaggioErr := 'Errore durante la procedura di accreditamento ente';
END; 

PROCEDURE insertAccreditamento (
  PAR_STRCODICEFISCALE  in VCH_ENTE_ACCREDITATO.STRCODICEFISCALE%type,                     
  PAR_CODSEDE           in VCH_ENTE_ACCREDITATO.CODSEDE%type,
  PAR_PRGAZIONI         in VCH_ENTE_ACCREDITATO.PRGAZIONI%type,          
  PAR_DATINIZIOVAL      in VCH_ENTE_ACCREDITATO.DATINIZIOVAL%type,                      
  PAR_DATFINEVAL        in VCH_ENTE_ACCREDITATO.DATFINEVAL%type,                      
  PAR_CDNUTINS          in VCH_ENTE_ACCREDITATO.CDNUTINS%type,
  errCodeOut               out number,
  messaggioErr             out varchar2) IS
BEGIN 
 IF   PAR_STRCODICEFISCALE is not null 
  and PAR_CODSEDE is not null 
  and PAR_PRGAZIONI is not null 
  and PAR_DATINIZIOVAL is not null 
  and PAR_DATFINEVAL is not null 
  and PAR_CDNUTINS is not null
 THEN 
  IF PAR_DATINIZIOVAL <= PAR_DATFINEVAL
  THEN 
   BEGIN
    INSERT INTO  VCH_ENTE_ACCREDITATO (PRGENTEACCREDITATO  , 
                                       CODSEDE              ,              
                                       STRCODICEFISCALE     ,                
                                       PRGAZIONI            ,        
                                       DATINIZIOVAL         ,                   
                                       DATFINEVAL           ,                     
                                       CDNUTINS             ,     
                                       DTMINS               ,          
                                       CDNUTMOD             , 
                                       DTMMOD               ,     
                                       NUMKLOENTEACCREDITATO)
                               VALUES (s_vch_ente_accreditato.nextval  , 
                                       PAR_CODSEDE              ,              
                                       PAR_STRCODICEFISCALE     ,                
                                       PAR_PRGAZIONI            ,        
                                       PAR_DATINIZIOVAL         ,                   
                                       PAR_DATFINEVAL           ,                     
                                       PAR_CDNUTINS             ,     
                                       sysdate                  ,          
                                       PAR_CDNUTINS             , 
                                       sysdate                  ,     
                                       null/*GESTITO DA TRIGGER*/);
   
     errCodeOut   := 00;
     messaggioErr := 'Operazione completata con successo';  
   Exception
    when others then
      Rollback;
      errCodeOut   := 91;
      messaggioErr := 'Errore inserimeto accreditamento';
   END;
  ELSE
      Rollback;
      errCodeOut   := 93;
      messaggioErr := 'Errore Data inizio validità maggiore della data fine';
  END IF;
 ELSE
  errCodeOut := 40;
  messaggioErr := 'Parametri obbligatori di input incompleti';
 END IF;    

EXCEPTION
	WHEN OTHERS THEN
     Rollback;
      errCodeOut   := 91;
      messaggioErr := 'Errore inserimeto accreditamento';
END; 

PROCEDURE deleteAccreditamento (
  PAR_PRGENTEACCREDITATO  in VCH_ENTE_ACCREDITATO.PRGENTEACCREDITATO%type,                     
  errCodeOut              out number,
  messaggioErr            out varchar2) IS
  
  
  VAR_NUMEMISU number ;
BEGIN 
 IF   PAR_PRGENTEACCREDITATO is not null 
 THEN 
   BEGIN
   -- controllo se può essere eseguita la cancellazione
   -- può essere cancellato solo se non esiste nessun voucher 
   -- della stessa misura (azione) per quell'ente (CF + sede). 
   SELECT Count(*)
     INTO VAR_NUMEMISU
     FROM or_vch_voucher vc
        inner join or_percorso_concordato pc
            on vc.prgpercorso = pc.prgpercorso
        inner join VCH_ENTE_ACCREDITATO ente
           on ente.strcodicefiscale =vc.strcfenteaccreditato
           AND ente.codsede = vc.CODSEDE
           AND ente.prgazioni = pc.prgazioni
     WHERE ente.prgenteaccreditato=PAR_PRGENTEACCREDITATO;
     
     IF VAR_NUMEMISU =0
     THEN      
       DELETE VCH_ENTE_ACCREDITATO
        WHERE PRGENTEACCREDITATO =PAR_PRGENTEACCREDITATO;
        errCodeOut   := 00;
        messaggioErr := 'Operazione completata con successo';  
     ELSE
      errCodeOut := 20;
      messaggioErr := 'Non è possibile cancellare l''accreditamento perchè esiste almeno un Titolo di Acquisto attivato per questo soggetto. Se si desidera impedire nuove attivazioni modificare opportunamente le date di validità dell''accreditamento';
     END IF;
   Exception
    when others then
      Rollback;
      errCodeOut   := 91;
      messaggioErr := 'Errore cancellazione accreditamento';
   END;
 ELSE
  errCodeOut := 40;
  messaggioErr := 'Parametri obbligatori di input incompleti';
 END IF;    

EXCEPTION
	WHEN OTHERS THEN
     Rollback;
      errCodeOut   := 91;
      messaggioErr := 'Errore inserimeto accreditamento';
END; 

--updateAccreditamento
       -- memorizzo il lock ottimistico tabelle

PROCEDURE updateAccreditamento (
  PAR_PRGENTEACCREDITATO  in VCH_ENTE_ACCREDITATO.PRGENTEACCREDITATO%type,
  PAR_DATINIZIOVAL        in VCH_ENTE_ACCREDITATO.DATINIZIOVAL%type,                      
  PAR_DATFINEVAL          in VCH_ENTE_ACCREDITATO.DATFINEVAL%type,                      
  PAR_CDNUTMOD            in VCH_ENTE_ACCREDITATO.CDNUTMOD%type,
  errCodeOut               out number,
  messaggioErr             out varchar2) IS
  
  VAR_NUMKLOENTEACCREDITATO VCH_ENTE_ACCREDITATO.Numkloenteaccreditato%type;
BEGIN 
 IF   PAR_PRGENTEACCREDITATO is not null 
  and PAR_DATINIZIOVAL is not null 
  and PAR_DATFINEVAL is not null 
  and PAR_CDNUTMOD is not null
 THEN 
  IF PAR_DATINIZIOVAL <= PAR_DATFINEVAL
  THEN 
   BEGIN
    VAR_NUMKLOENTEACCREDITATO := getValoLockTable ('NUMKLOENTEACCREDITATO','VCH_ENTE_ACCREDITATO',' PRGENTEACCREDITATO ='||PAR_PRGENTEACCREDITATO);
    UPDATE VCH_ENTE_ACCREDITATO SET DATINIZIOVAL = PAR_DATINIZIOVAL,
                                    DATFINEVAL   = PAR_DATFINEVAL,
                                    CDNUTMOD     = PAR_CDNUTMOD,                                             
                                    DTMMOD       = sysdate,     
                                    NUMKLOENTEACCREDITATO  = VAR_NUMKLOENTEACCREDITATO + 1
                              WHERE PRGENTEACCREDITATO = PAR_PRGENTEACCREDITATO;
  
     errCodeOut   := 00;
     messaggioErr := 'Operazione completata con successo';  
   Exception
    when others then
      Rollback;
      errCodeOut   := 91;
      messaggioErr := 'Errore aggiornamento accreditamento';
   END;
  ELSE
      Rollback;
      errCodeOut   := 93;
      messaggioErr := 'Errore Data inizio validità maggiore della data fine';
  END IF;
 ELSE
  errCodeOut := 40;
  messaggioErr := 'Parametri obbligatori di input incompleti';
 END IF;    

EXCEPTION
	WHEN OTHERS THEN
     Rollback;
      errCodeOut   := 91;
      messaggioErr := 'Errore inserimeto accreditamento';
END; 

FUNCTION inserisciModelloTda (
	prgAzioniVar in VCH_MODELLO_VOUCHER.PRGAZIONI%type, 
	flagCMVar in VCH_MODELLO_VOUCHER.FLGCM%type,
	codSelModalitaVar in VCH_MODELLO_VOUCHER.CODSELEZMODALITA%type,
	numGGAttVar in VCH_MODELLO_VOUCHER.NUMNGMAXATTVCH%type,
	numGGErogVar in VCH_MODELLO_VOUCHER.NUMNGMAXEROGVCH%type,
	valTotVar in VCH_MODELLO_VOUCHER.DECVALTOT%type,
	cdnParUtenteVar in VCH_MODELLO_VOUCHER.CDNUTINS%TYPE) RETURN NUMBER IS
	
	prgModelloTdaVar VCH_MODELLO_VOUCHER.PRGMODVOUCHER%type;
 
BEGIN

	select S_VCH_MODELLO_VOUCHER.nextval
	into prgModelloTdaVar
	from dual;
	
	insert into VCH_MODELLO_VOUCHER(PRGMODVOUCHER,PRGAZIONI,DECVALTOT, NUMNGMAXATTVCH, NUMNGMAXEROGVCH, CODSELEZMODALITA, FLGATTIVO,
					FLGCM, CDNUTINS, DTMINS, CDNUTMOD, DTMMOD)			
	values (prgModelloTdaVar, prgAzioniVar ,valTotVar, numGGAttVar, numGGErogVar, codSelModalitaVar, 'N', flagCMVar,
			cdnParUtenteVar, sysdate, cdnParUtenteVar, sysdate);

	return prgModelloTdaVar;
	
EXCEPTION
	WHEN OTHERS THEN
		return -1;

END;

FUNCTION aggiornaModelloTda (
	prgModelloTdaVar in VCH_MODELLO_VOUCHER.PRGMODVOUCHER%type,
	numKLockVar in VCH_MODELLO_VOUCHER.NUMKLOMODVOUCHER%type, 
	flagCMVar in VCH_MODELLO_VOUCHER.FLGCM%type,
	codSelModalitaVar in VCH_MODELLO_VOUCHER.CODSELEZMODALITA%type,
	numGGAttVar in VCH_MODELLO_VOUCHER.NUMNGMAXATTVCH%type,
	numGGErogVar in VCH_MODELLO_VOUCHER.NUMNGMAXEROGVCH%type,
	valTotVar in VCH_MODELLO_VOUCHER.DECVALTOT%type,
	cdnParUtenteVar in VCH_MODELLO_VOUCHER.CDNUTINS%TYPE) RETURN NUMBER IS
 
BEGIN
	update VCH_MODELLO_VOUCHER
		set NUMKLOMODVOUCHER = numKLockVar +1,
			CDNUTMOD = cdnParUtenteVar,
			DTMMOD = sysdate,
			DECVALTOT = valTotVar,
			NUMNGMAXATTVCH = numGGAttVar,
			NUMNGMAXEROGVCH = numGGErogVar,
			CODSELEZMODALITA = codSelModalitaVar,
			FLGCM = flagCMVar
		where
			PRGMODVOUCHER = prgModelloTdaVar;
	
	 PG_LOG.doLog('U', 'VCH_MODELLO_VOUCHER', cdnParUtenteVar, ' WHERE PRGMODVOUCHER = ' || prgModelloTdaVar);
	
	return prgModelloTdaVar;
	
EXCEPTION
	WHEN OTHERS THEN
		return -1;

END;

FUNCTION gestioneModalitaModTda (
	tipoOperazioneVar in varchar,
	prgModelloTdaVar in VCH_MODELLO_VOUCHER.PRGMODVOUCHER%type,
	prgModalitaTdaVar in VCH_MODELLO_MODALITA.PRGMODMODALITA%type,
	numKLockVar in VCH_MODELLO_MODALITA.NUMKLOMODMODALITA%type, 
 	codModalitaErogVar in VCH_MODELLO_MODALITA.codvchmoderog%type, 
	tipoDurataVar in VCH_MODELLO_MODALITA.codtipologiadurata%type,
	durataMinvar in VCH_MODELLO_MODALITA.numduratamin%type,
	durataMaxvar in VCH_MODELLO_MODALITA.numduratamax%type,
	percentualeVar in VCH_MODELLO_MODALITA.NUMPERCPARCOMPLET%type,
	tipoRimborsoVar in VCH_MODELLO_MODALITA.codmonotiprimborso%type,
	valUnitVar in VCH_MODELLO_MODALITA.decValUnitario%type,
	valTotVar in VCH_MODELLO_MODALITA.decValTotale%type,
	cdnParUtenteVar in VCH_MODELLO_MODALITA.CDNUTINS%TYPE) RETURN NUMBER IS
 
	modelloAttivo VCH_MODELLO_VOUCHER.FLGATTIVO%type;
	prgModalitaKey VCH_MODELLO_MODALITA.PRGMODMODALITA%type;
	valTotValue VCH_MODELLO_MODALITA.decValTotale%type;
	
BEGIN
	
	select FLGATTIVO
	into modelloAttivo
	from VCH_MODELLO_VOUCHER
	where PRGMODVOUCHER = prgModelloTdaVar;
	
	if(modelloAttivo = 'S') then
		return -10;
	end if;

	if(tipoRimborsoVar = 'T' and (valUnitVar is not null or valUnitVar > 0)) then
		return -20;
	end if;
	
	if(tipoOperazioneVar = 'INSERISCI' and tipoRimborsoVar = 'C' and (valTotVar is not null or valTotVar > 0)) then  
		return -30;
	end if;
	
	if(tipoRimborsoVar = 'C' and (valUnitVar is null or valUnitVar <= 0)) then
		return -40;
	end if;

	valTotValue := valTotVar;
  
	/* calcola valore totale modalità*/
	if(tipoRimborsoVar = 'C') then 
		valTotValue := valUnitVar*durataMaxvar;
	end if;
	
	if(tipoOperazioneVar = 'INSERISCI') then 
		select S_VCH_MODELLO_MODALITA.nextval
		into prgModalitaKey
		from dual;

		insert into VCH_MODELLO_MODALITA (PRGMODMODALITA,PRGMODVOUCHER,CODTIPOLOGIADURATA, NUMDURATAMAX, NUMDURATAMIN, DECVALUNITARIO, DECVALTOTALE, NUMPERCPARCOMPLET,
					CODMONOTIPRIMBORSO,CODVCHMODEROG, CDNUTINS, DTMINS, CDNUTMOD, DTMMOD)
		values (prgModalitaKey, prgModelloTdaVar, tipoDurataVar, durataMaxvar, durataMinvar, valUnitVar, valTotValue, percentualeVar,
				   tipoRimborsoVar, codModalitaErogVar,cdnParUtenteVar,sysdate, cdnParUtenteVar, sysdate );

		return prgModalitaKey;
	end if;
	
	if(tipoOperazioneVar = 'AGGIORNA') then
		PG_LOG.doLog('U', 'VCH_MODELLO_MODALITA', cdnParUtenteVar, ' WHERE PRGMODMODALITA = ' || prgModalitaTdaVar);
		
		update VCH_MODELLO_MODALITA
		set NUMKLOMODMODALITA = numKLockVar +1,
			codvchmoderog = codModalitaErogVar,
			codtipologiadurata = tipoDurataVar,
			numduratamin = durataMinvar,
			numduratamax = durataMaxvar,
			NUMPERCPARCOMPLET = percentualeVar,
			codmonotiprimborso = tipoRimborsoVar,
			decValUnitario = valUnitVar,
			decValTotale = valTotValue,
			CDNUTMOD = cdnParUtenteVar,
			DTMMOD = sysdate
		where PRGMODMODALITA = prgModalitaTdaVar;
		
		return prgModalitaTdaVar;
	end if;
 
 
EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;

FUNCTION deleteModalitaModelloTDA (
	prgModalitaTdaVar in VCH_MODELLO_MODALITA.PRGMODMODALITA%type,
 	cdnParUtenteVar in VCH_MODELLO_MODALITA.CDNUTINS%TYPE) RETURN NUMBER IS
BEGIN
   PG_LOG.doLog('D', 'VCH_MODELLO_MODALITA', cdnParUtenteVar, ' WHERE PRGMODMODALITA = ' || prgModalitaTdaVar);
   delete from VCH_MODELLO_MODALITA where prgmodmodalita =prgModalitaTdaVar;
return 0;
 
EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;
END;

FUNCTION aggiornaValoreTotaleModelloTDA (
	prgModelloTdaVar in VCH_MODELLO_VOUCHER.PRGMODVOUCHER%type,
 	cdnParUtenteVar in VCH_MODELLO_VOUCHER.CDNUTMOD%TYPE) RETURN NUMBER IS
 
 	updataValoreTotale boolean := false;
	modelloAttivo VCH_MODELLO_VOUCHER.FLGATTIVO%type;
	tipoServizio de_azione.CODTIPOSERVIZIO%type;
	codSelezModello VCH_MODELLO_VOUCHER.CODSELEZMODALITA%type;
	valTotale VCH_MODELLO_VOUCHER.DECVALTOT%type;
	valMassimoAttuale VCH_MODELLO_MODALITA.decValTotale%type;
	numKLockModello VCH_MODELLO_VOUCHER.NUMKLOMODVOUCHER%type;
	
BEGIN
	
	select FLGATTIVO
	into modelloAttivo
	from VCH_MODELLO_VOUCHER
	where PRGMODVOUCHER = prgModelloTdaVar;
	
	if(modelloAttivo = 'S') then
		return 10;
	end if;
		
	SELECT codTipoServizio 
	into tipoServizio		   
	FROM DE_AZIONE 
    LEFT JOIN   VCH_MODELLO_VOUCHER modello  on (modello.PRGAZIONI = DE_AZIONE.PRGAZIONI) 
 	WHERE modello.PRGMODVOUCHER = prgModelloTdaVar;
 
	if(tipoServizio is null ) then
		return 50;
	end if;
	
	if( tipoServizio = 'SR') then
		return 40;
	end if;
	
	if( tipoServizio = 'SP') then
		updataValoreTotale := true;
	end if;
	 
	 if(updataValoreTotale) then
	 
	 	 select codselezmodalita 
		 into codSelezModello
		 from VCH_MODELLO_VOUCHER
		 where PRGMODVOUCHER = prgModelloTdaVar;
		 
		 select DECVALTOT 
		 into valTotale
		 from VCH_MODELLO_VOUCHER
		 where PRGMODVOUCHER = prgModelloTdaVar;
		 
		 if(codSelezModello = 'A' or codSelezModello = 'T') then
		 			select sum(decValTotale)
					 into valMassimoAttuale
					 from VCH_MODELLO_MODALITA
					 where prgmodvoucher = prgModelloTdaVar;
					 
					 valTotale := valMassimoAttuale;
		 else 
		 	if(codSelezModello = 'S') then
					 select max(decValTotale)
					 into valMassimoAttuale
					 from VCH_MODELLO_MODALITA
					 where prgmodvoucher = prgModelloTdaVar;
					 
					 valTotale := valMassimoAttuale;
			end if;
		end if;
		 
			PG_LOG.doLog('U', 'VCH_MODELLO_VOUCHER', cdnParUtenteVar, ' WHERE PRGMODVOUCHER = ' || prgModelloTdaVar);
			select NUMKLOMODVOUCHER 
			into numKLockModello
			from VCH_MODELLO_VOUCHER
			where prgmodvoucher = prgModelloTdaVar;
			
			update VCH_MODELLO_VOUCHER 
			set decvaltot = valTotale, 
				NUMKLOMODVOUCHER = numKLockModello+1, 
				CDNUTMOD = cdnParUtenteVar,
				DTMMOD = sysdate
			where prgmodvoucher = prgModelloTdaVar;
		 
	 end if;
		  
return 0;
 
EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;

FUNCTION controllaCoerenzaModello (
	prgModelloTdaVar in VCH_MODELLO_VOUCHER.PRGMODVOUCHER%type) RETURN NUMBER IS
	
	coerenzaModTda number := 0;
  	parametroControlloMod number := 4;
	moltiplicatoreModalita number := 0;
  	parametroControlloModalita number := 6;
	coerenzaModalita number := 0;
	coerenzaAttivita number := 0;
  	parametroControlloAttivita number := 0;
	
BEGIN
	
	/* CONTROLLO COERENZA- OBBLIGATORIETA' DATI MODELLO TDA */
	/* CONTROLLO BLOCCANTE*/
	SELECT
    SUM(t1.countMod) 
	into coerenzaModTda
	FROM (
      SELECT
          case when codselezmodalita is null then 0 else 1 end  AS countMod
     from VCH_MODELLO_VOUCHER
      where prgmodvoucher = prgModelloTdaVar
      UNION ALL
            SELECT
                case when numngmaxattvch is null then 0 else 1 end  AS countMod
            from VCH_MODELLO_VOUCHER
      where prgmodvoucher = prgModelloTdaVar
      UNION ALL
            SELECT
               case when numngmaxerogvch is null then 0 else 1 end  AS countMod
          from VCH_MODELLO_VOUCHER
      where prgmodvoucher = prgModelloTdaVar
       UNION ALL
            SELECT
               case when decvaltot is null then 0 else 1 end  AS countMod
          from VCH_MODELLO_VOUCHER
      where prgmodvoucher = prgModelloTdaVar
      ) t1;
      
      if(coerenzaModTda < parametroControlloMod) then
      	return 60;
      end if;
      
      /* CONTROLLO COERENZA- OBBLIGATORIETA' REGOLE MODALITA' MODELLO TDA */
      /* CONTROLLO BLOCCANTE*/
	  select count(*) 
	  into moltiplicatoreModalita
	  from VCH_MODELLO_MODALITA where prgmodvoucher = prgModelloTdaVar;
	  
	  SELECT
    	SUM(t2.countModalita) 
		into coerenzaModalita
		FROM (
      SELECT
          case when codtipologiadurata is null then 0 else 1 end  AS countModalita
     from VCH_MODELLO_MODALITA
      where prgmodvoucher = prgModelloTdaVar
      UNION ALL
            SELECT
                case when numduratamin is null then 0 else 1 end  AS countModalita
            from VCH_MODELLO_MODALITA
      where prgmodvoucher = prgModelloTdaVar
      UNION ALL
            SELECT
               case when numduratamax is null then 0 else 1 end  AS countModalita
          from VCH_MODELLO_MODALITA
      where prgmodvoucher = prgModelloTdaVar
       UNION ALL
            SELECT
               case when numpercparcomplet is null then 0 else 1 end  AS countModalita
          from VCH_MODELLO_MODALITA
      where prgmodvoucher = prgModelloTdaVar
      UNION ALL
            SELECT
               case when codmonotiprimborso is null then 0 else 1 end  AS countModalita
          from VCH_MODELLO_MODALITA
      where prgmodvoucher = prgModelloTdaVar
         UNION ALL
            SELECT
               case when decvaltotale is null then 0 else 1 end  AS countModalita
          from VCH_MODELLO_MODALITA
      where prgmodvoucher = prgModelloTdaVar
      ) t2;
      
      if(coerenzaModalita < parametroControlloModalita*moltiplicatoreModalita) then
      	return 70;
      end if;
      
      /*CONTROLLO COERENZA ATTIVITA*/
      /*CONTROLLO NON BLOCCANTE*/
      	select count(*)  
      	into coerenzaAttivita
		from DE_VCH_ATTIVITA att
		inner join REL_VCH_ATT_AZ on (att.CODVCHATTIVITA = REL_VCH_ATT_AZ.CODATTIVITA)
		inner join DE_AZIONE on (REL_VCH_ATT_AZ.PRGAZIONI = DE_AZIONE.PRGAZIONI)
		inner join VCH_MODELLO_VOUCHER on (VCH_MODELLO_VOUCHER.PRGAZIONI =  DE_AZIONE.PRGAZIONI)
		where VCH_MODELLO_VOUCHER.PRGMODVOUCHER = prgModelloTdaVar;
		
		if(coerenzaAttivita = parametroControlloAttivita) then
      		return 80;
      	end if;
      
return 0;
 
EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;

FUNCTION attivaDisattivaModello (
	prgModelloTdaVar in VCH_MODELLO_VOUCHER.PRGMODVOUCHER%type,
	cdnParUtenteVar in VCH_MODELLO_VOUCHER.CDNUTINS%TYPE,
	flgAttivoVar in VCH_MODELLO_VOUCHER.FLGATTIVO%TYPE) RETURN NUMBER IS
	
	numKLockModello VCH_MODELLO_VOUCHER.NUMKLOMODVOUCHER%type;
	
BEGIN

	PG_LOG.doLog('U', 'VCH_MODELLO_VOUCHER', cdnParUtenteVar, ' WHERE PRGMODVOUCHER = ' || prgModelloTdaVar);
			
	select NUMKLOMODVOUCHER 
	into numKLockModello
	from VCH_MODELLO_VOUCHER
	where prgmodvoucher = prgModelloTdaVar;
			
	update VCH_MODELLO_VOUCHER 
		set FLGATTIVO = flgAttivoVar, 
			NUMKLOMODVOUCHER = numKLockModello+1, 
			CDNUTMOD = cdnParUtenteVar,
			DTMMOD = sysdate
		where prgmodvoucher = prgModelloTdaVar;
	
	return 0;
 
EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;

end PG_GESTIONE_VOUCHER;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_IDO.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_IDO IS

  -- Author  : Davide giuliani, Stefania Orioli
  -- Purpose : Funzioni utilizzate nell'Incrocio Domnada Offerta
TYPE typRefCurs IS REF CURSOR;

FUNCTION storicizzaRichiesta(prgRichiestaAz NUMBER, flgCopia INTEGER, flgGestCopia INTEGER, ErrCodeOut OUT NUMBER) RETURN NUMBER;
FUNCTION reiteraRichAzienda( pPrgRichSTR      		 VARCHAR2,
                             pPrgAziendaSTR   		 VARCHAR2,
                             pPrgUnitaSTR     		 VARCHAR2,
                             pDatRichiestaSTR 		 VARCHAR2,
                             pDatScadenzaSTR  		 VARCHAR2,
                             pFlgPubblSTR     		 VARCHAR2,
                             pDatPubblSTR     		 VARCHAR2,
                             pDatScadPubblSTR 		 VARCHAR2,
                             pCdnUtInsModSTR  		 VARCHAR2,
                             pSTRMANSIONEPUBB 		 VARCHAR2,
                           	 pCODCPI          		 VARCHAR2,
                             pFLGART16        		 VARCHAR2,
                             pSTRSESSO        		 VARCHAR2,
                    	     pcodMotGenere    		 VARCHAR2,
                             pSTRMOTIVSESSO   		 VARCHAR2,
                             pNUMPROFRICHIESTIstr    VARCHAR2,
                             pSTRLOCALITA            VARCHAR2,
                             pPRGSPIstr              VARCHAR2,
                             pSTRCOGNOMERIFERIMENTO  VARCHAR2,
                             pSTRNOMERIFERIMENTO     VARCHAR2,
                             pSTRTELRIFERIMENTO      VARCHAR2,
                             pSTRFAXRIFERIMENTO      VARCHAR2,
                             pSTREMAILRIFERIMENTO    VARCHAR2,
                             pFLGAUTOMUNITO          VARCHAR2,
                             pFLGMILITE              VARCHAR2,
                             pFLGMOTOMUNITO          VARCHAR2,
                             pFLGVITTOALLOGGIO       VARCHAR2,
                             pFLGVITTO               VARCHAR2,
                             pFLGTURISMO             VARCHAR2,
                             pCODTRASFERTA           VARCHAR2,
                             pFLGFUORISEDE           VARCHAR2,
                             pTXTFIGURAPROFESSIONALE VARCHAR2,
                             pTXTCARATTERISTFIGPROF  VARCHAR2,
                             pTXTCONDCONTRATTUALE    VARCHAR2,
                             pTXTNOTEOPERATORE       VARCHAR2,
                             pCODAREA                VARCHAR2,
                             pCdnGruppoStr           VARCHAR2,
                             pNumPostoAS             VARCHAR2,
                             pNumPostoLSU            VARCHAR2,
                             pNumPostoMilitare       VARCHAR2,
                             pNumPostoMB             VARCHAR2,
                             pFlgRiusoGraduatoria    VARCHAR2,
                             ptipoLSU                VARCHAR2,
                             pDatChiamata            VARCHAR2,
                             pFlagAS                 VARCHAR2,
                             pCodMonoTipoGrado       VARCHAR2,
                             pNumPostiCM             VARCHAR2,
               			     pNumAnnoRedditoCM       VARCHAR2,
                             pDatChiamataCM          VARCHAR2,
                             pCodTipoLista           VARCHAR2,
                             pFlagCM                 VARCHAR2,
                             pFlgSvantaggiati        VARCHAR2,
                             pStrMotSvantaggiati     VARCHAR2,
                             pDatVerificaSvanStr     VARCHAR2,
                             pFlgDisNonIscr          VARCHAR2,
                             pStrMotNonIscr          VARCHAR2,
                             pDatVerificaDis         VARCHAR2,
							 pFlagParAsOnline		 VARCHAR2
               ) RETURN VARCHAR2;
procedure pdStorico_AZ (prgParAzienda in AN_AZIENDA.PRGAZIENDA%TYPE,
           strParCodicefiscale in AN_AZIENDA.STRCODICEFISCALE%TYPE,
         strParPartitaiva  in AN_AZIENDA.STRPARTITAIVA%TYPE,
         strParRagionesociale in AN_AZIENDA.STRRAGIONESOCIALE%TYPE,
           codParNatgiuridica in AN_AZIENDA.CODNATGIURIDICA%TYPE,
           codParTipoazienda in AN_AZIENDA.CODTIPOAZIENDA%TYPE,
      strParUtente in TS_UTENTE.CDNUT%TYPE);
procedure pdStorico_UA (prgParAzienda in AN_UNITA_AZIENDA.PRGAZIENDA%TYPE,
           prgParUnita in AN_UNITA_AZIENDA.PRGUNITA%TYPE,
      codParCom in AN_UNITA_AZIENDA.CODCOM%TYPE,
       codParazstato in AN_UNITA_AZIENDA.CODAZSTATO%TYPE,
       codParateco in AN_UNITA_AZIENDA.CODATECO%TYPE,
      strParUtente in TS_UTENTE.CDNUT%TYPE);
function protocolla ( pNumProtocolloStr VARCHAR2,
                      pNumAnnoProtStr   VARCHAR2,
                      pDataProtStr      VARCHAR2,
                      pAutomatica       VARCHAR2
                    ) return number;
procedure pdInsRichiesta_az (prgParAzienda in DO_RICHIESTA_AZ.PRGAZIENDA%TYPE,
             prgParUnita in DO_RICHIESTA_AZ.PRGUNITA%TYPE,
        prgParRichiesta in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
        strParUtente in TS_UTENTE.CDNUT%TYPE,
        numParStorico in DO_RICHIESTA_AZ.numstorico%TYPE,
        flgParFuoriSede in DO_RICHIESTA_AZ.FLGFUORISEDE%TYPE);
function WebStrMansioni(parPrgRichiestaAz in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE) return varchar2;
function WebStrContratti(parPrgRichiestaAz in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE) return varchar2;
function WebStrTerritorio(parPrgRichiestaAz in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE) return varchar2;
function WebGrigliaProvQuery return varchar2;
--griglia per il modulo AS
function WebGrigliaASQuery return typRefCurs;

function WebGrigliaCMQuery RETURN typRefCurs;

--
function cancAutomaticaDaRosa(p_prgRosa DO_NOMINATIVO.PRGROSA%type,
          p_cdnUt DO_NOMINATIVO.CDNUTCANC%type,
         p_prgRichOrig DO_INCROCIO.PRGRICHIESTAAZ%type) RETURN NUMBER;


function deleteCopiaRichiesta(pRichiesta DO_ALTERNATIVA.prgRichiestaAz%TYPE)return number;

function resetCopiaRichiesta(pRichiesta DO_ALTERNATIVA.prgRichiestaAz%TYPE) return number;

function WebStrMansioniProfilo(parPrgRichiestaAz in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
                               parPrgAlternativa in DO_ALTERNATIVA.PRGALTERNATIVA%TYPE) return varchar2;

function WebStrContrattiProfilo(parPrgRichiestaAz in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
                                parPrgAlternativa in DO_ALTERNATIVA.PRGALTERNATIVA%TYPE) return varchar2;

/****************************************************************************************
* Salva il riferimento del documento per le richieste trovate - tabella AS_REL_RICH_DOC *
****************************************************************************************/
function ASInsRelDocRich(p_prgDocumento number,
                         dataChiamata varchar2,
                         codCpi varchar2,
                         modPubblicazione varchar2,
                         p_errCode OUT number
                         ) RETURN NUMBER;

function STR_EVASIONE(PAR_STR VARCHAR2) RETURN VARCHAR2;

END PG_IDO;
/
CREATE OR REPLACE PACKAGE BODY PG_IDO IS
/*
PROCEDURE prova(pAnno am_protocollo.NUMANNOPROT%TYPE)IS
ESITO VARCHAR2(10);
varNumProt AM_PROTOCOLLO.NUMPROTOCOLLO%TYPE;
BEGIN
 SELECT AM_PROTOCOLLO.NUMPROTOCOLLO INTO varNumProt
   FROM AM_PROTOCOLLO
  WHERE AM_PROTOCOLLO.NUMANNOPROT = pAnno;
 UPDATE AM_PROTOCOLLO
    SET AM_PROTOCOLLO.NUMPROTOCOLLO = varNumProt+1000,
        AM_PROTOCOLLO.NUMKLOPROTOCOLLO = AM_PROTOCOLLO.NUMKLOPROTOCOLLO+1
  WHERE AM_PROTOCOLLO.NUMANNOPROT = pAnno;
END;
*/
FUNCTION storicizzaRichiesta(prgRichiestaAz NUMBER, flgCopia INTEGER, flgGestCopia INTEGER, ErrCodeOut OUT NUMBER ) RETURN NUMBER IS
  pPrgRich    do_richiesta_az.PRGRICHIESTAAZ%TYPE;
  prgRichOriginale do_richiesta_az.PRGRICHIESTAAZ%TYPE;
  vNewPrgRich do_richiesta_az.PRGRICHIESTAAZ%TYPE;
  vFlgExp     do_alternativa.FLGESPERIENZA%TYPE;
  vFlgFroma   do_alternativa.FLGFORMAZIONEPROF%TYPE;
  vNuma       do_alternativa.NUMA%TYPE;
  vNamAss     do_alternativa.NUMANNIESPERIENZA%TYPE;
  vNumDA      do_alternativa.NUMDA%TYPE;
  vCodMotEta  do_alternativa.CODMOTETA%TYPE;
  vStrMotEta  do_alternativa.STRMOTIVETA%TYPE;
  vStrNote    do_alternativa.STRNOTE%TYPE;
  codev       DO_EVASIONE.CODEVASIONE%TYPE;
  cstatorich     DO_EVASIONE.CDNSTATORICH%TYPE;
  cmonostatorich  DO_EVASIONE.CODMONOSTATORICH%TYPE;
 prgcopia    do_richiesta_az.PRGRICHIESTAAZ%TYPE;
 p_numStorico  do_richiesta_az.NUMSTORICO%TYPE;
 p_numAnno do_richiesta_az.NUMANNO%TYPE;
 p_numRichiesta do_richiesta_az.NUMRICHIESTA%TYPE;
  vExistRecord INTEGER;
  cdn integer;
  conta integer;
  codEsitRich do_evasione.codesitorichiesta%TYPE;
  p_flggraduatoria de_evasione_rich.flggraduatoria%type;
BEGIN
 pPrgRich      := prgRichiestaAz;

 -- nel caso si tratta di una richiesta per l'art.16 non bisogna storicizzarla
 select evr.flggraduatoria into p_flggraduatoria
 from do_richiesta_az ric
 LEFT OUTER join do_evasione ev on ev.prgrichiestaaz = ric.prgrichiestaaz
 LEFT OUTER join de_evasione_rich evr on evr.codevasione = ev.codevasione
 where ric.prgrichiestaaz = pPrgRich;

 if (p_flggraduatoria is not null) then
    return prgRichiestaAz;
 end if;

 -- cambio stato di evasione della richiesta
 -- E' stato spostato nel salvataggio della rosa grezza
 /*
    UPDATE DO_EVASIONE
    SET   DO_EVASIONE.CDNSTATORICH=2
    WHERE  DO_EVASIONE.PRGRICHIESTAAZ = pPrgRich
    and DO_EVASIONE.CDNSTATORICH=1;
  */
 -- VERIFICO L'ESISTENZA DELLA COPIA LAVORO
  SELECT
      count(*)
   INTO
   conta
  FROM
    DO_RICHIESTA_AZ az1,
    DO_RICHIESTA_AZ az2
  WHERE
    az1.numstorico=1 and
    az1.numanno=az2.numanno and
    az1.numRichiesta=az2.numRichiesta and
    az2.prgRichiestaAz = pPrgRich;
if (conta> 0 ) then
  SELECT az1.prgrichiestaaz
   INTO
   prgcopia
  FROM
    DO_RICHIESTA_AZ az1,
    DO_RICHIESTA_AZ az2
  WHERE
    az1.numstorico=1 and
    az1.numanno=az2.numanno and
    az1.numRichiesta=az2.numRichiesta and
    az2.prgRichiestaAz = pPrgRich;
end if;
 IF (conta = 0 and flgGestCopia = 1)  THEN
     -- CREO IL NUOVO RECORD E LO DUPLICO
  SELECT S_do_richiesta_az.nextval INTO vNewPrgRich FROM DUAL;
  INSERT INTO do_richiesta_az
  (PRGRICHIESTAAZ,
   NUMANNO,
   NUMRICHIESTA,
   NUMSTORICO,
   PRGAZIENDA,
   PRGUNITA,
   CODCPI,
   DATRICHIESTA,
   PRGRICHIESTAPADRE,
   CODTIPORICHIESTA,
   FLGART16,
   STRSESSO,
   FLGPUBBLICATA,
   STRMOTIVSESSO,
   DATPUBBLICAZIONE,
   DATSCADENZAPUBBLICAZIONE,
   DATSCADENZA,
   NUMPROFRICHIESTI,
   STRLOCALITA,
   PRGSPI,
   STRCOGNOMERIFERIMENTO,
   STRNOMERIFERIMENTO,
   STRTELRIFERIMENTO,
   STRFAXRIFERIMENTO,
   STREMAILRIFERIMENTO,
   FLGAUTOMUNITO,
   FLGMILITE,
   FLGMOTOMUNITO,
   FLGVITTOALLOGGIO,
   FLGVITTO,
   FLGTURISMO,
   CODTRASFERTA,
   FLGFUORISEDE,
   TXTFIGURAPROFESSIONALE,
   TXTCARATTERISTFIGPROF,
   TXTCONDCONTRATTUALE,
   TXTNOTEOPERATORE,
   CODAREA,
   CODMOTGENERE,
   CDNUTINS,
   CDNUTMOD,
   DTMINS,
   DTMMOD,
   NUMKLORICHIESTAAZ,
   STRCOGNOMERIFPUBB ,
   STRNOMERIFPUBB ,
   STRTELRIFPUBB ,
   STRFAXRIFPUBB ,
   STREMAILRIFPUBB ,
   STRDATIAZIENDAPUBB,
   STRMANSIONEPUBB,
   STRLUOGOLAVORO,
   STRFORMAZIONEPUBB,
   STRCONOSCENZEPUBB,
   STRNOTEORARIOPUBB,
   STRRIFCANDIDATURAPUBB,
   codqualifica,
   cdnGruppo,
   CODMONOCMCATEGORIA,
   FLGSVANTAGGIATI,
   STRMOTSVANTAGGIATI,
   DATVERIFICASVAN,
   FLGDISNONISCR,
   STRMOTNONISCR,
   DATVERIFICADIS,
   CODRAPPORTOLAV,
   FLGNULLAOSTA, CODPROVINCIAPROV, NUMRICHIESTAORIG
  )
 SELECT  vNewPrgRich,
   raz.NUMANNO,
   raz.NUMRICHIESTA,
   raz.NUMSTORICO+1,
   raz.PRGAZIENDA,
   raz.PRGUNITA,
   raz.CODCPI,
   raz.DATRICHIESTA,
   raz.PRGRICHIESTAPADRE,
   raz.CODTIPORICHIESTA,
   raz.FLGART16,
   raz.STRSESSO,
   raz.FLGPUBBLICATA,
   raz.STRMOTIVSESSO,
   raz.DATPUBBLICAZIONE,
   raz.DATSCADENZAPUBBLICAZIONE,
   raz.DATSCADENZA,
   raz.NUMPROFRICHIESTI,
   raz.STRLOCALITA,
   raz.PRGSPI,
   raz.STRCOGNOMERIFERIMENTO,
   raz.STRNOMERIFERIMENTO,
   raz.STRTELRIFERIMENTO,
   raz.STRFAXRIFERIMENTO,
   raz.STREMAILRIFERIMENTO,
   raz.FLGAUTOMUNITO,
   raz.FLGMILITE,
   raz.FLGMOTOMUNITO,
   raz.FLGVITTOALLOGGIO,
   raz.FLGVITTO,
   raz.FLGTURISMO,
   raz.CODTRASFERTA,
   raz.FLGFUORISEDE,
   raz.TXTFIGURAPROFESSIONALE,
   raz.TXTCARATTERISTFIGPROF,
   raz.TXTCONDCONTRATTUALE,
   raz.TXTNOTEOPERATORE,
   raz.CODAREA,
   raz.CODMOTGENERE,
   raz.CDNUTINS,
   raz.CDNUTMOD,
   SYSDATE,
   SYSDATE,
   raz.NUMKLORICHIESTAAZ,
   raz.STRCOGNOMERIFPUBB ,
   raz.STRNOMERIFPUBB ,
   raz.STRTELRIFPUBB ,
   raz.STRFAXRIFPUBB ,
   raz.STREMAILRIFPUBB ,
   raz.STRDATIAZIENDAPUBB,
   raz.STRMANSIONEPUBB,
   raz.STRLUOGOLAVORO,
   raz.STRFORMAZIONEPUBB,
   raz.STRCONOSCENZEPUBB,
   raz.STRNOTEORARIOPUBB,
   raz.STRRIFCANDIDATURAPUBB,
   raz.codqualifica,
   raz.cdnGruppo,
   raz.CODMONOCMCATEGORIA,
   raz.FLGSVANTAGGIATI,
   raz.STRMOTSVANTAGGIATI,
   raz.DATVERIFICASVAN,
   raz.FLGDISNONISCR,
   raz.STRMOTNONISCR,
   raz.DATVERIFICADIS,
   raz.CODRAPPORTOLAV,
   raz.FLGNULLAOSTA, raz.CODPROVINCIAPROV, raz.NUMRICHIESTAORIG
 from do_richiesta_az raz
 where raz.PRGRICHIESTAAZ = pPrgRich;
 -- COPIO LA DO_ALTERNATIVA
 -- la insert precedente sulla tabella do_richiesata_az fa scattare un trigger che inserisce già dei campi
 -- nella do_alternativa con il nuovo PRGRICHIESTAAZ e con PRGALTERNATIVA=1. Occorre quindi solo inserire
 -- i nuovi valori con una UPDATE
SELECT do_alternativa.FLGESPERIENZA,
       do_alternativa.FLGFORMAZIONEPROF,
      do_alternativa.NUMA,
      do_alternativa.NUMANNIESPERIENZA,
      do_alternativa.NUMDA,
    do_alternativa.CODMOTETA,
      do_alternativa.STRMOTIVETA,
      do_alternativa.STRNOTE
  INTO vFlgExp, vFlgFroma, vNuma, vNamAss, vNumDA, vCodMotEta, vStrMotEta, vStrNote
  FROM do_alternativa
 WHERE do_alternativa.prgalternativa = 1
   AND do_alternativa.PRGRICHIESTAAZ = pPrgRich;
UPDATE do_alternativa
   SET FLGESPERIENZA = vFlgExp,
       FLGFORMAZIONEPROF = vFlgFroma,
      NUMA = vNuma,
      NUMANNIESPERIENZA = vNamAss,
      NUMDA = vNumDA,
    CODMOTETA = vCodMotEta,
      STRMOTIVETA = vStrMotEta,
      STRNOTE = vStrNote
 WHERE do_alternativa.prgalternativa = 1
   AND do_alternativa.PRGRICHIESTAAZ = vNewPrgRich;
--inserisco le altre alternative cioè quellli con PRGALTERNATIVA>1(se esistenti)
insert into do_alternativa
     ( PRGRICHIESTAAZ,
     FLGESPERIENZA,
      FLGFORMAZIONEPROF,
     NUMA,
     NUMANNIESPERIENZA,
     NUMDA,
     PRGALTERNATIVA,
   CODMOTETA,
     STRMOTIVETA,
     STRNOTE,
     CDNUTINS,
     CDNUTMOD,
     DTMINS,
     DTMMOD
     )
 select vNewPrgRich,-- prg In Cui inserire
      do_alternativa.FLGESPERIENZA,
       do_alternativa.FLGFORMAZIONEPROF,
      do_alternativa.NUMA,
      do_alternativa.NUMANNIESPERIENZA,
      do_alternativa.NUMDA,
      do_alternativa.PRGALTERNATIVA,
   do_alternativa.CODMOTETA,
      do_alternativa.STRMOTIVETA,
      do_alternativa.STRNOTE,
    do_alternativa.CDNUTINS,
   do_alternativa.CDNUTMOD,
     SYSDATE,
    SYSDATE
   from do_alternativa
  where do_alternativa.PRGALTERNATIVA > 1
    and do_alternativa.PRGRICHIESTAAZ = pPrgRich;
 -- ************ COPIA RECORD DELLA DO_ABILITAZIONE_GEN  **************
 SELECT COUNT(1) INTO vExistRecord FROM DO_ABILITAZIONE_GEN  WHERE prgRichiestaAz = pPrgRich;
 IF (vExistRecord<>0) THEN
 INSERT INTO DO_ABILITAZIONE_GEN
       (
     PRGRICHIESTAAZ,
        CODABILITAZIONEGEN,
      FLGINDISPENSABILE,
         CDNUTINS,
         CDNUTMOD,
         DTMINS,
         DTMMOD,
         FLGINVIOCL
       )
 SELECT vNewPrgRich,
        DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN,
        DO_ABILITAZIONE_GEN.FLGINDISPENSABILE,
        DO_ABILITAZIONE_GEN.CDNUTINS,
     DO_ABILITAZIONE_GEN.CDNUTMOD,
        SYSDATE,
        SYSDATE,
        DO_ABILITAZIONE_GEN.FLGINVIOCL
  FROM DO_ABILITAZIONE_GEN
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 -- ********************** PROVINCIA **************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_PROVINCIA  WHERE prgRichiestaAz = pPrgRich;
 IF (vExistRecord<>0) THEN
 INSERT INTO DO_PROVINCIA
       (
     PRGRICHIESTAAZ,
        PRGPROVINCIA,
      CODPROVINCIA,
         CDNUTINS,
         CDNUTMOD,
         DTMINS,
         DTMMOD
       )
 SELECT vNewPrgRich,
        S_DO_PROVINCIA.NEXTVAL,
        DO_PROVINCIA.CODPROVINCIA,
        DO_PROVINCIA.CDNUTINS,
     DO_PROVINCIA.CDNUTMOD,
        SYSDATE,
        SYSDATE
   FROM DO_PROVINCIA
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 -- ************************** CITTADINZANZA **************************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_CITTADINANZA  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_CITTADINANZA
       (PRGRICHIESTAAZ,
       PRGCITTADINANZA,
        CODCITTADINANZA,
     CODMOTNAZIONALITA,
       STRMOTIVAZIONE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
        S_DO_CITTADINANZA.NEXTVAL,
        DO_CITTADINANZA.CODCITTADINANZA,
     DO_CITTADINANZA.CODMOTNAZIONALITA,
        DO_CITTADINANZA.STRMOTIVAZIONE,
        DO_CITTADINANZA.CDNUTINS,
     DO_CITTADINANZA.CDNUTMOD,
       SYSDATE,
        SYSDATE
   FROM DO_CITTADINANZA
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --******************************* ORARIO ***************************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_ORARIO  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_ORARIO
       (
     PRGRICHIESTAAZ,
     PRGORARIO,
     CODORARIO,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD,
        FLGINVIOCL
       )
 SELECT vNewPrgRich,
        S_DO_ORARIO.NEXTVAL,
     DO_ORARIO.CODORARIO,
        DO_ORARIO.CDNUTINS,
     DO_ORARIO.CDNUTMOD,
     SYSDATE,
        SYSDATE,
        DO_ORARIO.FLGINVIOCL
  FROM DO_ORARIO
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --************************************ TURNO **********************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_TURNO  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_TURNO
       (PRGRICHIESTAAZ,
       PRGTURNO,
       CODTURNO,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
        S_DO_TURNO.NEXTVAL,
     DO_TURNO.CODTURNO,
        DO_TURNO.CDNUTINS,
     DO_TURNO.CDNUTMOD,
     SYSDATE,
        SYSDATE
   FROM DO_TURNO
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --************************************* COMUNE **********************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_COMUNE  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_COMUNE
       (PRGRICHIESTAAZ,
     PRGCOMUNE,
     CODCOM,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD,
        FLGINVIOCL
      )
 SELECT vNewPrgRich,
        S_DO_COMUNE.NEXTVAL,
     DO_COMUNE.CODCOM,
        DO_COMUNE.CDNUTINS,
        DO_COMUNE.CDNUTMOD,
     SYSDATE,
        SYSDATE,
        DO_COMUNE.FLGINVIOCL
   FROM DO_COMUNE
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --************************************* EVASIONE **********************************
 -- COPIO LA DO_EVASIONE
 -- la insert precedente sulla tabella do_richiesata_az fa scattare un trigger che inserisce già dei campi
 -- nella DO_EVASIONE con il nuovo PRGRICHIESTAAZ  Occorre quindi solo inserire
 -- i nuovi valori con una UPDATE
 SELECT  DO_EVASIONE.CODEVASIONE,
        DO_EVASIONE.CDNSTATORICH,
        DO_EVASIONE.CODMONOSTATORICH,
          DO_EVASIONE.CODESITORICHIESTA
   INTO codev, cstatorich, cmonostatorich, codEsitRich   FROM DO_EVASIONE
  WHERE  DO_EVASIONE.PRGRICHIESTAAZ = pPrgRich;
 UPDATE DO_EVASIONE
    SET  DO_EVASIONE.CODEVASIONE =codev,
        DO_EVASIONE.CDNSTATORICH=cstatorich,
        DO_EVASIONE.CODMONOSTATORICH= cmonostatorich,
          DO_EVASIONE.CODESITORICHIESTA= codEsitRich
  WHERE  DO_EVASIONE.PRGRICHIESTAAZ = vNewPrgRich;
 -- Aggiorniamo le tabelle relative alle alternative
 SELECT COUNT(1) INTO vExistRecord FROM DO_AGEVOLAZIONE  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_AGEVOLAZIONE
       (
     PRGRICHIESTAAZ,
     PRGAGEVOLAZIONE,
     PRGALTERNATIVA,
     CODAGEVOLAZIONE,
     FLGINDISPENSABILE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
     S_DO_AGEVOLAZIONE.NEXTVAL,
     DO_AGEVOLAZIONE.PRGALTERNATIVA,
     DO_AGEVOLAZIONE.CODAGEVOLAZIONE,
     DO_AGEVOLAZIONE.FLGINDISPENSABILE,
        DO_AGEVOLAZIONE.CDNUTINS,
        DO_AGEVOLAZIONE.CDNUTMOD,
     SYSDATE,
        SYSDATE
   FROM DO_AGEVOLAZIONE
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 SELECT COUNT(1) INTO vExistRecord FROM DO_CONTRATTO  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_CONTRATTO
       (
     PRGRICHIESTAAZ,
     PRGALTERNATIVA,
     PRGCONTRATTO,
     CODCONTRATTO,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD,
        FLGINVIOCL
       )
 SELECT vNewPrgRich,
     DO_CONTRATTO.PRGALTERNATIVA,
        S_DO_CONTRATTO.NEXTVAL,
     DO_CONTRATTO.CODCONTRATTO,
        DO_CONTRATTO.CDNUTINS,
        DO_CONTRATTO.CDNUTMOD,
     SYSDATE,
        SYSDATE,
        DO_CONTRATTO.FLGINVIOCL
   FROM DO_CONTRATTO
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 SELECT COUNT(1) INTO vExistRecord FROM DO_COMPETENZA  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_COMPETENZA
       (PRGRICHIESTAAZ,
     PRGALTERNATIVA,
     PRGCOMPETENZA,
     CODCOMPETENZA,
     FLGINDISPENSABILE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
     DO_COMPETENZA.PRGALTERNATIVA,
        S_DO_COMPETENZA.NEXTVAL,
     DO_COMPETENZA.CODCOMPETENZA,
     DO_COMPETENZA.FLGINDISPENSABILE,
        DO_COMPETENZA.CDNUTINS,
        DO_COMPETENZA.CDNUTMOD,
     SYSDATE,
        SYSDATE
   FROM DO_COMPETENZA
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 SELECT COUNT(1) INTO vExistRecord FROM DO_STUDIO  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_STUDIO
       (
     PRGRICHIESTAAZ,
     PRGALTERNATIVA,
     PRGSTUDIO,
       CODTITOLO,
       FLGCONSEGUITO,
       FLGINDISPENSABILE,
       STRSPECIFICA,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
     DO_STUDIO.PRGALTERNATIVA,
        S_DO_STUDIO.NEXTVAL,
       DO_STUDIO.CODTITOLO,
       DO_STUDIO.FLGCONSEGUITO,
       DO_STUDIO.FLGINDISPENSABILE,
       DO_STUDIO.STRSPECIFICA,
        DO_STUDIO.CDNUTINS,
        DO_STUDIO.CDNUTMOD,
     SYSDATE,
        SYSDATE
   FROM DO_STUDIO
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 
 
SELECT COUNT(1) INTO vExistRecord FROM DO_FORMAZIONE_PROF  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_FORMAZIONE_PROF
       (PRGRICHIESTAAZ, 
        PRGFORMPROF,      
	    PRGALTERNATIVA, 
		CODCORSO, 
		CDNUTINS, 
		DTMINS,          
		CDNUTMOD, 
		DTMMOD,          
		FLGINDISPENSABILE 
       )
 SELECT vNewPrgRich,
		S_DO_FORMAZIONE_PROF.nextval,
		DO_FORMAZIONE_PROF.PRGALTERNATIVA,
		DO_FORMAZIONE_PROF.CODCORSO,
		DO_FORMAZIONE_PROF.CDNUTINS,
		SYSDATE,
		DO_FORMAZIONE_PROF.CDNUTMOD,
		SYSDATE,
		DO_FORMAZIONE_PROF.FLGINDISPENSABILE
   FROM DO_FORMAZIONE_PROF
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 
 SELECT COUNT(1) INTO vExistRecord FROM DO_INFO  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_INFO
       (
       PRGRICHIESTAAZ,
       PRGALTERNATIVA,
       PRGINFO,
       CODTIPOINFO,
       CODDETTINFO,
       CDNGRADO,
       FLGINDISPENSABILE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
       DO_INFO.PRGALTERNATIVA,
        S_DO_INFO.NEXTVAL,
       DO_INFO.CODTIPOINFO,
       DO_INFO.CODDETTINFO,
       DO_INFO.CDNGRADO,
       DO_INFO.FLGINDISPENSABILE,
       DO_INFO.CDNUTINS,
        DO_INFO.CDNUTMOD,
       SYSDATE,
        SYSDATE
   FROM DO_INFO
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --****************************** MANSIONE *****************************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_MANSIONE  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_MANSIONE
       (PRGRICHIESTAAZ,
         PRGALTERNATIVA,
       PRGMANSIONE,
       CODMANSIONE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD,
        FLGINVIOCL
       )
 SELECT vNewPrgRich,
         DO_MANSIONE.PRGALTERNATIVA,
        S_DO_MANSIONE.NEXTVAL,
       DO_MANSIONE.CODMANSIONE,
        DO_MANSIONE.CDNUTINS,
       DO_MANSIONE.CDNUTMOD,
       SYSDATE,
        SYSDATE,
        DO_MANSIONE.FLGINVIOCL
  FROM DO_MANSIONE
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --************************** LINGUA **********************************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_LINGUA  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_LINGUA
       (
       PRGRICHIESTAAZ,
         PRGALTERNATIVA,
       PRGLINGUA,
       CODLINGUA,
        CDNGRADOLETTO,
       CDNGRADOPARLATO,
       CDNGRADOSCRITTO,
       FLGINDISPENSABILE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
        DO_LINGUA.PRGALTERNATIVA,
        S_DO_LINGUA.NEXTVAL,
       DO_LINGUA.CODLINGUA,
        DO_LINGUA.CDNGRADOLETTO,
       DO_LINGUA.CDNGRADOPARLATO,
       DO_LINGUA.CDNGRADOSCRITTO,
       DO_LINGUA.FLGINDISPENSABILE,
        DO_LINGUA.CDNUTINS,
       DO_LINGUA.CDNUTMOD,
       SYSDATE,
        SYSDATE
   FROM DO_LINGUA
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
-- Esiste la copia di lavoro (oppure non la devo creare per via del profilo)
ELSIF (flgCopia = 0) THEN
  if(flgGestCopia = 0) then
     -- non posso usare la copia di lavoro, devo restituire per forza
  -- il prgRichiestaAz della richiesta originale (numStorico=0)
  SELECT az1.prgRichiestaAz into prgRichOriginale
  FROM
    DO_RICHIESTA_AZ az1,
    DO_RICHIESTA_AZ az2
     WHERE
    az1.NUMSTORICO = 0 and az1.NUMANNO = az2.NUMANNO and az1.NUMRICHIESTA = az2.NUMRICHIESTA
    and az2.PRGRICHIESTAAZ = pPrgRich;
  vNewPrgRich := prgRichOriginale;
  else
    -- passo il prg della copia
    vNewPrgRich := prgcopia ;
  end if;
--Esiste la copia ma faccio un'altra copia con numstorico= MAX(numstorico)+1
ELSE
 if(flgGestCopia=0) then
  -- se l'utente non è abilitato alla gestione della copia di lavoro allora si deve
  -- fare la copia della richiesta originale (numStorico=0)
  SELECT az1.prgRichiestaAz into prgRichOriginale
  FROM
    DO_RICHIESTA_AZ az1,
    DO_RICHIESTA_AZ az2
     WHERE
    az1.NUMSTORICO = 0 and az1.NUMANNO = az2.NUMANNO and az1.NUMRICHIESTA = az2.NUMRICHIESTA
    and az2.PRGRICHIESTAAZ = pPrgRich;
  pPrgRich := prgRichOriginale;
 end if;
 -- Seleziono il record con il numstorico maggiore
 SELECT
    az1.prgRichiestaAz,
    az1.numstorico,
    az1.numanno,
    az1.numRichiesta
  INTO
   prgcopia,
   p_numStorico,
   p_numAnno,
   p_numRichiesta
  FROM
    DO_RICHIESTA_AZ az1,
    DO_RICHIESTA_AZ az2
  WHERE
    az1.numanno=az2.numanno       and
    az1.numRichiesta=az2.numRichiesta and
    az1.numstorico >= all (select az3.numstorico
               from DO_RICHIESTA_AZ az3
              where
        az3.numanno = az1.numanno and
        az3.numrichiesta = az1.numrichiesta
           ) and
    az2.prgRichiestaAz = pPrgRich;
  -- CREO IL NUOVO RECORD CON NUMSTORICO=MAX(numstorico)+1
  SELECT S_do_richiesta_az.nextval INTO vNewPrgRich FROM DUAL;
  if(flgCopia=0 and p_numStorico=0) then
   -- numStorico=1 è riservato alla copia di lavoro pertanto
  p_numStorico := 1;
  end if;
  p_numStorico := p_numStorico + 1;
  INSERT INTO do_richiesta_az
  (PRGRICHIESTAAZ,
   NUMANNO,
   NUMRICHIESTA,
   NUMSTORICO,
   PRGAZIENDA,
   PRGUNITA,
   CODCPI,
   DATRICHIESTA,
   PRGRICHIESTAPADRE,
   CODTIPORICHIESTA,
   FLGART16,
   STRSESSO,
   FLGPUBBLICATA,
   STRMOTIVSESSO,
   DATPUBBLICAZIONE,
   DATSCADENZAPUBBLICAZIONE,
   DATSCADENZA,
   NUMPROFRICHIESTI,
   STRLOCALITA,
   PRGSPI,
   STRCOGNOMERIFERIMENTO,
   STRNOMERIFERIMENTO,
   STRTELRIFERIMENTO,
   STRFAXRIFERIMENTO,
   STREMAILRIFERIMENTO,
   FLGAUTOMUNITO,
   FLGMILITE,
   FLGMOTOMUNITO,
   FLGVITTOALLOGGIO,
   FLGVITTO,
   FLGTURISMO,
   CODTRASFERTA,
   FLGFUORISEDE,
   TXTFIGURAPROFESSIONALE,
   TXTCARATTERISTFIGPROF,
   TXTCONDCONTRATTUALE,
   TXTNOTEOPERATORE,
   CODAREA,
   CODMOTGENERE,
   CDNUTINS,
   CDNUTMOD,
   DTMINS,
   DTMMOD,
   STRCOGNOMERIFPUBB ,
   STRNOMERIFPUBB ,
   STRTELRIFPUBB ,
   STRFAXRIFPUBB ,
   STREMAILRIFPUBB ,
   STRDATIAZIENDAPUBB,
   STRMANSIONEPUBB,
   STRLUOGOLAVORO,
   STRFORMAZIONEPUBB,
   STRCONOSCENZEPUBB,
   STRNOTEORARIOPUBB,
   STRRIFCANDIDATURAPUBB,
   codqualifica,
   cdnGruppo,
   CODMONOCMCATEGORIA,
   FLGSVANTAGGIATI,
   STRMOTSVANTAGGIATI,
   DATVERIFICASVAN,
   FLGDISNONISCR,
   STRMOTNONISCR,
   DATVERIFICADIS, CODPROVINCIAPROV, NUMRICHIESTAORIG
   )
 SELECT  vNewPrgRich,
   p_numAnno,
   p_numRichiesta,
   p_numStorico,
   raz.PRGAZIENDA,
   raz.PRGUNITA,
   raz.CODCPI,
   raz.DATRICHIESTA,
   raz.PRGRICHIESTAPADRE,
   raz.CODTIPORICHIESTA,
   raz.FLGART16,
   raz.STRSESSO,
   raz.FLGPUBBLICATA,
   raz.STRMOTIVSESSO,
   raz.DATPUBBLICAZIONE,
   raz.DATSCADENZAPUBBLICAZIONE,
   raz.DATSCADENZA,
   raz.NUMPROFRICHIESTI,
   raz.STRLOCALITA,
   raz.PRGSPI,
   raz.STRCOGNOMERIFERIMENTO,
   raz.STRNOMERIFERIMENTO,
   raz.STRTELRIFERIMENTO,
   raz.STRFAXRIFERIMENTO,
   raz.STREMAILRIFERIMENTO,
   raz.FLGAUTOMUNITO,
   raz.FLGMILITE,
   raz.FLGMOTOMUNITO,
   raz.FLGVITTOALLOGGIO,
   raz.FLGVITTO,
   raz.FLGTURISMO,
   raz.CODTRASFERTA,
   raz.FLGFUORISEDE,
   raz.TXTFIGURAPROFESSIONALE,
   raz.TXTCARATTERISTFIGPROF,
   raz.TXTCONDCONTRATTUALE,
   raz.TXTNOTEOPERATORE,
   raz.CODAREA,
   raz.CODMOTGENERE,
   raz.CDNUTINS,
   raz.CDNUTMOD,
   SYSDATE,
   SYSDATE,
   raz.STRCOGNOMERIFPUBB ,
   raz.STRNOMERIFPUBB ,
   raz.STRTELRIFPUBB ,
   raz.STRFAXRIFPUBB ,
   raz.STREMAILRIFPUBB ,
   raz.STRDATIAZIENDAPUBB,
   raz.STRMANSIONEPUBB,
   raz.STRLUOGOLAVORO,
   raz.STRFORMAZIONEPUBB,
   raz.STRCONOSCENZEPUBB,
   raz.STRNOTEORARIOPUBB,
   raz.STRRIFCANDIDATURAPUBB,
   raz.codqualifica,
   raz.CdnGruppo,
   raz.CODMONOCMCATEGORIA,
   raz.FLGSVANTAGGIATI,
   raz.STRMOTSVANTAGGIATI,
   raz.DATVERIFICASVAN,
   raz.FLGDISNONISCR,
   raz.STRMOTNONISCR,
   raz.DATVERIFICADIS, raz.CODPROVINCIAPROV, raz.NUMRICHIESTAORIG
 from do_richiesta_az raz
 where raz.PRGRICHIESTAAZ = pPrgRich;
 -- COPIO LA DO_ALTERNATIVA
 -- la insert precedente sulla tabella do_richiesata_az fa scattare un trigger che inserisce già dei campi
 -- nella do_alternativa con il nuovo PRGRICHIESTAAZ e con PRGALTERNATIVA=1. Occorre quindi solo inserire
 -- i nuovi valori con una UPDATE
SELECT do_alternativa.FLGESPERIENZA,
       do_alternativa.FLGFORMAZIONEPROF,
      do_alternativa.NUMA,
      do_alternativa.NUMANNIESPERIENZA,
      do_alternativa.NUMDA,
    do_alternativa.CODMOTETA,
      do_alternativa.STRMOTIVETA,
      do_alternativa.STRNOTE
  INTO vFlgExp, vFlgFroma, vNuma, vNamAss, vNumDA, vCodMotEta, vStrMotEta, vStrNote
  FROM do_alternativa
 WHERE do_alternativa.prgalternativa = 1
   AND do_alternativa.PRGRICHIESTAAZ = pPrgRich;
UPDATE do_alternativa
   SET FLGESPERIENZA = vFlgExp,
       FLGFORMAZIONEPROF = vFlgFroma,
      NUMA = vNuma,
      NUMANNIESPERIENZA = vNamAss,
      NUMDA = vNumDA,
    CODMOTETA = vCodMotEta,
      STRMOTIVETA = vStrMotEta,
      STRNOTE = vStrNote
 WHERE do_alternativa.prgalternativa = 1
   AND do_alternativa.PRGRICHIESTAAZ = vNewPrgRich;
--inserisco le altre alternative cioè quellli con PRGALTERNATIVA>1(se esistenti)
insert into do_alternativa
     ( PRGRICHIESTAAZ,
     FLGESPERIENZA,
      FLGFORMAZIONEPROF,
     NUMA,
     NUMANNIESPERIENZA,
     NUMDA,
     PRGALTERNATIVA,
   CODMOTETA,
     STRMOTIVETA,
     STRNOTE,
     CDNUTINS,
     CDNUTMOD,
     DTMINS,
     DTMMOD
     )
 select vNewPrgRich,-- prg In Cui inserire
      do_alternativa.FLGESPERIENZA,
       do_alternativa.FLGFORMAZIONEPROF,
      do_alternativa.NUMA,
      do_alternativa.NUMANNIESPERIENZA,
      do_alternativa.NUMDA,
      do_alternativa.PRGALTERNATIVA,
   do_alternativa.CODMOTETA,
      do_alternativa.STRMOTIVETA,
      do_alternativa.STRNOTE,
    do_alternativa.CDNUTINS,
   do_alternativa.CDNUTMOD,
     SYSDATE,
    SYSDATE
   from do_alternativa
  where do_alternativa.PRGALTERNATIVA > 1
    and do_alternativa.PRGRICHIESTAAZ = pPrgRich;
 -- ************ COPIA RECORD DELLA DO_ABILITAZIONE_GEN  **************
 SELECT COUNT(1) INTO vExistRecord FROM DO_ABILITAZIONE_GEN  WHERE prgRichiestaAz = pPrgRich;
 IF (vExistRecord<>0) THEN
 INSERT INTO DO_ABILITAZIONE_GEN
       (
     PRGRICHIESTAAZ,
        CODABILITAZIONEGEN,
      FLGINDISPENSABILE,
         CDNUTINS,
         CDNUTMOD,
         DTMINS,
         DTMMOD,
         FLGINVIOCL
       )
 SELECT vNewPrgRich,
        DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN,
        DO_ABILITAZIONE_GEN.FLGINDISPENSABILE,
        DO_ABILITAZIONE_GEN.CDNUTINS,
     DO_ABILITAZIONE_GEN.CDNUTMOD,
        SYSDATE,
        SYSDATE,
        DO_ABILITAZIONE_GEN.FLGINVIOCL
   FROM DO_ABILITAZIONE_GEN
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 -- ********************** PROVINCIA **************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_PROVINCIA  WHERE prgRichiestaAz = pPrgRich;
 IF (vExistRecord<>0) THEN
 INSERT INTO DO_PROVINCIA
       (
     PRGRICHIESTAAZ,
        PRGPROVINCIA,
      CODPROVINCIA,
         CDNUTINS,
         CDNUTMOD,
         DTMINS,
         DTMMOD
       )
 SELECT vNewPrgRich,
        S_DO_PROVINCIA.NEXTVAL,
        DO_PROVINCIA.CODPROVINCIA,
        DO_PROVINCIA.CDNUTINS,
     DO_PROVINCIA.CDNUTMOD,
        SYSDATE,
        SYSDATE
   FROM DO_PROVINCIA
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 -- ************************** CITTADINZANZA **************************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_CITTADINANZA  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_CITTADINANZA
       (PRGRICHIESTAAZ,
       PRGCITTADINANZA,
        CODCITTADINANZA,
     CODMOTNAZIONALITA,
       STRMOTIVAZIONE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
        S_DO_CITTADINANZA.NEXTVAL,
        DO_CITTADINANZA.CODCITTADINANZA,
     DO_CITTADINANZA.CODMOTNAZIONALITA,
        DO_CITTADINANZA.STRMOTIVAZIONE,
        DO_CITTADINANZA.CDNUTINS,
     DO_CITTADINANZA.CDNUTMOD,
       SYSDATE,
        SYSDATE
   FROM DO_CITTADINANZA
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --******************************* ORARIO ***************************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_ORARIO  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_ORARIO
       (
     PRGRICHIESTAAZ,
     PRGORARIO,
     CODORARIO,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD,
        FLGINVIOCL
       )
 SELECT vNewPrgRich,
        S_DO_ORARIO.NEXTVAL,
     DO_ORARIO.CODORARIO,
        DO_ORARIO.CDNUTINS,
     DO_ORARIO.CDNUTMOD,
     SYSDATE,
        SYSDATE,
        DO_ORARIO.FLGINVIOCL
   FROM DO_ORARIO
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --************************************ TURNO **********************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_TURNO  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_TURNO
       (PRGRICHIESTAAZ,
       PRGTURNO,
       CODTURNO,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
        S_DO_TURNO.NEXTVAL,
     DO_TURNO.CODTURNO,
        DO_TURNO.CDNUTINS,
     DO_TURNO.CDNUTMOD,
     SYSDATE,
        SYSDATE
   FROM DO_TURNO
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --************************************* COMUNE **********************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_COMUNE  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_COMUNE
       (PRGRICHIESTAAZ,
     PRGCOMUNE,
     CODCOM,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD,
        FLGINVIOCL
       )
 SELECT vNewPrgRich,
        S_DO_COMUNE.NEXTVAL,
     DO_COMUNE.CODCOM,
        DO_COMUNE.CDNUTINS,
        DO_COMUNE.CDNUTMOD,
     SYSDATE,
        SYSDATE,
        DO_COMUNE.FLGINVIOCL
   FROM DO_COMUNE
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --************************************* EVASIONE **********************************
 -- COPIO LA DO_EVASIONE
 -- la insert precedente sulla tabella do_richiesata_az fa scattare un trigger che inserisce già dei campi
 -- nella DO_EVASIONE con il nuovo PRGRICHIESTAAZ  Occorre quindi solo inserire
 -- i nuovi valori con una UPDATE
 SELECT  DO_EVASIONE.CODEVASIONE,
        DO_EVASIONE.CDNSTATORICH,
        DO_EVASIONE.CODMONOSTATORICH,
          DO_EVASIONE.CODESITORICHIESTA
   INTO codev, cstatorich, cmonostatorich, codEsitRich   FROM DO_EVASIONE
  WHERE  DO_EVASIONE.PRGRICHIESTAAZ = pPrgRich;
 UPDATE DO_EVASIONE
    SET  DO_EVASIONE.CODEVASIONE =codev,
        DO_EVASIONE.CDNSTATORICH=cstatorich,
        DO_EVASIONE.CODMONOSTATORICH= cmonostatorich,
          DO_EVASIONE.CODESITORICHIESTA= codEsitRich
  WHERE  DO_EVASIONE.PRGRICHIESTAAZ = vNewPrgRich;
 -- Aggiorniamo le tabelle relative alle alternative
 SELECT COUNT(1) INTO vExistRecord FROM DO_AGEVOLAZIONE  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_AGEVOLAZIONE
       (
     PRGRICHIESTAAZ,
     PRGAGEVOLAZIONE,
     PRGALTERNATIVA,
     CODAGEVOLAZIONE,
     FLGINDISPENSABILE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
     S_DO_AGEVOLAZIONE.NEXTVAL,
     DO_AGEVOLAZIONE.PRGALTERNATIVA,
     DO_AGEVOLAZIONE.CODAGEVOLAZIONE,
     DO_AGEVOLAZIONE.FLGINDISPENSABILE,
        DO_AGEVOLAZIONE.CDNUTINS,
        DO_AGEVOLAZIONE.CDNUTMOD,
     SYSDATE,
        SYSDATE
   FROM DO_AGEVOLAZIONE
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 SELECT COUNT(1) INTO vExistRecord FROM DO_CONTRATTO  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_CONTRATTO
       (
     PRGRICHIESTAAZ,
     PRGALTERNATIVA,
     PRGCONTRATTO,
     CODCONTRATTO,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD,
        FLGINVIOCL
      )
 SELECT vNewPrgRich,
     DO_CONTRATTO.PRGALTERNATIVA,
        S_DO_CONTRATTO.NEXTVAL,
     DO_CONTRATTO.CODCONTRATTO,
        DO_CONTRATTO.CDNUTINS,
        DO_CONTRATTO.CDNUTMOD,
     SYSDATE,
        SYSDATE,
        DO_CONTRATTO.FLGINVIOCL
   FROM DO_CONTRATTO
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 SELECT COUNT(1) INTO vExistRecord FROM DO_COMPETENZA  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_COMPETENZA
       (PRGRICHIESTAAZ,
     PRGALTERNATIVA,
     PRGCOMPETENZA,
     CODCOMPETENZA,
     FLGINDISPENSABILE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
     DO_COMPETENZA.PRGALTERNATIVA,
        S_DO_COMPETENZA.NEXTVAL,
     DO_COMPETENZA.CODCOMPETENZA,
     DO_COMPETENZA.FLGINDISPENSABILE,
        DO_COMPETENZA.CDNUTINS,
        DO_COMPETENZA.CDNUTMOD,
     SYSDATE,
        SYSDATE
   FROM DO_COMPETENZA
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 SELECT COUNT(1) INTO vExistRecord FROM DO_STUDIO  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_STUDIO
       (
     PRGRICHIESTAAZ,
     PRGALTERNATIVA,
     PRGSTUDIO,
       CODTITOLO,
       FLGCONSEGUITO,
       FLGINDISPENSABILE,
       STRSPECIFICA,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
     DO_STUDIO.PRGALTERNATIVA,
        S_DO_STUDIO.NEXTVAL,
       DO_STUDIO.CODTITOLO,
       DO_STUDIO.FLGCONSEGUITO,
       DO_STUDIO.FLGINDISPENSABILE,
       DO_STUDIO.STRSPECIFICA,
        DO_STUDIO.CDNUTINS,
        DO_STUDIO.CDNUTMOD,
     SYSDATE,
        SYSDATE
   FROM DO_STUDIO
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_FORMAZIONE_PROF  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_FORMAZIONE_PROF
       (PRGRICHIESTAAZ, 
        PRGFORMPROF,      
	    PRGALTERNATIVA, 
		CODCORSO, 
		CDNUTINS, 
		DTMINS,          
		CDNUTMOD, 
		DTMMOD,          
		FLGINDISPENSABILE 
       )
 SELECT vNewPrgRich,
		S_DO_FORMAZIONE_PROF.nextval,
		DO_FORMAZIONE_PROF.PRGALTERNATIVA,
		DO_FORMAZIONE_PROF.CODCORSO,
		DO_FORMAZIONE_PROF.CDNUTINS,
		SYSDATE,
		DO_FORMAZIONE_PROF.CDNUTMOD,
		SYSDATE,
		DO_FORMAZIONE_PROF.FLGINDISPENSABILE
   FROM DO_FORMAZIONE_PROF
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 SELECT COUNT(1) INTO vExistRecord FROM DO_INFO  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_INFO
       (
     PRGRICHIESTAAZ,
     PRGALTERNATIVA,
     PRGINFO,
       CODTIPOINFO,
       CODDETTINFO,
       CDNGRADO,
       FLGINDISPENSABILE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
     DO_INFO.PRGALTERNATIVA,
        S_DO_INFO.NEXTVAL,
       DO_INFO.CODTIPOINFO,
       DO_INFO.CODDETTINFO,
       DO_INFO.CDNGRADO,
       DO_INFO.FLGINDISPENSABILE,
     DO_INFO.CDNUTINS,
        DO_INFO.CDNUTMOD,
     SYSDATE,
        SYSDATE
   FROM DO_INFO
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --****************************** MANSIONE *****************************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_MANSIONE  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_MANSIONE
       (PRGRICHIESTAAZ,
         PRGALTERNATIVA,
       PRGMANSIONE,
       CODMANSIONE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD,
        FLGINVIOCL
        )
 SELECT vNewPrgRich,
         DO_MANSIONE.PRGALTERNATIVA,
        S_DO_MANSIONE.NEXTVAL,
       DO_MANSIONE.CODMANSIONE,
        DO_MANSIONE.CDNUTINS,
       DO_MANSIONE.CDNUTMOD,
       SYSDATE,
        SYSDATE,
        DO_MANSIONE.FLGINVIOCL
   FROM DO_MANSIONE
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 --************************** LINGUA **********************************************
 SELECT COUNT(1) INTO vExistRecord FROM DO_LINGUA  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_LINGUA
       (
       PRGRICHIESTAAZ,
         PRGALTERNATIVA,
       PRGLINGUA,
       CODLINGUA,
        CDNGRADOLETTO,
       CDNGRADOPARLATO,
       CDNGRADOSCRITTO,
       FLGINDISPENSABILE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
       )
 SELECT vNewPrgRich,
        DO_LINGUA.PRGALTERNATIVA,
        S_DO_LINGUA.NEXTVAL,
       DO_LINGUA.CODLINGUA,
        DO_LINGUA.CDNGRADOLETTO,
       DO_LINGUA.CDNGRADOPARLATO,
       DO_LINGUA.CDNGRADOSCRITTO,
       DO_LINGUA.FLGINDISPENSABILE,
        DO_LINGUA.CDNUTINS,
       DO_LINGUA.CDNUTMOD,
       SYSDATE,
        SYSDATE
   FROM DO_LINGUA
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
END IF;
COMMIT;
RETURN vNewPrgRich;
 exception
      when others then
          ErrCodeOut := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       return -1;
END; --storicizzaRichiesta
--****************************************************************************
--****************************************************************************
--      Funzione che replica(NON copia) la richiesta di un'azienda
--****************************************************************************
FUNCTION reiteraRichAzienda( pPrgRichSTR      VARCHAR2,
                             pPrgAziendaSTR   VARCHAR2,
                             pPrgUnitaSTR     VARCHAR2,
                             pDatRichiestaSTR VARCHAR2,
                      		 pDatScadenzaSTR  VARCHAR2,
                             pFlgPubblSTR     VARCHAR2,
                             pDatPubblSTR     VARCHAR2,
                             pDatScadPubblSTR VARCHAR2,
                             pCdnUtInsModSTR  VARCHAR2,
                           pSTRMANSIONEPUBB        VARCHAR2,
                           pCODCPI                 VARCHAR2,
                           pFLGART16               VARCHAR2,
                           pSTRSESSO               VARCHAR2,
                           pcodMotGenere           VARCHAR2,
                           pSTRMOTIVSESSO          VARCHAR2,
                           pNUMPROFRICHIESTIstr    VARCHAR2,
                           pSTRLOCALITA            VARCHAR2,
                           pPRGSPIstr              VARCHAR2,
                           pSTRCOGNOMERIFERIMENTO  VARCHAR2,
                           pSTRNOMERIFERIMENTO     VARCHAR2,
                           pSTRTELRIFERIMENTO      VARCHAR2,
                           pSTRFAXRIFERIMENTO      VARCHAR2,
                           pSTREMAILRIFERIMENTO    VARCHAR2,
                           pFLGAUTOMUNITO          VARCHAR2,
                           pFLGMILITE              VARCHAR2,
                           pFLGMOTOMUNITO          VARCHAR2,
                           pFLGVITTOALLOGGIO       VARCHAR2,
               			   pFLGVITTO              VARCHAR2,
               			   pFLGTURISMO            VARCHAR2,
                           pCODTRASFERTA           VARCHAR2,
                           pFLGFUORISEDE           VARCHAR2,
                           pTXTFIGURAPROFESSIONALE VARCHAR2,
                           pTXTCARATTERISTFIGPROF  VARCHAR2,
                           pTXTCONDCONTRATTUALE    VARCHAR2,
                           pTXTNOTEOPERATORE       VARCHAR2,
                           pCODAREA                VARCHAR2,
                           pCdnGruppoStr           VARCHAR2,
                           pNumPostoAS             VARCHAR2,
                           pNumPostoLSU            VARCHAR2,
                           pNumPostoMilitare       VARCHAR2,
                           pNumPostoMB             VARCHAR2,
                           pFlgRiusoGraduatoria    VARCHAR2,
                           ptipoLSU                VARCHAR2,
                           pDatChiamata            VARCHAR2,
                           pFlagAS                 VARCHAR2,
                           pCodMonoTipoGrado       VARCHAR2,
                           pNumPostiCM             VARCHAR2,
               			   pNumAnnoRedditoCM       VARCHAR2,
                           pDatChiamataCM          VARCHAR2,
                           pCodTipoLista           VARCHAR2,
                           pFlagCM                 VARCHAR2,
                           pFlgSvantaggiati        VARCHAR2,
                           pStrMotSvantaggiati     VARCHAR2,
                           pDatVerificaSvanStr     VARCHAR2,
                           pFlgDisNonIscr          VARCHAR2,
                           pStrMotNonIscr          VARCHAR2,
                           pDatVerificaDis         VARCHAR2,
						   pFlagParAsOnline		 VARCHAR2
                           ) RETURN VARCHAR2 IS
  pPrgRich      do_richiesta_az.PRGRICHIESTAAZ%TYPE;
  pPrgAzienda   do_richiesta_az.prgazienda%TYPE;
  pPrgUnita     do_richiesta_az.prgunita%TYPE;
  pDatRichiesta do_richiesta_az.DATRICHIESTA%TYPE;
  pDatScadenza  do_richiesta_az.DATSCADENZA%TYPE;
  pFlgPubbl     do_richiesta_az.FLGPUBBLICATA%TYPE;
  pDatPubbl     do_richiesta_az.DATPUBBLICAZIONE%TYPE;
  pDatScadPubbl do_richiesta_az.DATSCADENZAPUBBLICAZIONE%TYPE;
  pCdnUtInsMod  do_richiesta_az.CDNUTINS%TYPE;
  pNUMANNO            do_richiesta_az.NUMANNO%TYPE;
  pNUMRICHIESTA       do_richiesta_az.NUMRICHIESTA%TYPE;
  pNUMSTORICO         do_richiesta_az.NUMSTORICO%TYPE;
  pPRGRICHIESTAPADRE  do_richiesta_az.PRGRICHIESTAPADRE%TYPE;
  pNUMPROFRICHIESTI   do_richiesta_az.NUMPROFRICHIESTI%TYPE;
  pPRGSPI             do_richiesta_az.PRGSPI%TYPE;
  vNewPrgRich do_richiesta_az.PRGRICHIESTAAZ%TYPE;
  pCdnGruppo  do_richiesta_az.CDNGRUPPO%TYPE;
 vFlgExp     do_alternativa.FLGESPERIENZA%TYPE;
 vFlgFroma   do_alternativa.FLGFORMAZIONEPROF%TYPE;
 vNuma       do_alternativa.NUMA%TYPE;
 vNamAss     do_alternativa.NUMANNIESPERIENZA%TYPE;
 vNumDA      do_alternativa.NUMDA%TYPE;
 vCodMotEta  do_alternativa.CODMOTETA%TYPE;
 vStrMotEta  do_alternativa.STRMOTIVETA%TYPE;
 vStrNote    do_alternativa.STRNOTE%TYPE;
 nVarNumeroRichiesta do_richiesta_az.NUMRICHIESTA%TYPE;
 nVarNumAnno do_richiesta_az.NUMANNO%TYPE;
 nVarNumStorico do_richiesta_az.NUMSTORICO%TYPE:=0;
 codParComAz  do_comune.CODCOM%TYPE;

 vNumPostoAS  do_richiesta_az.numpostoas%TYPE;
 vNumPostoLSU do_richiesta_az.numpostolsu%TYPE;
 vNumPostoMilitare  do_richiesta_az.numpostomilitare%TYPE;
 vNumPostoMB  do_richiesta_az.numpostomb%TYPE;
 vDatChiamata  do_richiesta_az.datchiamata%TYPE;
 vtipoLSU do_richiesta_az.codtipolsu%TYPE;

 vCodMonoTipoGrad do_richiesta_az.codmonotipograd%TYPE;
 vNumPostiCM do_richiesta_az.numposticm%TYPE;
 vNumAnnoRedditoCM do_richiesta_az.numannoredditocm%TYPE;
 vDatChiamataCM do_richiesta_az.datchiamatacm%TYPE;
 vCodTipoLista do_richiesta_az.codtipolista%TYPE;
 pDatVerificaSvan  do_richiesta_az.DATVERIFICASVAN%TYPE;

 --vMaxPrg  NUMBER;
 vExistRecord INTEGER;
BEGIN
  pPrgRich      := TO_NUMBER(pPrgRichSTR);
  pPrgAzienda   := TO_NUMBER(pPrgAziendaSTR);
  pPrgUnita     := TO_NUMBER(pPrgUnitaSTR);
  pDatRichiesta := TO_DATE(pDatRichiestaSTR,'DD/MM/YYYY');
  pDatScadenza  := TO_DATE(pDatScadenzaSTR,'DD/MM/YYYY');
  pFlgPubbl     := pFlgPubblSTR;
  pDatPubbl     := TO_DATE(pDatPubblSTR,'DD/MM/YYYY');
  pDatScadPubbl := TO_DATE(pDatScadPubblSTR,'DD/MM/YYYY');
  pCdnUtInsMod  := TO_NUMBER(pCdnUtInsModSTR);
  pNUMPROFRICHIESTI  := TO_NUMBER(pNUMPROFRICHIESTIstr);
  pPRGSPI            := TO_NUMBER(pPRGSPIstr);
  nVarNumAnno := TO_NUMBER(TO_CHAR(TO_DATE(pDatRichiestaSTR,'DD/MM/YYYY'),'YYYY'));
  pCdnGruppo      := TO_NUMBER(pCdnGruppoStr);

  vNumPostoAS := TO_NUMBER(pNumPostoAS);
  vNumPostoLSU := TO_NUMBER(pNumPostoLSU);
  vNumPostoMilitare := TO_NUMBER(pNumPostoMilitare);
  vNumPostoMB := TO_NUMBER(pNumPostoMB);
  vDatChiamata := TO_DATE(pDatChiamata,'DD/MM/YYYY');
  vtipoLSU := Ptipolsu;

  vCodMonoTipoGrad := Pcodmonotipogrado;
  vNumPostiCM := TO_NUMBER(Pnumposticm);
  vNumAnnoRedditoCM := TO_NUMBER(PNumAnnoRedditoCM);
  vDatChiamataCM := TO_DATE(Pdatchiamatacm,'DD/MM/YYYY');
  vCodTipoLista := pcodtipolista;
  pDatVerificaSvan := TO_DATE(pDatVerificaSvanStr,'DD/MM/YYYY');

 select nvl(max(NUMRICHIESTA),0) + 1
 into nVarNumeroRichiesta
 from do_richiesta_az where do_richiesta_az.NUMANNO = nVarNumAnno;
 SELECT S_do_richiesta_az.nextval INTO vNewPrgRich FROM DUAL;

 -- INIT-PARTE-TEMP
 if (pFlagCM is null) then
 -- END-PARTE-TEMP
   INSERT INTO do_richiesta_az
    (PRGRICHIESTAAZ,
     NUMANNO,
     NUMRICHIESTA,
     NUMSTORICO,
     PRGAZIENDA,
     PRGUNITA,
     CODCPI,
     DATRICHIESTA,
     FLGART16,
     STRSESSO,
     FLGPUBBLICATA,
     STRMOTIVSESSO,
     DATPUBBLICAZIONE,
     DATSCADENZAPUBBLICAZIONE,
     DATSCADENZA,
     STRMANSIONEPUBB,
     NUMPROFRICHIESTI,
     STRLOCALITA,
     PRGSPI,
     STRCOGNOMERIFERIMENTO,
     STRNOMERIFERIMENTO,
     STRTELRIFERIMENTO,
     STRFAXRIFERIMENTO,
     STREMAILRIFERIMENTO,
     FLGAUTOMUNITO,
     FLGMILITE,
     FLGMOTOMUNITO,
     FLGVITTOALLOGGIO,
     FLGVITTO,
     FLGTURISMO,
     CODTRASFERTA,
     FLGFUORISEDE,
     TXTFIGURAPROFESSIONALE,
     TXTCARATTERISTFIGPROF,
     TXTCONDCONTRATTUALE,
     TXTNOTEOPERATORE,
     CODAREA,
     CODMOTGENERE,
     CDNUTINS,
     CDNUTMOD,
     DTMINS,
     DTMMOD,
     NUMKLORICHIESTAAZ,
     CDNGRUPPO,
     NUMPOSTOAS,
     NUMPOSTOLSU,
     NUMPOSTOMILITARE,
     NUMPOSTOMB,
     FLGRIUSOGRADUATORIA,
     DATCHIAMATA,
     CODTIPOLSU,
     FLGSVANTAGGIATI,
     STRMOTSVANTAGGIATI,
     DATVERIFICASVAN,
     FLGDISNONISCR,
	 STRMOTNONISCR,
     DATVERIFICADIS,
	 FLGASONLINE,
	 DTMASONLINE
     )
   VALUES
     ( vNewPrgRich,
       nVarNumAnno,
       nVarNumeroRichiesta,
       nVarNumStorico,
       pPrgAzienda,--raz.PRGAZIENDA,
       pPrgUnita,--raz.PRGUNITA,
       pCODCPI,
       pDatRichiesta,
       pFLGART16,
       pSTRSESSO,
       pFlgPubbl,
       pSTRMOTIVSESSO,
       pDatPubbl,
       pDatScadPubbl,
       pDatScadenza,
       pSTRMANSIONEPUBB,
       pNUMPROFRICHIESTI,
       pSTRLOCALITA,
       pPRGSPI,
       pSTRCOGNOMERIFERIMENTO,
       pSTRNOMERIFERIMENTO,
       pSTRTELRIFERIMENTO,
       pSTRFAXRIFERIMENTO,
       pSTREMAILRIFERIMENTO,
       pFLGAUTOMUNITO,
       pFLGMILITE,
       pFLGMOTOMUNITO,
       pFLGVITTOALLOGGIO,
       pFLGVITTO,
       pFLGTURISMO,
       pCODTRASFERTA,
       pFLGFUORISEDE,
       pTXTFIGURAPROFESSIONALE,
       pTXTCARATTERISTFIGPROF,
       pTXTCONDCONTRATTUALE,
       pTXTNOTEOPERATORE,
       pCODAREA,
       pcodMotGenere,
       pCdnUtInsMod,--raz.CDNUTINS,
       pCdnUtInsMod,--raz.CDNUTMOD,
       SYSDATE,
       SYSDATE,
       NULL,
       pCdnGruppo,
       vNumPostoAS,
       vNumPostoLSU,
       vNumPostoMilitare,
       vNumPostoMB,
       pFlgRiusoGraduatoria,
       vDatChiamata,
       vtipoLSU,
       pFlgSvantaggiati,
       pStrMotSvantaggiati,
       pDatVerificaSvan,
       pFlgDisNonIscr,
       pStrMotNonIscr,
       pDatVerificaDis,
	   pFlagParAsOnline,
	   null
      );
 -- INIT-PARTE-TEMP
 ELSE
 -- END-PARTE-TEMP
    INSERT INTO do_richiesta_az
    (  PRGRICHIESTAAZ,
       NUMANNO,
       NUMRICHIESTA,
       NUMSTORICO,
       PRGAZIENDA,
       PRGUNITA,
       CODCPI,
       DATRICHIESTA,
       FLGART16,
       STRSESSO,
       FLGPUBBLICATA,
       STRMOTIVSESSO,
       DATPUBBLICAZIONE,
       DATSCADENZAPUBBLICAZIONE,
       DATSCADENZA,
       STRMANSIONEPUBB,
       NUMPROFRICHIESTI,
       STRLOCALITA,
       PRGSPI,
       STRCOGNOMERIFERIMENTO,
       STRNOMERIFERIMENTO,
       STRTELRIFERIMENTO,
       STRFAXRIFERIMENTO,
       STREMAILRIFERIMENTO,
       FLGAUTOMUNITO,
       FLGMILITE,
       FLGMOTOMUNITO,
       FLGVITTOALLOGGIO,
       FLGVITTO,
       FLGTURISMO,
       CODTRASFERTA,
       FLGFUORISEDE,
       TXTFIGURAPROFESSIONALE,
       TXTCARATTERISTFIGPROF,
       TXTCONDCONTRATTUALE,
       TXTNOTEOPERATORE,
       CODAREA,
       CODMOTGENERE,
       CDNUTINS,
       CDNUTMOD,
       DTMINS,
       DTMMOD,
       NUMKLORICHIESTAAZ,
       CDNGRUPPO,
       NUMPOSTOAS,
       NUMPOSTOLSU,
       NUMPOSTOMILITARE,
       NUMPOSTOMB,
       FLGRIUSOGRADUATORIA,
       DATCHIAMATA,
       CODTIPOLSU,
       CODMONOTIPOGRAD,
       NUMPOSTICM,
       NUMANNOREDDITOCM,
       DATCHIAMATACM,
       CODTIPOLISTA,
       FLGSVANTAGGIATI,
       STRMOTSVANTAGGIATI,
       DATVERIFICASVAN,
       FLGDISNONISCR,
	   STRMOTNONISCR,
       DATVERIFICADIS,
	   FLGASONLINE,
	   DTMASONLINE
     )
   VALUES
     ( vNewPrgRich,
       nVarNumAnno,
     nVarNumeroRichiesta,
     nVarNumStorico,
      pPrgAzienda,--raz.PRGAZIENDA,
     pPrgUnita,--raz.PRGUNITA,
     pCODCPI,
     pDatRichiesta,
     pFLGART16,
     pSTRSESSO,
     pFlgPubbl,
     pSTRMOTIVSESSO,
     pDatPubbl,
     pDatScadPubbl,
     pDatScadenza,
       pSTRMANSIONEPUBB,
     pNUMPROFRICHIESTI,
     pSTRLOCALITA,
     pPRGSPI,
     pSTRCOGNOMERIFERIMENTO,
     pSTRNOMERIFERIMENTO,
     pSTRTELRIFERIMENTO,
     pSTRFAXRIFERIMENTO,
     pSTREMAILRIFERIMENTO,
     pFLGAUTOMUNITO,
     pFLGMILITE,
     pFLGMOTOMUNITO,
     pFLGVITTOALLOGGIO,
     pFLGVITTO,
     pFLGTURISMO,
     pCODTRASFERTA,
     pFLGFUORISEDE,
     pTXTFIGURAPROFESSIONALE,
     pTXTCARATTERISTFIGPROF,
     pTXTCONDCONTRATTUALE,
     pTXTNOTEOPERATORE,
     pCODAREA,
     pcodMotGenere,
     pCdnUtInsMod,--raz.CDNUTINS,
     pCdnUtInsMod,--raz.CDNUTMOD,
     SYSDATE,
     SYSDATE,
       NULL,
       pCdnGruppo,
       vNumPostoAS,
       vNumPostoLSU,
       vNumPostoMilitare,
       vNumPostoMB,
       pFlgRiusoGraduatoria,
       vDatChiamata,
       vtipoLSU,
       vcodmonotipograd,
       vnumposticm,
       vnumannoredditocm,
       vdatchiamatacm,
       vcodtipolista,
       pFlgSvantaggiati,
       pStrMotSvantaggiati,
       pDatVerificaSvan,
       pFlgDisNonIscr,
       pStrMotNonIscr,
       pDatVerificaDis,
	   pFlagParAsOnline,
	   null
      );
 -- INIT-PARTE-TEMP
 END IF;
 -- END-PARTE-TEMP

-- 20/08/2004 correzione per reiterazione: comune della sede non va inserito in copia
-- perchè ci pensa già il trigger in inserimento richiesta.
    select ua.codcom into codParComAz
 from an_unita_azienda ua, do_richiesta_az dor
 where ua.prgazienda = dor.prgAzienda
 and   ua.prgunita   = dor.prgUnita
 and   dor.prgRichiestaAz = vNewPrgRich;

-- Copio la DO_ALTERNATIVA
-- la insert precedente sulla tabella do_richiesata_az fa scattare un trigger che inserisce già dei campi
-- nella do_alternativa con il nuovo PRGRICHIESTAAZ e con PRGALTERNATIVA=1. Occorre quindi solo inserire
-- i nuovi valori con una UPDATE
SELECT do_alternativa.FLGESPERIENZA,
       do_alternativa.FLGFORMAZIONEPROF,
      do_alternativa.NUMA,
      do_alternativa.NUMANNIESPERIENZA,
      do_alternativa.NUMDA,
    do_alternativa.CODMOTETA,
      do_alternativa.STRMOTIVETA,
      do_alternativa.STRNOTE
  INTO vFlgExp, vFlgFroma, vNuma, vNamAss, vNumDA, vCodMotEta, vStrMotEta, vStrNote
  FROM do_alternativa
 WHERE do_alternativa.prgalternativa = 1
   AND do_alternativa.PRGRICHIESTAAZ = pPrgRich;
UPDATE do_alternativa
   SET FLGESPERIENZA = vFlgExp,
       FLGFORMAZIONEPROF = vFlgFroma,
      NUMA = vNuma,
      NUMANNIESPERIENZA = vNamAss,
      NUMDA = vNumDA,
    CODMOTETA = vCodMotEta,
      STRMOTIVETA = vStrMotEta,
      STRNOTE = vStrNote
 WHERE do_alternativa.prgalternativa = 1
   AND do_alternativa.PRGRICHIESTAAZ = vNewPrgRich;
-- inserisco le altre altre alternative, quelle con PRGALTERNATIVA>1 (se esistenti)
insert into do_alternativa
     ( PRGRICHIESTAAZ,
     FLGESPERIENZA,
      FLGFORMAZIONEPROF,
     NUMA,
     NUMANNIESPERIENZA,
     NUMDA,
     PRGALTERNATIVA,
   CODMOTETA,
     STRMOTIVETA,
     STRNOTE,
     CDNUTINS,
     CDNUTMOD,
     DTMINS,
     DTMMOD
     )
 select vNewPrgRich,-- prg In Cui inserire
      do_alternativa.FLGESPERIENZA,
        do_alternativa.FLGFORMAZIONEPROF,
      do_alternativa.NUMA,
      do_alternativa.NUMANNIESPERIENZA,
      do_alternativa.NUMDA,
      do_alternativa.PRGALTERNATIVA,
   do_alternativa.CODMOTETA,
      do_alternativa.STRMOTIVETA,
      do_alternativa.STRNOTE,
     pCdnUtInsMod,
     pCdnUtInsMod,
     SYSDATE,
    SYSDATE
   from do_alternativa
  where do_alternativa.PRGALTERNATIVA > 1
    and do_alternativa.PRGRICHIESTAAZ = pPrgRich; --prg Da Copiare
-- Se esistono dei record nella tabella inseriti con il prgRichiestaAz che vogliamo copiare allora... COPIAMO no!?
-- e ripetiamo la stessa operazione su tutte le tabelle legate alla richiesta dell'azienda
SELECT COUNT(1) INTO vExistRecord FROM DO_ABILITAZIONE_GEN  WHERE prgRichiestaAz = pPrgRich;
IF (vExistRecord<>0) THEN
INSERT INTO DO_ABILITAZIONE_GEN
      ( PRGRICHIESTAAZ,
       CODABILITAZIONEGEN,
       FLGINDISPENSABILE,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD,
        FLGINVIOCL
      )
SELECT vNewPrgRich,
       DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN,
       DO_ABILITAZIONE_GEN.FLGINDISPENSABILE,
       pCdnUtInsMod,
       pCdnUtInsMod,
       SYSDATE,
       SYSDATE,
       DO_ABILITAZIONE_GEN.FLGINVIOCL
  FROM DO_ABILITAZIONE_GEN
 WHERE prgRichiestaAz = pPrgRich;
END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_PROVINCIA  WHERE prgRichiestaAz = pPrgRich;
IF (vExistRecord<>0) THEN
INSERT INTO DO_PROVINCIA
      ( PRGRICHIESTAAZ,
       PRGPROVINCIA,
       CODPROVINCIA,
        CDNUTINS,
        CDNUTMOD,
        DTMINS,
        DTMMOD
      )
SELECT vNewPrgRich,
       S_DO_PROVINCIA.NEXTVAL,
       DO_PROVINCIA.CODPROVINCIA,
       pCdnUtInsMod,
       pCdnUtInsMod,
       SYSDATE,
       SYSDATE
  FROM DO_PROVINCIA
 WHERE prgRichiestaAz = pPrgRich;
END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_CITTADINANZA  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_CITTADINANZA
      (PRGRICHIESTAAZ,
      PRGCITTADINANZA,
       CODCITTADINANZA,
    CODMOTNAZIONALITA,
      STRMOTIVAZIONE,
       CDNUTINS,
       CDNUTMOD,
       DTMINS,
       DTMMOD
      )
SELECT vNewPrgRich,
       S_DO_CITTADINANZA.NEXTVAL,
       DO_CITTADINANZA.CODCITTADINANZA,
    DO_CITTADINANZA.CODMOTNAZIONALITA,
       DO_CITTADINANZA.STRMOTIVAZIONE,
       pCdnUtInsMod,
       pCdnUtInsMod,
      SYSDATE,
       SYSDATE
  FROM DO_CITTADINANZA
 WHERE prgRichiestaAz = pPrgRich;
END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_ORARIO  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_ORARIO
      (PRGRICHIESTAAZ,
      PRGORARIO,
      CODORARIO,
       CDNUTINS,
       CDNUTMOD,
       DTMINS,
       DTMMOD,
       FLGINVIOCL
      )
SELECT vNewPrgRich,
       S_DO_ORARIO.NEXTVAL,
      DO_ORARIO.CODORARIO,
       pCdnUtInsMod,
       pCdnUtInsMod,
      SYSDATE,
       SYSDATE,
       DO_ORARIO.FLGINVIOCL
  FROM DO_ORARIO
 WHERE prgRichiestaAz = pPrgRich;
END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_TURNO  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_TURNO
      (PRGRICHIESTAAZ,
      PRGTURNO,
      CODTURNO,
       CDNUTINS,
       CDNUTMOD,
       DTMINS,
       DTMMOD
      )
SELECT vNewPrgRich,
       S_DO_TURNO.NEXTVAL,
      DO_TURNO.CODTURNO,
       pCdnUtInsMod,
       pCdnUtInsMod,
      SYSDATE,
       SYSDATE
  FROM DO_TURNO
 WHERE prgRichiestaAz = pPrgRich;
END IF;
-- il trigger sulla richiesta inserisce il territorio associato alla sede azienda, non va reinserito
SELECT COUNT(1) INTO vExistRecord FROM DO_COMUNE  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_COMUNE
      (PRGRICHIESTAAZ,
      PRGCOMUNE,
      CODCOM,
       CDNUTINS,
       CDNUTMOD,
       DTMINS,
       DTMMOD,
       FLGINVIOCL
      )
SELECT vNewPrgRich,
       S_DO_COMUNE.NEXTVAL,
      DO_COMUNE.CODCOM,
       pCdnUtInsMod,
       pCdnUtInsMod,
      SYSDATE,
       SYSDATE,
       DO_COMUNE.FLGINVIOCL
 FROM DO_COMUNE
 WHERE prgRichiestaAz = pPrgRich and codCom <> codParComAz;
END IF;
-- nella richiesta originale potrebbe essere stato eliminato il territorio corrisponente alla sede azienda, in tal caso va eliminato anche nella copia di reiterazione
SELECT COUNT(1) INTO vExistRecord FROM DO_COMUNE  WHERE prgRichiestaAz = pPrgRich and codCom = codParComAz;
IF vExistRecord=0 THEN
   delete from do_comune where prgRichiestaAz =vNewPrgRich  and codCom = codParComAz;
END IF;



--*************** Aggiorniamo le tabelle relative alle alternative *********************
SELECT COUNT(1) INTO vExistRecord FROM DO_AGEVOLAZIONE  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_AGEVOLAZIONE
      (PRGRICHIESTAAZ,
      PRGALTERNATIVA,
      PRGAGEVOLAZIONE,
     CODAGEVOLAZIONE,
      FLGINDISPENSABILE,
       CDNUTINS,
       CDNUTMOD,
       DTMINS,
       DTMMOD
      )
SELECT vNewPrgRich,
      DO_AGEVOLAZIONE.PRGALTERNATIVA,
       S_DO_AGEVOLAZIONE.NEXTVAL,
     DO_AGEVOLAZIONE.CODAGEVOLAZIONE,
     DO_AGEVOLAZIONE.FLGINDISPENSABILE,
       pCdnUtInsMod,
       pCdnUtInsMod,
      SYSDATE,
       SYSDATE
  FROM DO_AGEVOLAZIONE
 WHERE prgRichiestaAz = pPrgRich;
END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_CONTRATTO  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_CONTRATTO
      (DO_CONTRATTO.PRGRICHIESTAAZ,
      DO_CONTRATTO.PRGALTERNATIVA,
      DO_CONTRATTO.PRGCONTRATTO,
   DO_CONTRATTO.CODCONTRATTO,
       DO_CONTRATTO.CDNUTINS,
       DO_CONTRATTO.CDNUTMOD,
       DO_CONTRATTO.DTMINS,
       DO_CONTRATTO.DTMMOD,
       DO_CONTRATTO.FLGINVIOCL
    )
SELECT vNewPrgRich,
      DO_CONTRATTO.PRGALTERNATIVA,
       S_DO_CONTRATTO.NEXTVAL,
     DO_CONTRATTO.CODCONTRATTO,
       pCdnUtInsMod,
       pCdnUtInsMod,
      SYSDATE,
       SYSDATE,
       DO_CONTRATTO.FLGINVIOCL
  FROM DO_CONTRATTO
 WHERE prgRichiestaAz = pPrgRich;
END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_COMPETENZA  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_COMPETENZA
      (DO_COMPETENZA.PRGRICHIESTAAZ,
      DO_COMPETENZA.PRGALTERNATIVA,
      DO_COMPETENZA.PRGCOMPETENZA,
   DO_COMPETENZA.CODCOMPETENZA,
   DO_COMPETENZA.FLGINDISPENSABILE,
       DO_COMPETENZA.CDNUTINS,
       DO_COMPETENZA.CDNUTMOD,
       DO_COMPETENZA.DTMINS,
       DO_COMPETENZA.DTMMOD
      )
SELECT vNewPrgRich,
      DO_COMPETENZA.PRGALTERNATIVA,
       S_DO_COMPETENZA.NEXTVAL,
   DO_COMPETENZA.CODCOMPETENZA,
   DO_COMPETENZA.FLGINDISPENSABILE,
       pCdnUtInsMod,
       pCdnUtInsMod,
    SYSDATE,
       SYSDATE
  FROM DO_COMPETENZA
 WHERE prgRichiestaAz = pPrgRich;
END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_STUDIO  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_STUDIO
      (DO_STUDIO.PRGRICHIESTAAZ,
      DO_STUDIO.PRGALTERNATIVA,
      DO_STUDIO.PRGSTUDIO,
     DO_STUDIO.CODTITOLO,
     DO_STUDIO.FLGCONSEGUITO,
     DO_STUDIO.FLGINDISPENSABILE,
     DO_STUDIO.STRSPECIFICA,
       DO_STUDIO.CDNUTINS,
       DO_STUDIO.CDNUTMOD,
       DO_STUDIO.DTMINS,
       DO_STUDIO.DTMMOD
      )
SELECT vNewPrgRich,
      DO_STUDIO.PRGALTERNATIVA,
       S_DO_STUDIO.NEXTVAL,
     DO_STUDIO.CODTITOLO,
     DO_STUDIO.FLGCONSEGUITO,
     DO_STUDIO.FLGINDISPENSABILE,
     DO_STUDIO.STRSPECIFICA,
       pCdnUtInsMod,
       pCdnUtInsMod,
      SYSDATE,
       SYSDATE
  FROM DO_STUDIO
 WHERE prgRichiestaAz = pPrgRich;
END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_FORMAZIONE_PROF  WHERE prgRichiestaAz = pPrgRich;
 IF vExistRecord<>0 THEN
 INSERT INTO DO_FORMAZIONE_PROF
       (PRGRICHIESTAAZ, 
        PRGFORMPROF,      
	    PRGALTERNATIVA, 
		CODCORSO, 
		CDNUTINS, 
		DTMINS,          
		CDNUTMOD, 
		DTMMOD,          
		FLGINDISPENSABILE 
       )
 SELECT vNewPrgRich,
		S_DO_FORMAZIONE_PROF.nextval,
		DO_FORMAZIONE_PROF.PRGALTERNATIVA,
		DO_FORMAZIONE_PROF.CODCORSO,
		DO_FORMAZIONE_PROF.CDNUTINS,
		SYSDATE,
		DO_FORMAZIONE_PROF.CDNUTMOD,
		SYSDATE,
		DO_FORMAZIONE_PROF.FLGINDISPENSABILE
   FROM DO_FORMAZIONE_PROF
  WHERE prgRichiestaAz = pPrgRich;
 END IF;
 
 SELECT COUNT(1) INTO vExistRecord FROM DO_INFO  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_INFO
      (DO_INFO.PRGRICHIESTAAZ,
      DO_INFO.PRGALTERNATIVA,
      DO_INFO.PRGINFO,
     DO_INFO.CODTIPOINFO,
     DO_INFO.CODDETTINFO,
     DO_INFO.CDNGRADO,
     DO_INFO.FLGINDISPENSABILE,
       DO_INFO.CDNUTINS,
       DO_INFO.CDNUTMOD,
       DO_INFO.DTMINS,
       DO_INFO.DTMMOD
      )
SELECT vNewPrgRich,
      DO_INFO.PRGALTERNATIVA,
       S_DO_INFO.NEXTVAL,
     DO_INFO.CODTIPOINFO,
     DO_INFO.CODDETTINFO,
     DO_INFO.CDNGRADO,
     DO_INFO.FLGINDISPENSABILE,
       pCdnUtInsMod,
       pCdnUtInsMod,
      SYSDATE,
       SYSDATE
  FROM DO_INFO
 WHERE prgRichiestaAz = pPrgRich;
END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_MANSIONE  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_MANSIONE
      (PRGRICHIESTAAZ,
       PRGALTERNATIVA,
      PRGMANSIONE,
      CODMANSIONE,
       CDNUTINS,
       CDNUTMOD,
       DTMINS,
       DTMMOD,
       FLGINVIOCL
      )
SELECT vNewPrgRich,
       DO_MANSIONE.PRGALTERNATIVA,
       S_DO_MANSIONE.NEXTVAL,
      DO_MANSIONE.CODMANSIONE,
       pCdnUtInsMod,
       pCdnUtInsMod,
      SYSDATE,
       SYSDATE,
       DO_MANSIONE.FLGINVIOCL
  FROM DO_MANSIONE
 WHERE prgRichiestaAz = pPrgRich;
END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_LINGUA  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_LINGUA
      (PRGRICHIESTAAZ,
       PRGALTERNATIVA,
      PRGLINGUA,
      CODLINGUA,
       CDNGRADOLETTO,
      CDNGRADOPARLATO,
      CDNGRADOSCRITTO,
      FLGINDISPENSABILE,
       CDNUTINS,
       CDNUTMOD,
       DTMINS,
       DTMMOD
      )
SELECT vNewPrgRich,
       DO_LINGUA.PRGALTERNATIVA,
       S_DO_LINGUA.NEXTVAL,
      DO_LINGUA.CODLINGUA,
       DO_LINGUA.CDNGRADOLETTO,
      DO_LINGUA.CDNGRADOPARLATO,
      DO_LINGUA.CDNGRADOSCRITTO,
      DO_LINGUA.FLGINDISPENSABILE,
       pCdnUtInsMod,
       pCdnUtInsMod,
      SYSDATE,
       SYSDATE
  FROM DO_LINGUA
 WHERE prgRichiestaAz = pPrgRich;
END IF;
SELECT COUNT(1) INTO vExistRecord FROM DO_RICHIESTA_ESITO  WHERE prgRichiestaAz = pPrgRich;
IF vExistRecord<>0 THEN
INSERT INTO DO_RICHIESTA_ESITO
      (PRGDORICHIESTAESITO,
       PRGRICHIESTAAZ,
       CODESITOOFF,
       NUMVALORE
      )
SELECT S_DO_RICHIESTA_ESITO.NEXTVAL,
     vNewPrgRich,
       ESITO.CODESITOOFF,
       ESITO.NUMVALORE
  FROM DO_RICHIESTA_ESITO ESITO
 WHERE ESITO.prgRichiestaAz = pPrgRich;
END IF;
COMMIT;
RETURN TO_CHAR(vNewPrgRich);
END;  --PROCEDURE reiteraRichAzienda
--******************************************************************************************
--******************************************************************************************
procedure pdStorico_AZ (prgParAzienda in AN_AZIENDA.PRGAZIENDA%TYPE,
           strParCodicefiscale in AN_AZIENDA.STRCODICEFISCALE%TYPE,
         strParPartitaiva  in AN_AZIENDA.STRPARTITAIVA%TYPE,
         strParRagionesociale in AN_AZIENDA.STRRAGIONESOCIALE%TYPE,
           codParNatgiuridica in AN_AZIENDA.CODNATGIURIDICA%TYPE,
           codParTipoazienda in AN_AZIENDA.CODTIPOAZIENDA%TYPE,
      strParUtente in TS_UTENTE.CDNUT%TYPE)
IS
begin
-- inserisco l'informazione corrente nella tabella di storicizzazione
     insert into AN_AZ_STORIA_INF
  (PRGAZSTORIAINF,
   PRGAZIENDA,
   STRCODICEFISCALE,
   STRPARTITAIVA,
   STRRAGIONESOCIALE,
     CODNATGIURIDICA,
     CODTIPOAZIENDA,
     DATINIZIO,
     DATFINE,
     STRNOTE,
     CDNUTINS,
     DTMINS,
     CDNUTMOD,
     DTMMOD) -- il kloK è gestito dal trigger di before insert nella parte std di gestione dei lock
   values
   (S_AN_AZ_STORIA_INF.nextval,
    prgParAzienda,
    strParCodicefiscale,
    strParPartitaiva,
    strParRagionesociale,
      codParNatgiuridica,
      codParTipoazienda,
    sysdate,
    null,
    null,
    strParUtente,
    sysdate,
    strParUtente,
    sysdate);
end;
procedure pdStorico_UA (prgParAzienda in AN_UNITA_AZIENDA.PRGAZIENDA%TYPE,
           prgParUnita in AN_UNITA_AZIENDA.PRGUNITA%TYPE,
      codParCom in AN_UNITA_AZIENDA.CODCOM%TYPE,
       codParazstato in AN_UNITA_AZIENDA.CODAZSTATO%TYPE,
       codParateco in AN_UNITA_AZIENDA.CODATECO%TYPE,
      strParUtente in TS_UTENTE.CDNUT%TYPE)
IS
codiceCPI         DE_CPI.CODCPI%TYPE;
progAzistorico   AN_UA_STORIA_INF.PRGAZSTORIAINF%TYPE;
begin
select codcpi into codiceCPI
  from de_comune
 where codcom = codParCom;
select min(prgazstoriainf) into progAzistorico
  from an_az_storia_inf
 where prgazienda = prgParAzienda;
-- inserisco l'informazione corrente nella tabella di storicizzazione
    insert into AN_UA_STORIA_INF
 (PRGUASTORIAINF,
  PRGAZIENDA,
  PRGUNITA,
  PRGAZSTORIAINF,
  CODCPITIT,
  CODCOM,
  CODAZSTATO,
  CODATECO,
  DATINIZIO,
  DATFINE,
  STRNOTE,
  CDNUTINS,
  DTMINS,
  CDNUTMOD,
  DTMMOD)
 values
 (S_AN_UA_STORIA_INF.nextval,
  prgParAzienda,
  prgParUnita,
  progAzistorico,
  codiceCPI,
  codParCom,
  codParazstato,
  codParateco,
  sysdate,
  null,
  null,
  strParUtente,
  sysdate,
  strParUtente,
  sysdate);
end;
-- ===============================================================================================================
-- Funzione che gestisce la protocollazione di un documento, sia AUTOMATICA che MANUALE.
--
-- AUTOMATICA: Se l'anno di prot esiste già aggiorna il num di protocollo,
--             altrimenti aggiunge un record con il nuovo anno di prot.
--
-- MANUALE: Controlla che il num di protocollo inserito sia coerente con la data
--          di inserimento, altrimento restituisce un valore negativo di errore.
--
function protocolla ( pNumProtocolloStr VARCHAR2,
                      pNumAnnoProtStr   VARCHAR2,
                      pDataProtStr      VARCHAR2,
                      pAutomatica       VARCHAR2
                    ) return number is
pNumProtocollo AM_PROTOCOLLO.NUMPROTOCOLLO%TYPE;
pNumAnnoProt   AM_PROTOCOLLO.NUMANNOPROT%TYPE;
pNumKeyLock    AM_PROTOCOLLO.NUMKLOPROTOCOLLO%TYPE;
pDataProt      AM_DOCUMENTO.DATPROTOCOLLO%TYPE;
vExistAnno     AM_PROTOCOLLO.NUMPROTOCOLLO%TYPE;
vExistProt     AM_DOCUMENTO.NUMPROTOCOLLO%TYPE;
vUpdateOK      boolean;
minNumProt     AM_DOCUMENTO.NUMANNOPROT%TYPE;
maxNumProt     AM_DOCUMENTO.NUMANNOPROT%TYPE;

BEGIN
pNumProtocollo := TO_NUMBER(pNumProtocolloStr);
pNumAnnoProt   := TO_NUMBER(pNumAnnoProtStr);
vUpdateOK      := true;


BEGIN
pDataProt      := TO_DATE(pDataProtStr,'DD/MM/YYYY HH24:MI');
-- In caso di protocollazione la data è obbligatoria:
-- controlliamo che sia inserita e che abbia un formato corretto (+o-)
IF (pDataProt IS NULL) THEN
 RETURN -40;
END IF;
       EXCEPTION
        WHEN OTHERS THEN
            IF (SQLCODE = -01858 ) THEN
              -- La data non è corretta (es. stringa vuota o un valore non numerico tipo "05 Luglio 2004")
              RETURN -41;
            ELSE
              RETURN -1;
            END IF;
END;


-- ** Protocollazione automatica **
IF (pAutomatica = 'S') THEN
BEGIN
  /*
     Questa sezione è stata commentata perchè ora la protocollazione automatica viene gestita nella classe
    it/eng/sil/bean/Documento.java.
  Questa modifica si è resa necessaria per poter gestire correnttamente la concorrenza.

  -- Controllo che l'anno in corso esista già in AM_PROTOCOLLO
  SELECT count(AM_PROTOCOLLO.NUMANNOPROT) INTO vExistAnno
    FROM AM_PROTOCOLLO
   WHERE AM_PROTOCOLLO.NUMANNOPROT = pNumAnnoProt;
  IF ( vExistAnno = 1 ) THEN
    LOOP
    BEGIN
      SELECT (AM_PROTOCOLLO.NUMKLOPROTOCOLLO+1) INTO pNumKeyLock FROM AM_PROTOCOLLO WHERE AM_PROTOCOLLO.NUMANNOPROT = pNumAnnoProt;
      SELECT (AM_PROTOCOLLO.NUMPROTOCOLLO+1) INTO pNumProtocollo FROM AM_PROTOCOLLO WHERE AM_PROTOCOLLO.NUMANNOPROT = pNumAnnoProt;
      UPDATE AM_PROTOCOLLO
         SET AM_PROTOCOLLO.NUMPROTOCOLLO    = pNumProtocollo,
             AM_PROTOCOLLO.NUMKLOPROTOCOLLO = pNumKeyLock
       WHERE AM_PROTOCOLLO.NUMANNOPROT      = pNumAnnoProt;
       -- if(sql%rowcount<1) then
       --    return -7;
       -- else return sql%rowcount;
       -- end if; --Righe di debug.
       -- Se raggiungiamo la riga seguente allora l'aggiornamento è andato a buon fine.
       -- Altrimento viene lanciata un'eccezione che è raccolata dal blocco 'EXCEPTION' sottostante
       -- e qual'ora sia dovuta a concorrenza ripetiamo l'inserimento (fino a che non si esce dalla concorrenza
       -- o fino a che non viene generato un'altro errore)
       EXIT;
       EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line(SQLERRM);
            IF (SQLCODE <> -20000) THEN
              -- NON è un errore di CONCORRENZA
              RETURN SQLCODE;
            END IF;
     END;
     END LOOP;
  ELSE
    -- L'anno non esiste ancora: è il primo documento portocollato in quell'anno.
    -- Inseriamo il nuovo anno.
    pNumProtocollo := 1;
    INSERT INTO AM_PROTOCOLLO
            ( AM_PROTOCOLLO.NUMPROTOCOLLO,
              AM_PROTOCOLLO.NUMANNOPROT,
              AM_PROTOCOLLO.NUMKLOPROTOCOLLO
            )
            VALUES
            (pNumProtocollo,pNumAnnoProt,1);
  END IF;
  */
  return -7;
END;

-- ** Protocollazione manuale **
ELSIF (pAutomatica = 'N') THEN
  BEGIN
    -- Verifichiamo che il num protocollo inserito sia corretto:

 -- non deve esistere un documento che abbia già questo numero di protocollo
 select COUNT(am_documento.PRGDOCUMENTO) into vExistProt
   from am_documento
  where am_documento.NUMPROTOCOLLO = pNumProtocollo
  -- Savino 07/10/05: aggiunta condizione sull'anno
      and am_documento.NUMANNOPROT = pNumAnnoProt;
 if (vExistProt>0) then
   return -31;
   -- Il numero di protocollo è già stato inserito
  else
    -- Deve essere minore del num di prot associato alla data di protocollazione
    -- successiva alla data inserita e maggiore del numero di protocollo associato
    -- alla data precedente alla data inserita
    select nvl(min(am2.NUMPROTOCOLLO),-1) INTO minNumProt
      from am_documento am2
     where pDataProt < am2.DATPROTOCOLLO
    -- Savino 07/10/05: aggiunta condizione sull'anno
      and am2.NUMANNOPROT = pNumAnnoProt;
    IF ((minNumProt <> -1) and (pNumProtocollo >= minNumProt)) THEN
       -- Il num di prot e troppo grande
       return -2;
    END IF;
    select nvl(max(am1.NUMPROTOCOLLO),-1) INTO maxNumProt
     from am_documento am1
    where pDataProt > am1.DATPROTOCOLLO
    -- Savino 07/10/05: aggiunta condizione sull'anno
      and am1.NUMANNOPROT = pNumAnnoProt;
    IF ((maxNumProt <> -1) and (pNumProtocollo <= maxNumProt)) THEN
       -- Il num di prot e troppo piccolo
       return -3;
    END IF;
 end if;
  END;

ELSE
  --Non è stata specificato alcun tipo di protocollazione
  return -6;
END IF;
RETURN pNumProtocollo;
END;
--FINE protocolla()

procedure pdInsRichiesta_az (prgParAzienda in DO_RICHIESTA_AZ.PRGAZIENDA%TYPE,
             prgParUnita in DO_RICHIESTA_AZ.PRGUNITA%TYPE,
        prgParRichiesta in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
        strParUtente in TS_UTENTE.CDNUT%TYPE,
        numParStorico in DO_RICHIESTA_AZ.numstorico%TYPE,
        flgParFuoriSede in DO_RICHIESTA_AZ.FLGFUORISEDE%TYPE)
IS
comune       DE_COMUNE.CODCOM%TYPE;
progcomune      DO_COMUNE.PRGCOMUNE%TYPE;
fuorisede      DO_RICHIESTA_AZ.FLGFUORISEDE%TYPE;

begin
 insert into DO_ALTERNATIVA
 (PRGRICHIESTAAZ, PRGALTERNATIVA, CDNUTINS, DTMINS, CDNUTMOD, DTMMOD)
   values
 (prgParRichiesta,1,strParUtente,sysdate,strParUtente,sysdate);

 insert into DO_EVASIONE
 (PRGRICHIESTAAZ, CDNSTATORICH, CDNUTINS, DTMINS, CDNUTMOD, DTMMOD)
 values
 (prgParRichiesta, 1, strParUtente, sysdate, strParUtente, sysdate );

 select codcom into comune
 from an_unita_azienda
 where prgazienda = prgParAzienda
 and prgunita = prgParUnita;

 fuorisede := nvl(flgParFuoriSede,'N');

 if (numParStorico=0 and fuorisede = 'N') then

  if  comune is not null then
     if comune <> 'NT' then
     select S_DO_COMUNE.nextval into progcomune
     from dual;

     insert into DO_COMUNE
     (PRGCOMUNE, CODCOM, PRGRICHIESTAAZ, CDNUTINS, DTMINS, CDNUTMOD, DTMMOD, FLGINVIOCL)
     values
     (progcomune, comune, prgParRichiesta, strParUtente, sysdate, strParUtente, sysdate, 'S' );
     end if;
  end if;
 end if;

end;
-- Funzioni di Utilità utilizzate nelle Pubblicazioni Web delle Richieste di Personale
function WebStrMansioni(parPrgRichiestaAz in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE) return varchar2 IS
   CURSOR curMansioni IS
       select distinct(de_mansione.STRDESCRIZIONE) as descr
    from do_mansione, de_mansione
    where prgRichiestaAz = parPrgRichiestaAz
    and (do_mansione.PRGALTERNATIVA=1)
      and (do_mansione.CODMANSIONE=de_mansione.CODMANSIONE);
    strMansioni varchar2(3000) := '';
BEGIN
  FOR rec in curMansioni LOOP
  if(length(strMansioni)>0) then
     strMansioni := strMansioni ||'<br>';
  end if;
  strMansioni := strMansioni || rec.descr;
 END LOOP;
 return strMansioni;
 exception
       when others then
        return '';
END WebStrMansioni;
--
function WebStrContratti(parPrgRichiestaAz in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE) return varchar2 IS
   CURSOR curContratti IS
       select distinct(de_contratto.STRDESCRIZIONE) as descr
    from do_contratto, de_contratto
    where do_contratto.PRGRICHIESTAAZ = parPrgRichiestaAz
    and (do_contratto.PRGALTERNATIVA=1)
      and (do_contratto.CODCONTRATTO=de_contratto.CODCONTRATTO);
    strContratti varchar2(3000) := '';
BEGIN
  FOR rec in curContratti LOOP
  if(length(strContratti)>0) then
     strContratti := strContratti ||'<br>';
  end if;
  strContratti := strContratti || rec.descr;
 END LOOP;
 return strContratti;
 exception
       when others then
        return '';
END WebStrContratti;
--
function WebStrTerritorio(parPrgRichiestaAz in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE) return varchar2 IS
   CURSOR curComuni IS
       select distinct de_comune.STRDENOMINAZIONE as descr, de_provincia.STRTARGA
    from do_comune, de_comune, de_provincia
    where do_comune.PRGRICHIESTAAZ = parPrgRichiestaAz
      and (do_comune.CODCOM=de_comune.CODCOM)
    and (de_comune.CODPROVINCIA=de_provincia.CODPROVINCIA);
 CURSOR curProvince IS
     select distinct de_provincia.STRDENOMINAZIONE as descr
     from do_provincia, de_provincia
     where do_provincia.PRGRICHIESTAAZ = parPrgRichiestaAz
     and (do_provincia.CODPROVINCIA = de_provincia.CODPROVINCIA);
    strTerritorio varchar2(3000) := '';
 dummy number;
BEGIN
  -- Comuni
  begin
   FOR rec in curComuni LOOP
    if(length(strTerritorio)>0) then
       strTerritorio := strTerritorio ||'<br>';
    end if;
    strTerritorio := strTerritorio || rec.descr || ' (' || rec.STRTARGA || ')';
   END LOOP;
   exception
         when others then
          dummy := 0;
  end;
  -- Province
  begin
   FOR rec in curProvince LOOP
    if(length(strTerritorio)>0) then
       strTerritorio := strTerritorio ||'<br>';
    end if;
    strTerritorio := strTerritorio || 'Prov. di ' || rec.descr;
   END LOOP;
   exception
         when others then
          dummy := 0;
  end;
  if(length(strTerritorio)>0) then
   -- ok ritorno la stringa
  return strTerritorio;
  else
   -- Trovo il comune sede dell'azienda
   begin
    select de_comune.STRDENOMINAZIONE || ' (' || de_provincia.STRTARGA || ')' into strTerritorio
    from do_richiesta_az ric
       inner join an_unita_azienda un on (ric.PRGAZIENDA=un.PRGAZIENDA and ric.PRGUNITA=un.PRGUNITA)
      inner join de_comune on (un.CODCOM=de_comune.CODCOM)
      inner join de_provincia on (de_comune.CODPROVINCIA=de_provincia.CODPROVINCIA)
    where ric.PRGRICHIESTAAZ = parPrgRichiestaAz;
    exception
         when others then
          strTerritorio := '';
  end;
  return strTerritorio;
  end if;
END WebStrTerritorio;

function WebGrigliaProvQuery return varchar2 is
  cursor curQualifica is
      select de_qualifica_pub.CODQUALIFICA
      from de_qualifica_pub;

  str varchar2(10000);
  i number;
  -- Debug
  lenStr number;
    tmpStr char(255);
    j number;

begin
  i := 1;
  str := 'select de_cpi.CODCPI, de_cpi.STRDESCRIZIONE ';
  FOR rec in curQualifica loop
    str := str ||
      ',(select count(1) ' ||
      'from do_richiesta_az ' ||
    'inner join do_evasione on (do_richiesta_az.PRGRICHIESTAAZ=do_evasione.PRGRICHIESTAAZ) ' ||
    'where (do_richiesta_az.NUMSTORICO=0 and do_richiesta_az.FLGPUBBLICATA=''S'') ' ||
    'and (do_richiesta_az.DATPUBBLICAZIONE <= sysdate and sysdate <= do_richiesta_az.DATSCADENZAPUBBLICAZIONE) ' ||
    'and (do_evasione.FLGPUBBWEB = ''S'') ' ||
    'and (do_evasione.CODEVASIONE in (''DFA'',''DFD'',''DPR'',''DRA'') ) ' ||
    'and (do_evasione.CDNSTATORICH<>5) ' ||
    'and (do_richiesta_az.CODCPI=de_cpi.CODCPI) ' ||
    'and (do_richiesta_az.CODQUALIFICA=''' || rec.codQualifica || ''') ' ||
    ') as ' || rec.codQualifica;
   i := i + 1;
  end loop;
  str := str ||
     ' from de_cpi ' ||
   'where (de_cpi.CODPROVINCIA=(select codProvinciaSil from ts_generale where rownum=1)) and ' ||
   '(de_cpi.DATFINEVAL >= sysdate) and ' ||
   'length(trim(translate(de_cpi.CODCPI, '' +-.0123456789'', '' ''))) is null ' ||
   'order by de_cpi.CODCPI ';


 -- Debug
 /*
 lenStr := length(str);
 j:= 1;
 while (j<=lenStr) loop
  tmpStr := substr(str,j, 255);
  j := j+255;
  dbms_output.PUT_LINE(tmpStr);
 end loop;
 */
 return str;
end WebGrigliaProvQuery;
--
--


--griglia per il modulo AS
function WebGrigliaASQuery RETURN typRefCurs is
  cursor cpi is
     select  de_cpi.CODCPI codice, 'AS_'||de_cpi.CODCPI as codcpi,
             replace(de_cpi.STRDESCRIZIONE,' ','_') as STRDESCRIZIONE
    from de_cpi
    where (de_cpi.CODPROVINCIA=(select codProvinciaSil from ts_generale where rownum=1))
    and  (de_cpi.DATFINEVAL >= sysdate)
    and  length(trim(translate(de_cpi.CODCPI, ' +-.0123456789', ' '))) is null
    order by  de_cpi.CODCPI;

 cursor chiam is
     SELECT  to_date(ric.datchiamata, 'dd/mm/yyyy') AS datchiamata
       FROM  do_richiesta_az ric
       INNER JOIN do_evasione ON (ric.prgrichiestaaz = do_evasione.prgrichiestaaz)
           INNER JOIN de_cpi ON (ric.codcpi = de_cpi.codcpi)
       WHERE  (ric.numstorico = 0 AND ric.flgpubblicata = 'S')
        AND  (ric.datpubblicazione <= to_date(to_char(SYSDATE, 'DD-MON-YYYY')) AND (to_date(to_char(SYSDATE, 'DD-MON-YYYY')) <= ric.datscadenzapubblicazione OR ric.datscadenzapubblicazione IS NULL))
       AND (do_evasione.flgpubbweb = 'S')
       AND (do_evasione.cdnstatorich <> 5)
      -- AND (do_evasione.cdnstatorich <> 4)
       AND (do_evasione.codevasione = 'AS')
       AND (ric.codcpi = de_cpi.codcpi)
    GROUP BY ric.datchiamata
    ORDER BY ric.datchiamata ASC;


  str long;
  rep long;
  cod varchar2(100);
  codice varchar2(100);
  risultato typRefCurs;

  i number;
  -- Debug
  lenStr number;
    tmpStr char(255);
    j number;

begin
  i := 1;

  str := 'select to_char(rich.DATCHIAMATA,''dd/mm/yyyy'') as DATCHIAMATA';
  FOR rec in cpi loop
   rep := replace(rec.STRDESCRIZIONE, ' ', '_' );
   --rep := rec.STRDESCRIZIONE;
   cod := rec.CODCPI;
   codice := rec.codice;
     str := str ||
       ',(select count(1) ' ||
       ' FROM do_richiesta_az ' ||
       ' INNER JOIN do_evasione ON (do_richiesta_az.prgrichiestaaz = do_evasione.prgrichiestaaz) '||
       ' inner join de_cpi on (do_richiesta_az.CODCPI=de_cpi.CODCPI) ' ||
           ' WHERE (do_richiesta_az.numstorico = 0 AND do_richiesta_az.flgpubblicata = ''S'') ' ||
            ' AND (do_richiesta_az.datpubblicazione <= to_date(to_char(SYSDATE, ''DD-MON-YYYY'')) AND (to_date(to_char(SYSDATE, ''DD-MON-YYYY'')) <= do_richiesta_az.datscadenzapubblicazione OR do_richiesta_az.datscadenzapubblicazione IS NULL)) '||
            ' AND (do_evasione.flgpubbweb = ''S'')' ||
            ' AND (do_evasione.cdnstatorich <> 5) ' ||
         --   ' AND (do_evasione.cdnstatorich <> 4) ' ||
            ' AND (do_evasione.codevasione = ''AS'') ' ||
            ' AND (de_cpi.CODCPI =''' || codice || ''') ' ||
            -- per il corretto funzionamento riferisco la data chiamata della subquery uguale a quella della query fuori dal loop --
            ' AND (do_richiesta_az.DATCHIAMATA = rich.DATCHIAMATA) ' ||
     ') as "' || cod || '" ' ;


  end loop;
  str := str ||
     ' from do_richiesta_az rich ' ||
    'inner join do_evasione on (rich.PRGRICHIESTAAZ=do_evasione.PRGRICHIESTAAZ) ' ||
    'inner join de_cpi on (rich.CODCPI=de_cpi.CODCPI) ' ||
    'where (rich.NUMSTORICO=0 and rich.FLGPUBBLICATA=''S'') ' ||
    'and (rich.DATPUBBLICAZIONE <= to_date(to_char(SYSDATE, ''DD-MON-YYYY'')) and (to_date(to_char(SYSDATE, ''DD-MON-YYYY'')) <= rich.DATSCADENZAPUBBLICAZIONE OR rich.datscadenzapubblicazione IS NULL)) ' ||
    'and (do_evasione.FLGPUBBWEB = ''S'')' ||
    'and (do_evasione.CDNSTATORICH<>5) ' ||
   -- 'and (do_evasione.CDNSTATORICH<>4) ' ||
    'and (do_evasione.CODEVASIONE=''AS'')' ||
    'and (rich.CODCPI=de_cpi.CODCPI) ' ||
    'group by rich.datchiamata ' ||
    'order by rich.DATCHIAMATA ASC';



 -- Debug
 /*
 lenStr := length(str);
 j:= 1;
 while (j<=lenStr) loop
  tmpStr := substr(str,j, 255);
  j := j+255;
  dbms_output.PUT_LINE(tmpStr);
 end loop;
 */

 open risultato for str;
   return risultato;
end WebGrigliaASQuery;
--
--

function WebGrigliaCMQuery RETURN typRefCurs is

  cursor cpi is
     select  de_cpi.CODCPI codice, 'CM_'||de_cpi.CODCPI as codcpi,
             replace(de_cpi.STRDESCRIZIONE,' ','_') as STRDESCRIZIONE
    from de_cpi
    where (de_cpi.CODPROVINCIA=(select codProvinciaSil from ts_generale where rownum=1))
    and  (de_cpi.DATFINEVAL >= sysdate)
    and  length(trim(translate(de_cpi.CODCPI, ' +-.0123456789', ' '))) is null
         order by  de_cpi.CODCPI;

 cursor chiam is
     SELECT  to_date(ric.datchiamatacm, 'dd/mm/yyyy') AS datchiamatacm
       FROM  do_richiesta_az ric
       INNER JOIN do_evasione ON (ric.prgrichiestaaz = do_evasione.prgrichiestaaz)
           INNER JOIN de_cpi ON (ric.codcpi = de_cpi.codcpi)
       WHERE  (ric.numstorico = 0 AND ric.flgpubblicata = 'S')
        AND  (ric.datpubblicazione <= to_date(to_char(SYSDATE, 'DD-MON-YYYY')) AND (to_date(to_char(SYSDATE, 'DD-MON-YYYY')) <= ric.datscadenzapubblicazione OR ric.datscadenzapubblicazione IS NULL))
       AND (do_evasione.flgpubbweb = 'S')
       AND (do_evasione.cdnstatorich <> 5)
      -- AND (do_evasione.cdnstatorich <> 4)
       AND (do_evasione.codevasione = 'CMA')
       AND (ric.codcpi = de_cpi.codcpi)
    GROUP BY ric.datchiamatacm
    ORDER BY ric.datchiamatacm ASC;


  str long;
  rep long;
  cod varchar2(100);
  codice varchar2(100);
  risultato typRefCurs;

  i number;
  -- Debug
  lenStr number;
    tmpStr char(255);
    j number;

begin
  i := 1;

  str := 'select to_char(rich.DATCHIAMATACM,''dd/mm/yyyy'') as DATCHIAMATACM';
  FOR rec in cpi loop
   rep := replace(rec.STRDESCRIZIONE, ' ', '_' );
   --rep := rec.STRDESCRIZIONE;
   cod := rec.CODCPI;
   codice := rec.codice;
     str := str ||
       ',(select count(1) ' ||
       ' FROM do_richiesta_az ' ||
       ' INNER JOIN do_evasione ON (do_richiesta_az.prgrichiestaaz = do_evasione.prgrichiestaaz) '||
       ' inner join de_cpi on (do_richiesta_az.CODCPI=de_cpi.CODCPI) ' ||
           ' WHERE (do_richiesta_az.numstorico = 0 AND do_richiesta_az.flgpubblicata = ''S'') ' ||
            ' AND (do_richiesta_az.datpubblicazione <= to_date(to_char(SYSDATE, ''DD-MON-YYYY'')) AND (to_date(to_char(SYSDATE, ''DD-MON-YYYY'')) <= do_richiesta_az.datscadenzapubblicazione OR do_richiesta_az.datscadenzapubblicazione IS NULL)) '||
            ' AND (do_evasione.flgpubbweb = ''S'')' ||
            ' AND (do_evasione.cdnstatorich <> 5) ' ||
         --   ' AND (do_evasione.cdnstatorich <> 4) ' ||
            ' AND (do_evasione.codevasione = ''CMA'') ' ||
            ' AND (de_cpi.CODCPI =''' || codice || ''') ' ||
            -- per il corretto funzionamento riferisco la data chiamata della subquery uguale a quella della query fuori dal loop --
            ' AND (do_richiesta_az.DATCHIAMATACM = rich.DATCHIAMATACM) ' ||
     ') as "' || cod || '" ' ;


  end loop;
  str := str ||
     ' from do_richiesta_az rich ' ||
    'inner join do_evasione on (rich.PRGRICHIESTAAZ=do_evasione.PRGRICHIESTAAZ) ' ||
    'inner join de_cpi on (rich.CODCPI=de_cpi.CODCPI) ' ||
    'where (rich.NUMSTORICO=0 and rich.FLGPUBBLICATA=''S'') ' ||
    'and (rich.DATPUBBLICAZIONE <= to_date(to_char(SYSDATE, ''DD-MON-YYYY'')) and (to_date(to_char(SYSDATE, ''DD-MON-YYYY'')) <= rich.DATSCADENZAPUBBLICAZIONE OR rich.datscadenzapubblicazione IS NULL)) ' ||
    'and (do_evasione.FLGPUBBWEB = ''S'')' ||
    'and (do_evasione.CDNSTATORICH<>5) ' ||
   -- 'and (do_evasione.CDNSTATORICH<>4) ' ||
    'and (do_evasione.CODEVASIONE=''CMA'')' ||
    'and (rich.CODCPI=de_cpi.CODCPI) ' ||
    'group by rich.datchiamatacm ' ||
    'order by rich.DATCHIAMATACM ASC';



 -- Debug
 /*
 lenStr := length(str);
 j:= 1;
 while (j<=lenStr) loop
  tmpStr := substr(str,j, 255);
  j := j+255;
  dbms_output.PUT_LINE(tmpStr);
 end loop;
 */

 open risultato for str;
   return risultato;
end WebGrigliaCMQuery;


function cancAutomaticaDaRosa(p_prgRosa DO_NOMINATIVO.PRGROSA%type,
          p_cdnUt DO_NOMINATIVO.CDNUTCANC%type,
         p_prgRichOrig DO_INCROCIO.PRGRICHIESTAAZ%type) RETURN NUMBER IS
-- declare
    CURSOR curNom IS
        select * from do_nominativo
     WHERE do_nominativo.PRGROSA = p_prgRosa
       and do_nominativo.CODTIPOCANC is null
     and not exists
      (select 1 from do_disponibilita
      where do_disponibilita.PRGRICHIESTAAZ=p_prgRichOrig
      and do_disponibilita.CDNLAVORATORE=do_nominativo.CDNLAVORATORE
      and do_disponibilita.CODDISPONIBILITAROSA is not null);


BEGIN
  FOR rec in curNom LOOP
   update do_nominativo
   set
     do_nominativo.CODTIPOCANC = 'A',
    do_nominativo.STRMOTIVOCANC = 'Automatica per mancanza di dati sulla disponibilita'' della specifica richiesta',
    do_nominativo.DTMCANC = sysdate,
    do_nominativo.CDNUTCANC = p_cdnUt,
    do_nominativo.NUMKLONOMINATIVO = (rec.NUMKLONOMINATIVO +1)
   where
     do_nominativo.PRGNOMINATIVO = rec.PRGNOMINATIVO;
  END LOOP;
  --
  --commit; -- Non ci va perchè è chiamata all'interno di una transaction
  return 0;
  --
  exception
       when others then
        --rollback; -- Non ci va perchè è chiamata all'interno di una transaction
     return -1;
END cancAutomaticaDaRosa;


function deleteCopiaRichiesta(pRichiesta DO_ALTERNATIVA.prgRichiestaAz%TYPE) return number is

alternativa        DO_ALTERNATIVA.prgAlternativa%TYPE;
prgCopiaRichiesta   DO_ALTERNATIVA.prgRichiestaAz%TYPE;
prgRichiestaOrig   DO_ALTERNATIVA.prgRichiestaAz%TYPE;
val number;

cursor cursore_alter is
    select  prgAlternativa
         from DO_ALTERNATIVA
         where prgRichiestaAz = pRichiesta;
begin

--seleziono il progressivo della rihiesta Copia il cui numStorico è 1
select az1.prgRichiestaAz
 into prgCopiaRichiesta
 from DO_RICHIESTA_AZ az1,
   DO_RICHIESTA_AZ az2
 where
   az1.numstorico=1 and
   az1.numanno=az2.numanno and
   az1.numRichiesta=az2.numRichiesta and
   az2.prgRichiestaAz = pRichiesta;

prgRichiestaOrig := pRichiesta;

--elimino le righe dalle tabelle cui hanno un riferimento alla tabella do_alternativa
for val_cursore in cursore_alter
 loop

  alternativa:= val_cursore.prgAlternativa;

  delete from do_competenza
      where prgRichiestaAz = prgCopiaRichiesta
      and prgAlternativa = alternativa;


  delete from do_agevolazione
      where prgRichiestaAz = prgCopiaRichiesta
      and prgAlternativa = alternativa;

  delete from do_studio
      where prgRichiestaAz = prgCopiaRichiesta
      and prgAlternativa = alternativa;

  delete from do_formazione_prof
      where prgRichiestaAz = prgCopiaRichiesta
      and prgAlternativa = alternativa;
	  
  delete from do_info
      where prgRichiestaAz = prgCopiaRichiesta
      and prgAlternativa = alternativa;

  delete from do_contratto
      where prgRichiestaAz = prgCopiaRichiesta
      and prgAlternativa = alternativa;

  delete from do_mansione
      where prgRichiestaAz = prgCopiaRichiesta
      and prgAlternativa = alternativa;

  delete from do_lingua
      where prgRichiestaAz = prgCopiaRichiesta
      and prgAlternativa = alternativa;


 end loop;

-- elimino la tabella do_alternativa
delete from do_alternativa
    where prgRichiestaAz=prgCopiaRichiesta;

--elimino le righe dalle tabelle cui hanno un riferimento alla tabella do_richiesta_az
delete from do_evasione
    where prgRichiestaAz=prgCopiaRichiesta;


delete from do_cittadinanza
    where prgRichiestaAz=prgCopiaRichiesta;

delete from do_orario
    where prgRichiestaAz=prgCopiaRichiesta;

delete from do_turno
    where prgRichiestaAz=prgCopiaRichiesta;

delete from do_provincia
    where prgRichiestaAz=prgCopiaRichiesta;

delete from do_comune
    where prgRichiestaAz=prgCopiaRichiesta;

delete from do_abilitazione_gen
    where prgRichiestaAz=prgCopiaRichiesta;


--elimino la richiesta
delete from do_richiesta_az
    where prgRichiestaAz = prgCopiaRichiesta
    and numStorico = 1;

return prgRichiestaOrig;

end;


function resetCopiaRichiesta(pRichiesta DO_ALTERNATIVA.prgRichiestaAz%TYPE)return number is

errorCode  Number;
valueReturn Number;
prgRichiestaOrig      DO_ALTERNATIVA.prgRichiestaAz%TYPE;
begin
  prgRichiestaOrig := deleteCopiaRichiesta(pRichiesta);
  valueReturn := storicizzaRichiesta(prgRichiestaOrig, 0, 1,errorCode);
  if valueReturn =-1 then raise_application_error(-20001, 'Storicizzazione Richiesta Fallita');
  end if;
  return valueReturn;
exception
   when others then
      dbms_output.put_line('Errore= ' || errorCode || ' ' || sqlerrm);
   raise;
end;

-- Funzioni di Utilità utilizzate nella lista aste Art.16 Web della Raccolta Adesioni
function WebStrMansioniProfilo(parPrgRichiestaAz in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
                               parPrgAlternativa in DO_ALTERNATIVA.PRGALTERNATIVA%TYPE) return varchar2 IS
   CURSOR curMansioni IS
       select distinct('-'||de_mansione.STRDESCRIZIONE) as descr
    from do_mansione, de_mansione
    where prgRichiestaAz = parPrgRichiestaAz
    and (do_mansione.PRGALTERNATIVA=parPrgAlternativa)
      and (do_mansione.CODMANSIONE=de_mansione.CODMANSIONE);
    strMansioni varchar2(3000) := '';
BEGIN
  FOR rec in curMansioni LOOP
  if(length(strMansioni)>0) then
     strMansioni := strMansioni ||'<br>';
  end if;
  strMansioni := strMansioni || rec.descr;
 END LOOP;
 return strMansioni;
 exception
       when others then
        return '';
END WebStrMansioniProfilo;

function WebStrContrattiProfilo(parPrgRichiestaAz in DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
                                parPrgAlternativa in DO_ALTERNATIVA.PRGALTERNATIVA%TYPE) return varchar2 IS
   CURSOR curContratti IS
       select distinct('-'||de_contratto.STRDESCRIZIONE) as descr
    from do_contratto, de_contratto
    where do_contratto.PRGRICHIESTAAZ = parPrgRichiestaAz
    and (do_contratto.PRGALTERNATIVA = parPrgAlternativa)
      and (do_contratto.CODCONTRATTO = de_contratto.CODCONTRATTO);
    strContratti varchar2(3000) := '';
BEGIN
  FOR rec in curContratti LOOP
  if(length(strContratti)>0) then
     strContratti := strContratti ||'<br>';
  end if;
  strContratti := strContratti || rec.descr;
 END LOOP;
 return strContratti;
 exception
       when others then
        return '';
END WebStrContrattiProfilo;


/****************************************************************************************
* Salva il riferimento del documento per le richieste trovate - tabella AS_REL_RICH_DOC *
****************************************************************************************/
function ASInsRelDocRich(p_prgDocumento number,
                         dataChiamata varchar2,
                         codCpi varchar2,
                         modPubblicazione varchar2,
                         p_errCode OUT number
                         ) RETURN NUMBER is


str varchar2(6000);
str1 varchar2(6000);
query varchar2(6000);
risultatoCursor typRefCurs;
aarisultatoCursor typRefCurs;
P_PRGRICHIESTA DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE;

begin

  str:=  ' select raz.prgrichiestaaz '||
       ' from do_richiesta_az raz '||
       ' inner join do_evasione ev on ev.prgrichiestaaz = raz.prgrichiestaaz  '||
       ' where ev.cdnstatorich <> 5 '||
       ' and ( ev.codevasione = ''AS'' or ev.codevasione = ''CMA'' ) '||
       ' and (raz.DATPUBBLICAZIONE < sysdate) '||
       ' and (raz.DATSCADENZAPUBBLICAZIONE is null or raz.DATSCADENZAPUBBLICAZIONE >= sysdate) '||
       ' and ( raz.datchiamata = to_date('''|| dataChiamata ||''', ''dd/mm/yyyy'') '||
     ' or raz.datchiamatacm = to_date('''|| dataChiamata ||''', ''dd/mm/yyyy'') ) '||
       ' and raz.codcpi = '''|| codCpi ||''' ';

  if (modPubblicazione is not null) then
     if (to_number(modPubblicazione) = 1) then
        query := str || ' and ev.FLGPUBBWEB = ''S'' ';
     elsif (to_number(modPubblicazione) = 2) then
        query := str || ' and ev.FLGPUBBBACHECA = ''S'' ';
     end if;

  end if;

 open risultatoCursor for query;


  LOOP
    FETCH risultatoCursor INTO P_PRGRICHIESTA;
    EXIT WHEN risultatoCursor%NOTFOUND;

    insert into as_rel_rich_doc
    (prgrichiestaaz,
    prgdocumento)
    values
    (P_PRGRICHIESTA,
    p_prgDocumento);

  END LOOP;

  return 0;

  exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         p_errCode := sqlcode;
         rollback;
       return -1;

end ASInsRelDocRich;


FUNCTION STR_EVASIONE(PAR_STR VARCHAR2)
RETURN VARCHAR2 is
 BUFFER VARCHAR2(50);
BEGIN

  IF (PAR_STR='D') THEN
    BUFFER := 'Avviamento Numerico art. 8';
  ELSIF (PAR_STR='A') THEN
    BUFFER := 'Avviamento Numerico art. 18';
  ELSIF (PAR_STR='G') THEN
    BUFFER := 'Graduatoria art. 1';
  END IF;

RETURN buffer;

END STR_EVASIONE;

END PG_IDO;
/



/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_INCROCIO.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_INCROCIO AS
  -- Autore  : Stefania Orioli
  -- Algoritmi di Matching
  -- Versione 2_4
  TYPE t_cursor IS REF CURSOR ;
  TYPE typRefCurs IS REF CURSOR ;
  -- Crea le componenti per lo statement che esegue il matching Esatto
  function Matching_esatto
    (
    p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
    p_prgRosa DO_ROSA.PRGROSA%TYPE,           -- progressivo della rosa sulla quale eseguire il matching
    p_statoCv DE_STATO_SCHEDALAV.CODSTATOLAV%TYPE,    -- stato del CV (opzionale - non usato per ora)
    p_usaPref int,            -- utilizza anche i parametri con richiesta "preferibile"
    p_usaNonInd int,            -- utilizza anche i parametri con richiesta "non indispensabile"
    p_flagDI int,             -- solo Disoccupati/Inoccupati
    p_flagIncMir int,         -- flag collocamento mirato
    p_db int,                -- base dati da utilizzare
    p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_dataValCV  varchar2,           -- data in base alla quale considerare valido un CV
    p_checkCM  number,              -- interruttore per il collocamento mirato
    encrypeterKey varchar2,
    p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
  p_flagGG int,             -- solo Garanzia Giovani
    p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
    p_out_query_select OUT varchar2,
    p_out_query_from OUT varchar2,
    p_out_query_join OUT varchar2,
    p_out_query_where OUT long,
      p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,   -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE      -- progressivo della rosa
    ) return number;
  -- Crea le componenti per lo statement che esegue il matching Esatto senza considerare la mansione richiesta
   function Matching_esatto_no_mansione
    (
    p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
    p_prgRosa DO_ROSA.PRGROSA%TYPE,           -- progressivo della rosa sulla quale eseguire il matching
    p_statoCv DE_STATO_SCHEDALAV.CODSTATOLAV%TYPE,    -- stato del CV (opzionale - non usato per ora)
    p_usaPref int,            -- utilizza anche i parametri con richiesta "preferibile"
    p_usaNonInd int,            -- utilizza anche i parametri con richiesta "non indispensabile"
    p_flagDI int,             -- solo Disoccupati/Inoccupati
    p_flagIncMir int,         -- flag collocamento mirato
    p_db int,                -- base dati da utilizzare
    p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_dataValCV  varchar2,           -- data in base alla quale considerare valido un CV
    p_checkCM  number,              -- interruttore per il collocamento mirato
    encrypterKey varchar2,
    p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
  p_flagGG int,             -- solo Garanzia Giovani
    p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
    p_out_query_select OUT varchar2,
    p_out_query_from OUT varchar2,
    p_out_query_join OUT varchar2,
      p_out_query_where OUT long,
      p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,   -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE      -- progressivo della rosa
    ) return number;
   -- Esegue il matching date le componenti della query generate da uno degli algoritmi di matching
   -- il parametro p_mem=1 serve per l'esecuzione in locale, quando si utilizza la cooperazione
   -- applicativa la procedura viene chiamata con p_mem=0 in modo da restituire i risultati parziali
   -- nel recordset p_cursor.
   function eseguiIncrocio(
   p_query_select varchar2,
   p_query_from varchar2,
   p_query_join varchar2,
   p_query_where long,
   p_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,  -- progressivo dell'incrocio
   p_prgRosa DO_ROSA.PRGROSA%TYPE,      -- progressivo della rosa
   p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
   p_mem char,
   encrypterkey varchar2,
   p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
   p_ErrCode OUT number
   --p_cursor OUT t_cursor
   ) return number;

   -- Crea le componenti per lo statement di prima selezione dei candidati da pesare
   function Matching_Pesato_PEsatti(
    p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
    p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
    p_db int,                -- base dati da utilizzare
    p_dataValCV  varchar2,          -- data in base alla quale considerare valido un CV
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_numPFasciaEtaPrima number,         -- peso associato alla prima fascia di età estesa
    p_numPFasciaEtaSec number,         -- peso associato alla seconda fascia di età estesa
    p_numPStudioGruppo number,         -- peso associato a un titolo di studio nel gruppo
    p_numPStudioAlias number,          -- peso associato a un titolo di studio associato
    p_numPMansioneGruppo number,         -- peso associato a una mansione nel gruppo
    p_numPMansioneAlias number,         -- peso associato a una mansione associata
    p_numPNoEsperienza number,         -- peso associato alla mansione senza esperienza
    p_numPEsperienzaAlias number,         -- peso associato all'esperienza in una mansione simile
    p_numPInfoMin number,           -- peso associato alla conoscenza info con grado minore
    p_numPInfoGruppo number,          -- peso associato a una conoscenza info nello stesso gruppo
    p_numPInfoGruppoMIn number,         -- peso associato a una conoscenza info nello stesso gruppo e grado minore
    p_numPLinguaInf number,           -- peso associato a una conoscenza linguistica con grado minore
    p_numPSogliaRichiesta number,         -- valore di soglia entro il quale estrarre i candidati
    p_flagIncMir int,         -- flag collocamento mirato
    p_checkCM  number,              -- interruttore per il collocamento mirato
    p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
    p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
    p_out_query_select OUT varchar2,
    p_out_query_from OUT varchar2,
    p_out_query_join OUT varchar2,
    p_out_query_where OUT long,
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE,       -- progressivo della rosa
    p_out_where_territorio OUT varchar2
    ) return number;
 -- Esegue il matching pesato date le componenti della query  discriminante generata
 -- dall'algoritmo Matching_Pesato_PEsatti.
    -- Il parametro p_mem=1 serve per l'esecuzione in locale, quando si utilizza la cooperazione
    -- applicativa la procedura viene chiamata con p_mem=0 in modo da restituire i risultati parziali
    -- nel recordset p_cursor.
function eseguiIncrocioPesato(
   p_in_query_select varchar2,
   p_in_query_from varchar2,
   p_in_query_join varchar2,
   p_in_query_where long,
   p_in_where_territorio varchar2,
   p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%type, -- progressivo della richiesta
   p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%type, -- progressivo dell'alternativa
   p_in_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,  -- progressivo dell'incrocio
   p_in_prgRosa DO_ROSA.PRGROSA%TYPE,      -- progressivo della rosa
   p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
   p_mem char,
   p_numPFasciaEtaPrima number,         -- peso associato alla prima fascia di età estesa
   p_numPFasciaEtaSec number,         -- peso associato alla seconda fascia di età estesa
   p_numPStudioGruppo number,         -- peso associato a un titolo di studio nel gruppo
   p_numPStudioAlias number,          -- peso associato a un titolo di studio associato
   p_numPMansioneGruppo number,         -- peso associato a una mansione nel gruppo
   p_numPMansioneAlias number,         -- peso associato a una mansione associata
   p_numPNoEsperienza number,         -- peso associato alla mansione senza esperienza
   p_numPEsperienzaAlias number,         -- peso associato all'esperienza in una mansione simile
   p_numPInfoMin number,           -- peso associato alla conoscenza info con grado minore
   p_numPInfoGruppo number,          -- peso associato a una conoscenza info nello stesso gruppo
   p_numPInfoGruppoMIn number,         -- peso associato a una conoscenza info nello stesso gruppo e grado minore
   p_numPLinguaInf number,           -- peso associato a una conoscenza linguistica con grado minore
   p_numPSogliaRichiesta number,         -- valore di soglia entro il quale estrarre i candidati
   p_flagIncMir int,         -- flag collocamento mirato
   p_checkCM  number,              -- interruttore per il collocamento mirato
   encrypterKey varchar2,
   p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
   p_ErrCode OUT number
   --p_cursor OUT t_cursor
   ) return number;
   /*********************************************************
   * Funzioni per la creazione della Rosa Nominativa Grezza *
   *********************************************************/
       /* Funzione per la creazione della Rosa Nominativa Grezza in cui si può definire il commit immeddiato o demandato a chi la invoca */
    function creaRosaNomGrezzaTrans(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,               -- progressivo della richiesta (originale o copia di lavoro)
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_isCommitted number,          -- definisce se la procedura deve essre committata
    p_errCode OUT number,           -- Codice di Errore
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,   -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE      -- progressivo della rosa
    ) RETURN NUMBER;

      /* Funzione per la creazione della Rosa Nominativa Grezza richiama la creaRosaNomGrezzaTrans con p_isCommitted a true*/
   function creaRosaNomGrezza(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,               -- progressivo della richiesta (originale o copia di lavoro)
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_errCode OUT number,           -- Codice di Errore
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,   -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE      -- progressivo della rosa
    ) RETURN NUMBER;

   /****************************************************************************
   * Funzione per l'inserimento di un lavoratore in una Rosa Nominativa Grezza *
   *****************************************************************************/

   /* Funzione per l'inserimento di un lavoratore in una Rosa Nominativa Grezza in cui si può definire il commit immeddiato o demandato a chi la invoca */
   function inserisciLavRosaNomGrezzaTrans(
       p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,      -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
       p_cdnUtente TS_UTENTE.CDNUT%TYPE,       -- utente che effettua l'incrocio
       p_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
       p_prgRosa DO_ROSA.PRGROSA%TYPE,       -- progressivo della rosa
       p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,   -- cdnLavoratore da inserire nella rosa
       p_codCpi DE_CPI.CODCPI%TYPE,        -- il cpi del contatto
       p_prgSpiContatto AN_SPI.PRGSPI%TYPE,      -- il progressivo dell'operatore servizio cpi del contatto
       p_prgTipoContatto DE_TIPO_CONTATTOAG.PRGTIPOCONTATTO%TYPE, -- il tipo di contatto (e-mail, tel etc.)
       p_isCommitted number,          -- definisce se la procedura deve essre committata
       p_errCode OUT number          -- Codice di Errore
  ) RETURN NUMBER ;

  /* Funzione per l'inserimento di un lavoratore in una Rosa Nominativa Grezza richiama la inserisciLavRosaNomGrezzaTrans con p_isCommitted a true*/
  function inserisciLavRosaNomGrezza(
       p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,      -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
       p_cdnUtente TS_UTENTE.CDNUT%TYPE,       -- utente che effettua l'incrocio
       p_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
       p_prgRosa DO_ROSA.PRGROSA%TYPE,       -- progressivo della rosa
       p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,   -- cdnLavoratore da inserire nella rosa
       p_codCpi DE_CPI.CODCPI%TYPE,        -- il cpi del contatto
       p_prgSpiContatto AN_SPI.PRGSPI%TYPE,      -- il progressivo dell'operatore servizio cpi del contatto
       p_prgTipoContatto DE_TIPO_CONTATTOAG.PRGTIPOCONTATTO%TYPE, -- il tipo di contatto (e-mail, tel etc.)
       p_errCode OUT number          -- Codice di Errore
  ) RETURN NUMBER ;
  /**************************************************************************************
  * Funzione per la cancellazione fisica di un lavoratore da una Rosa Nominativa Grezza *
  **************************************************************************************/
  function delFisicaLavRosaNomGrezza(
      p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,       -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
      p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
      p_prgRosa DO_ROSA.PRGROSA%TYPE,        -- progressivo della rosa
      p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,    -- cdnLavoratore da inserire nella rosa
        p_errCode OUT number           -- Codice di Errore
  ) RETURN NUMBER;
  /*************************************************************************
  * Procedura per l'inserimento nella rosa della data di invio della stessa *
  **************************************************************************/
  PROCEDURE insDataInvioRosa( pPrgRichAzStr VARCHAR2,
                            pPrgRosaStr   VARCHAR2,
                            pDatInvioStr  VARCHAR2,
                            pCdnUtModStr  VARCHAR2,
       pTutteStr   VARCHAR2,
       pCdnGrpModStr VARCHAR2);
   --*******************************************************
   -- Funzioni di utilita' per gli algoritmi di Matching
   --*******************************************************
   function pdMasterLavo(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type) RETURN NUMBER;
   function pdStatoOcc(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type) RETURN NUMBER;
   function pdCpiTit(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type) RETURN varchar;
   function pdDidLavo(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type) RETURN do_nominativo.DATDICHIARAZIONE%type;
   function pdIndispAzienda(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type,
       p_prgRichiestaAZ DO_RICHIESTA_AZ.PRGRICHIESTAAZ%type) RETURN number;
   function checkGG(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type) RETURN NUMBER;
   function checkFormProf(p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE, p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE, p_usaNonInd int) RETURN VARCHAR2;
   function checkGGCresco(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type,
            p_datarichiesta DO_RICHIESTA_AZ.DATRICHIESTA%TYPE,
            p_datascadpubbl DO_RICHIESTA_AZ.DATSCADENZAPUBBLICAZIONE%TYPE) RETURN NUMBER;
   --*******************************************************
   -- Funzioni di utilità varie
   --*******************************************************
   /*function pdTerrSedeAz(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,
        p_codCom AN_UNITA_AZIENDA.CODCOM%TYPE,
       p_strMansione varchar) return number;*/
   /*function pdTerrRichiestaAz(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,
        p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
       numComuni number,
       numProvince number,
       p_strMansione varchar) return number;*/
   function pdStatoRichOrig(p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE) RETURN varchar2;
   function pdStatoEvRichOrig(p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE) RETURN varchar2;
   -- calcola gli anni (non compiuti) del lavoratore
   function etaMatch(p_dataNasc date) return number;
   -- calcola gli anni (non compiuti) del lavoratore, alla data chiamata della richiesta di personale
   function etaMatchChiamata(p_dataNasc date, p_dataChiamata date) return number;
   -- calcolo della disponibilità territoriale per l'incrocio esatto
   function pdCalcoloNumT(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,
        p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
       p_strMansione varchar2,
       numComuni number, numProv number) return number;

     /************************************************************
   * Funzione per la predisposizione dell'asta per le adesioni *
   *************************************************************/
   function AScreaRosaNomGrezza(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,               -- progressivo della richiesta (originale o copia di lavoro)
    p_codEvasioneRich DO_EVASIONE.Codevasione%type,
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_errCode OUT number,           -- Codice di Errore
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,   -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE      -- progressivo della rosa
    ) RETURN NUMBER;

      /**************************************************************************************
   * Funzione per la cancellazione del profilo della rosa e degli incroci corrispondenti  *
   ****************************************************************************************/
   function ASdeleteProfiloRosaNomGrezza(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,               -- progressivo della richiesta (originale o copia di lavoro)
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,       -- progressivo del profilo
    p_errCode OUT number           -- Codice di Errore
   ) RETURN NUMBER;

    /**************************************************************************************
    * Funzione per l'inserimento di una adesione per il lavoratore specifico alla richiesta *
    ***************************************************************************************/


function ASInsertAdesioneLavoratore(
    p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
      p_prgSpiContatto Ag_Contatto.Prgspicontatto%TYPE,                 -- operatore selezionato
      p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
      p_cdnGruppo Ts_Gruppo.Cdngruppo%TYPE,                       -- gruppo a cui fa parte l'utente
      p_errCode OUT number,           -- Codice di Errore
      p_codmonodid   IN      do_nominativo.codmonodid%type, -- Calcolo Did (Da Sil, A prescindere, o escludi)
      p_codmonoisee  IN      do_nominativo.codmonoisee%type, -- Calcolo Isee (Da Sil o escludi)
	  p_numcaricofam IN      do_nominativo.numcaricofam%type,
	  p_flgprofessionalita IN do_nominativo.flgprofessionalita%type,
	  p_flgfamdec      IN     do_nominativo.flgfamdec%type)
 RETURN NUMBER;



function ASUpdateAdesioneLavoratore(
    p_prgNominativo Do_nominativo.Prgnominativo%TYPE,                                   -- progressivo della rosa
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
    p_codmonodid   do_nominativo.codmonodid%type, -- Calcolo Did (Da Sil, A prescindere, o escludi)
    p_codmonoisee  do_nominativo.codmonoisee%type, -- Calcolo Isee (Da Sil o escludi)
	p_numcaricofam IN      do_nominativo.numcaricofam%type,
	p_flgprofessionalita IN do_nominativo.flgprofessionalita%type,
	p_flgfamdec      IN     do_nominativo.flgfamdec%type,
    p_errCode OUT number         -- Codice di Errore
) RETURN NUMBER;

    /**************************************************************************************
    * Funzione per la cancellazione di una adesione per il lavoratore specifico           *
    * e il cambio dello stato della rosa a temporanea se non vi sono altre adesioni       *
    ***************************************************************************************/
    function ASDeleteAdesioneLavoratore(
        p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
        p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
          p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,                  -- progressivo dell'adesione
        p_errCode OUT number           -- Codice di Errore
    ) RETURN NUMBER;

    /**************************************************************************************
    * Funzione per l'inserimento di un contatto per l'adesione alla richiesta *
    ***************************************************************************************/
    function ASInsertContattoAdesione(
          p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
          p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,                 -- progressivo dell'adesione
        p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del lavoratore
          p_prgSpiContatto Ag_Contatto.Prgspicontatto%TYPE,                 -- operatore selezionato
          p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
          p_cdnGruppo Ts_Gruppo.Cdngruppo%TYPE,                       -- gruppo a cui fa parte l'utente
        p_errCode OUT number           -- Codice di Errore
    ) RETURN NUMBER;

    /**************************************************************************************
    * Funzione per la cancellazione di un contatto per l'adesione alla richiesta *
    ***************************************************************************************/
    function ASDeleteContattoAdesione(
      p_prgRosa Do_Rosa.Prgrosa%TYPE,
      p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,                 -- progressivo dell'adesione                                -- progressivo della rosa
    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del lavoratore
     p_dataIns do_nominativo.dtmins%TYPE,                       -- data inserimento adesione
      p_errCode OUT number                                    -- Codice di Errore
    ) RETURN NUMBER;

    /***************************************************************************
    * Funzione per la verifica del tiporosa nell'aggiornamento della richiesta *
    ****************************************************************************/
    function AScheckTipoRosa(
        p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,     -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
          p_prgTipoIncrocio DO_INCROCIO.PRGTIPOINCROCIO%TYPE,     -- tipo dell'incrocio
        p_errCode OUT number         -- Codice di Errore
    ) RETURN NUMBER;

    /****************************************************************************
    * Funzione per la riapertura della graduatoria, genera una copia della rosa *
    * e dell'incrocio e aggiorna il prgRosaFiglia della rosa di partenza        *
    ****************************************************************************/
    function ASRiaperturaGraduatoria(
    p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa da copiare
      p_numklorosa Do_Rosa.Numklorosa%TYPE,                             -- Numklorosa della rosa da aggiornare
      p_prgIncrocio Do_Incrocio.Prgincrocio%TYPE,                        -- progressivo dell'incricio da copiare
      p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
      p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,               -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE,                        -- progressivo della rosa
      p_errCode OUT number                                             -- Codice di Errore
      ) RETURN NUMBER;

/***************************************************************************
* Funzione per la verifica della presenza della DID alla data di pubblicazione *
****************************************************************************/
function ASPresenzaDispDID(
    p_cdnLavoratore   DO_NOMINATIVO.CDNLAVORATORE%TYPE,       -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_dataPubblicazione DO_RICHIESTA_AZ.DATPUBBLICAZIONE%TYPE,     -- tipo dell'incrocio
    p_dataChiamata      DO_RICHIESTA_AZ.DATCHIAMATA%TYPE,
    p_errCode OUT number         -- Codice di Errore
) RETURN BOOLEAN;

/***************************************************************************
* Funzione per la verifica dello Stato Occupazionale Disoccupato o Inoccupato a Data Chiamata (per CAL)  o DataPubblicazione (per VDA) *
****************************************************************************/
function ASStatoOccDataChiam(
    p_cdnLavoratore   DO_NOMINATIVO.CDNLAVORATORE%TYPE,       -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_dataChiamata      DO_RICHIESTA_AZ.DATCHIAMATA%TYPE,
	p_dataPubblicazione DO_RICHIESTA_AZ.DATPUBBLICAZIONE%TYPE,
	p_config            Ts_Config_Loc.num%type,
    p_errCode OUT number         -- Codice di Errore
) RETURN BOOLEAN;

/***************************************************************************
* Funzione per la verifica dello stato Occupazionale a Data Chiamata per maggiorazione punteggio Art.16 in caso Fam.Deceduto sul lavoro *
****************************************************************************/
function ASStatoOccupazFamDec(
    p_prgnominativo   DO_NOMINATIVO.PRGNOMINATIVO%TYPE,       -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_errCode OUT number         -- Codice di Errore
) RETURN NUMBER;

      /*****************************************************************************************
      * Avvia tutti i candidati passati nell'ARRAY                                             *
      * la procedura si occupa dell'inserimento di tutti i cndLavoratori presenti nell'ARRAY   *
      * passato.                                                                               *
      ******************************************************************************************/
      FUNCTION ASInsertCandidatiGraduatoria(inputCdnLavoratore IN INT_ARRAY,
                        inputPrgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,
                        inputPrgTipoIncrocio DO_INCROCIO.PRGTIPOINCROCIO%TYPE,
                        p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                        p_prgAvvio OUT AS_AVVIO.Prgavvio%TYPE)
                        RETURN NUMBER;

      /**************************************************************************************
      * Avvia i primi N (numero di candidati passati) candidati presenti nella graduatoria  *
      * questa funzione inserisce nella tabella di selezione i primi N candidati ciclando   *
      * sui possibili profili per la richiesta selezionata                                  *
      ***************************************************************************************/
      function ASAvviaPrimiNCandidati(
              p_numCandidati number,                                            -- numero di candidati da avviare
                p_prgRichiesta Do_Richiesta_Az.Prgrichiestaaz%TYPE,               -- progressivo della richiesta
                p_prgTipoIncrocio Do_Incrocio.Prgtipoincrocio%TYPE,               -- progressivo del tipo di incrocio
                p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                p_errCode OUT number,                                             -- Codice di Errore
                p_prgAvvio OUT AS_AVVIO.Prgavvio%TYPE
                ) RETURN NUMBER;

      /********************************************************************************************
      * Batch di aggiornamento degli avvii a selezione consultamndo gli avviamenti nei movimenti  *
      *********************************************************************************************/
      procedure ASBatch_AvvASelezioneDaMov_old(p_result OUT Varchar2,
                                    p_numMaxMesi number,
                                    p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                   );

      procedure ASBatch_AvvASelezioneDaMov(p_result OUT Varchar2,
                                    p_numMaxMesi number,
                                    p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                   );

      function ASAvvASelezioneDaMov(p_res OUT Varchar2,
                                  p_numMaxMesi number,
                                  p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                  p_tipo_avv char
                                       ) RETURN NUMBER;


      function ASAvvASelezioneDaMov_New(p_res OUT Varchar2,
                              p_numMaxMesi number,
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                   ) RETURN NUMBER;

      /********************************************************************************
      * utility per testing
      * utilizzata per inserire i candidati presenti nel range dato nella rosa passata *
      *********************************************************************************/
      PROCEDURE ASRiempiRosaPerProve(p_prgRosa Do_Rosa.Prgrosa%TYPE,
                                     p_cdnlavoratoreDa number,
                                     p_cdnlavoratoreA number);

    /******************************************************************************************
    * funzione che calcola il punteggio del lavoratore passato                                 *
    * il punteggio finale = punteggioIniziale - punteggioISEE + punteggioDID + punteggioEta    *
    * la funzione si occupa di inserire il punteggio finale nella tabella do_nominativo        *
    * e i singoli punteggi calcolati nella tabella AS_PUNTEGGIO                                *
    ********************************************************************************************/
    function calcoloPunteggioLavoratore(p_prgNominativo number,
                                     tipoGraduatoria varchar2,
									 p_flagAsOnline varchar2,
									 p_iseeAsOnline do_nominativo.numvaloreisee%type,
                                     p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                     p_errCode OUT number )
                         RETURN NUMBER;

    /*****************************************************************
    * recupero il punteggio iniziale dalla tabella di configurazione *
    ******************************************************************/
    function calcoloPunteggioIniziale(tipoGraduatoria varchar2,
                         p_strValore ts_config_punteggio.strvalore%TYPE)
                         RETURN NUMBER;

    /******************************************************************************
    * recupero il valore dei punti da sottrarre per ogni tot euro del valore ISEE *
    * dalla tabella di configurazione                                             *
    *******************************************************************************/
    function calcoloPunteggioISEE_MENO(tipoGraduatoria varchar2)
                              RETURN NUMBER;

    /******************************************************************************
    * recupero il valore di quanti euro del valore ISEE vanno sottratti i punti   *
    * dalla tabella di configurazione                                             *
    *******************************************************************************/
    function calcoloPuntiISEE_OGNI(tipoGraduatoria varchar2)
                              RETURN NUMBER;

    /******************************************************
    * recupero il valore massimo di punti da sottrarre    *
    * dalla tabella di configurazione                     *
    *******************************************************/
    function calcoloPuntiISEE_MAX(tipoGraduatoria varchar2)
                              RETURN NUMBER;

    /********************************************************************************
    * recupero il valore di punti se il candidato non ha inserito il valore ISEE    *
    * dalla tabella di configurazione                                               *
    *********************************************************************************/
    function calcoloPuntiISEE_NO(tipoGraduatoria varchar2)
                              RETURN NUMBER;

    /*********************************************************************
    * calcolo i punti riferiti al valore ISEE del lavoratore             *
    * y punti per ogni z Euro, dato ISEE, fino a k punti massimo.        *
    * Si sottraggono n punti alla persona che non presenti il dato ISEE  *
    *********************************************************************/
    function calcoloPuntiISEE(valoreISEE number,
                          euroISEE_OGNI number,
                          puntiEuroISEE_MENO number,
                          puntiISEE_MAX number)
                              RETURN NUMBER;

    /*********************************************************************
    * calcolo i punti riferiti al valore ISEE del lavoratore             *
    * y punti per ogni z Euro, dato ISEE, fino a k punti massimo.        *
    * Si sottraggono n punti alla persona che non presenti il dato ISEE  *
    *********************************************************************/
    procedure calcoloPunteggioISEE(valoreISEE number,
                        tipoGraduatoria varchar2,
                        cdnlavoratore varchar2,
                        inizio varchar2,
                        fine varchar2,
                        numanno varchar2,
                        strnote varchar2,
                        cdnutins varchar2,
                        cdnutmod varchar2,
            p_strIbanNazione as_valore_isee.strIbanNazione%TYPE,
            p_strIbanControllo as_valore_isee.strIbanControllo%TYPE,
            p_strCinLavoratore as_valore_isee.strCinLavoratore%TYPE,
            p_strAbiLavoratore as_valore_isee.strAbiLavoratore%TYPE,
            p_strCabLavoratore as_valore_isee.strCabLavoratore%TYPE,
            p_strCCLavoratore as_valore_isee.strCCLavoratore%TYPE);

    /*********************************************************************
    * ricalcolo del puteggio del valore ISEE in fase di aggiornamento    *
    *                         *
    *                    *
    *********************************************************************/
    procedure aggiornamentoPunteggioISEE(p_cdnlavoratore varchar2,
            p_valoreISEE number,
            p_datainizioval varchar2,
            p_datafineval varchar2,
            p_numanno varchar2,
            p_strnote varchar2,
            p_codmonomotivomodifica varchar2,
            p_cdnutins varchar2,
            p_cdnutmod varchar2,
            p_prgValIsee number,
            p_tipoGraduatoria varchar2,
            p_numKloValoreIsee number,
            p_strIbanNazione as_valore_isee.strIbanNazione%TYPE,
            p_strIbanControllo as_valore_isee.strIbanControllo%TYPE,
            p_strCinLavoratore as_valore_isee.strCinLavoratore%TYPE,
            p_strAbiLavoratore as_valore_isee.strAbiLavoratore%TYPE,
            p_strCabLavoratore as_valore_isee.strCabLavoratore%TYPE,
            p_strCCLavoratore as_valore_isee.strCCLavoratore%TYPE, p_storicizza varchar2);

    /************************************************************
    * recupero il valore di punti se il candidato ha una DID    *
    * dalla tabella di configurazione                           *
    ************************************************************/
    function incrementoPuntiDID(tipoGraduatoria varchar2)
                              RETURN NUMBER;
							  
    
   /************************************************************
    * recupero il valore di punti se il candidato ha una DID    *
    * dalla tabella di configurazione                           *
    ************************************************************/
    function incrementoPuntiDIDAnzianita(tipoGraduatoria varchar2,
                                     p_anzianita do_nominativo.stranzianita%type,
									 p_config  Ts_Config_Loc.num%type,  
									 p_prgConfigPunteggioDID  OUT number )
                              RETURN NUMBER;

    /*****************************************************************
    * recupero il valore di punti a seconda dell'età del candidato   *
    * dalla tabella di configurazione                                *
    *****************************************************************/
    function incrementoPuntiEta(tipoGraduatoria varchar2,
                            etaCandidato number)
                              RETURN NUMBER;
							  
	/************************************************************
	* recupero il valore di punti se il candidato ha una DID    *
	* dalla tabella di configurazione                           *
	************************************************************/
	function incrementoPuntiEsperienza(tipoGraduatoria varchar2,
										 p_mesiEsp number
										  )
								  RETURN NUMBER; 							  

    /*****************************************************************
    * recupero il prgConfigPunteggio a seconda della stringa passata *
    * dalla tabella di configurazione                                *
    *****************************************************************/
    function checkPrgConfigPunteggio(tipoGraduatoria varchar2,
                             p_strValore ts_config_punteggio.strvalore%TYPE)
                              RETURN NUMBER;

    /*********************************************************************
    * esegue l'inserimento o l'aggiornamento nella tabella AS_PUNTEGGIO  *
    * dei singoli punteggi che danno il punteggio completo               *
    **********************************************************************/
    procedure ASUpdatePunteggio(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                                 p_prgConfigPunteggio Ts_Config_Punteggio.Prgconfigpunteggio%TYPE,
                                 p_punteggio number,
                                 p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                );

    /*************************************************************************************
    * esegue l'aggiornamento del numpunteggio del lavoratore nella graduatoria specifica *
    *************************************************************************************/
    function ASUpdatePunteggioLavoratore(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                                     p_punteggio number,
                                     p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                    ) RETURN NUMBER;
/*********************************************************************
* esegue l'aggiornamento nella tabella DO_NOMINATIVO  *
* con ValoreIsee alla data chiamata                   *
**********************************************************************/
procedure ASUpdateValoreISEE(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                           p_ValoreIsee Do_Nominativo.Numvaloreisee%TYPE,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                           p_CodeOut OUT number
                           );
                           
/*********************************************************************
* esegue la gestione dei valori Isee passati dall'istanza online *
**********************************************************************/
function ASGestioneIseeOnline(p_cdnLavoratore IN NUMBER,
                                                 p_dataIstanza IN VARCHAR2, 
                                                 p_valoreIsee IN NUMBER,
                                                 p_annoRiferimento IN NUMBER,
                                                 p_cdnutente IN NUMBER,
                                                 p_prgrosa IN do_rosa.prgrosa%type,
                                                 p_prgRichAz IN do_richiesta_Az.prgrichiestaaz%type) 
                                                 return number;

/*********************************************************************
* esegue l'inserimento nella tabella degli scarti di inserimenti Isee non andati a buon fine *
**********************************************************************/
procedure ASInserisciScartoIsee(p_cdnLavoratore IN NUMBER,
                                                 p_dataIstanza IN VARCHAR2, 
                                                 p_valoreIsee IN NUMBER,
                                                 p_annoRiferimento IN NUMBER,
                                                 p_cdnutente IN NUMBER,
                                                 p_prgrosa IN do_rosa.prgrosa%type,
                                                 p_prgRichAz IN do_richiesta_Az.prgrichiestaaz%type) ;                          
/*********************************************************************
* esegue l'aggiornamento nella tabella DO_NOMINATIVO  *
* con STRANZIANITA alla data Pubblicazione                   *
**********************************************************************/						   

procedure ASAggiornaAnzianita(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                           p_Anzianita Do_Nominativo.STRANZIANITA%TYPE,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                           p_CodeOut OUT number
                           ) ;
						   
/*********************************************************************
* esegue l'aggiornamento nella tabella DO_NOMINATIVO  *
* con Numero Mesi Esperienza alla data Pubblicazione                   *
**********************************************************************/
procedure ASAggiornaMesiEsp(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                           p_NumMesiEsp Do_Nominativo.NUMMESIESP%TYPE,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                           p_CodeOut OUT number
                           );						   
    /******************************************************************************************
    * esegue l'aggiornamento del numOrdine di tutti i lavoratori per la graduatoria specifica *
    *******************************************************************************************/
    function ASCalcolaPosizione(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                            p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE)
                             RETURN NUMBER;

	/******************************************************************************************
    * esegue il cacolo dell'esperienza maturata per quella mansione *
    *******************************************************************************************/
    function ASCalcolaEsperienza(p_cdnlavoratore Do_Nominativo.cdnLavoratore%TYPE,
                             p_prgIncrocio  do_incrocio.prgincrocio%type,
							 p_prgRichiestaAZ do_richiesta_az.prgRichiestaAz%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                    ) RETURN NUMBER;
    /***************************************************************************************************
    * rende definitive tutte le graduatorie di quel tipo e ricalcola la posizione di ciascun lavoratore*
    ***************************************************************************************************/
    function ASSetGraduatoriaDefinitiva(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                                    p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE)
                                   RETURN NUMBER;

    /***************************************************************************************************
    * gestisce la riapertura di una graduatoria:                                                       *
    * inserisce il motivo di riapertura                                                                *
    * per ogni graduatoria definitiva dello stesso tipo viene creata una nuova graduatoria grezza      *
    ***************************************************************************************************/
    function ASRiapriGraduatorie(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                             p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                             p_prgRosa Do_Rosa.Prgrosa%TYPE,
                             p_motivo varchar2,
                             cdnutmod varchar2,
                             p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,               -- progressivo dell'incrocio
                             p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE,                        -- progressivo della rosa
                             p_errCode OUT number                                             -- Codice di Errore
                             )
                            RETURN NUMBER;


    /***************************************************************************************************
    * gestisce le operazione per la riapertura di una graduatoria                                      *
    *(viene chiamata all'interno della funzione precedente)                                            *
    ***************************************************************************************************/
    function ASGestioneRiapertura(p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa da copiare
                                p_numklorosa Do_Rosa.Numklorosa%TYPE,                             -- Numklorosa della rosa da aggiornare
                                p_prgIncrocio Do_Incrocio.Prgincrocio%TYPE,                       -- progressivo dell'incricio da copiare
                                p_cdnUtente TS_UTENTE.CDNUT%TYPE,                                -- Codice di Errore
                                p_prgMotivo AS_MOTIVO_APERTURAGRAD.Prgmotivoaperturagrad%TYPE
                                ) RETURN NUMBER;

    /***************************************************************************************************
    * gestione dei dati dell'approvazione di una graduatoria                                           *
    ***************************************************************************************************/
    function ASSalvaApprovazGrad(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                             p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                             p_prgapprovazionegrad as_approvazione_grad.prgapprovazionegrad%TYPE,
                             p_numDetermina varchar2,
                             p_datProtocollazione varchar2,
                             p_datPubblicazione varchar2,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                ) RETURN NUMBER;

    /***************************************************************************************************
    * verifica che per la richiesta e l'alternativa data vi sia un contratto a tempo determinato       *
    ***************************************************************************************************/
    function checkControlloAdesione(p_prgRichiestaAz DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE,
                                p_prgAlternativa DO_ALTERNATIVA.Prgalternativa%TYPE)
                         RETURN NUMBER;

    /***************************************************************************************************
    * verifica che per quel lavoratore vi sia un rapporto di                                           *
    * lavoro aperto alla data chiamata della richiesta                                                 *
    ***************************************************************************************************/
    function checkControlloMovimento(p_prgRichiestaAz DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE,
                                p_cdnLavoratore DO_NOMINATIVO.CDNLAVORATORE%TYPE)
                         RETURN NUMBER;

    /***************************************************************************************************
    * gestione storicizzazione dei dati dello stato occupazione del lavoratore per l'incrocio passato  *
    ***************************************************************************************************/
    function ASStoricizzaStatoOcc(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                             p_cdnLavoratore am_stato_occupaz.cdnlavoratore%TYPE,
                             p_prgIncrocio do_incrocio.prgincrocio%TYPE,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                ) RETURN NUMBER;

  /***************************************************************************************************
   * gestione storicizzazione dei dati dello stato occupazione del lavoratore per l'incrocio passato  *
   ***************************************************************************************************/
   function ASAggiornaStatoOcc(p_dataChiamata do_richiesta_az.datchiamata%TYPE,
                            p_dataPubblicazione do_richiesta_az.datpubblicazione%type,
                            p_config            Ts_Config_Loc.num%type,
                            p_cdnLavoratore am_stato_occupaz.cdnlavoratore%TYPE,
                            p_prgIncrocio do_incrocio.prgincrocio%TYPE,
                            p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                ) RETURN NUMBER;

    /*****************************************************************************************************
    * gestione eliminazione dello stoto occupazione storicizzato per la medesima adesione del lavoratore *
    *****************************************************************************************************/
    function ASDeleteStoriaStatoOcc(p_cdnLavoratore am_stato_occupaz.cdnlavoratore%TYPE,
                             p_prgIncrocio do_incrocio.prgincrocio%TYPE
                                ) RETURN NUMBER;

    function Matching_esatto_CM(
                              p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
                              p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
                              p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
                              p_statoCv DE_STATO_SCHEDALAV.CODSTATOLAV%TYPE,    -- stato del CV (opzionale - non usato per ora)
                              p_usaPref int,            -- utilizza anche i parametri con richiesta "preferibile"
                              p_usaNonInd int,            -- utilizza anche i parametri con richiesta "non indispensabile"
                              p_flagDI int,             -- solo Disoccupati/Inoccupati
                              p_flagIncMir int,         -- flag collocamento mirato
                              p_db int,                -- base dati da utilizzare
                              p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
                              p_dataValCV  varchar2,          -- data in base alla quale considerare valido un CV
                              p_checkCM  number,              -- interruttore per il collocamento mirato
                              encrypterKey varchar2,
                              p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
                p_flagGG int,             -- solo Garanzia Giovani
                              p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
                              p_out_query_select OUT varchar2,
                              p_out_query_from OUT varchar2,
                              p_out_query_join OUT varchar2,
                              p_out_query_where OUT long,
                              p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
                              p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE       -- progressivo della rosa
    ) return number;

function Matching_esatto_no_mansione_CM(
                              p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
                              p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
                              p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
                              p_statoCv DE_STATO_SCHEDALAV.CODSTATOLAV%TYPE,    -- stato del CV (opzionale - non usato per ora)
                              p_usaPref int,            -- utilizza anche i parametri con richiesta "preferibile"
                              p_usaNonInd int,            -- utilizza anche i parametri con richiesta "non indispensabile"
                              p_flagDI int,             -- solo Disoccupati/Inoccupati
                              p_flagIncMir int,         -- flag collocamento mirato
                              p_db int,                -- base dati da utilizzare
                              p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
                              p_dataValCV  varchar2,          -- data in base alla quale considerare valido un CV
                              p_checkCM  number,              -- interruttore per il collocamento mirato
                              encrypterKey varchar2,
                              p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
                p_flagGG int,             -- solo Garanzia Giovani
                              p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
                              p_out_query_select OUT varchar2,
                              p_out_query_from OUT varchar2,
                              p_out_query_join OUT varchar2,
                              p_out_query_where OUT long,
                              p_out_cm_query_join OUT varchar2,
                              p_out_cm_query_where OUT varchar2,
                              p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
                              p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE       -- progressivo della rosa
    ) return number;

-- Crea le componenti per lo statement di prima selezione dei candidati da pesare
   function Matching_Pesato_PEsatti_CM(
                              p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
                              p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
                              p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
                              p_db int,                -- base dati da utilizzare
                              p_dataValCV  varchar2,          -- data in base alla quale considerare valido un CV
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
                              p_numPFasciaEtaPrima number,         -- peso associato alla prima fascia di età estesa
                              p_numPFasciaEtaSec number,         -- peso associato alla seconda fascia di età estesa
                              p_numPStudioGruppo number,         -- peso associato a un titolo di studio nel gruppo
                              p_numPStudioAlias number,          -- peso associato a un titolo di studio associato
                              p_numPMansioneGruppo number,         -- peso associato a una mansione nel gruppo
                              p_numPMansioneAlias number,         -- peso associato a una mansione associata
                              p_numPNoEsperienza number,         -- peso associato alla mansione senza esperienza
                              p_numPEsperienzaAlias number,         -- peso associato all'esperienza in una mansione simile
                              p_numPInfoMin number,           -- peso associato alla conoscenza info con grado minore
                              p_numPInfoGruppo number,          -- peso associato a una conoscenza info nello stesso gruppo
                              p_numPInfoGruppoMIn number,         -- peso associato a una conoscenza info nello stesso gruppo e grado minore
                              p_numPLinguaInf number,           -- peso associato a una conoscenza linguistica con grado minore
                              p_numPSogliaRichiesta number,         -- valore di soglia entro il quale estrarre i candidati
                              p_flagIncMir int,         -- flag collocamento mirato
                              p_checkCM  number,              -- interruttore per il collocamento mirato
                              p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
                              p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
                              p_out_query_select OUT varchar2,
                              p_out_query_from OUT varchar2,
                              p_out_query_join OUT varchar2,
                              p_out_query_where OUT long,
                              p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
                              p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE,       -- progressivo della rosa
                              p_out_where_territorio OUT varchar2
    ) return number;

function ESEGUIINCROCIOCM_NOMANSIONE(p_query_select varchar2,
               p_query_from varchar2,
               p_query_join varchar2,
               p_query_where varchar2,
               p_cm_query_join varchar2,
               p_cm_query_where varchar2,
               p_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,  -- progressivo dell'incrocio
               p_prgRosa DO_ROSA.PRGROSA%TYPE,     -- progressivo della rosa
               p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
               p_mem char,
               encrypterkey varchar2,
               p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
               p_ErrCode OUT number
               --p_cursor OUT t_cursor
               ) return number;

 -- Esegue il matching pesato date le componenti della query  discriminante generata
 -- dall'algoritmo Matching_Pesato_PEsatti.
    -- Il parametro p_mem=1 serve per l'esecuzione in locale, quando si utilizza la cooperazione
    -- applicativa la procedura viene chiamata con p_mem=0 in modo da restituire i risultati parziali
    -- nel recordset p_cursor.
function eseguiIncrocioPesato_CM(
                             p_in_query_select varchar2,
                             p_in_query_from varchar2,
                             p_in_query_join varchar2,
                             p_in_query_where long,
                             p_in_where_territorio varchar2,
                             p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%type, -- progressivo della richiesta
                             p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%type, -- progressivo dell'alternativa
                             p_in_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,  -- progressivo dell'incrocio
                             p_in_prgRosa DO_ROSA.PRGROSA%TYPE,      -- progressivo della rosa
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
                             p_mem char,
                             p_numPFasciaEtaPrima number,         -- peso associato alla prima fascia di età estesa
                             p_numPFasciaEtaSec number,         -- peso associato alla seconda fascia di età estesa
                             p_numPStudioGruppo number,         -- peso associato a un titolo di studio nel gruppo
                             p_numPStudioAlias number,          -- peso associato a un titolo di studio associato
                             p_numPMansioneGruppo number,         -- peso associato a una mansione nel gruppo
                             p_numPMansioneAlias number,         -- peso associato a una mansione associata
                             p_numPNoEsperienza number,         -- peso associato alla mansione senza esperienza
                             p_numPEsperienzaAlias number,         -- peso associato all'esperienza in una mansione simile
                             p_numPInfoMin number,           -- peso associato alla conoscenza info con grado minore
                             p_numPInfoGruppo number,          -- peso associato a una conoscenza info nello stesso gruppo
                             p_numPInfoGruppoMIn number,         -- peso associato a una conoscenza info nello stesso gruppo e grado minore
                             p_numPLinguaInf number,           -- peso associato a una conoscenza linguistica con grado minore
                             p_numPSogliaRichiesta number,         -- valore di soglia entro il quale estrarre i candidati
                             p_flagIncMir int,         -- flag collocamento mirato
                             p_checkCM  number,              -- interruttore per il collocamento mirato
                             encrypterKey varchar2,
                             p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
                             p_ErrCode OUT number
                             --p_cursor OUT t_cursor
   ) return number;

function updateRosaParamCM(p_CODMONOTIPOAZIENDA varchar2,
                            MR5 number,
                      IN2 number,
                            PO1 number,
                            PO2 number,
                      PO6 number,
                            PO7 number,
                            LO2 number,
                            LO3 number,
                      MV1 number,
                            MV2 number,
                            MV3 number,
                      MV4 number,
                            AC1 number,
                            FA2 number,
                      FA3 number,
                            SL1 number,
                            SL2 number,
                            p_flgescfisica varchar2,
                            p_flgescpsichica varchar2,
                            p_flgescsensoriale varchar2,
                            p_flgescintellettiva varchar2,
              p_flgescnondeterminato varchar2,
                            p_prgrosa do_rosa.prgrosa%TYPE,
                            encrypterKey varchar2,
                            p_cdnUtente TS_UTENTE.CDNUT%TYPE,
              p_configDiagnFunz varchar2,
                            p_ErrCode OUT number,
                            p_query OUT varchar2
                           )
                         RETURN NUMBER;

function Matching_mobilita(
                          p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
                          p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
                          p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
                          p_db int,                -- base dati da utilizzare
                          p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
                          p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
                          p_flgXcpi varchar2,
                          p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
                          p_out_query OUT long,
                          p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
                          p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE       -- progressivo della rosa
                          ) return number;

function Matching_mobilita_no_mansione(
                          p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
                          p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
                          p_db int,                -- base dati da utilizzare
                          p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
                          p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
                          p_flgXcpi varchar2,
                          p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
                          p_out_query OUT long,
                          p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
                          p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE       -- progressivo della rosa
                          ) return number;

function eseguiIncrocioMobilita(
                           p_query long,
                           p_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,  -- progressivo dell'incrocio
                           p_prgRosa DO_ROSA.PRGROSA%TYPE,     -- progressivo della rosa
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
                           p_mem char,
                           p_ErrCode OUT number
                           ) return number;

function checkFlagCM(p_cdnLavoratore An_Lavoratore.CDNLAVORATORE%type,
                     encrypterKey varchar2
                     ) return number;

/**********************************************
 *  gestione capacità diagnosi funzionale per *
 *  i filtri CM dell'incrocio mirato VDA      *
 **********************************************/

function updateRosaParamCMVDA(p_CODMONOTIPOAZIENDA varchar2,
                              IN4 varchar2,
                          IN5 varchar2,
                          IN6 varchar2,
                          PO8 varchar2,
                          PO9 varchar2,
                              PO10 varchar2,
                              PO11 varchar2,
                              PO12 varchar2,
                              PO13 varchar2,
                              PO14 varchar2,
                              LO4 varchar2,
                              LO5 varchar2,
                              LO6 varchar2,
                              MV5 varchar2,
                              MV6 number,
                              MV7 varchar2,
                              AC5 varchar2,
                              AC6 varchar2,
                              FA7 varchar2,
                              FA8 varchar2,
                              SL5 varchar2,
                              SL6 varchar2,
                              SL7 varchar2,
                              SL8 varchar2,
                              SL9 varchar2,
                              CA1 varchar2,
                              CA2 varchar2,
                              CA3 varchar2,
                              CA4 varchar2,
                              p_flgescfisica varchar2,
                              p_flgescpsichica varchar2,
                              p_flgescsensoriale varchar2,
                              p_flgescintellettiva varchar2,
                              p_flgescnondeterminato varchar2,
                              p_prgrosa do_rosa.prgrosa%TYPE,
                              encrypterKey varchar2,
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                              p_configDiagnFunz varchar2,
                              p_ErrCode OUT number,
                              p_query OUT varchar2
                           )
                         RETURN NUMBER;
/*********************************************************************
    * aggiornaDtFineRecordPrecedente *
    *********************************************************************/
    procedure aggiornaDtFineRecordPrecedente(
            p_datafineval varchar2,
            p_cdnutmod varchar2,
            p_prgValIsee number);
			
			
/***********************************************************************************************
* Funzione per l'inserimento di una adesione ONLINE per il lavoratore specifico alla richiesta *
************************************************************************************************/			
function ASInsAdesioneOnlineLav(
    p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
      p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
      p_cdnGruppo Ts_Gruppo.Cdngruppo%TYPE,                       -- gruppo a cui fa parte l'utente
	  p_numvaloreisee  do_nominativo.NUMVALOREISEE%type,
      p_codmonoisee        do_nominativo.codmonoisee%type, -- Calcolo Isee (Da Sil o escludi)
	  p_NUMANNOPROTISTANZA       do_nominativo.NUMANNOPROTISTANZA%type,  
	  p_STRPROTISTANZA       do_nominativo.STRPROTISTANZA%type,  
	  p_STRIDISTANZA       do_nominativo.STRIDISTANZA%type  ,
	  p_errCode OUT number           -- Codice di Errore
	 )
 RETURN NUMBER;			
	
/***********************************************************************************************
* Funzione per l'aggiornamento di una adesione ONLINE per il lavoratore specifico alla richiesta *
************************************************************************************************/
function ASUpdateAdesioneOnlineLav(
	p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
    p_prgNominativo Do_nominativo.Prgnominativo%TYPE,                                   -- progressivo della rosa
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
    p_codmonoisee  do_nominativo.codmonoisee%type, -- Calcolo Isee (Da Sil o escludi)
	   p_numvaloreisee  do_nominativo.NUMVALOREISEE%type,
	  p_NUMANNOPROTISTANZA       do_nominativo.NUMANNOPROTISTANZA%type,  
	  p_STRPROTISTANZA       do_nominativo.STRPROTISTANZA%type,  
	  p_STRIDISTANZA       do_nominativo.STRIDISTANZA%type,
    p_errCode OUT number         -- Codice di Errore
) RETURN NUMBER;


function updateAsOnlineRosa (prgParDoRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
 flagParAsOnline DO_RICHIESTA_AZ.FLGASONLINE%TYPE,
            cdnParUtMod  TS_UTENTE.CDNUTMOD%TYPE,
p_errCode OUT number         -- Codice di Errore			
) return number;

    /***************************************************************************************************
    * rende definitive tutte le graduatorie di quel tipo e ricalcola la posizione di ciascun lavoratore*
    ***************************************************************************************************/
    function ASSetGraduatoriaDefOnline(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                                    p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE)
                                   RETURN NUMBER;

END PG_INCROCIO;
/
create or replace PACKAGE BODY PG_INCROCIO AS
  -- Autore  : Stefania Orioli
  -- Algoritmi di Matching
  -- Versione 2_4
/*********************************************************************
  Matching esatto
  restituisce le 4 stringhe che compongono lo statement da utilizzare per
  eseguire il matching esatto date una richiesta e ad una determinata alternativa.
  Se p_usaPref = 1 allora nel matching si devono
  considerare i parametri indicati come preferibili (flag='P')
  come se fossero obbligatori.
  Se p_usaNonInd = 1 allora nel matching si devono
  considerare i parametri indicati come non indispensabili
  come se fossero obbligatori.
  Se p_flagDI = 1 allora la ricerca va ristretta a tutti coloro che
  sono in stato di disoccupazione e di inoccupazione.
  p_db indica la base dati sulla quale eseguire il matching:
      1 - la ricerca va ristretta ai lavoratori iscritti all'elenco
        anagrafico del CPI il cui codice è passato come parametro in p_codCpi
    2 - la ricerca viene fatta a livello provinciale, quindi non servono ulteriori filtri
    3 - Regione ---> entra in gioco la cooperazione applicativa
  Il codice di ritorno vale:
  0 - se è tutto ok
  1 - non è stata specificata nessuna mansione, per cui non si può eseguire il matching
  2 - la richiesta è stata chiusa
  -1 - si è verificata una eccezione
*********************************************************************/
function Matching_esatto(
    p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
    p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
    p_statoCv DE_STATO_SCHEDALAV.CODSTATOLAV%TYPE,    -- stato del CV (opzionale - non usato per ora)
    p_usaPref int,            -- utilizza anche i parametri con richiesta "preferibile"
    p_usaNonInd int,            -- utilizza anche i parametri con richiesta "non indispensabile"
    p_flagDI int,             -- solo Disoccupati/Inoccupati
    p_flagIncMir int,         -- flag collocamento mirato
    p_db int,                -- base dati da utilizzare
    p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_dataValCV  varchar2,          -- data in base alla quale considerare valido un CV
    p_checkCM  number,              -- interruttore per il collocamento mirato
    encrypeterKey varchar2,
    p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
  p_flagGG int,             -- solo Garanzia Giovani
    p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
    p_out_query_select OUT varchar2,
    p_out_query_from OUT varchar2,
    p_out_query_join OUT varchar2,
    p_out_query_where OUT long,
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE       -- progressivo della rosa
    ) return number IS

  p_sql_query long;
  query_select varchar2(100);
  query_from varchar2(100);
  query_join varchar2(4000);
  query_where long;
  p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
  p_Originale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;
  p_flgpubbcresco DO_EVASIONE.FLGPUBBCRESCO%TYPE;
  p_flgpubblicata DO_RICHIESTA_AZ.FLGPUBBLICATA%TYPE;
  p_datarichiesta varchar2(10);
  p_datascadpubbl varchar2(10);

  -- MASTER
  --DONA
  --where_cpi_master varchar2(500) := ' and (PG_INCROCIO.PDMASTERLAVO(an.cdnLavoratore)=1) ';
  -- CPI DI APPARTENENZA -----------------------------------------------------------------------------------------------------------------------------------------------
  -- per ora escluso, rifare come cpi_master se da inserire
  where_cpi varchar2(500) := '';
  -- STATO DI DISOCCUPAZIONE ---------------------------------------------------------------------------------------------------------------------------
  where_stato_occ varchar(100) := ' and (PG_INCROCIO.PDSTATOOCC(an.cdnLavoratore)=1) ';
  ------------------------------------------------------------------------------------------------------------------------------------------------------

  -- GARANZIA GIOVANI ---------------------------------------------------------------------------------------------------------------------------
  where_garanzia_giovani varchar(100) := ' and (PG_INCROCIO.CHECKGG(an.cdnLavoratore)=1) ';
  ------------------------------------------------------------------------------------------------------------------------------------------------------

  --where_mansione varchar2(4000) := '';
  where_mansione long := '';
  query_agevolazioni varchar2(2000) := '';
  like_mansione varchar2(20);
  where_titoli varchar2(4000) := '';
  where_form_prof varchar2(4000) := '';
  like_titolo varchar(8);
  where_corsi varchar2(4000) := '';
  where_luogo varchar2(2000) := '';
  recRichiesta DO_RICHIESTA_AZ%ROWTYPE;
  numComuni number;
  numProv number;
  codComAz AN_UNITA_AZIENDA.CODCOM%TYPE;
  strMansione varchar2(300);
  recAlternativa DO_ALTERNATIVA%ROWTYPE;
  numAnniEsp DO_ALTERNATIVA.NUMANNIESPERIENZA%TYPE;
  bFuoriSede boolean;
  numConLinguistiche number;
  numConLinIta number;
  numCompetenze number;
  numConInformatiche number;
  numAbilitazioni number;
  numMobilita number;
  numCollocMirato number;
  numDisocc number;
  numApprendistato number;
  numTitoli number;
  numMansioni number;
  numCorsi number;
  abilitatoIDO number;
  -- Parametri
  parPrgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;
  parAutomunito DO_RICHIESTA_AZ.FLGAUTOMUNITO%TYPE;
  parMotomunito DO_RICHIESTA_AZ.FLGMOTOMUNITO%TYPE;
  parTrasferta DO_RICHIESTA_AZ.CODTRASFERTA%TYPE;
  parMilitare DO_RICHIESTA_AZ.FLGMILITE%TYPE;
  parFuoriSede DO_RICHIESTA_AZ.FLGFUORISEDE%TYPE;
  parMezziPub AN_UNITA_AZIENDA.FLGMEZZIPUB%TYPE;
  parEsperienza DO_ALTERNATIVA.FLGESPERIENZA%TYPE;
  parFormProf DO_ALTERNATIVA.FLGFORMAZIONEPROF%TYPE;
  -- Parametri impliciti
  par_impliciti varchar2(1000);
  par_impl_p_stato_begin varchar2(1000);
  par_impl_p_stato_end varchar2(300);
  par_statoIN varchar2(15);
  -- Indisponibilità
  --DONA
  --par_indisponibilita_az varchar(100) := ' and (PG_INCROCIO.pdIndispAzienda(an.cdnLavoratore,' || p_prgRichiestaAz || ')=0) ';

  patenteB number;
  -- Cursori
  CURSOR curMansioni IS
     select DO_MANSIONE.codMansione
   from DO_MANSIONE
   where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_MANSIONE.PRGALTERNATIVA = p_prgAlternativa;
  CURSOR curTurni IS
     select DO_TURNO.CODTURNO from DO_TURNO where DO_TURNO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curOrari IS
     select DO_ORARIO.CODORARIO from DO_ORARIO where DO_ORARIO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curContratti IS
     select DO_CONTRATTO.CODCONTRATTO from DO_CONTRATTO
   where DO_CONTRATTO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_CONTRATTO.PRGALTERNATIVA = p_prgAlternativa;
  CURSOR curTitoli IS
     select DO_STUDIO.CODTITOLO, DO_STUDIO.FLGINDISPENSABILE, DO_STUDIO.FLGCONSEGUITO
   from DO_STUDIO
   where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
  CURSOR curCorsi IS
     select DO_FORMAZIONE_PROF.CODCORSO, DO_FORMAZIONE_PROF.FLGINDISPENSABILE
   from DO_FORMAZIONE_PROF
   where DO_FORMAZIONE_PROF.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_FORMAZIONE_PROF.PRGALTERNATIVA = p_prgAlternativa;  -- Clausole IN
  inTurni varchar2(2000) := '';
  inOrario varchar2(2000) := '';
  inMansioni varchar2(2000) := '';
  inContratti varchar2(2000) := '';
  -- Informazioni da memorizzare in DO_PARAMETRI_INCROCIO
  rflgPref char(1);
  rflgNonInd char(1);
  rflgDis char(1);
  rflgGG char(1);
  rNumCand number;
  -- Debug
  lenStr number;
  tmpStr char(255);
  j number;
  k number;
BEGIN
 if(p_prgRosa is null) then
  query_select := 'select distinct an.CDNLAVORATORE ';
  query_from := 'from AN_LAVORATORE an ';
  query_where := '';
  --DONA
  --query_where := where_cpi_master;
 else
  query_select := 'select distinct an.CDNLAVORATORE ';
  query_from := 'from do_nominativo ';
  query_join := 'inner join an_lavoratore an on (do_nominativo.CDNLAVORATORE=an.CDNLAVORATORE) ';
  query_where := ' and (do_nominativo.PRGROSA=' || p_prgRosa || ') ';
 end if;
 query_join := query_join || 'inner join PR_MANSIONE prm on (an.cdnLavoratore = prm.cdnLavoratore) ';
 query_join := query_join || 'inner join PR_VALIDITA on (an.CDNLAVORATORE=PR_VALIDITA.CDNLAVORATORE) ';
 query_join := query_join || 'left outer join PR_MOBIL_GEOGR on (prm.prgMansione=PR_MOBIL_GEOGR.PRGMANSIONE) ';
 query_join := query_join || 'left outer join PR_DIS_TURNO on (prm.prgMansione=PR_DIS_TURNO.PRGMANSIONE) ';
 query_join := query_join || 'left outer join PR_DIS_ORARIO on (prm.prgMansione=PR_DIS_ORARIO.PRGMANSIONE) ';
 query_join := query_join || 'left outer join PR_DIS_CONTRATTO on (prm.prgMansione=PR_DIS_CONTRATTO.PRGMANSIONE) ';
-- query_join := query_join || 'left outer join PR_NOTA_LAV on (an.cdnLavoratore=PR_NOTA_LAV.CDNLAVORATORE) ';

  -- Controllo che ci sia almeno una MANSIONE
  select count(*) into numMansioni
  from DO_MANSIONE
  where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_MANSIONE.PRGALTERNATIVA = p_prgAlternativa;
  if(numMansioni=0) then
   return 1;
  --dbms_output.put_line('Non è possibile effettuare l''incrocio in quanto non è stata specificata nessuna mansione!');
  end if;
  -- Controllo che la richiesta non sia stata CHIUSA mentre si accedeva all'incrocio
  SELECT RICH2.PRGRICHIESTAAZ INTO p_Originale
  FROM DO_RICHIESTA_AZ RICH1
         INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
     WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;

  SELECT ev.CDNSTATORICH, nvl(ev.FLGPUBBCRESCO, 'N'), nvl(ric.FLGPUBBLICATA, 'N'), to_char(ric.DATRICHIESTA,'dd/mm/yyyy'), to_char(nvl(ric.DATSCADENZAPUBBLICAZIONE, SYSDATE),'dd/mm/yyyy')
      into p_cdnStatoRich, p_flgpubbcresco, p_flgpubblicata, p_datarichiesta, p_datascadpubbl
  FROM DO_RICHIESTA_AZ ric, DO_EVASIONE ev
  WHERE (ric.PRGRICHIESTAAZ = ev.PRGRICHIESTAAZ)
  AND ric.PRGRICHIESTAAZ = p_Originale;

  if(p_cdnStatoRich=4 OR p_cdnStatoRich=5) then
   return 2;
  end if;

 -- Se devo estrarre i candidati di competenza di un certo CpI
 -- al momento sospeso
 /*
 if((p_codCpi is not null) and (p_db=1)) then
  query_where := query_where || where_cpi;
 end if;
 */
 -- Se devo estrarre solamente i candidati Disoccupati/Inoccupati
 if((p_flagDI is not null) and (p_flagDI=1)) then
  if((p_flgpubbcresco = 'S') and (p_flgpubblicata = 'S')) then
  query_where := query_where ||
              ' and (an.cdnlavoratore in (select st.cdnLavoratore ' ||
              ' from am_stato_occupaz st ' ||
              ' inner join de_stato_occupaz ds on (st.CODSTATOOCCUPAZ=ds.CODSTATOOCCUPAZ) ' ||
              ' where st.CDNLAVORATORE = an.cdnlavoratore ' ||
              ' and (ds.CODSTATOOCCUPAZRAGG = ''D'' or ds.CODSTATOOCCUPAZRAGG = ''I'') ' ||
              ' and ds.CODSTATOOCCUPAZ <> ''B1'' ' ||
              ' and st.datinizio <= to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy'') ' ||
              ' and to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy'') <= nvl(st.datfine, sysdate)) ' ||
              ' or an.cdnlavoratore in (select cdnLavoratore from am_movimento mov ' ||
              ' where mov.CDNLAVORATORE = an.cdnlavoratore and mov.codContratto = ''LI'' ' ||
              ' and mov.codStatoAtto = ''PR'' and mov.codTipoMov = ''AVV'' ' ||
              ' and mov.datiniziomov <= to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy'') ' ||
              ' and to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy'') <= nvl(PG_ANAGRAFICA_PROFESSIONALE_RP.GetDataFineMovEffForRp(mov.PRGMOVIMENTO), sysdate))) ';
  else
  query_where := query_where || where_stato_occ;
  end if;
 end if;

 -- Se devo estrarre solamente i candidati in GG
 if((p_flagGG is not null) and (p_flagGG=1)) then
  if((p_flgpubbcresco = 'S') and (p_flgpubblicata = 'S')) then
  query_where := query_where || ' and (PG_INCROCIO.CHECKGGCRESCO(an.cdnLavoratore, to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy''), to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy''))=1) ';
  else
  query_where := query_where || where_garanzia_giovani;
  end if;
 end if;

  -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;
  dbms_output.put_line('Prg Incrocio=' || p_out_prgIncrocio || ' - Prg Rosa=' || p_out_prgRosa);
  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgIncrocio, p_prgRichiestaAz, p_prgAlternativa, 1, 'E',
  p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgRosa, null, p_out_prgIncrocio, 1, p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 3: memorizzo i parametri dell'incrocio
  if(p_usaPref=1) then
   rflgPref := 'S';
  else
   rflgPref := 'N';
  end if;
  if(p_usaNonInd=1) then
   rflgNonInd := 'S';
  else
   rflgNonInd := 'N';
  end if;
  if(p_flagDI=1) then
   rflgDis := 'S';
  else
   rflgDis := 'N';
  end if;
  if(p_flagGG=1) then
   rflgGG := 'S';
  else
   rflgGG := 'N';
  end if;
  insert into do_parametri_incrocio
  (PRGPARAMETRIINCROCIO, PRGINCROCIO, CODSTATOLAV, DATSTATOLAV, CODTERRITORIO,
  PRGROSA, FLGPREFERIBILE, FLGNONINDISPENSABILE, FLGSOLODISOCCUPATO, FLGGARANZIAGIOVANI)
  values
  (S_DO_PARAMETRI_INCROCIO.nextval, p_out_prgIncrocio, p_statoCv, to_date(p_dataValCV, 'dd/mm/yyyy'),
  p_db, p_out_prgRosa, rflgPref, rflgNonInd, rflgDis, rflgGG);
/*******************************************************************************************************/
 select * into recRichiesta from DO_RICHIESTA_AZ where DO_RICHIESTA_AZ.PRGRICHIESTAAZ = p_prgRichiestaAz;
 parAutomunito := recRichiesta.flgAutomunito;
 parMotomunito := recRichiesta.flgMotomunito;
 parTrasferta := recRichiesta.codTrasferta;
 parMilitare := recRichiesta.flgMilite;
 parFuoriSede := recRichiesta.flgFuoriSede;
 parPrgAzienda := recRichiesta.prgAzienda;
 --
 /*
 -- Sospeso
 select AN_UNITA_AZIENDA.FLGMEZZIPUB into parMezziPub
 from AN_UNITA_AZIENDA
 where an_unita_azienda.PRGAZIENDA=recRichiesta.prgAzienda and an_unita_azienda.PRGUNITA=recRichiesta.prgUnita;
 */

 --dbms_output.put_line('Azienda raggiungibile con mezzi pubblici = ' ||parMezziPub);
 if(p_prgAlternativa is not null) then
    select * into recAlternativa from DO_ALTERNATIVA
    where DO_ALTERNATIVA.PRGRICHIESTAAZ = p_prgRichiestaAz
    and DO_ALTERNATIVA.PRGALTERNATIVA = p_prgAlternativa;
    parEsperienza := recAlternativa.flgEsperienza;
    numAnniEsp := recAlternativa.numAnniEsperienza;
    parFormProf := recAlternativa.flgFormazioneProf;
 end if;
/*******************************************************************************************************/
 select count(*) into numComuni from DO_COMUNE where DO_COMUNE.PRGRICHIESTAAZ = p_prgRichiestaAz;
 select count(*) into numProv from DO_PROVINCIA where DO_PROVINCIA.PRGRICHIESTAAZ = p_prgRichiestaAz;
 if((parFuoriSede='S') or (numComuni>0) or (numProv>0)) then
    bFuoriSede := true;
 else
    bFuoriSede := false;
 end if;
 if(numComuni=0 and numProv=0) then
  select an_az.CODCOM into codComAz
  from DO_RICHIESTA_AZ daz
    inner join AN_UNITA_AZIENDA an_az on (daz.prgAzienda=an_az.prgAzienda and daz.prgUnita=an_az.prgUnita)
  where daz.PRGRICHIESTAAZ = p_prgRichiestaAz;
 end if;
 -- Popolo la stringa con l'insieme dei codici dei turni
 FOR rec in curTurni LOOP
  if(length(inTurni)>0) then
     inTurni := inTurni ||',';
  end if;
  inTurni := inTurni || '''' || rec.codTurno || '''';
 END LOOP;
 --dbms_output.put_line('Turni IN (' || inTurni || ')');
 -- Popolo la stringa con l'insieme dei codici degli orari
 FOR rec in curOrari LOOP
  if(length(inOrario)>0) then
     inOrario := inOrario ||',';
  end if;
  inOrario:= inOrario || '''' || rec.codOrario || '''';
 END LOOP;
 --dbms_output.put_line('Orari IN (' || inOrario || ')');
 -- Popolo la stringa con l'insieme dei codici dei contratti
 if(p_prgAlternativa is not null) then
  FOR rec in curContratti LOOP
   if(length(inContratti)>0) then
      inContratti := inContratti ||',';
   end if;
   inContratti:= inContratti || '''' || rec.codContratto || '''';
  END LOOP;
 end if;
 --dbms_output.put_line('Contratti IN (' || inContratti || ')');
 /********************************************************************
 * Mansione (dipende dall'Alternativa e parametri collegati          *
 * alle mansioni:                                                    *
 * - automunito (Preferibili)                                        *
 * - motomunito (Preferibili)                                        *
 * - formazione                                                      *
 * - sede raggiungibile con mezzi pubblici (fuori sede) --> sospeso  *
 * - turno                                                           *
 * - orario                                                          *
 * - contratto e agevolazione apprendistato                          *
 * - trasferte                                                       *
 * - esperienza                                                      *
 * - Luogo di Lavoro                                                 *
 ********************************************************************/
 /* Va gestito il raggruppamento  xyabcde, xyabc00 */
 FOR rec IN curMansioni LOOP
  if(where_mansione='' or (where_mansione is null)) then
    dbms_output.put_line('');
  else
     where_mansione := where_mansione || ' or ';
  end if;

    if(SUBSTR(rec.codMansione,-2)='00') then
     strMansione := '(SUBSTR(prm.codMansione,1,5)=''' || SUBSTR(rec.codMansione,1,5) || ''') ';
    else--mansione specifica
       strMansione := '(prm.codMansione=''' || rec.codMansione || ''') ';
    end if;

  --disponibilità
  if (p_checkcm = 0) then
    where_mansione := where_mansione || '(' || strMansione || ' and prm.FLGDISPONIBILE=''S'' ';
  else
    where_mansione := where_mansione || '(' || strMansione || ' and (prm.FLGDISPONIBILE=''S'' OR prm.FLGDISPONIBILE=''P'') ';
  end if;
  like_mansione :=
   case
    when substr(rec.codMansione,-2)<>'00' then rec.codMansione || '%'
    when substr(rec.codMansione,-2)='00' then substr(rec.codMansione,1,5) || '%'
    else rec.codMansione
   end;
  --Automunito
  if( (parAutomunito='P' and p_usaPref=1) or (parAutomunito='S') ) then
   where_mansione := where_mansione ||
            ' and (PR_MOBIL_GEOGR.FLGDISPAUTO=''S'' ) ';
--         '(PR_MOBIL_GEOGR.FLGDISPAUTO is null and PR_NOTA_LAV.FLGAUTOMUNITO=''S'') )';
  end if;
  -- Motomunito
  if( (parMotomunito='P' and p_usaPref=1) or (parMotomunito='S') ) then
   where_mansione := where_mansione ||
            ' and (PR_MOBIL_GEOGR.FLGDISPMOTO=''S'' ) ';
--         '(PR_MOBIL_GEOGR.FLGDISPMOTO is null and PR_NOTA_LAV.FLGMOTOMUNITO=''S'') )';
  end if;
  -- formazione
  if (parFormProf='S' or (parFormProf='P' and p_usaPref=1)) then
   where_mansione := where_mansione ||
         ' and (prm.flgEspForm=''S'')';
  end if;
  -- Sede raggiungibile con mezzi pubblici
  -- Parametro Escluso dal matching
  /*
  if(bFuoriSede=false) then
   dbms_output.put_line('In sede');
   if(parMezziPub='S') then
      where_mansione := where_mansione ||
              ' and (PR_MOBIL_GEOGR.FLGMEZZIPUB=''S'' or PR_MOBIL_GEOGR.FLGMEZZIPUB is null)';
   else
      if(parMezziPub='N') then
         where_mansione := where_mansione ||
              ' and (PR_MOBIL_GEOGR.FLGMEZZIPUB=''N'' or PR_MOBIL_GEOGR.FLGMEZZIPUB is null)';
      end if;
   end if;
  else
   dbms_output.put_line('Fuori sede');
  end if;
  */
  -- Turno
  if(length(inTurni)>0) then
   where_mansione := where_mansione ||
            ' AND ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
         ' (an.CDNLAVORATORE not in (select pm.CDNLAVORATORE from PR_DIS_TURNO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
         'where pm.cdnLavoratore=an.cdnLavoratore and pm.codMansione LIKE ''' || like_mansione ||
         ''')))';
  end if;
  -- Orario
  if(length(inOrario)>0) then
   where_mansione := where_mansione ||
            ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrario || ')) or ' ||
         ' (an.CDNLAVORATORE not in (select pm.CDNLAVORATORE from PR_DIS_ORARIO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
         'where pm.cdnLavoratore=an.cdnLavoratore and pm.codMansione LIKE ''' || like_mansione ||
         ''')))';
  end if;
  -- Contratto
  -- Apprendistato (Indispensabile e dipendente dall'alternativa) --> SOSPESO
     -- 'APP' --> 'I' oppure 'L', ma dalla richiesta mi dovrebbe arrivare solo 'I'
  if(p_usaNonInd=1) then
   select count(*) into numApprendistato
   from DO_AGEVOLAZIONE
   where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
      and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
      and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='D0' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='A0');
  else
   select count(*) into numApprendistato
   from DO_AGEVOLAZIONE
   where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
      and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
      and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='D0' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='A0')
      and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
  end if;


  if (numApprendistato>0) then
     if(length(inContratti)>0) then
      inContratti := inContratti ||',';
   end if;
   inContratti:= inContratti || '''AP''';
  end if;
  if(length(inContratti)>0) then
   where_mansione := where_mansione ||
            ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
         ' (an.CDNLAVORATORE not in (select pm.CDNLAVORATORE from PR_DIS_CONTRATTO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
         'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
         'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
         'pm.cdnLavoratore=an.cdnLavoratore and pm.codMansione like ''' || like_mansione ||
         ''')))';
  end if;
  -- Trasferte
  if(parTrasferta is not null and (to_number(parTrasferta)<>1)) then
   where_mansione := where_mansione ||
            ' and to_number(PR_MOBIL_GEOGR.CODTRASFERTA)>=' || parTrasferta || ' ';
  end if;
  -- Esperienza
  if((parEsperienza='P' and p_usaPref=1) or (parEsperienza='S')) then
   where_mansione := where_mansione ||
            ' and (prm.FLGESPERIENZA=''S'' OR prm.FLGESPERIENZA=''E'') ';
  end if;
  -- Luogo di Lavoro
  if(numComuni=0 and numProv=0) then
   -- come riferimento prendo il comune della sede dell'azienda
   where_mansione := where_mansione ||
            ' and (an.CDNLAVORATORE in (select dter.CDNLAVORATORE from VW_PR_DIS_TERRITORIO dter ' ||
         'where dter.cdnLavoratore=an.cdnLavoratore and ' ||
         'dter.codMansione like ' || '''' || like_mansione || '''' || ' and ' ||
         'dter.codCom=' || '''' || codComAz || ''') OR ' ||
          'an.CDNLAVORATORE in (select pm.CDNLAVORATORE from pr_mansione pm ' ||
            'inner join pr_dis_stato on (pr_dis_stato.PRGMANSIONE=pm.PRGMANSIONE) ' ||
              ' where pm.CDNLAVORATORE=an.CDNLAVORATORE ' ||
            'and pr_dis_stato.CODCOM=''Z000'' and ' ||
            'pm.CODMANSIONE=prm.codMansione)' ||
          ') ';
  else
   where_mansione := where_mansione || ' and (';
   -- Esistenza disponibilità per l'intero stato italiano
   where_mansione := where_mansione ||
           'an.CDNLAVORATORE in (select pm.CDNLAVORATORE from pr_mansione pm ' ||
            'inner join pr_dis_stato on (pr_dis_stato.PRGMANSIONE=pm.PRGMANSIONE) ' ||
              ' where pm.CDNLAVORATORE=an.CDNLAVORATORE ' ||
            'and pr_dis_stato.CODCOM=''Z000'' and ' ||
            'pm.CODMANSIONE=prm.codMansione)';
   -- Disponibilità per i comuni
   if(numComuni>0) then
        where_mansione := where_mansione || ' OR an.CDNLAVORATORE in (' ||
         'select dter.cdnLavoratore from VW_PR_DIS_TERRITORIO dter ' ||
         'inner join DO_COMUNE oter on (oter.codCom=dter.codCom) ' ||
         'where dter.cdnLavoratore=an.cdnLavoratore and ' ||
         'dter.codMansione like ' || '''' || like_mansione || '''' || ' and ' ||
         'oter.prgRichiestaAz=' || p_prgRichiestaAz || ') ';
   end if;
   -- Disponibilità per le province
   if(numProv>0) then
        where_mansione := where_mansione || ' OR an.CDNLAVORATORE in (' ||
         'select dter.cdnLavoratore from VW_PR_DIS_PROVINCIA dter ' ||
         'inner join DO_PROVINCIA oter on (oter.codProvincia=dter.codProvincia) ' ||
         'where dter.cdnLavoratore=an.cdnLavoratore and ' ||
         'dter.codMansione like ' || '''' || like_mansione || '''' || ' and ' ||
         'oter.prgRichiestaAz=' || p_prgRichiestaAz || ') ';
   end if;
   where_mansione := where_mansione || ' ) ';
  end if;
  -- Fine where_mansione
  where_mansione := where_mansione || ') ';
 END LOOP;
 query_where := query_where || ' and (' || where_mansione || ') ';
 /*---------------------------------- FINE MANSIONE ------------------------------------*/
 -- Servizio Militare / Servizio Civile (Preferibili)
 if( (parMilitare='P' and p_usaPref=1) or (parMilitare='S')) then
  query_where := query_where ||
        ' and ((an.STRSESSO=''M'' and an.FLGMILITE=''S'') or (an.STRSESSO=''F'')) ';
 end if;
 -- Conoscenze Linguistiche (Indispensabili - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numConLinguistiche
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numConLinguistiche
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
  and DO_LINGUA.FLGINDISPENSABILE='S';
 end if;
 if(numConLinguistiche>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_LINGUA cv_lin inner join ' ||
       'DO_LINGUA o_lin on (' ||
          'cv_lin.codLingua = o_lin.codLingua and ' ||
       'nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and ' ||
       'nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and ' ||
       'nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1)) ' ||
       'where (cv_lin.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_lin.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
       'o_lin.prgAlternativa=' || p_prgAlternativa || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_lin.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) ' ||
        '>= ' || numConLinguistiche; -- || ') ';
  -- Controllo se è richiesta la lingua italiana
  if(p_usaNonInd=1) then
     select count(*) into numConLinIta
     from DO_LINGUA
     where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
        and DO_LINGUA.codLingua='003';
  else
     select count(*) into numConLinIta
     from DO_LINGUA
     where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
        and DO_LINGUA.FLGINDISPENSABILE='S'
     and DO_LINGUA.CODLINGUA='003';
  end if;
  -- se e' richiesta la conoscenza della lingua italiana allora numConLinIta > 0
  if(numConLinIta>0) then
     if(numConLinguistiche=1) then
      -- è richiesta la sola conoscenza della lingua italiana
      query_where := query_where || ' OR (an.codCittadinanza=''000'' or an.codCittadinanza2=''000'')';
     else
         query_where := query_where || ' OR ' ||
              '(select count(*) from PR_LINGUA cv_lin inner join ' ||
          'DO_LINGUA o_lin on (' ||
          'cv_lin.codLingua = o_lin.codLingua and ' ||
       'nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and ' ||
       'nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and ' ||
       'nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1)) ' ||
       'where (cv_lin.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_lin.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
       'o_lin.prgAlternativa=' || p_prgAlternativa || ' and o_lin.codLingua<>''003'' ' ||
       'and (an.codCittadinanza=''000'' or an.codCittadinanza2=''000'')';
      if(p_usaNonInd=0 or (p_usaNonInd is null)) then
         query_where := query_where || 'and o_lin.flgIndispensabile=''S'' ';
      end if;
         query_where := query_where || ')) >= ' || (numConLinguistiche - numConLinIta);
      end if;
  end if;
  query_where := query_where || ') ';
 end if;
 -- Competenze (Indispensabili e dipendono dall'alternativa - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numCompetenze
  from DO_COMPETENZA
  where DO_COMPETENZA.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_COMPETENZA.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numCompetenze
  from DO_COMPETENZA
  where DO_COMPETENZA.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_COMPETENZA.PRGALTERNATIVA = p_prgAlternativa
     and DO_COMPETENZA.FLGINDISPENSABILE='S';
 end if;
 if(numCompetenze>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_COMPETENZA cv_comp inner join ' ||
       'DO_COMPETENZA o_comp on (' ||
          'cv_comp.codCompetenza = o_comp.codCompetenza) ' ||
       'where (cv_comp.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_comp.prgRichiestaAz=' || p_prgRichiestaAz ||
       ' and o_comp.prgAlternativa=' || p_prgAlternativa || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_comp.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) >= ' || numCompetenze ||
        ') ';
 end if;
 -- Conoscenze Informatiche (Indispensabili e dipendenti dall'alternativa - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numConInformatiche
  from DO_INFO
  where DO_INFO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_INFO.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numConInformatiche
  from DO_INFO
  where DO_INFO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_INFO.PRGALTERNATIVA = p_prgAlternativa
     and DO_INFO.FLGINDISPENSABILE='S';
 end if;
 if(numConInformatiche>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_INFO cv_inf inner join ' ||
       'DO_INFO o_inf on (' ||
          'cv_inf.codDettInfo = o_inf.codDettInfo and ' ||
       'cv_inf.codTipoInfo = o_inf.codTipoInfo and ' ||
       'nvl(cv_inf.cdnGrado,1) >= nvl(o_inf.cdnGrado,1)) ' ||
       'where (cv_inf.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_inf.prgRichiestaAz=' || p_prgRichiestaAz || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_inf.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where ||
       'and o_inf.prgAlternativa=' || p_prgAlternativa ||
        ')) >= ' || numConInformatiche ||
        ') ';
 end if;
 -- Abilitazioni (Indispensabili  - condizioni in AND)
 -- Es. patente specifica, patentino specifico, ....
 if(p_usaNonInd=1) then
  select count(*) into numAbilitazioni
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN<>'PGB';

  select count(*) into patenteB
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN='PGB';
 else
  select count(*) into numAbilitazioni
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.FLGINDISPENSABILE='S'
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN<>'PGB';

  select count(*) into patenteB
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.FLGINDISPENSABILE='S'
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN='PGB';
 end if;
 if(numAbilitazioni>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_ABILITAZIONE cv_abi inner join ' ||
       'DO_ABILITAZIONE_GEN o_abi on (' ||
          'cv_abi.codAbilitazioneGen = o_abi.codAbilitazioneGen) ' ||
       'where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_abi.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
       'o_abi.codAbilitazioneGen <> ''PGB'' ' ;
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_abi.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) >= ' || numAbilitazioni ||
        ') ';
    end if;
 if(patenteB>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_ABILITAZIONE cv_abi ' ||
       'where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
         '(cv_abi.codAbilitazioneGen = ''PGB'' or cv_abi.codAbilitazioneGen = ''PGC'' or cv_abi.codAbilitazioneGen = ''PGD'') ';
  query_where := query_where || ')) >= 1 ' ||
        ') ';
 end if;
 -- Titoli di Studio (Indispensabili e dipendenti dall'alternativa - condizioni in OR)
 -- /* Va gestito il raggruppamento xy0000, xyab00, xyabcd */
 if(p_usaNonInd=1) then
  select count(*) into numTitoli
  from DO_STUDIO
  where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numTitoli
  from DO_STUDIO
  where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa
     and DO_STUDIO.FLGINDISPENSABILE='S';
 end if;
 dbms_output.put_line('Sono richiesti n. ' || numTitoli || ' Titoli di Studio');
 if(numTitoli>0) then
  --dbms_output.put_line('I Titoli sono in OR e va gestito il raggruppamento XY0000, XYAB00, XYABCD');
  where_titoli := '';
  FOR rec IN curTitoli LOOP
   if((rec.flgIndispensabile='S') or (p_usaNonInd=1)) then
      if(length(where_titoli)>0) then
         where_titoli := where_titoli || ' union ';
      end if;
      where_titoli := where_titoli || ' (';
     -- modifica TITOLI FASE 3
     -- Le codifiche dei titoli di studio sono composte di 8 digit
     like_titolo :=
     case
      when substr(rec.codTitolo, -7)='0000000' then substr(rec.codTitolo,1,1) || '%'
      when substr(rec.codTitolo, -6)='000000' then substr(rec.codTitolo,1,2) || '%'
      when substr(rec.codTitolo, -5)='00000' then substr(rec.codTitolo,1,3) || '%'
      when substr(rec.codTitolo, -3)='000' then substr(rec.codTitolo,1,5) || '%'
      else rec.codTitolo
     end;
      where_titoli := where_titoli ||
             'select cv_tit.cdnLavoratore from PR_STUDIO cv_tit ' ||
          'where cv_tit.cdnLavoratore=an.cdnLavoratore and ' ||
          'cv_tit.CODTITOLO like ' || '''' || like_titolo || '''' || ' and ';
      if(rec.flgConseguito='S' or (rec.flgConseguito is null)) then
         where_titoli := where_titoli ||
            'cv_tit.CODMONOSTATO=''C'' ';
      else
          if(rec.flgConseguito='N') then
          where_titoli := where_titoli ||
                   'cv_tit.CODMONOSTATO in (''A'',''I'',''C'') ';
       end if;
      end if;
      where_titoli := where_titoli || ') ';
   end if;
  END LOOP;
 end if;
 --dbms_output.put_line('WhereTitoli=' || where_titoli);
 if(length(where_titoli)>0) then
    query_where := query_where || ' and an.CDNLAVORATORE in (' || where_titoli || ') ';
 end if;

 -- Corsi di Formazione 
select count(*) into abilitatoIDO
from ts_config_loc, de_tipo_config, ts_generale
where  ts_generale.prggenerale = 1
and ts_generale.codprovinciasil = ts_config_loc.strcodrif
and de_tipo_config.codtipoconfig = ts_config_loc.codtipoconfig
and trunc(sysdate) between trunc(de_tipo_config.datinizioval)
and trunc(de_tipo_config.datfineval)
and ts_config_loc.num=1
and upper(ts_config_loc.codtipoconfig) = 'IDOFPRO';

if(abilitatoIDO>0) then
	where_form_prof:= PG_INCROCIO.checkFormProf(p_prgRichiestaAZ ,p_prgAlternativa,p_usaNonInd);
    if(length(where_form_prof)>0) then
       query_where := query_where || ' and an.CDNLAVORATORE in (' || where_form_prof  || ') ';
    end if;
end if;
 /*****************************************************
 *            AGEVOLAZIONI                            *
 * Sono indispensabili e dipendenti dall'alternativa. *
 * Vanno considerate in OR fra loro                   *
 * Il Collocamento Mirato viene trattato in modo      *
 * speciale: se è presente nella richiesta allora va  *
 * aggiunta una clausola in OR assieme alle altre     *
 * agevolazioni, mentre se non viene richiesto si deve*
 * aggiungere una clausola in AND alle altre condizio-*
 * ni della query.                                    *
 * Le agevolazioni considerate sono:                  *
 * - Mobilità                                         *
 * - Collocamento Mirato                              *
 * - Disoccupazione L. 407/90                         *
 * - Apprendistato                                    *
 *****************************************************/
 query_agevolazioni := '';
 -- In Mobilità (Indispensabile e dipendente dall'alternativa --> fa parte delle agevolazioni )
 -- 'MOB' --> 'A'
 if(p_usaNonInd=1) then
  select count(*) into numMobilita
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S5', 'S6', 'S7', '75', '76', '77');
 else
  select count(*) into numMobilita
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S5', 'S6', 'S7', '75', '76', '77')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 if(numMobilita>0) then
     if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || ' OR ';
  end if;
  -- aggiungo il join con AM_MOBILITA_ISCR
  QUERY_JOIN := QUERY_JOIN ||
          'left outer join AM_MOBILITA_ISCR on (an.cdnLavoratore=AM_MOBILITA_ISCR.CDNLAVORATORE) and (AM_MOBILITA_ISCR.FLGNONIMPRENDITORE is null or AM_MOBILITA_ISCR.FLGNONIMPRENDITORE = ''N'') ';
  -- fare un controllo sul formato delle date in questa tabella
  query_agevolazioni := query_agevolazioni ||
        ' (trunc(AM_MOBILITA_ISCR.DATINIZIO) <= trunc(sysdate) and ' ||
        '(AM_MOBILITA_ISCR.DATFINE is null or trunc(sysdate) <= trunc(AM_MOBILITA_ISCR.DATFINE)))';
 end if;
 -- Collocamento Mirato (Indispensabile e dipendente dall'alternativa --> fa parte delle agevolazioni)
 -- 'CLM' --> 'R' oppure 'S'
 if(p_usaNonInd=1) then
  select count(*) into numCollocMirato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE = '66' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='67');
 else
  select count(*) into numCollocMirato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE = '66' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='67')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 -- aggiungo il join con AM_CM_ISCR

 -- donato: modifica cifratura cdnlavoratore
 --query_join := query_join || 'left outer join AM_CM_ISCR on (an.cdnLavoratore=decrypt(AM_CM_ISCR.CDNLAVORATORE, '''|| encrypeterkey ||''')) ';
  -- inserisco i lavoratori CM nella tabella temporanea

 if(numCollocMirato>0) then
  if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || ' OR ';
  end if;
  -- Savino 28/06/05 tolta la condizione sul tipo di accertamento sanitario 'A'
 -- query_agevolazioni := query_agevolazioni ||
 --       ' ((' ||
 --       'trunc(AM_CM_ISCR.DATDATAINIZIO) <= trunc(sysdate) and ' ||
 --       'AM_CM_ISCR.DATDATAFINE is null)' ||
 --       ') ';

    query_join := query_join || ' left outer join global_cm on (an.cdnlavoratore=global_cm.cdnlavoratore) ';

    query_agevolazioni := query_agevolazioni || ' global_cm.cdncrypt is not null ';

 else -- PERCHE' VIENE AGGIUNTA QUESTA QUERY SE NON E' RICHIESTA LA AGEVOLAZIONE?
 -- semplice, perche' devono essere considerati solo i lavoratori abili al lavoro
 -- codAccertamentoSanitario='A' = abilitato all'incrocio
 --
 -- Savino 28/06/05 commento del codice dell'else: se non e' stato richiesta una ricerca di lavoratori in
 -- collolamento mirato allora si prendono tutti, e non solo quelli abili al lavoro.......
 --
 -- query_where := query_where ||
 --       ' and ((' ||
 --       '(AM_CM_ISCR.CODACCERTSANITARIO=''A'') and trunc(AM_CM_ISCR.DATDATAINIZIO) <= trunc(sysdate) ' ||
 --       ' and AM_CM_ISCR.DATDATAFINE is null) ' ||
 --       ' OR ((select count(*) from AM_CM_ISCR where AM_CM_ISCR.CDNLAVORATORE=an.cdnLavoratore ) = 0) ' ||
 --       ' OR (exists(select * from VW_LAST_AM_CM_ISCR iscr where iscr.CDNLAVORATORE=an.cdnLavoratore ' ||
 --       '            and trunc(iscr.DATDATAFINE) < trunc(sysdate) )) ' ||
 --       ') ';
     query_where := query_where;
 end if;
 -- Disoccupazione L. 407/90 (Indispensabile e dipendente dall'alternativa)
 -- 'DIS' --> 'D'
 if(p_usaNonInd=1) then
  select count(*) into numDisocc
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S8', '58');
 else
  select count(*) into numDisocc
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S8', '58')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 if(numDisocc>0) then
  if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || ' OR ';
  end if;
  query_join := query_join ||
          'left outer join VW_AM_LAV_SITUAZ_AMMIN on (an.cdnLavoratore=VW_AM_LAV_SITUAZ_AMMIN.CDNLAVORATORE) ';
  query_agevolazioni := query_agevolazioni || ' (VW_AM_LAV_SITUAZ_AMMIN.flg40790=''S'') ';
 end if;
 /*
         e' stata spostata piu' su ed inglobata nella gestione contratti
            Andrea 11/04/2005


 -- Apprendistato (Indispensabile e dipendente dall'alternativa) --> SOSPESO
 -- 'APP' --> 'I' oppure 'L', ma dalla richiesta mi dovrebbe arrivare solo 'I'
 if(p_usaNonInd=1) then
  select count(*) into numApprendistato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='I' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='L');
 else
  select count(*) into numApprendistato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='I' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='L')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;

 if(numApprendistato>0) then
  if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || ' OR ';
  end if;
--  query_agevolazioni := query_agevolazioni ||
--            ' (PR_DIS_CONTRATTO.CODCONTRATTO=''AP'' and PG_INCROCIO.ETAMATCH(an.DATNASC) between 15 and 29)';
  query_agevolazioni := query_agevolazioni || '(PR_DIS_CONTRATTO.CODCONTRATTO=''AP'')';
 end if;
*/
 if(length(query_agevolazioni)>0) then
  query_where := query_where || ' and (' || query_agevolazioni || ') ';
 end if;
 -- Ricavo la query sql da eseguire
 par_impl_p_stato_begin := ' (pr_validita.CODTIPOVALIDITA = ''DL'' and PR_VALIDITA.CODSTATOLAV in (''COM''';
 if(p_dataValCv is null) then
  par_impliciti := ' (pr_validita.CODTIPOVALIDITA = ''DL'' and PR_VALIDITA.CODSTATOLAV=''COM'' and ' ||
          'trunc(sysdate) between ' ||
       'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
       'trunc(PR_VALIDITA.DATFINECURR)) ';
  par_impl_p_stato_end := ') and ' ||
                  'trunc(sysdate) between ' ||
          'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
          'trunc(PR_VALIDITA.DATFINECURR)) ';
 else
  par_impliciti := ' (pr_validita.CODTIPOVALIDITA = ''DL'' and PR_VALIDITA.CODSTATOLAV=''COM'' and ' ||
          'to_date(''' || p_dataValCv || ''',''dd/mm/yyyy'') between ' ||
       'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
       'trunc(PR_VALIDITA.DATFINECURR)) ';
  par_impl_p_stato_end := ') and ' ||
                  'to_date(''' || p_dataValCv || ''',''dd/mm/yyyy'') between ' ||
          'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
          'trunc(PR_VALIDITA.DATFINECURR)) ';
 end if;
 if(p_statoCv is not null) then
    par_statoIN :=
         case
              when p_statoCv='VAL' then ',''VAL'''
        when p_statoCv='PAR' then ',''VAL'',''PAR'''
        else ''
       end;
     query_where := query_where || ' and' || par_impl_p_stato_begin || par_statoIN || par_impl_p_stato_end;
 else
  query_where := query_where || ' and' || par_impliciti;
 end if;
 -- DONA
 --query_where := query_where || par_indisponibilita_az;
 query_where:= ltrim(query_where, 'and ');
 p_sql_query := query_select ||
       query_from ||
       query_join || ' where ' ||
       query_where;
 /********************************
 Check dei parametri di Ritorno
 ********************************/
 if(p_out_prgIncrocio is null or p_out_prgRosa is null) then
    rollback;
    return -1;
 end if;
 if(length(query_select)=0 or length(query_from)=0 or length(query_join)=0 or length(query_where)=0) then
    rollback;
    return -1;
 end if;
 -- Preparo i parametri di Output
 p_out_query_select := query_select;
 p_out_query_from := query_from;
 p_out_query_join := query_join;
 p_out_query_where := ' where ' || query_where;
 return 0;
 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       return -1;
END Matching_esatto;

-- Crea le componenti per lo statement che esegue il matching Esatto senza considerare la mansione richiesta
function Matching_esatto_no_mansione(
    p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
    p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
    p_statoCv DE_STATO_SCHEDALAV.CODSTATOLAV%TYPE,    -- stato del CV (opzionale - non usato per ora)
    p_usaPref int,            -- utilizza anche i parametri con richiesta "preferibile"
    p_usaNonInd int,            -- utilizza anche i parametri con richiesta "non indispensabile"
    p_flagDI int,             -- solo Disoccupati/Inoccupati
    p_flagIncMir int,         -- flag collocamento mirato
    p_db int,                -- base dati da utilizzare
    p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_dataValCV  varchar2,          -- data in base alla quale considerare valido un CV
    p_checkCM  number,              -- interruttore per il collocamento mirato
    encrypterKey varchar2,
    p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
  p_flagGG int,             -- solo Garanzia Giovani
    p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
    p_out_query_select OUT varchar2,
    p_out_query_from OUT varchar2,
    p_out_query_join OUT varchar2,
    p_out_query_where OUT long,
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE       -- progressivo della rosa
    ) return number IS

  p_sql_query long;
  query_select varchar2(100);
  query_from varchar2(100);
  query_join varchar2(4096);
  query_where long;
  p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
  p_Originale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;
  p_flgpubbcresco DO_EVASIONE.FLGPUBBCRESCO%TYPE;
  p_flgpubblicata DO_RICHIESTA_AZ.FLGPUBBLICATA%TYPE;
  p_datarichiesta varchar2(10);
  p_datascadpubbl varchar2(10);

  -- MASTER
  -- DONA 22/04/2008
  --where_cpi_master varchar2(500) := ' and (PG_INCROCIO.PDMASTERLAVO(an.cdnLavoratore)=1) ';
  -- CPI DI APPARTENENZA -----------------------------------------------------------------------------------------------------------------------------------------------
  -- per ora escluso, rifare come cpi_master se da inserire
  where_cpi varchar2(500) := '';
  -- STATO DI DISOCCUPAZIONE ---------------------------------------------------------------------------------------------------------------------------
  where_stato_occ varchar(100) := ' and (PG_INCROCIO.PDSTATOOCC(an.cdnLavoratore)=1) ';
  ------------------------------------------------------------------------------------------------------------------------------------------------------

  -- GARANZIA GIOVANI ---------------------------------------------------------------------------------------------------------------------------
  where_garanzia_giovani varchar(100) := ' and (PG_INCROCIO.CHECKGG(an.cdnLavoratore)=1) ';
  ------------------------------------------------------------------------------------------------------------------------------------------------------

  --where_mansione varchar2(4000) := '';
  where_mansione long := '';
  query_agevolazioni varchar2(2000) := '';
  like_mansione varchar2(20);
  where_titoli varchar2(4000) := '';
  where_form_prof varchar2(4000) := '';
  like_titolo varchar(8);
  where_luogo varchar2(2000) := '';
  recRichiesta DO_RICHIESTA_AZ%ROWTYPE;
  numComuni number;
  numProv number;
  codComAz AN_UNITA_AZIENDA.CODCOM%TYPE;
  strMansione varchar2(300);
  recAlternativa DO_ALTERNATIVA%ROWTYPE;
  numAnniEsp DO_ALTERNATIVA.NUMANNIESPERIENZA%TYPE;
  bFuoriSede boolean;
  numConLinguistiche number;
  numConLinIta number;
  numCompetenze number;
  numConInformatiche number;
  numAbilitazioni number;
  numMobilita number;
  numCollocMirato number;
  numDisocc number;
  numApprendistato number;
  numTitoli number;
  numMansioni number;
  abilitatoIDO number;
  -- Parametri
  parPrgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;
  parAutomunito DO_RICHIESTA_AZ.FLGAUTOMUNITO%TYPE;
  parMotomunito DO_RICHIESTA_AZ.FLGMOTOMUNITO%TYPE;
  parTrasferta DO_RICHIESTA_AZ.CODTRASFERTA%TYPE;
  parMilitare DO_RICHIESTA_AZ.FLGMILITE%TYPE;
  parFuoriSede DO_RICHIESTA_AZ.FLGFUORISEDE%TYPE;
  parMezziPub AN_UNITA_AZIENDA.FLGMEZZIPUB%TYPE;
  parEsperienza DO_ALTERNATIVA.FLGESPERIENZA%TYPE;
  parFormProf DO_ALTERNATIVA.FLGFORMAZIONEPROF%TYPE;
  -- Parametri impliciti
  par_impliciti varchar2(1000);
  par_impl_p_stato_begin varchar2(1000);
  par_impl_p_stato_end varchar2(300);
  par_statoIN varchar2(15);
  -- Indisponibilità
  -- DONA 22/04/2008
  --par_indisponibilita_az varchar(100) := ' and (PG_INCROCIO.pdIndispAzienda(an.cdnLavoratore,' || p_prgRichiestaAz || ')=0) ';

  patenteB number;
  -- Cursori
  CURSOR curTurni IS
     select DO_TURNO.CODTURNO from DO_TURNO where DO_TURNO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curOrari IS
     select DO_ORARIO.CODORARIO from DO_ORARIO where DO_ORARIO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curContratti IS
     select DO_CONTRATTO.CODCONTRATTO from DO_CONTRATTO
   where DO_CONTRATTO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_CONTRATTO.PRGALTERNATIVA = p_prgAlternativa;
  CURSOR curTitoli IS
     select DO_STUDIO.CODTITOLO, DO_STUDIO.FLGINDISPENSABILE, DO_STUDIO.FLGCONSEGUITO
   from DO_STUDIO
   where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
  -- Clausole IN
  inTurni varchar2(2000) := '';
  inOrario varchar2(2000) := '';
  inMansioni varchar2(2000) := '';
  inContratti varchar2(2000) := '';
  -- Informazioni da memorizzare in DO_PARAMETRI_INCROCIO
  rflgPref char(1);
  rflgNonInd char(1);
  rflgDis char(1);
  rflgGG char(1);
  rNumCand number;
  -- Debug
  lenStr number;
  tmpStr char(255);
  j number;
  k number;
  crlf VARCHAR2( 2 ):= CHR( 13 ) || CHR( 10 );
BEGIN
 if(p_prgRosa is null) then
  --query_select := 'select distinct an.CDNLAVORATORE, an.STRCOGNOME, an.STRNOME ';
  query_select := 'select distinct an.CDNLAVORATORE ';
  query_from := 'from AN_LAVORATORE an ';
  query_where := '';
  --query_where := where_cpi_master;
 else
  --query_select := 'select distinct an.CDNLAVORATORE, an.STRCOGNOME, an.STRNOME ';
  query_select := 'select distinct an.CDNLAVORATORE ';
  query_from := 'from do_nominativo ';
  query_join := 'inner join an_lavoratore an on (do_nominativo.CDNLAVORATORE=an.CDNLAVORATORE) ';
  query_where := ' and (do_nominativo.PRGROSA=' || p_prgRosa || ') ';
 end if;
 query_join := query_join || 'inner join PR_MANSIONE prm on (an.cdnLavoratore = prm.cdnLavoratore) ';
 query_join := query_join || 'inner join PR_VALIDITA on (an.CDNLAVORATORE=PR_VALIDITA.CDNLAVORATORE) ';

  -- Il controllo che ci sia almeno una MANSIONE in questo tipo di matching non ha senso, per cui non viene fatto
  -- Controllo che la richiesta non sia stata CHIUSA mentre si accedeva all'incrocio
  SELECT RICH2.PRGRICHIESTAAZ INTO p_Originale
  FROM DO_RICHIESTA_AZ RICH1
         INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
     WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;

  SELECT ev.CDNSTATORICH, nvl(ev.FLGPUBBCRESCO, 'N'), nvl(ric.FLGPUBBLICATA, 'N'), to_char(ric.DATRICHIESTA,'dd/mm/yyyy'), to_char(nvl(ric.DATSCADENZAPUBBLICAZIONE, SYSDATE),'dd/mm/yyyy')
      into p_cdnStatoRich, p_flgpubbcresco, p_flgpubblicata, p_datarichiesta, p_datascadpubbl
  FROM DO_RICHIESTA_AZ ric, DO_EVASIONE ev
  WHERE (ric.PRGRICHIESTAAZ = ev.PRGRICHIESTAAZ)
  AND ric.PRGRICHIESTAAZ = p_Originale;

  if(p_cdnStatoRich=4 OR p_cdnStatoRich=5) then
   return 2;
  end if;

 -- Se devo estrarre i candidati di competenza di un certo CpI
 -- al momento sospeso
 /*
 if((p_codCpi is not null) and (p_db=1)) then
  query_where := query_where || where_cpi;
 end if;
 */
 -- Se devo estrarre solamente i candidati Disoccupati/Inoccupati
 if((p_flagDI is not null) and (p_flagDI=1)) then
  if((p_flgpubbcresco = 'S') and (p_flgpubblicata = 'S')) then
  query_where := query_where ||
          ' and (an.cdnlavoratore in (select st.cdnLavoratore ' ||
          ' from am_stato_occupaz st ' ||
          ' inner join de_stato_occupaz ds on (st.CODSTATOOCCUPAZ=ds.CODSTATOOCCUPAZ) ' ||
          ' where st.CDNLAVORATORE = an.cdnlavoratore ' ||
          ' and (ds.CODSTATOOCCUPAZRAGG = ''D'' or ds.CODSTATOOCCUPAZRAGG = ''I'') ' ||
          ' and ds.CODSTATOOCCUPAZ <> ''B1'' ' ||
          ' and st.datinizio <= to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy'') ' ||
          ' and to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy'') <= nvl(st.datfine, sysdate)) ' ||
          ' or an.cdnlavoratore in (select cdnLavoratore from am_movimento mov ' ||
          ' where mov.CDNLAVORATORE = an.cdnlavoratore and mov.codContratto = ''LI'' ' ||
          ' and mov.codStatoAtto = ''PR'' and mov.codTipoMov = ''AVV'' ' ||
          ' and mov.datiniziomov <= to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy'') ' ||
          ' and to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy'') <= nvl(PG_ANAGRAFICA_PROFESSIONALE_RP.GetDataFineMovEffForRp(mov.PRGMOVIMENTO), sysdate))) ';
  else
  query_where := query_where || where_stato_occ;
  end if;
 end if;

 -- Se devo estrarre solamente i candidati in GG
 if((p_flagGG is not null) and (p_flagGG=1)) then
  if((p_flgpubbcresco = 'S') and (p_flgpubblicata = 'S')) then
  query_where := query_where || ' and (PG_INCROCIO.CHECKGGCRESCO(an.cdnLavoratore, to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy''), to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy''))=1) ';
  else
  query_where := query_where || where_garanzia_giovani;
  end if;
 end if;

  -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;
  dbms_output.put_line('Prg Incrocio=' || p_out_prgIncrocio || ' - Prg Rosa=' || p_out_prgRosa);
  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgIncrocio, p_prgRichiestaAz, p_prgAlternativa, 1, 'E',
  p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgRosa, null, p_out_prgIncrocio, 1, p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 3: memorizzo i parametri dell'incrocio
  if(p_usaPref=1) then
   rflgPref := 'S';
  else
   rflgPref := 'N';
  end if;
  if(p_usaNonInd=1) then
   rflgNonInd := 'S';
  else
   rflgNonInd := 'N';
  end if;
  if(p_flagDI=1) then
   rflgDis := 'S';
  else
   rflgDis := 'N';
  end if;
  if(p_flagGG=1) then
   rflgGG := 'S';
  else
   rflgGG := 'N';
  end if;
  -- vengono registrati i parametri dell'incrocio
  insert into do_parametri_incrocio
  (PRGPARAMETRIINCROCIO, PRGINCROCIO, CODSTATOLAV, DATSTATOLAV, CODTERRITORIO, PRGROSA,
  FLGPREFERIBILE, FLGNONINDISPENSABILE, FLGSOLODISOCCUPATO, FLGNOMANSIONE, FLGGARANZIAGIOVANI)
  values
  (S_DO_PARAMETRI_INCROCIO.nextval, p_out_prgIncrocio, p_statoCv, to_date(p_dataValCV, 'dd/mm/yyyy'),
  p_db, p_out_prgRosa, rflgPref, rflgNonInd, rflgDis, 'S', rflgGG);
/***********      avvio della generazione della query    ****************************************************/
    -- selezione dei parametri della richiesta
 select * into recRichiesta from DO_RICHIESTA_AZ where DO_RICHIESTA_AZ.PRGRICHIESTAAZ = p_prgRichiestaAz;
 parAutomunito := recRichiesta.flgAutomunito;
 parMotomunito := recRichiesta.flgMotomunito;
 parTrasferta := recRichiesta.codTrasferta;
 parMilitare := recRichiesta.flgMilite;
 parFuoriSede := recRichiesta.flgFuoriSede;
 parPrgAzienda := recRichiesta.prgAzienda;
 --
 /*
 -- Sospeso
 select AN_UNITA_AZIENDA.FLGMEZZIPUB into parMezziPub
 from AN_UNITA_AZIENDA
 where an_unita_azienda.PRGAZIENDA=recRichiesta.prgAzienda and an_unita_azienda.PRGUNITA=recRichiesta.prgUnita;
 */

 --dbms_output.put_line('Azienda raggiungibile con mezzi pubblici = ' ||parMezziPub);
 if(p_prgAlternativa is not null) then
    select * into recAlternativa from DO_ALTERNATIVA
    where DO_ALTERNATIVA.PRGRICHIESTAAZ = p_prgRichiestaAz
    and DO_ALTERNATIVA.PRGALTERNATIVA = p_prgAlternativa;
    parEsperienza := recAlternativa.flgEsperienza;
    numAnniEsp := recAlternativa.numAnniEsperienza;
    parFormProf := recAlternativa.flgFormazioneProf;
 end if;
/*******************************************************************************************************/
 select count(*) into numComuni from DO_COMUNE where DO_COMUNE.PRGRICHIESTAAZ = p_prgRichiestaAz;
 select count(*) into numProv from DO_PROVINCIA where DO_PROVINCIA.PRGRICHIESTAAZ = p_prgRichiestaAz;
 if((parFuoriSede='S') or (numComuni>0) or (numProv>0)) then
    bFuoriSede := true;
 else
    bFuoriSede := false;
 end if;
 if(numComuni=0 and numProv=0) then
  select an_az.CODCOM into codComAz
  from DO_RICHIESTA_AZ daz
    inner join AN_UNITA_AZIENDA an_az on (daz.prgAzienda=an_az.prgAzienda and daz.prgUnita=an_az.prgUnita)
  where daz.PRGRICHIESTAAZ = p_prgRichiestaAz;
 end if;
 -- Popolo la stringa con l'insieme dei codici dei turni
 FOR rec in curTurni LOOP
  if(length(inTurni)>0) then
     inTurni := inTurni ||',';
  end if;
  inTurni := inTurni || '''' || rec.codTurno || '''';
 END LOOP;
 --dbms_output.put_line('Turni IN (' || inTurni || ')');
 -- Popolo la stringa con l'insieme dei codici degli orari
 FOR rec in curOrari LOOP
  if(length(inOrario)>0) then
     inOrario := inOrario ||',';
  end if;
  inOrario:= inOrario || '''' || rec.codOrario || '''';
 END LOOP;
 --dbms_output.put_line('Orari IN (' || inOrario || ')');
 -- Popolo la stringa con l'insieme dei codici dei contratti
 if(p_prgAlternativa is not null) then
  FOR rec in curContratti LOOP
   if(length(inContratti)>0) then
      inContratti := inContratti ||',';
   end if;
   inContratti:= inContratti || '''' || rec.codContratto || '''';
  END LOOP;
 end if;
 --dbms_output.put_line('Contratti IN (' || inContratti || ')');
 /********************************************************************
 * - automunito (Preferibili)                                        *
 * - motomunito (Preferibili)                                        *
 * - formazione                                                      *
 * - sede raggiungibile con mezzi pubblici (fuori sede) --> sospeso  *
 * - turno                                                           *
 * - orario                                                          *
 * - contratto                                                       *
 * - trasferte                                                       *
 * - esperienza                                                      *
 * - Luogo di Lavoro                                                 *
 ********************************************************************/
 if(where_mansione='' or (where_mansione is null)) then
   dbms_output.put_line('');
 else
    where_mansione := where_mansione || ' or ';
 end if;
 if (p_checkcm = 0) then
    where_mansione := where_mansione || crlf || '( prm.FLGDISPONIBILE=''S'' ';
 else
    where_mansione := where_mansione || crlf || '( (prm.FLGDISPONIBILE=''S'' OR prm.FLGDISPONIBILE=''P'') ';
 end if;

    --where_mansione := where_mansione || ' (1=1 ';
 --Automunito
 if( (parAutomunito='P' and p_usaPref=1) or (parAutomunito='S') ) then
  where_mansione := where_mansione ||
    crlf ||   ' and an.cdnlavoratore in (select PR_MANSIONE.cdnLavoratore from PR_MOBIL_GEOGR inner join PR_MANSIONE on (PR_MANSIONE.prgMansione=PR_MOBIL_GEOGR.PRGMANSIONE)' ||
        '             where PR_MANSIONE.cdnLavoratore=an.cdnLavoratore and PR_MOBIL_GEOGR.FLGDISPAUTO=''S'' )';
 end if;
 -- Motomunito
 if( (parMotomunito='P' and p_usaPref=1) or (parMotomunito='S') ) then
  where_mansione := where_mansione ||
    crlf ||   ' and an.cdnlavoratore in (select PR_MANSIONE.cdnLavoratore from PR_MOBIL_GEOGR inner join PR_MANSIONE on (PR_MANSIONE.prgMansione=PR_MOBIL_GEOGR.PRGMANSIONE)' ||
        '             where PR_MANSIONE.cdnLavoratore=an.cdnLavoratore and PR_MOBIL_GEOGR.FLGDISPMOTO=''S'' )';
 end if;
 -- formazione
 if (parFormProf='S' or (parFormProf='P' and p_usaPref=1)) then
     query_join := query_join || ' inner join VW_MATCH_NRO_FLAG_MAN vwef on (an.cdnlavoratore = vwef.cdnlavoratore) ';
  query_where := query_where || ' and vwef.nroFormazione>0';
  /*
  where_mansione := where_mansione ||
--        ' and (prm.flgEspForm=''S'')';
     ' and exists (select 1'||
           '    from pr_mansione'||
     '    where pr_mansione.cdnlavoratore = an.cdnLavoratore and pr_mansione.FLGDISPONIBILE=''S'' '||
     '    and pr_mansione.flgEspForm=''S'' '||
     ' ) ';*/
 end if;
 -- Sede raggiungibile con mezzi pubblici
 -- Parametro Escluso dal matching: potrebbe tornare
 /*
 if(bFuoriSede=false) then
  dbms_output.put_line('In sede');
  if(parMezziPub='S') then
     where_mansione := where_mansione ||
             ' and (PR_MOBIL_GEOGR.FLGMEZZIPUB=''S'' or PR_MOBIL_GEOGR.FLGMEZZIPUB is null)';
  else
     if(parMezziPub='N') then
        where_mansione := where_mansione ||
             ' and (PR_MOBIL_GEOGR.FLGMEZZIPUB=''N'' or PR_MOBIL_GEOGR.FLGMEZZIPUB is null)';
     end if;
  end if;
 else
  dbms_output.put_line('Fuori sede');
 end if;
 */
 -- Turno
 if(length(inTurni)>0) then

     where_mansione := where_mansione || crlf ||
      ' and (an.cdnlavoratore in (select PR_MANSIONE.cdnLavoratore from PR_MANSIONE inner join PR_DIS_TURNO on (PR_MANSIONE.prgMansione=PR_DIS_TURNO.PRGMANSIONE) '||
   '             where PR_MANSIONE.cdnlavoratore = an.cdnLavoratore and PR_DIS_TURNO.codTurno in ('|| inTurni ||') )' ||
   ' or an.cdnlavoratore in (select vm.cdnLavoratore from VW_MATCH_NRO_X_MANSIONE vm where vm.cdnLavoratore = an.cdnLavoratore and vm.nroturni=0)) ';
 end if;
 -- Orario
 if(length(inOrario)>0) then
  where_mansione := where_mansione || crlf ||
           ' and (an.cdnlavoratore in (select PR_MANSIONE.cdnLavoratore from PR_MANSIONE inner join PR_DIS_ORARIO on (PR_MANSIONE.prgMansione=PR_DIS_ORARIO.PRGMANSIONE) ' ||
       '              where PR_DIS_ORARIO.CODORARIO in (' || inOrario || ')' ||
    '                  and PR_MANSIONE.CDNLAVORATORE = an.cdnlavoratore ) ' ||
    ' or an.cdnlavoratore in (select vm.cdnLavoratore from VW_MATCH_NRO_X_MANSIONE vm where vm.cdnLavoratore = an.cdnLavoratore and vm.nroOrari=0)) ';
 end if;
 -- Contratto

 -- Apprendistato (Indispensabile e dipendente dall'alternativa) --> SOSPESO
 -- 'APP' --> 'I' oppure 'L', ma dalla richiesta mi dovrebbe arrivare solo 'I'
 if(p_usaNonInd=1) then
  select count(*) into numApprendistato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='D0' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='A0');
 else
  select count(*) into numApprendistato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='D0' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='A0')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 if (numApprendistato>0) then
     if(length(inContratti)>0) then
      inContratti := inContratti ||',';
     end if;
     inContratti:= inContratti || '''AP''';
 end if;

 if(length(inContratti)>0) then
    where_mansione := where_mansione || crlf ||
           ' and (an.cdnlavoratore in (select PR_MANSIONE.cdnLavoratore from PR_MANSIONE inner join PR_DIS_CONTRATTO on (PR_MANSIONE.prgMansione=PR_DIS_CONTRATTO.PRGMANSIONE) ' ||
        '              where PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')'||
        '                  and PR_MANSIONE.CDNLAVORATORE = an.cdnlavoratore ) '||
                 ' or an.cdnlavoratore in (select vm.cdnLavoratore from VW_MATCH_NRO_X_MANSIONE vm where vm.cdnLavoratore = an.cdnLavoratore and vm.nroContratti=0)) ';
 end if;
 -- Trasferte
 if(parTrasferta is not null and (to_number(parTrasferta)<>1)) then
  where_mansione := where_mansione || crlf ||
           ' and an.cdnlavoratore in (select PR_MANSIONE.cdnLavoratore from PR_MOBIL_GEOGR inner join PR_MANSIONE on (PR_MANSIONE.prgMansione=PR_MOBIL_GEOGR.PRGMANSIONE)' ||
        '             where PR_MANSIONE.cdnLavoratore=an.cdnLavoratore  ' ||
        '                 and to_number(PR_MOBIL_GEOGR.CODTRASFERTA)>=' || parTrasferta || ' ) ';
 end if;
 -- Esperienza
 if((parEsperienza='P' and p_usaPref=1) or (parEsperienza='S')) then
     if (parFormProf='S' or (parFormProf='P' and p_usaPref=1)) then
     query_join := query_join;
  else
     query_join := query_join || ' inner join VW_MATCH_NRO_FLAG_MAN vwef on (an.cdnlavoratore = vwef.cdnlavoratore) ';
  end if;
  query_where := query_where || ' and vwef.nroEsperienze>0 ';
     /*
  where_mansione := where_mansione || crlf ||
   --        ' and (prm.FLGESPERIENZA=''S'' OR prm.FLGESPERIENZA=''E'') ';
                    ' and exists (select 1'||
                          '    from pr_mansione'||
                    '    where pr_mansione.cdnlavoratore = an.cdnLavoratore and pr_mansione.FLGDISPONIBILE=''S'' '||
                    '    and  (pr_mansione.FLGESPERIENZA=''S'' OR pr_mansione.FLGESPERIENZA=''E'') '||
                    ' ) ';*/
 end if;
 -- Luogo di Lavoro
 if(numComuni=0 and numProv=0) then
  -- come riferimento prendo il comune della sede dell'azienda
  where_mansione := where_mansione || crlf ||
           ' and (an.cdnlavoratore in (select dter.cdnLavoratore from VW_PR_DIS_TERRITORIO dter ' ||
        '           where dter.cdnLavoratore=an.cdnLavoratore and ' ||
        '               dter.codCom=' || '''' || codComAz || ''')  ' ||
        '     or an.CDNLAVORATORE in (select pm.CDNLAVORATORE from pr_mansione pm ' ||
            'inner join pr_dis_stato on (pr_dis_stato.PRGMANSIONE=pm.PRGMANSIONE) ' ||
              ' where pm.CDNLAVORATORE=an.CDNLAVORATORE ' ||
            'and pr_dis_stato.CODCOM=''Z000'' and ' ||
            'pm.CODMANSIONE=prm.codMansione)' ||

        ' ) ';
 else
     where_mansione := where_mansione || crlf ||  ' and (';
  -- Esistenza disponibilità per l'intero stato italiano
  where_mansione := where_mansione ||
           'an.CDNLAVORATORE in (select pm.CDNLAVORATORE from pr_mansione pm ' ||
            'inner join pr_dis_stato on (pr_dis_stato.PRGMANSIONE=pm.PRGMANSIONE) ' ||
              ' where pm.CDNLAVORATORE=an.CDNLAVORATORE ' ||
            'and pr_dis_stato.CODCOM=''Z000'' and ' ||
            'pm.CODMANSIONE=prm.codMansione) ';
  -- Disponibilità per i comuni
  if(numComuni>0) then
       where_mansione := where_mansione || crlf || '    '|| ' OR an.cdnlavoratore in (' ||
        'select dter.cdnLavoratore from VW_PR_DIS_TERRITORIO dter ' ||
        'inner join DO_COMUNE oter on (oter.codCom=dter.codCom) ' ||
        'where dter.cdnLavoratore=an.cdnLavoratore  ' ||
        '   and oter.prgRichiestaAz=' || p_prgRichiestaAz ||
        '   and dter.CODMANSIONE=prm.codMansione) ';
  end if;
  -- Disponibilità per le province
  if(numProv>0) then
       where_mansione := where_mansione || crlf || '    '|| ' OR an.cdnlavoratore in (' ||
        'select dter.cdnLavoratore from VW_PR_DIS_PROVINCIA dter ' ||
        'inner join DO_PROVINCIA oter on (oter.codProvincia=dter.codProvincia) ' ||
        'where dter.cdnLavoratore=an.cdnLavoratore ' ||
        '   and oter.prgRichiestaAz=' || p_prgRichiestaAz ||
        '   and dter.CODMANSIONE=prm.codMansione) ';
  end if;
  where_mansione := where_mansione || ' ) ';
 end if;
 where_mansione := where_mansione || crlf ||') ';
 query_where := query_where || ' and (' || where_mansione || crlf || ') ';
 /*---------------------------------- FINE MANSIONE ------------------------------------*/
 -- Servizio Militare / Servizio Civile (Preferibili)
 if( (parMilitare='P' and p_usaPref=1) or (parMilitare='S')) then
  query_where := query_where || crlf ||
        ' and ((an.STRSESSO=''M'' and an.FLGMILITE=''S'') or (an.STRSESSO=''F'')) ';
 end if;
 -- Conoscenze Linguistiche (Indispensabili - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numConLinguistiche
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numConLinguistiche
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
  and DO_LINGUA.FLGINDISPENSABILE='S';
 end if;
 if(numConLinguistiche>0) then
  query_where := query_where || crlf ||
        ' and (' ||
        '  (select count(*) from PR_LINGUA cv_lin inner join ' ||
        '   DO_LINGUA o_lin on (' ||
          'cv_lin.codLingua = o_lin.codLingua and ' ||
       'nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and ' ||
       'nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and ' ||
       'nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1)) ' ||
       'where (cv_lin.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_lin.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
       'o_lin.prgAlternativa=' || p_prgAlternativa || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_lin.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) >= ' || numConLinguistiche;
  -- Controllo se è richiesta la lingua italiana
  if(p_usaNonInd=1) then
     select count(*) into numConLinIta
     from DO_LINGUA
     where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
        and DO_LINGUA.codLingua='003';
  else
     select count(*) into numConLinIta
     from DO_LINGUA
     where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
        and DO_LINGUA.FLGINDISPENSABILE='S'
     and DO_LINGUA.CODLINGUA='003';
  end if;
  -- se numConLinIta >0  allora e' richiesta la lingua intaliana
  if(numConLinIta>0) then
     if(numConLinguistiche=1) then
      -- è richiesta la sola conoscenza della lingua italiana
      query_where := query_where || ' OR (an.codCittadinanza=''000'' or an.codCittadinanza2=''000'')';
     else
         query_where := query_where || ' OR ' ||
              '(select count(*) from PR_LINGUA cv_lin inner join ' ||
          'DO_LINGUA o_lin on (' ||
          'cv_lin.codLingua = o_lin.codLingua and ' ||
       'nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and ' ||
       'nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and ' ||
       'nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1)) ' ||
       'where (cv_lin.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_lin.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
       'o_lin.prgAlternativa=' || p_prgAlternativa || ' and o_lin.codLingua<>''003'' ' ||
       'and (an.codCittadinanza=''000'' or an.codCittadinanza2=''000'')';
      if(p_usaNonInd=0 or (p_usaNonInd is null)) then
         query_where := query_where || 'and o_lin.flgIndispensabile=''S'' ';
      end if;
         query_where := query_where || ')) ' ||
        '>= ' || (numConLinguistiche - numConLinIta);
     end if;
  end if;
  query_where := query_where || ') ';
 end if;
 -- Competenze (Indispensabili e dipendono dall'alternativa - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numCompetenze
  from DO_COMPETENZA
  where DO_COMPETENZA.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_COMPETENZA.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numCompetenze
  from DO_COMPETENZA
  where DO_COMPETENZA.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_COMPETENZA.PRGALTERNATIVA = p_prgAlternativa
     and DO_COMPETENZA.FLGINDISPENSABILE='S';
 end if;
 if(numCompetenze>0) then
  query_where := query_where || crlf ||
        ' and (' ||
        '   (select count(*) from PR_COMPETENZA cv_comp inner join DO_COMPETENZA o_comp on (' ||
        '       cv_comp.codCompetenza = o_comp.codCompetenza) ' ||
        '    where (cv_comp.cdnLavoratore = an.cdnLavoratore and ' ||
        '       o_comp.prgRichiestaAz=' || p_prgRichiestaAz ||
        '       and o_comp.prgAlternativa=' || p_prgAlternativa || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_comp.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) >= ' || numCompetenze || ') ';
 end if;
 -- Conoscenze Informatiche (Indispensabili e dipendenti dall'alternativa - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numConInformatiche
  from DO_INFO
  where DO_INFO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_INFO.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numConInformatiche
  from DO_INFO
  where DO_INFO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_INFO.PRGALTERNATIVA = p_prgAlternativa
     and DO_INFO.FLGINDISPENSABILE='S';
 end if;
 /*************************************************************
   DA QUESTO PUNTO SI UTILIZZERA' LA VARIABILE 'query_where'
 **************************************************************/
 if(numConInformatiche>0) then
  query_where := query_where || crlf ||
        ' and (' ||
        '   (select count(*) from PR_INFO cv_inf inner join DO_INFO o_inf on (' ||
        '       cv_inf.codDettInfo = o_inf.codDettInfo and ' ||
        '       cv_inf.codTipoInfo = o_inf.codTipoInfo and ' ||
        '       nvl(cv_inf.cdnGrado,1) >= nvl(o_inf.cdnGrado,1)) ' ||
        '    where (cv_inf.cdnLavoratore = an.cdnLavoratore and ' ||
           '       o_inf.prgRichiestaAz=' || p_prgRichiestaAz || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_inf.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where ||
       'and o_inf.prgAlternativa=' || p_prgAlternativa ||
        ')) >= ' || numConInformatiche ||
        ') ';
 end if;
 -- Abilitazioni (Indispensabili  - condizioni in AND)
 -- Es. patente specifica, patentino specifico, ....
 if(p_usaNonInd=1) then
  select count(*) into numAbilitazioni
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN<>'PGB';

  select count(*) into patenteB
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN='PGB';
 else
  select count(*) into numAbilitazioni
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.FLGINDISPENSABILE='S'
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN<>'PGB';

  select count(*) into patenteB
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.FLGINDISPENSABILE='S'
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN='PGB';
 end if;
 if(numAbilitazioni>0) then
  query_where := query_where || crlf ||
        ' and (' ||
        '    (select count(*) from PR_ABILITAZIONE cv_abi inner join DO_ABILITAZIONE_GEN o_abi on (' ||
        '        cv_abi.codAbilitazioneGen = o_abi.codAbilitazioneGen) ' ||
        '     where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
        '        o_abi.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
        '        o_abi.codAbilitazioneGen <> ''PGB'' ' ;
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_abi.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) >= ' || numAbilitazioni || ') ';
    end if;
 if(patenteB>0) then
  query_where := query_where || crlf ||
        ' and (' ||
        '    (select count(*) from PR_ABILITAZIONE cv_abi ' ||
        '     where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
           '        (cv_abi.codAbilitazioneGen = ''PGB'' or '||
        '         cv_abi.codAbilitazioneGen = ''PGC'' or '||
        '         cv_abi.codAbilitazioneGen = ''PGD'') ';
  query_where := query_where || ')) >= 1 ' || ') ';
 end if;
 -- Titoli di Studio (Indispensabili e dipendenti dall'alternativa - condizioni in OR)
 if(p_usaNonInd=1) then
  select count(*) into numTitoli
  from DO_STUDIO
  where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numTitoli
  from DO_STUDIO
  where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa
     and DO_STUDIO.FLGINDISPENSABILE='S';
 end if;
 dbms_output.put_line('Sono richiesti n. ' || numTitoli || ' Titoli di Studio');
 if(numTitoli>0) then
  --dbms_output.put_line('I Titoli sono in OR e va gestito il raggruppamento XY0000, XYAB00, XYABCD');
  FOR rec IN curTitoli LOOP
   if((rec.flgIndispensabile='S') or (p_usaNonInd=1)) then
      if(length(where_titoli)>0) then
         where_titoli := where_titoli || ' union ';
      else
         where_titoli := '' || crlf;
      end if;
      where_titoli := where_titoli || ' (';
     -- modifica TITOLI FASE 3
     -- Le codifiche dei titoli di studio sono composte di 8 digit
     like_titolo :=
     case
      when substr(rec.codTitolo, -7)='0000000' then substr(rec.codTitolo,1,1) || '%'
      when substr(rec.codTitolo, -6)='000000' then substr(rec.codTitolo,1,2) || '%'
      when substr(rec.codTitolo, -5)='00000' then substr(rec.codTitolo,1,3) || '%'
      when substr(rec.codTitolo, -3)='000' then substr(rec.codTitolo,1,5) || '%'
      else rec.codTitolo
     end;
      where_titoli := where_titoli ||
             'select cv_tit.cdnLavoratore from PR_STUDIO cv_tit ' ||
          'where cv_tit.cdnLavoratore=an.cdnLavoratore and ' ||
          'cv_tit.CODTITOLO like ' || '''' || like_titolo || '''' || ' and ';
      if(rec.flgConseguito='S' or (rec.flgConseguito is null)) then
         where_titoli := where_titoli ||
            'cv_tit.CODMONOSTATO=''C'' ';
      else
          if(rec.flgConseguito='N') then
          where_titoli := where_titoli ||
                   'cv_tit.CODMONOSTATO in (''A'',''I'',''C'') ';
       end if;
      end if;
      where_titoli := where_titoli || ') ';
   end if;
  END LOOP;
 end if;
 --dbms_output.put_line('WhereTitoli=' || where_titoli);
 if(length(where_titoli)>0) then
    query_where := query_where || ' and an.cdnlavoratore in (' || where_titoli || ') ';
 end if;
-- Corsi di Formazione 
select count(*) into abilitatoIDO
from ts_config_loc, de_tipo_config, ts_generale
where  ts_generale.prggenerale = 1
and ts_generale.codprovinciasil = ts_config_loc.strcodrif
and de_tipo_config.codtipoconfig = ts_config_loc.codtipoconfig
and trunc(sysdate) between trunc(de_tipo_config.datinizioval)
and trunc(de_tipo_config.datfineval)
and ts_config_loc.num=1
and upper(ts_config_loc.codtipoconfig) = 'IDOFPRO';

if(abilitatoIDO>0) then
	where_form_prof:= PG_INCROCIO.checkFormProf(p_prgRichiestaAZ ,p_prgAlternativa,p_usaNonInd);
    if(length(where_form_prof)>0) then
       query_where := query_where || ' and an.CDNLAVORATORE in (' || where_form_prof  || ') ';
    end if;
end if;

/*****************************************************
 *            AGEVOLAZIONI                            *
 * Sono indispensabili e dipendenti dall'alternativa. *
 * Vanno considerate in OR fra loro                   *
 * Il Collocamento Mirato viene trattato in modo      *
 * speciale: se è presente nella richiesta allora va  *
 * aggiunta una clausola in OR assieme alle altre     *
 * agevolazioni, mentre se non viene richiesto si deve*
 * aggiungere una clausola in AND alle altre condizio-*
 * ni della query.                                    *
 * Le agevolazioni considerate sono:                  *
 * - Mobilità                                         *
 * - Collocamento Mirato                              *
 * - Disoccupazione L. 407/90                         *
 * - Apprendistato                                    *
 *****************************************************/
 query_agevolazioni := '';
 -- In Mobilità (Indispensabile e dipendente dall'alternativa --> fa parte delle agevolazioni )
 -- 'MOB' --> 'A'
 if(p_usaNonInd=1) then
  select count(*) into numMobilita
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S5', 'S6', 'S7', '75', '76', '77');
 else
  select count(*) into numMobilita
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S5', 'S6', 'S7', '75', '76', '77')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 if(numMobilita>0) then
     if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || crlf || ' OR ';
  else
     query_agevolazioni := query_agevolazioni || crlf;
  end if;
  -- aggiungo il join con AM_MOBILITA_ISCR
  QUERY_JOIN := QUERY_JOIN ||
          'left outer join AM_MOBILITA_ISCR on (an.cdnLavoratore=AM_MOBILITA_ISCR.CDNLAVORATORE) and (AM_MOBILITA_ISCR.FLGNONIMPRENDITORE is null or AM_MOBILITA_ISCR.FLGNONIMPRENDITORE = ''N'') ';
  -- fare un controllo sul formato delle date in questa tabella
  query_agevolazioni := query_agevolazioni ||
        ' (trunc(AM_MOBILITA_ISCR.DATINIZIO) <= trunc(sysdate) and ' ||
        '(AM_MOBILITA_ISCR.DATFINE is null or trunc(sysdate) <= trunc(AM_MOBILITA_ISCR.DATFINE))) ';
 end if;
 -- Collocamento Mirato (Indispensabile e dipendente dall'alternativa --> fa parte delle agevolazioni)
 -- 'CLM' --> 'R' oppure 'S'
 if(p_usaNonInd=1) then
  select count(*) into numCollocMirato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE = '66' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='67');
 else
  select count(*) into numCollocMirato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE = '66' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='67')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 -- aggiungo il join con AM_CM_ISCR

 -- donato: modifica cifratura
 --query_join := query_join ||
 --        'left outer join AM_CM_ISCR on (an.cdnLavoratore=DECRYPT(AM_CM_ISCR.CDNLAVORATORE, '''|| encrypterkey ||''')) ';

 -- inserisco i lavoratori CM in una tabella globale

 if(numCollocMirato>0) then -- si considerano solo i lavoratori in collocamento mirato
                            -- e che possano accedere all'incrocio (CODACCERTSANITARIO='A')
  if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || crlf || ' OR ';
  else
       query_agevolazioni := query_agevolazioni || crlf;
  end if;
  -- Savino 28/06/05: tolta la condizione sul tipo di accertamento 'A'
  --query_agevolazioni := query_agevolazioni ||
  --      ' ((' ||
  --      'trunc(AM_CM_ISCR.DATDATAINIZIO)  <= trunc(sysdate) and ' ||
  --      'AM_CM_ISCR.DATDATAFINE is null)' ||
  --      ') ';

  query_join := query_join || ' left outer join global_cm on (an.cdnlavoratore=global_cm.cdnlavoratore) ';

  query_agevolazioni := query_agevolazioni || ' global_cm.cdncrypt is not null ';

 else -- si considerano solo i lavoratori abili al lavoro
 -- Savino 28/06/05: non e' piu' vero, si prendono tutti. Codice commentato, non si sa mai....
 -- query_where := query_where || crlf ||
 --       ' and ((' ||
 --       '(AM_CM_ISCR.CODACCERTSANITARIO=''A'') and ' ||
 --       'trunc(AM_CM_ISCR.DATDATAINIZIO) <= trunc(sysdate) and ' ||
 --       'AM_CM_ISCR.DATDATAFINE is null) ' ||
 --       ' OR ((select count(*) from AM_CM_ISCR where AM_CM_ISCR.CDNLAVORATORE=an.cdnLavoratore' ||
 --       ' ) = 0) ' ||
 --       'OR (exists(select * from VW_LAST_AM_CM_ISCR iscr where iscr.CDNLAVORATORE=an.cdnLavoratore ' ||
 --       'and trunc(iscr.DATDATAFINE) < trunc(sysdate) )) ' ||
 --       ') ';
    query_where := query_where;
 end if;
 -- Disoccupazione L. 407/90 (Indispensabile e dipendente dall'alternativa)
 -- 'DIS' --> 'D'
 if(p_usaNonInd=1) then
  select count(*) into numDisocc
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S8', '58');
 else
  select count(*) into numDisocc
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S8', '58')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 if(numDisocc>0) then
  if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || ' OR ';
  end if;
  query_join := query_join ||
          'left outer join VW_AM_LAV_SITUAZ_AMMIN on (an.cdnLavoratore=VW_AM_LAV_SITUAZ_AMMIN.CDNLAVORATORE) ';
  query_agevolazioni := query_agevolazioni || ' (VW_AM_LAV_SITUAZ_AMMIN.flg40790=''S'') ';
 end if;
 /*
 -- Apprendistato (Indispensabile e dipendente dall'alternativa) --> SOSPESO
 -- 'APP' --> 'I' oppure 'L', ma dalla richiesta mi dovrebbe arrivare solo 'I'
 if(p_usaNonInd=1) then
  select count(*) into numApprendistato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='I' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='L');
 else
  select count(*) into numApprendistato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='I' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='L')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;

 if(numApprendistato>0) then
  if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || crlf || ' OR ';
  else
   query_agevolazioni := query_agevolazioni || crlf;
  end if;
  query_agevolazioni := query_agevolazioni ||
            --' (PR_DIS_CONTRATTO.CODCONTRATTO=''AP'' and PG_INCROCIO.ETAMATCH(an.DATNASC) between 15 and 29)';
         ' (PR_DIS_CONTRATTO.CODCONTRATTO=''AP'')';
 end if;
*/
 if(length(query_agevolazioni)>0) then
  query_where := query_where || crlf || ' and (' || query_agevolazioni || crlf || '   ) ';
 end if;
 -- Ricavo la query sql da eseguire
 par_impl_p_stato_begin := ' (pr_validita.CODTIPOVALIDITA = ''DL'' and PR_VALIDITA.CODSTATOLAV in (''COM''';
 if(p_dataValCv is null) then
  par_impliciti := crlf || ' (pr_validita.CODTIPOVALIDITA = ''DL'' and PR_VALIDITA.CODSTATOLAV=''COM'' and ' ||
          'trunc(sysdate) between ' ||
       'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
       'trunc(PR_VALIDITA.DATFINECURR)) ';
  par_impl_p_stato_end := crlf || ') and ' ||
               'trunc(sysdate) between ' ||
        'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
        'trunc(PR_VALIDITA.DATFINECURR)) ';
 else
  par_impliciti := crlf || ' (pr_validita.CODTIPOVALIDITA = ''DL'' and PR_VALIDITA.CODSTATOLAV=''COM'' and ' ||
          'to_date(''' || p_dataValCv || ''',''dd/mm/yyyy'') between ' ||
       'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
       'trunc(PR_VALIDITA.DATFINECURR)) ';
  par_impl_p_stato_end := crlf || ') and ' ||
               'trunc(''' || p_dataValCv || ''',''dd/mm/yyyy'') between ' ||
        'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
        'trunc(PR_VALIDITA.DATFINECURR)) ';
 end if;
 if(p_statoCv is not null) then
    par_statoIN :=
         case
              when p_statoCv='VAL' then ',''VAL'''
        when p_statoCv='PAR' then ',''VAL'',''PAR'''
        else ''
       end;
     query_where := query_where || crlf || ' and' || par_impl_p_stato_begin || par_statoIN || par_impl_p_stato_end;
 else
    query_where := query_where || crlf || ' and' || par_impliciti;
 end if;
 -- DONA 22/04/2008
 --query_where := query_where || par_indisponibilita_az;
 /* se la clausola where inizia con un 'and' allora bisogna toglierla         */
 query_where:= ltrim(query_where, ' and ');
 /***************  non serve a niente: ***************************/
 p_sql_query := query_select ||
       query_from ||
       query_join || ' where ' ||
       query_where;
 /********************************
 Check dei parametri di Ritorno
 ********************************/
 if(p_out_prgIncrocio is null or p_out_prgRosa is null) then
    rollback;
    return -1;
 end if;
 if(length(query_select)=0 or length(query_from)=0 or length(query_join)=0 or length(query_where)=0) then
    rollback;
    return -1;
 end if;
 -- Preparo i parametri di Output
 p_out_query_select := query_select;
 p_out_query_from := query_from;
 p_out_query_join := query_join;
 p_out_query_where := ' where ' || query_where;
 return 0;
 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       /* se si verificano errori puo' essere comodo ritornare alcune informazioni per il debuggin

        p_out_query_select := 'length p_sql_query: ' ||length(p_sql_query);
     p_out_query_from := 'length query_where: ' || length(query_where);
      p_out_query_join := '';
         p_out_query_where := sqlerrm;
     */
       return -1;
END Matching_esatto_no_mansione;



-- Esegue l'incrocio
/***************************************************************
* Se il parametro p_mem=1 allora si memorizzano i dati nel db,
* altrimenti si restituisce il recordset dei candidati
*
* Il codice di ritorno vale:
*  0 se è tutto ok
*  -1 se si è verificata una eccezione
***************************************************************/
function eseguiIncrocio(
   p_query_select varchar2,
   p_query_from varchar2,
   p_query_join varchar2,
   p_query_where long,
   p_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,  -- progressivo dell'incrocio
   p_prgRosa DO_ROSA.PRGROSA%TYPE,     -- progressivo della rosa
   p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
   p_mem char,
   encrypterkey varchar2,
   p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
   p_ErrCode OUT number
   --p_cursor OUT t_cursor
   ) return number  IS
  -- Tipo del record per la tabella di appoggio
  /*
  type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
             strCognome AN_LAVORATORE.STRCOGNOME%TYPE,
        strNome AN_LAVORATORE.STRNOME%TYPE
              );*/
  type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type);
  type tab_ris is table of p_rec_ris;
  p_tab_ris tab_ris;
  sql_query CLOB;
  rCpiTit DE_CPI.CODCPI%type;
  rDid DO_NOMINATIVO.DATDICHIARAZIONE%type;
  nro number;
  p_categoriaCM do_richiesta_az.codmonocmcategoria%type;
  p_prgRichiestaAz do_incrocio.prgrichiestaaz%type;
begin

-- donato popolo la global_cm con i lavoratori iscritti al collocamento
if (p_codmonocmcategoria = 'D' OR p_codmonocmcategoria = 'A') then
  insert into global_cm
  select distinct decrypt(i.cdnlavoratore, encrypterkey), i.cdnlavoratore
  from am_cm_iscr i
  inner join de_cm_tipo_iscr dc on dc.codcmtipoiscr = i.codcmtipoiscr
  INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
  INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
  where
  DOC.CODSTATOATTO = 'PR' AND DOC.CDNLAVORATORE = decrypt(i.cdnlavoratore, encrypterkey)
  and DECODE(i.DATDATAFINE,NULL,'S','N') = 'S'
  and dc.codmonotiporagg = p_codmonocmcategoria;
else
  insert into global_cm
  select distinct decrypt(i.cdnlavoratore, encrypterkey), i.cdnlavoratore
  from am_cm_iscr i
  INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
  INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
  where
  DOC.CODSTATOATTO = 'PR' AND DOC.CDNLAVORATORE = decrypt(i.cdnlavoratore, encrypterkey)
  and DECODE(i.DATDATAFINE,NULL,'S','N') = 'S';
end if;


 select inc.prgrichiestaaz into p_prgRichiestaAz
 from do_incrocio inc
 where inc.prgincrocio = p_prgIncrocio;

 sql_query := p_query_select;
 sql_query := sql_query || p_query_from;
 sql_query := sql_query || p_query_join;
 sql_query := sql_query || p_query_where;

 execute immediate to_char(sql_query) bulk collect into p_tab_ris;
 dbms_output.put_line('');
 dbms_output.put_line('Elenco Candidati');


 if(p_mem=1) then
   FOR i in 1..p_tab_ris.COUNT
    loop
      --dbms_output.put_line(p_tab_ris(i).cdnLavoratore ||';' || p_tab_ris(i).strCognome || ';' || p_tab_ris(i).strNome);
     -- Inserimento del candidato in do_nominativo
     --rDid := PG_INCROCIO.PDDIDLAVO(p_tab_ris(i).cdnLavoratore);
     rCpiTit := PG_INCROCIO.PDCPITIT(p_tab_ris(i).cdnLavoratore);
     /*
     insert into DO_NOMINATIVO
     (prgNominativo, cdnLavoratore, numOrdine, codCpiTit, dtmIns, cdnUtIns, prgRosa, datDichiarazione)
     values
     (S_DO_NOMINATIVO.nextVal, p_tab_ris(i).cdnLavoratore, null,
     PG_INCROCIO.PDCPITIT(p_tab_ris(i).cdnLavoratore), sysdate, p_cdnUtente, p_prgRosa,
     PG_INCROCIO.PDDIDLAVO(p_tab_ris(i).cdnLavoratore));
     */
     if(p_prgRosa is null) then
        if (((PG_INCROCIO.PDMASTERLAVO(p_tab_ris(i).cdnLavoratore)=1))) then
           if ((PG_INCROCIO.pdIndispAzienda(p_tab_ris(i).cdnLavoratore, p_prgRichiestaAz)=0)) then
             insert into DO_NOMINATIVO
             (prgNominativo, cdnLavoratore, numOrdine, codCpiTit, dtmIns, cdnUtIns, prgRosa)
             values
             (S_DO_NOMINATIVO.nextVal, p_tab_ris(i).cdnLavoratore, null,
             rCpiTit, sysdate, p_cdnUtente, p_prgRosa);
           end if;
        end if;
     else
        if ((PG_INCROCIO.pdIndispAzienda(p_tab_ris(i).cdnLavoratore, p_prgRichiestaAz)=0)) then
           insert into DO_NOMINATIVO
           (prgNominativo, cdnLavoratore, numOrdine, codCpiTit, dtmIns, cdnUtIns, prgRosa)
           values
           (S_DO_NOMINATIVO.nextVal, p_tab_ris(i).cdnLavoratore, null,
           rCpiTit, sysdate, p_cdnUtente, p_prgRosa);
        end if;
     end if;

    end loop;
  --else
    --OPEN p_cursor FOR sql_query;
  end if;
  -- aggiorno lo stato dell'incrocio
  update do_incrocio set CODSTATOINCROCIO='C',NUMKLOINCROCIO=NUMKLOINCROCIO+1, CDNUTMOD=p_cdnUtente,
            DTMMOD=sysdate
    where PRGINCROCIO =  p_prgIncrocio;
  commit;
  return 0;
  exception
      --when no_data_found then
     --     rCpiTit := null;
      when others then
         p_errCode := sqlcode;
       --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       return -1;
end eseguiIncrocio;
--*****************************************************************
-- MATCHING PESATO
-- FASE 1: determinazione della query di selezione dei candidati
-- da "pesare"
--*****************************************************************

function Matching_Pesato_PEsatti(
    p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
    p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
    p_db int,                -- base dati da utilizzare
    p_dataValCV  varchar2,          -- data in base alla quale considerare valido un CV
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_numPFasciaEtaPrima number,         -- peso associato alla prima fascia di età estesa
    p_numPFasciaEtaSec number,         -- peso associato alla seconda fascia di età estesa
    p_numPStudioGruppo number,         -- peso associato a un titolo di studio nel gruppo
    p_numPStudioAlias number,          -- peso associato a un titolo di studio associato
    p_numPMansioneGruppo number,         -- peso associato a una mansione nel gruppo
    p_numPMansioneAlias number,         -- peso associato a una mansione associata
    p_numPNoEsperienza number,         -- peso associato alla mansione senza esperienza
    p_numPEsperienzaAlias number,         -- peso associato all'esperienza in una mansione simile
    p_numPInfoMin number,           -- peso associato alla conoscenza info con grado minore
    p_numPInfoGruppo number,          -- peso associato a una conoscenza info nello stesso gruppo
    p_numPInfoGruppoMIn number,         -- peso associato a una conoscenza info nello stesso gruppo e grado minore
    p_numPLinguaInf number,           -- peso associato a una conoscenza linguistica con grado minore
    p_numPSogliaRichiesta number,         -- valore di soglia entro il quale estrarre i candidati
    p_flagIncMir int,         -- flag collocamento mirato
    p_checkCM  number,              -- interruttore per il collocamento mirato
    p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
    p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
    p_out_query_select OUT varchar2,
    p_out_query_from OUT varchar2,
    p_out_query_join OUT varchar2,
    p_out_query_where OUT long,
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE,       -- progressivo della rosa
    p_out_where_territorio OUT varchar2
    ) return number IS
  p_sql_query long;
  query_select varchar2(100);
  query_from varchar2(100);
  query_join varchar2(4000);
  query_where varchar2(6000);
  p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
  p_Originale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;

  -- MASTER ----questo  non verrà eseguito, vedi sotto
 -- where_cpi_master varchar2(500) := ' and (PG_INCROCIO.PDMASTERLAVO(an.cdnLavoratore)=1) ';
  ------------------------------------------------
  --where_mansione varchar2(6000) := '';
  where_mansione long := '';
  where_test varchar2(6000) := '';
  where_territorio varchar2(6000) := '';
  like_mansione varchar2(20);
  where_luogo varchar2(2000) := '';
  -- Indisponibilità ---------------------------------
  par_indisponibilita_az varchar(100) := ' and (PG_INCROCIO.pdIndispAzienda(an.cdnLavoratore,' || p_prgRichiestaAz || ')=0) ';
  ----------------------------------------------------
  recRichiesta DO_RICHIESTA_AZ%ROWTYPE;
  parPrgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;
  parAutomunito DO_RICHIESTA_AZ.FLGAUTOMUNITO%TYPE;
  numComuni number;
  numProv number;
  codComAz AN_UNITA_AZIENDA.CODCOM%TYPE;
  strMansione varchar2(2000);
  numMansioni number;
  numRelMansioni number;
  p_prgMansione DE_MANSIONE.CODMANSIONE%TYPE;
 numAbilitazioni number;
 patenteB number;

  -- Parametri impliciti------------------------------------------
  par_impliciti varchar2(500) := ' (pr_validita.CODTIPOVALIDITA = ''DL'' and PR_VALIDITA.CODSTATOLAV=''COM'' and ' ||
          'trunc(sysdate) between ' ||
       'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
       'trunc(PR_VALIDITA.DATFINECURR)) ';
  par_impliciti_valCV varchar2(500) := ' (pr_validita.CODTIPOVALIDITA = ''DL'' and PR_VALIDITA.CODSTATOLAV=''COM'' and ' ||
          'to_date(''' || p_dataValCv || ''',''dd/mm/yyyy'') between ' ||
       'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
       'trunc(PR_VALIDITA.DATFINECURR)) ';
 -----------------------------------------------------------------
  -- Cursori
  CURSOR curMansioni IS
     select DO_MANSIONE.codMansione
   from DO_MANSIONE
   where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_MANSIONE.PRGALTERNATIVA = p_prgAlternativa;
  -- Debug
  lenStr number;
  tmpStr char(255);
  j number;
  k number;
  -- Tipo del record per la tabella di appoggio -- Debug
  type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
             strCognome AN_LAVORATORE.STRCOGNOME%TYPE,
        strNome AN_LAVORATORE.STRNOME%TYPE
              );
  type tab_ris is table of p_rec_ris;
  p_tab_ris tab_ris;
BEGIN
 if(p_prgRosa is null) then
  --query_select := 'select distinct an.CDNLAVORATORE, an.STRCOGNOME, an.STRNOME ';
  query_select := 'select distinct an.CDNLAVORATORE ';
  query_from := 'from AN_LAVORATORE an ';
  --query_where := '';
  --query_where := where_cpi_master; --sostituito con
   query_join := query_join || 'inner join an_lav_storia_inf i on (an.cdnlavoratore=i.cdnlavoratore)';
   query_join := query_join || 'inner join de_cpi on (i.CODCPITIT=de_cpi.CODCPI)';
   query_where := ' and (DECODE(i.DATFINE,NULL,''S'',''N'') = ''S'' and i.codmonotipocpi in (''C'',''T'') ';
   query_where :=query_where || ' and de_cpi.codprovincia = (select codProvinciaSil from ts_generale where rownum=1) )';
 else
  --query_select := 'select distinct an.CDNLAVORATORE, an.STRCOGNOME, an.STRNOME ';
  query_select := 'select distinct an.CDNLAVORATORE ';
  query_from := 'from do_nominativo ';
  query_join := 'inner join an_lavoratore an on (do_nominativo.CDNLAVORATORE=an.CDNLAVORATORE) ';
  query_where := ' and (do_nominativo.PRGROSA=' || p_prgRosa || ') ';
 end if;
  query_join := query_join || 'inner join PR_MANSIONE prm on (an.cdnLavoratore = prm.cdnLavoratore) ';
  query_join := query_join || 'inner join PR_VALIDITA on (an.CDNLAVORATORE=PR_VALIDITA.CDNLAVORATORE) ';
  query_join := query_join || 'left outer join PR_MOBIL_GEOGR on (prm.prgMansione=PR_MOBIL_GEOGR.PRGMANSIONE) ';
--  query_join := query_join || 'left outer join PR_NOTA_LAV on (an.cdnLavoratore=PR_NOTA_LAV.CDNLAVORATORE) ';

  -- Controllo che ci sia almeno una mansione
  select count(*) into numMansioni from DO_MANSIONE where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;
  if(numMansioni=0) then
 return 1;
 dbms_output.put_line('Non è possibile effettuare l''incrocio in quanto non è stata specificata nessuna mansione!');
  end if;
  -- Controllo che la richiesta non sia stata CHIUSA mentre si accedeva all'incrocio
  SELECT RICH2.PRGRICHIESTAAZ INTO p_Originale
  FROM DO_RICHIESTA_AZ RICH1
        INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
  WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;

  SELECT do_evasione.CDNSTATORICH into p_cdnStatoRich
  FROM DO_RICHIESTA_AZ, DO_EVASIONE
  WHERE (DO_RICHIESTA_AZ.PRGRICHIESTAAZ=DO_EVASIONE.PRGRICHIESTAAZ)
    AND DO_RICHIESTA_AZ.PRGRICHIESTAAZ=p_Originale;
  if(p_cdnStatoRich=4 OR p_cdnStatoRich=5) then
  return 2;
  end if;

  -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;
  dbms_output.put_line('Prg Incrocio=' || p_out_prgIncrocio || ' - Prg Rosa=' || p_out_prgRosa);
  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgIncrocio, p_prgRichiestaAz, p_prgAlternativa, 2, 'E',
  p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgRosa, null, p_out_prgIncrocio, 1, p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 3: memorizzo i parametri dell'incrocio  -> li memorizzo nella Function di esecuzione
  insert into do_parametri_incrocio
  (PRGPARAMETRIINCROCIO, PRGINCROCIO, CODTERRITORIO, PRGROSA, DATSTATOLAV,
  NUMPFASCIAETAESATTA, NUMPFASCIAETAPRIMA, NUMPFASCIAETASEC,
  NUMPSTUDIO, NUMPSTUDIOGRUPPO, NUMPSTUDIOALIAS,
  NUMPMANSIONE, NUMPMANSIONEGRUPPO, NUMPMANSIONEALIAS,
  NUMPESPERIENZA, NUMPNOESPERIENZA, NUMPESPERIENZAALIAS,
  NUMPINFO, NUMPINFOMIN, NUMPINFOGRUPPO, NUMPINFOGRUPPOMIN,
  NUMPLINGUA, NUMPLINGUAINF,
  DECSOGLIARICHIESTA)
  values
  (S_DO_PARAMETRI_INCROCIO.nextval, p_out_prgIncrocio, p_db, p_out_prgRosa, to_date(p_dataValCV, 'dd/mm/yyyy'),
  100, p_numPFasciaEtaPrima, p_numPFasciaEtaSec,
  100, p_numPStudioGruppo, p_numPStudioAlias,
  100, p_numPMansioneGruppo, p_numPMansioneAlias,
  100, p_numPNoEsperienza, p_numPEsperienzaAlias,
  100, p_numPInfoMin, p_numPInfoGruppo, p_numPInfoGruppoMin,
  100, p_numPLinguaInf,
  p_numPSogliaRichiesta);
  -- INDISPONIBILITA'
  select * into recRichiesta from DO_RICHIESTA_AZ where DO_RICHIESTA_AZ.PRGRICHIESTAAZ = p_prgRichiestaAz;
  parPrgAzienda := recRichiesta.prgAzienda;
  parAutomunito := recRichiesta.flgAutomunito;
  -- TERRITORIO
  select count(*) into numComuni from DO_COMUNE where DO_COMUNE.PRGRICHIESTAAZ = p_prgRichiestaAz;
  select count(*) into numProv from DO_PROVINCIA where DO_PROVINCIA.PRGRICHIESTAAZ = p_prgRichiestaAz;
  if(numComuni=0 and numProv=0) then
  select an_az.CODCOM into codComAz
  from DO_RICHIESTA_AZ daz
    inner join AN_UNITA_AZIENDA an_az on (daz.prgAzienda=an_az.prgAzienda and daz.prgUnita=an_az.prgUnita)
  where daz.PRGRICHIESTAAZ = p_prgRichiestaAz;
  end if;
 /*********************************************************
 * Mansione e parametri collegati alle mansioni:          *
 * - Automunito                                           *
 * - Luogo di Lavoro                                      *
 *********************************************************/
 /* Va gestito il raggruppamento xy0000, xyab00, xyabcd */
 FOR rec IN curMansioni LOOP
  if(where_mansione='' or (where_mansione is null)) then
    dbms_output.put_line('');
  else
     where_mansione := where_mansione || ' or ';
  end if;

  if(where_test='' or (where_test is null)) then
     dbms_output.put_line('');
  else
     where_test := where_test || ' or ';
  end if;

 -- if(SUBSTR(rec.codMansione,-4)='0000') then
  -- strMansione := '(SUBSTR(prm.codMansione,1,2)=''' || SUBSTR(rec.codMansione,1,2) || ''') ';
  -- like_mansione := SUBSTR(rec.codMansione,1,2) || '%';
  --else
    if(SUBSTR(rec.codMansione,-2)='00') then
    strMansione := '(SUBSTR(prm.codMansione,1,5)=''' || SUBSTR(rec.codMansione,1,5) || ''') ';
   like_mansione := SUBSTR(rec.codMansione,1,5) || '%';
    else
       strMansione := '(prm.codMansione=''' || rec.codMansione || ''') ';
    like_mansione := rec.codMansione;
    strMansione := '(prm.codMansione=''' || rec.codMansione || ''' or ' ||
          'SUBSTR(prm.codMansione,1,5)=''' || SUBSTR(rec.codMansione,1,5) || ''' ';
    select count(*) into numRelMansioni
    from DE_REL_MANSIONE
    where de_rel_mansione.codMansione=rec.codMansione and flgTipo=2;
    if(numRelMansioni>0) then
     p_prgMansione := rec.codMansione;
     strMansione := strMansione || ' or ' ||
          'SUBSTR(prm.codMansione,1,5) in '  ||
          '(select SUBSTR(codGruppo,1,5) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
          p_prgMansione || ''' and flgTipo=2)';
    end if;
    strMansione := strMansione || ') ';
    end if;
  --end if;

  if (p_checkcm = 0) then
     where_mansione := where_mansione || '(' || strMansione || ' and prm.FLGDISPONIBILE IN (''S'', ''P'') ';
     where_test := where_test || '(' || strMansione || ' and prm.FLGDISPONIBILE  IN (''S'', ''P'')  ';
  else
     where_mansione := where_mansione || '(' || strMansione || ' and (prm.FLGDISPONIBILE  IN (''S'', ''P'') ) ';
     where_test := where_test || '(' || strMansione || ' and (prm.FLGDISPONIBILE  IN (''S'', ''P'')  ) ';
  end if;

  like_mansione :=
   case
    --when substr(rec.codMansione,-4)='0000' then substr(rec.codMansione,1,2) || '%'
    when substr(rec.codMansione,-2)='00' then substr(rec.codMansione,1,5) || '%'
    else rec.codMansione
   end;

  --Automunito
  if( (parAutomunito='P') or (parAutomunito='S') ) then
   where_mansione := where_mansione ||
            ' and (PR_MOBIL_GEOGR.FLGDISPAUTO=''S'' ) ';
--         '(PR_MOBIL_GEOGR.FLGDISPAUTO is null and PR_NOTA_LAV.FLGAUTOMUNITO=''S'') )';
  end if;

  -- Non viene più utilizzato!!!
/*
  -- Luogo di Lavoro
  if(SUBSTR(rec.codMansione,-2)='00' or SUBSTR(rec.codMansione,-4)='0000') then
   -- CASO A: MANSIONE GENERICA
   if(numComuni=0 and numProv=0) then
    -- come riferimento prendo il comune della sede dell'azienda
    where_territorio := where_territorio ||
               ' and ( exists (' ||
          'select 1 from VW_PR_DIS_TERRITORIO dter ' ||
          'where dter.cdnLavoratore=app.cdnLavoratore and ' ||
          'dter.codMansione like ''' || like_mansione || ''' and ' ||
          'dter.codCom=' || '''' || codComAz || ''') OR ' ||
          'exists (select 1 from pr_mansione, pr_dis_stato ' ||
              ' where (pr_mansione.PRGMANSIONE=pr_dis_stato.PRGMANSIONE) ' ||
            'and pr_mansione.CDNLAVORATORE=app.CDNLAVORATORE ' ||
            'and pr_dis_stato.CODCOM=''Z000'' and ' ||
            'pr_mansione.CODMANSIONE=prm.codMansione)' ||
          ') ';
   else
       where_territorio := where_territorio || ' and (';
    -- Esistenza disponibilià per l'intero stato italiano
    where_territorio := where_territorio ||
            'exists (select 1 from pr_mansione, pr_dis_stato ' ||
           ' where (pr_mansione.PRGMANSIONE=pr_dis_stato.PRGMANSIONE) ' ||
         'and pr_mansione.CDNLAVORATORE=app.CDNLAVORATORE ' ||
         'and pr_dis_stato.CODCOM=''Z000'' and ' ||
         'pr_mansione.CODMANSIONE like ''' || like_mansione ||''')';
    -- Disponibilità per i comuni
    if(numComuni>0) then
     where_territorio := where_territorio || ' OR exists(' ||
             'select 1 from VW_PR_DIS_TERRITORIO dter ' ||
            'inner join DO_COMUNE oter on (oter.codCom=dter.codCom) ' ||
            'where dter.cdnLavoratore=app.cdnLavoratore and ' ||
            'dter.codMansione like ''' || like_mansione || ''' and ' ||
            'oter.prgRichiestaAz=' || p_prgRichiestaAz || ')';
    end if;
    -- Disponibilità per le province
    if(numProv>0) then
     where_territorio := where_territorio || ' OR exists(' ||
           'select 1 from VW_PR_DIS_PROVINCIA dter ' ||
            'inner join DO_PROVINCIA oter on (oter.codProvincia=dter.codProvincia) ' ||
            'where dter.cdnLavoratore=app.cdnLavoratore and ' ||
            'dter.codMansione like ''' || like_mansione || ''' and ' ||
            'oter.prgRichiestaAz=' || p_prgRichiestaAz || ')';
    end if;
    where_territorio := where_territorio || ')';
   end if;
  else
   -- CASO B: MANSIONE SPECIFICA (match su mansione, gruppo primario, gruppi secondari definiti nella DE_REL_MANSIONE)
   if(numComuni=0 and numProv=0) then
    -- come riferimento prendo il comune della sede dell'azienda
    where_territorio := where_territorio ||
         ' and ( exists (' ||
          'select 1 from VW_PR_DIS_TERRITORIO dter ' ||
          'where dter.cdnLavoratore=app.cdnLavoratore and ';
    where_territorio := where_territorio ||
          '(dter.codMansione=''' || rec.codMansione || ''' or ' ||
             'SUBSTR(dter.codMansione,1,4)=''' || SUBSTR(rec.codMansione,1,4) || ''' ';
    if(numRelMansioni>0) then
     where_territorio := where_territorio ||
             ' or SUBSTR(dter.codMansione,1,4) in '  ||
             '(select SUBSTR(codGruppo,1,4) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
             rec.codMansione || ''' and flgTipo=2)';
    end if;
    where_territorio := where_territorio || ') '; -- chiudo OR clausola mansione
    where_territorio := where_territorio ||
          'and dter.codCom=' || '''' || codComAz || ''') OR ' ||
           'exists (select 1 from pr_mansione, pr_dis_stato ' ||
              ' where (pr_mansione.PRGMANSIONE=pr_dis_stato.PRGMANSIONE) ' ||
            'and pr_mansione.CDNLAVORATORE=app.CDNLAVORATORE ' ||
            'and pr_dis_stato.CODCOM=''Z000'' and ' ||
            '(pr_mansione.CODMANSIONE=''' || rec.codMansione || ''' or ' ||
            'SUBSTR(pr_mansione.codMansione,1,4)=''' || SUBSTR(rec.codMansione,1,4) || ''' ';
    if(numRelMansioni>0) then
     where_territorio := where_territorio ||
             ' or SUBSTR(pr_mansione.codMansione,1,4) in '  ||
             '(select SUBSTR(codGruppo,1,4) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
             rec.codMansione || ''' and flgTipo=2)';
    end if;
    where_territorio := where_territorio || ') '; -- chiudo OR clausola mansione
    where_territorio := where_territorio || ') '; -- chiudo exists
    where_territorio := where_territorio || ') '; -- chiudo territorio
   else
    where_territorio := where_territorio || ' and (';
    -- Esistenza disponibilità per l'intero stato italiano
    where_territorio := where_territorio ||
          'exists (select 1 from pr_mansione, pr_dis_stato ' ||
           ' where (pr_mansione.PRGMANSIONE=pr_dis_stato.PRGMANSIONE) ' ||
         'and pr_mansione.CDNLAVORATORE=app.CDNLAVORATORE ' ||
         'and pr_dis_stato.CODCOM=''Z000'' and ' ||
         '(pr_mansione.CODMANSIONE=''' || rec.codMansione || ''' or ' ||
         'SUBSTR(pr_mansione.codMansione,1,4)=''' || SUBSTR(rec.codMansione,1,4) || ''' ';
    if(numRelMansioni>0) then
     where_territorio := where_territorio ||
             ' or SUBSTR(pr_mansione.codMansione,1,4) in '  ||
             '(select SUBSTR(codGruppo,1,4) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
             rec.codMansione || ''' and flgTipo=2)';
    end if;
    where_territorio := where_territorio || ') '; -- chiudo OR clausola mansione
    where_territorio := where_territorio || ') '; -- chiudo exists
    -- Esistenza disponibilità per i comuni
    if(numComuni>0) then
        where_territorio := where_territorio || ' OR exists(' ||
              'select 1 from VW_PR_DIS_TERRITORIO dter ' ||
             'inner join DO_COMUNE oter on (oter.codCom=dter.codCom) ' ||
             'where dter.cdnLavoratore=app.cdnLavoratore ' ||
             'and oter.prgRichiestaAz=' || p_prgRichiestaAz ||
           ' and (dter.codMansione=''' || rec.codMansione || ''' or ' ||
           'SUBSTR(dter.codMansione,1,4)=''' || SUBSTR(rec.codMansione,1,4) || ''' ';
        if(numRelMansioni>0) then
         where_territorio := where_territorio ||
            ' or SUBSTR(dter.codMansione,1,4) in '  ||
              '(select SUBSTR(codGruppo,1,4) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
              rec.codMansione || ''' and flgTipo=2)';
     end if;
     where_territorio := where_territorio || ') '; -- chiudo OR clausola mansione
     where_territorio := where_territorio || ') '; -- chiudo exists
    end if;
    -- Esistenza disponibilità per le province
    if(numProv>0) then
        where_territorio := where_territorio || ' OR exists(' ||
              'select 1 from VW_PR_DIS_PROVINCIA dter ' ||
             'inner join DO_PROVINCIA oter on (oter.codProvincia=dter.codProvincia) ' ||
             'where dter.cdnLavoratore=app.cdnLavoratore ' ||
             'and oter.prgRichiestaAz=' || p_prgRichiestaAz ||
           ' and (dter.codMansione=''' || rec.codMansione || ''' or ' ||
           'SUBSTR(dter.codMansione,1,4)=''' || SUBSTR(rec.codMansione,1,4) || ''' ';
        if(numRelMansioni>0) then
         where_territorio := where_territorio ||
            ' or SUBSTR(dter.codMansione,1,4) in '  ||
              '(select SUBSTR(codGruppo,1,4) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
              rec.codMansione || ''' and flgTipo=2)';
     end if;
     where_territorio := where_territorio || ') '; -- chiudo OR clausola mansione
     where_territorio := where_territorio || ') '; -- chiudo exists
    end if;
    --
    where_territorio := where_territorio || ') ';
   end if;
  end if;
  */
  -- Fine where_mansione
  where_mansione := where_mansione || ') ';
  where_test := where_test || ') ';
  --where_territorio := where_territorio || ') ';
 END LOOP;
 query_where := query_where || ' and (' || where_mansione || ') ';

 --11/01/2006 - Stefy
 -- Invece dell'intera query di verifica sulle disp. territoriali passo alla seconda funzione solamente
 -- la parte che riguarda la mansione
 where_territorio := where_test;


 -- Abilitazioni (Vengono considerate TUTTE Indispensabili  - condizioni in AND)
 -- Si controllano solamente le patenti di guida
 select count(*) into numAbilitazioni
 from DO_ABILITAZIONE_GEN inner join DE_ABILITAZIONE_GEN on
    (DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN = DE_ABILITAZIONE_GEN.CODABILITAZIONEGEN)
 where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
    and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN<>'PGB'
   and DE_ABILITAZIONE_GEN.CODTIPOABILITAZIONEGEN = 'PG' ;
 --
  select count(*) into patenteB
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN='PGB';
 --
 if(numAbilitazioni>0) then
  query_where := query_where ||
         ' and (' ||
         '(select count(*) from PR_ABILITAZIONE cv_abi ' ||
      'inner join DO_ABILITAZIONE_GEN o_abi on (cv_abi.codAbilitazioneGen = o_abi.codAbilitazioneGen) ' ||
       'inner join DE_ABILITAZIONE_GEN on (o_abi.CODABILITAZIONEGEN = DE_ABILITAZIONE_GEN.CODABILITAZIONEGEN)' ||
      ' where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
      ' DE_ABILITAZIONE_GEN.CODTIPOABILITAZIONEGEN=''PG'' and ' ||
      ' o_abi.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
      ' o_abi.codAbilitazioneGen <> ''PGB'')' ;
  query_where := query_where || ')>=' || numAbilitazioni ||
        ') ';
  end if;
 if(patenteB>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_ABILITAZIONE cv_abi ' ||
       'where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
         '(cv_abi.codAbilitazioneGen = ''PGB'' or cv_abi.codAbilitazioneGen = ''PGC'' or cv_abi.codAbilitazioneGen = ''PGD'') ';
  query_where := query_where || ')) >= 1 ' ||
        ') ';
 end if;
  --query_where := query_where || ' and' || par_impliciti;
  if(p_dataValCv is null) then
    query_where := query_where || ' and' || par_impliciti;
  else
   query_where := query_where || ' and' || par_impliciti_valCV;
  end if;
  query_where := query_where || par_indisponibilita_az;
  query_where:= ltrim(query_where, 'and ');
  p_sql_query := query_select ||
          query_from ||
     query_join || ' where ' ||
     query_where;
   /********************************
 Check dei parametri di Ritorno
 ********************************/
 if(p_out_prgIncrocio is null or p_out_prgRosa is null) then
    rollback;
    return -1;
 end if;
 if(length(query_select)=0 or length(query_from)=0 or length(query_join)=0 or length(query_where)=0) then
    rollback;
    return -1;
 end if;
 -- Preparo i parametri di Output
 p_out_query_select := query_select;
 p_out_query_from := query_from;
 p_out_query_join := query_join;
 p_out_query_where := ' where ' || query_where;
 p_out_where_territorio := where_territorio;
 return 0;
 rollback;
 exception
      when no_data_found then
          null;
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       return -1;
END Matching_Pesato_PEsatti;
-- Funzione che esegue la query per l'incrocio pesato
function eseguiIncrocioPesato(
   p_in_query_select varchar2,
   p_in_query_from varchar2,
   p_in_query_join varchar2,
   p_in_query_where long,
   p_in_where_territorio varchar2,
   p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%type, -- progressivo della richiesta
   p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%type, -- progressivo dell'alternativa
   p_in_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,  -- progressivo dell'incrocio
   p_in_prgRosa DO_ROSA.PRGROSA%TYPE,      -- progressivo della rosa
   p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
   p_mem char,
   p_numPFasciaEtaPrima number,         -- peso associato alla prima fascia di età estesa
   p_numPFasciaEtaSec number,         -- peso associato alla seconda fascia di età estesa
   p_numPStudioGruppo number,         -- peso associato a un titolo di studio nel gruppo
   p_numPStudioAlias number,          -- peso associato a un titolo di studio associato
   p_numPMansioneGruppo number,         -- peso associato a una mansione nel gruppo
   p_numPMansioneAlias number,         -- peso associato a una mansione associata
   p_numPNoEsperienza number,         -- peso associato alla mansione senza esperienza
   p_numPEsperienzaAlias number,         -- peso associato all'esperienza in una mansione simile
   p_numPInfoMin number,           -- peso associato alla conoscenza info con grado minore
   p_numPInfoGruppo number,          -- peso associato a una conoscenza info nello stesso gruppo
   p_numPInfoGruppoMIn number,         -- peso associato a una conoscenza info nello stesso gruppo e grado minore
   p_numPLinguaInf number,           -- peso associato a una conoscenza linguistica con grado minore
   p_numPSogliaRichiesta number,         -- valore di soglia entro il quale estrarre i candidati
   p_flagIncMir int,         -- flag collocamento mirato
   p_checkCM  number,              -- interruttore per il collocamento mirato
   encrypterKey varchar2,
   p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
   p_ErrCode OUT number
   --p_cursor OUT t_cursor
   ) return number  IS
  P_PRGROSAAPPOGGIO number;
  sql_query_cur varchar2(2000) := 'select P_IN_PRGROSA, s_do_nominativo.nextVal, app.CDNLAVORATORE,  ' ||
               'app.NUMPESOETA, app.NUMPESOTITOLO, app.NUMPESOMANSIONE, app.NUMPESOESP, ' ||
          'app.NUMPESOINFO, app.NUMPESOLINGUA, app.DECINDICEVICINANZA ' ||
          'from do_nominativo_appoggio app ' ||
          'where app.PRGROSAAPPOGGIO=';
  -- Tipo del record per la tabella di appoggio debug 1a parte
  /*type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
                strCognomeNome AN_LAVORATORE.STRCOGNOME%TYPE,
       strNome AN_LAVORATORE.STRNOME%type);*/
  --type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type);
  type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
             cpiTit DE_CPI.CODCPI%type,
        numPesoEta DO_NOMINATIVO_APPOGGIO.NUMPESOETA%TYPE,
        numPesoLingua DO_NOMINATIVO_APPOGGIO.NUMPESOLINGUA%type,
        numPesoInfo DO_NOMINATIVO_APPOGGIO.NUMPESOINFO%type,
        numPesoTitolo DO_NOMINATIVO_APPOGGIO.NUMPESOTITOLO%type,
        numPesoMansione DO_NOMINATIVO_APPOGGIO.NUMPESOMANSIONE%type,
        numPesoEsp DO_NOMINATIVO_APPOGGIO.NUMPESOESP%type,
        decIndiceVicinanza DO_NOMINATIVO_APPOGGIO.DECINDICEVICINANZA%type);
  type tab_ris is table of p_rec_ris;
  p_tab_ris tab_ris;
  -- Tipo del record per la tabella di appoggio debug 2a parte
  type t_app_rec is record ( cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
                 strCognome AN_LAVORATORE.STRCOGNOME%type,
        strNome AN_LAVORATORE.STRNOME%type,
        cpiTit DE_CPI.CODCPI%type,
        numPesoEta DO_NOMINATIVO_APPOGGIO.NUMPESOETA%TYPE,
        numPesoLingua DO_NOMINATIVO_APPOGGIO.NUMPESOLINGUA%type,
        numPesoInfo DO_NOMINATIVO_APPOGGIO.NUMPESOINFO%type,
        numPesoTitolo DO_NOMINATIVO_APPOGGIO.NUMPESOTITOLO%type,
        numPesoMansione DO_NOMINATIVO_APPOGGIO.NUMPESOMANSIONE%type,
        numPesoEsp DO_NOMINATIVO_APPOGGIO.NUMPESOESP%type,
        decIndiceVicinanza DO_NOMINATIVO_APPOGGIO.DECINDICEVICINANZA%type);
  type t_tab_app is table of t_app_rec;
  tab_app t_tab_app;
  --------------------------------------------------------------------------------
  sql_query_insert varchar2(4000) := 'select do_nominativo_appoggio.CDNLAVORATORE, ' ||
                 'an_lavoratore.STRCOGNOME, an_lavoratore.STRNOME, ' ||
          'PG_INCROCIO.PDCPITIT(do_nominativo_appoggio.CDNLAVORATORE), ' ||
          'do_nominativo_appoggio.NUMPESOLINGUA, ' ||
          'do_nominativo_appoggio.NUMPESOINFO, ' ||
          'do_nominativo_appoggio.NUMPESOTITOLO, ' ||
          'do_nominativo_appoggio.NUMPESOMANSIONE, ' ||
          'do_nominativo_appoggio.NUMPESOESP, ' ||
          'do_nominativo_appoggio.DECINDICEVICINANZA ' ||
          'from DO_NOMINATIVO_APPOGGIO ' ||
          'inner join an_lavoratore on (do_nominativo_appoggio.cdnLavoratore=an_lavoratore.cdnLavoratore) ' ||
          'where do_nominativo_appoggio.PRGROSAAPPOGGIO = ';
  --////////////////////////////////////////////////////////////////////--
  sql_query long;
  rCpiTit DE_CPI.CODCPI%type;

  numConLinguistiche number;
  numConLinIta number;
  numConInformatiche number;
  numTitoli number;
  numMansioni number;
  numRelMansioni number;
  nroCpi number;
  --numCompetenze number;
  --numAbilitazioni number;
  parEsperienza DO_ALTERNATIVA.FLGESPERIENZA%type;
  strPesaMansione varchar2(8000);
  -- Cursori
  CURSOR curTitoli IS
     select DO_STUDIO.CODTITOLO, DO_STUDIO.FLGINDISPENSABILE, DO_STUDIO.FLGCONSEGUITO
   from DO_STUDIO
   where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
 CURSOR curMansioni IS
     select DO_MANSIONE.codMansione from DO_MANSIONE
   where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_MANSIONE.PRGALTERNATIVA = p_prgAlternativa;
 CURSOR curTurni IS
     select DO_TURNO.CODTURNO from DO_TURNO where DO_TURNO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curOrari IS
     select DO_ORARIO.CODORARIO from DO_ORARIO where DO_ORARIO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curContratti IS
     select DO_CONTRATTO.CODCONTRATTO from DO_CONTRATTO
   where DO_CONTRATTO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_CONTRATTO.PRGALTERNATIVA = p_prgAlternativa;
  -- Clausole IN
  inTurni varchar2(2000) := '';
  inOrari varchar2(2000) := '';
  inContratti varchar2(2000) := '';

  numComuni number;
  numProv number;
BEGIN
  ---------------------------------------------------------------------------------------
  select S_DO_NOMINATIVO_APPOGGIO_2.nextVal into P_PRGROSAAPPOGGIO from dual;
  sql_query_cur := sql_query_cur || P_PRGROSAAPPOGGIO || ' and app.DECINDICEVICINANZA>=' || p_numPSogliaRichiesta;

  sql_query :=   'insert into global_rosa ' ||
       P_IN_QUERY_SELECT ||
     P_IN_QUERY_FROM ||
     P_IN_QUERY_JOIN ||
     P_IN_QUERY_WHERE;
  execute immediate sql_query;
  --
  insert into DO_NOMINATIVO_APPOGGIO
  (prgRosaAppoggio, prgNominativo, prgRosa, cdnLavoratore, codCpiTit)
  select
    P_PRGROSAAPPOGGIO, S_DO_NOMINATIVO_APPOGGIO.nextVal, P_IN_PRGROSA,
  global_rosa.cdnLavoratore, PG_INCROCIO.PDCPITIT(global_rosa.cdnLavoratore)
  from global_rosa;
  -- NEW --
  commit;

  -- Popolo la stringa con l'insieme dei codici dei turni
 FOR rec in curTurni LOOP
  if(length(inTurni)>0) then
     inTurni := inTurni ||',';
  end if;
  inTurni := inTurni || '''' || rec.codTurno || '''';
 END LOOP;
 dbms_output.put_line('Turni IN (' || inTurni || ')');
 -- Popolo la stringa con l'insieme dei codici degli orari
 FOR rec in curOrari LOOP
  if(length(inOrari)>0) then
     inOrari := inOrari ||',';
  end if;
  inOrari:= inOrari || '''' || rec.codOrario || '''';
 END LOOP;
 dbms_output.put_line('Orari IN (' || inOrari || ')');
 -- Popolo la stringa con l'insieme dei codici dei contratti
 if(p_prgAlternativa is not null) then
  FOR rec in curContratti LOOP
   if(length(inContratti)>0) then
      inContratti := inContratti ||',';
   end if;
   inContratti:= inContratti || '''' || rec.codContratto || '''';
  END LOOP;
 end if;
 dbms_output.put_line('Contratti IN (' || inContratti || ')');
 -- Parametro sull'esperienza
 select DO_ALTERNATIVA.FLGESPERIENZA into parEsperienza
 from DO_ALTERNATIVA
 where DO_ALTERNATIVA.PRGRICHIESTAAZ=p_prgRichiestaAz and DO_ALTERNATIVA.PRGALTERNATIVA=p_prgAlternativa;
  /********************************************************************
  *      PESATURA DEI PARAMETRI SUI CANDIDATI SELEZIONATI          *
  *********************************************************************/
  -- NOTA: flgIndispensabile non piu' utilizzato
  -----------------------------------------------------------------------
  -- CONOSCENZE LINGUISTICHE (Indispensabili - condizioni in AND)
  select count(*) into numConLinguistiche
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ
  and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa; --and DO_LINGUA.FLGINDISPENSABILE='S';
  --
  select count(*) into numConLinIta
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ
  and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
  and DO_LINGUA.CODLINGUA='003';
  -- 0. Se non vengono richieste Conoscenze Linguistiche p=100 per tutti
  if(numConLinguistiche=0) then
  update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=100 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOLINGUA is null;
  end if;
  -- 1. Matching esatto e livello maggiore o uguale a quello richiesto
  if(numConLinguistiche>0) then
     if(numConLinIta = 0) then
   -- Non è richiesta la conoscenza della lingua Italiana
  update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=100
  where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
  (select app.cdnLavoratore
   from DO_NOMINATIVO_APPOGGIO app
       inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
   where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
       (select count(*) from PR_LINGUA cv_lin
     inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua and
               nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and
           nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and
           nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1))
     where (cv_lin.cdnLavoratore = app.cdnLavoratore
       and o_lin.prgRichiestaAz=p_prgRichiestaAz
     and o_lin.prgAlternativa=p_prgAlternativa
     --and o_lin.flgIndispensabile='S'
     )
     ) >= numConLinguistiche
   );
     else
   -- E' richiesta la conoscenza della lingua Italiana
     if(numConLinguistiche=1) then
      -- E' richiesta la SOLA conoscenza della lingua Italiana
   update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=100
   where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
   (select app.cdnLavoratore
    from DO_NOMINATIVO_APPOGGIO app
         inner join an_lavoratore an on (app.cdnLavoratore=an.CDNLAVORATORE)
        --inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
    where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
       (
      (select count(*) from PR_LINGUA cv_lin
      inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua and
                nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and
            nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and
            nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1))
      where (cv_lin.cdnLavoratore = app.cdnLavoratore
        and o_lin.prgRichiestaAz=p_prgRichiestaAz
      and o_lin.prgAlternativa=p_prgAlternativa
      --and o_lin.flgIndispensabile='S'
      --and o_lin.codLingua='4'
      )
      ) >= numConLinguistiche
      OR
      (an.codCittadinanza='000' or an.codCittadinanza2='000')
     )
    );
  else
   update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=100
   where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
   (select app.cdnLavoratore
    from DO_NOMINATIVO_APPOGGIO app
         inner join an_lavoratore an on (app.cdnLavoratore=an.CDNLAVORATORE)
        inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
    where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
       (
      (select count(*) from PR_LINGUA cv_lin
      inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua and
                nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and
            nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and
            nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1))
      where (cv_lin.cdnLavoratore = app.cdnLavoratore
        and o_lin.prgRichiestaAz=p_prgRichiestaAz
      and o_lin.prgAlternativa=p_prgAlternativa
      --and o_lin.flgIndispensabile='S'
      )
      ) >= numConLinguistiche
      OR
      (select count(*) from PR_LINGUA cv_lin
      inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua and
                nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and
            nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and
            nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1))
      where (cv_lin.cdnLavoratore = app.cdnLavoratore
        and o_lin.prgRichiestaAz=p_prgRichiestaAz
      and o_lin.prgAlternativa=p_prgAlternativa
      --and o_lin.flgIndispensabile='S'
      and o_lin.codLingua<>'003'
      and (an.codCittadinanza='000' or an.codCittadinanza2='000')
      )
      ) >= (numConLinguistiche - numConLinIta)
    )
    );
  end if;
  end if;
  end if;
  -- 2. Matching esatto e livello inferiore a quello richiesto
  if(numConLinguistiche>0 and p_numPLinguaInf>0) then
     if(numConLinIta=0) then
     -- Non è richiesta la conoscenza della lingua Italiana
  update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=p_numPLinguaInf
  where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
  (select app.cdnLavoratore
   from DO_NOMINATIVO_APPOGGIO app
       inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
   where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
       (select count(*) from PR_LINGUA cv_lin
     inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua)
     where (cv_lin.cdnLavoratore = app.cdnLavoratore
       and o_lin.prgRichiestaAz=p_prgRichiestaAz
     and o_lin.prgAlternativa=p_prgAlternativa
     --and o_lin.flgIndispensabile='S'
     )
     ) >= numConLinguistiche
   );
  else
     -- E' richiesta la conoscenza della lingua Italiana
  if(numConLinguistiche=1) then
     -- E' richiesta la SOLA conoscenza della lingua Italiana
     update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=p_numPLinguaInf
     where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
     (select app.cdnLavoratore
      from DO_NOMINATIVO_APPOGGIO app
       --inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
     inner join an_lavoratore an on (app.cdnLavoratore=an.cdnLavoratore)
    where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
        (
         (select count(*) from PR_LINGUA cv_lin
          inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua)
       where (cv_lin.cdnLavoratore = app.cdnLavoratore
           and o_lin.prgRichiestaAz=p_prgRichiestaAz
         and o_lin.prgAlternativa=p_prgAlternativa
         --and o_lin.flgIndispensabile='S'
        )
         ) >= numConLinguistiche
         OR
       (an.codCittadinanza='000' or an.codCittadinanza2='000')
      )
     );
  else
     update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=p_numPLinguaInf
     where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
        (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
              inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
       where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
          (
         (select count(*) from PR_LINGUA cv_lin
          inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua)
          where (cv_lin.cdnLavoratore = app.cdnLavoratore
            and o_lin.prgRichiestaAz=p_prgRichiestaAz
        and o_lin.prgAlternativa=p_prgAlternativa
        --and o_lin.flgIndispensabile='S'
        )
        ) >= numConLinguistiche
        OR
          (select count(*) from PR_LINGUA cv_lin
         inner join an_lavoratore an on (cv_lin.cdnLavoratore=an.CDNLAVORATORE)
         inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua)
         where (cv_lin.cdnLavoratore = app.cdnLavoratore
             and o_lin.prgRichiestaAz=p_prgRichiestaAz
          and o_lin.prgAlternativa=p_prgAlternativa
          --and o_lin.flgIndispensabile='S'
          and o_lin.codLingua<>'003'
          and (an.codCittadinanza='000' or an.codCittadinanza2='000')
          )
        ) >= (numConLinguistiche - numConLinIta)
            )
        );
  end if;
  end if;
  end if;
  --3. Tutti gli altri vanno messi a zero
  update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=0 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOLINGUA is null;
  commit;
  --
  -- CONOSCENZE INFORMATICHE (Indispensabili e dipendenti dall'alternativa - condizioni in AND)
  select count(*) into numConInformatiche
  from DO_INFO
  where DO_INFO.PRGRICHIESTAAZ = p_prgRichiestaAZ
    and DO_INFO.PRGALTERNATIVA = p_prgAlternativa; -- and DO_INFO.FLGINDISPENSABILE='S';
  -- 0. Se non vengono richieste Conoscenze Informatiche p=100 per tutti
  if(numConInformatiche=0) then
  update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=100 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOINFO is null;
  end if;
  -- 1. Matching esatto e livello maggiore o uguale a quello richiesto
  if(numConInformatiche>0) then
 update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=100
 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
 (select app.cdnLavoratore
  from DO_NOMINATIVO_APPOGGIO app
      inner join PR_INFO on (app.CDNLAVORATORE=PR_INFO.CDNLAVORATORE)
  where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOINFO is null and
      (select count(*) from PR_INFO cv_inf
      inner join DO_INFO o_inf on (cv_inf.codDettInfo = o_inf.codDettInfo and
               cv_inf.codTipoInfo = o_inf.codTipoInfo and
          nvl(cv_inf.cdnGrado,1) >= nvl(o_inf.cdnGrado,1))
     where (cv_inf.cdnLavoratore = app.cdnLavoratore
        and o_inf.prgRichiestaAz=p_prgRichiestaAz
     --and o_inf.flgIndispensabile='S'
     and o_inf.prgAlternativa=p_prgAlternativa)
   ) >= numConInformatiche
 );
  end if;
  --2. Matching esatto e livello minore a quello richiesto
  if(numConInformatiche>0 and p_numPInfoMin>0) then
 update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=p_numPInfoMin
 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
 (select app.cdnLavoratore
  from DO_NOMINATIVO_APPOGGIO app
      inner join PR_INFO on (app.CDNLAVORATORE=PR_INFO.CDNLAVORATORE)
  where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOINFO is null and
      (select count(*) from PR_INFO cv_inf
      inner join DO_INFO o_inf on (cv_inf.codDettInfo = o_inf.codDettInfo and
               cv_inf.codTipoInfo = o_inf.codTipoInfo
          --and nvl(cv_inf.cdnGrado,1) <= nvl(o_inf.cdnGrado,1)
          )
     where (cv_inf.cdnLavoratore = app.cdnLavoratore
        and o_inf.prgRichiestaAz=p_prgRichiestaAz
     --and o_inf.flgIndispensabile='S'
     and o_inf.prgAlternativa=p_prgAlternativa)
   ) >= numConInformatiche
 );
  end if;
  --3. Matching con conoscenze nello stesso gruppo e livello maggiore o uguale a quello richiesto
  if(numConInformatiche>0 and p_numPInfoGruppo>0) then
 update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=p_numPInfoGruppo
 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
 (select app.cdnLavoratore
  from DO_NOMINATIVO_APPOGGIO app
      inner join PR_INFO on (app.CDNLAVORATORE=PR_INFO.CDNLAVORATORE)
  where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOINFO is null and
      (select count(distinct(cv_inf.CODTIPOINFO)) from PR_INFO cv_inf
      inner join DO_INFO o_inf on (cv_inf.codTipoInfo = o_inf.codTipoInfo and
          nvl(cv_inf.cdnGrado,1) >= nvl(o_inf.cdnGrado,1))
     where (cv_inf.cdnLavoratore = app.cdnLavoratore
        and o_inf.prgRichiestaAz=p_prgRichiestaAz
     --and o_inf.flgIndispensabile='S'
     and o_inf.prgAlternativa=p_prgAlternativa)
   ) >= (select count(distinct(DO_INFO.CODTIPOINFO))
        from DO_INFO where prgRichiestaAz = p_prgRichiestaAz
      and prgAlternativa = p_prgAlternativa
      --and flgIndispensabile='S'
      )
 );
  end if;
  --4. Matching con conoscenze nello stesso gruppo e livello minore a quello richiesto
  if(numConInformatiche>0 and p_numPInfoGruppoMin>0) then
 update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=p_numPInfoGruppoMin
 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
 (select app.cdnLavoratore
  from DO_NOMINATIVO_APPOGGIO app
      inner join PR_INFO on (app.CDNLAVORATORE=PR_INFO.CDNLAVORATORE)
  where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOINFO is null and
      (select count(distinct(cv_inf.CODTIPOINFO)) from PR_INFO cv_inf
      inner join DO_INFO o_inf on (cv_inf.codTipoInfo = o_inf.codTipoInfo
          --and nvl(cv_inf.cdnGrado,1) <= nvl(o_inf.cdnGrado,1)
          )
     where (cv_inf.cdnLavoratore = app.cdnLavoratore
        and o_inf.prgRichiestaAz=p_prgRichiestaAz
     --and o_inf.flgIndispensabile='S'
     and o_inf.prgAlternativa=p_prgAlternativa)
   ) >= (select count(distinct(DO_INFO.CODTIPOINFO))
        from DO_INFO where prgRichiestaAz = p_prgRichiestaAz
      and prgAlternativa = p_prgAlternativa
      --and flgIndispensabile='S'
      )
 );
  end if;
  --5. Tutti gli altri vanno messi a zero
  update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=0 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOINFO is null;
  commit;

  -- Titoli di Studio (Indispensabili e dipendenti dall'alternativa - condizioni in OR)
  -- /* Va gestito il raggruppamento xy0000, xyab00, xyabcd */
  select count(*) into numTitoli
  from DO_STUDIO
  where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
  -- 0. Se non vengono richiesti Titoli p=100 per tutti
  if(numTitoli=0) then
  update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOTITOLO is null;
  end if;
  -- 1. Per ogni titolo presente nella richiesta attribuisco al candidato il valore massimo
  -- fra quelli che gli verrebbero attribuiti dai diversi titoli di studio che ha indicato nel CV.
  if(numTitoli>0) then
 FOR rec IN curTitoli LOOP

  if(substr(rec.codTitolo,-7)='0000000') then
     -- Il titolo è di tipo X0000000 => p=100 per tutti i titoli che iniziano per XY
     if(rec.flgConseguito='S' or rec.flgConseguito is null) then
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,1)=substr(rec.codTitolo,1,1)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO='C'
       );
     else
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,1)=substr(rec.codTitolo,1,1)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO in ('C','I','A')
       );
     end if;
  end if;
  if(substr(rec.codTitolo,-6)='000000') then
     -- Il titolo è di tipo XY000000 => p=100 per tutti i titoli che iniziano per XY
     if(rec.flgConseguito='S' or rec.flgConseguito is null) then
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,2)=substr(rec.codTitolo,1,2)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO='C'
       );
     else
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,2)=substr(rec.codTitolo,1,2)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO in ('C','I','A')
       );
     end if;
  end if;
  if(substr(rec.codTitolo,-5)='00000') then
     -- Il titolo è di tipo XYA00000 => p=100 per tutti i titoli che iniziano per XY
     if(rec.flgConseguito='S' or rec.flgConseguito is null) then
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,3)=substr(rec.codTitolo,1,3)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO='C'
       );
     else
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,3)=substr(rec.codTitolo,1,3)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO in ('C','I','A')
       );
     end if;
  end if;
  if(substr(rec.codTitolo,-3)='000') then
     -- Il titolo è di tipo XYABC000 => p=100 per tutti i titoli che iniziano per XY
     if(rec.flgConseguito='S' or rec.flgConseguito is null) then
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,5)=substr(rec.codTitolo,1,5)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO='C'
       );
     else
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,5)=substr(rec.codTitolo,1,5)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO in ('C','I','A')
       );
     end if;
  end if;
  if(substr(rec.codTitolo,-3)<>'000' and substr(rec.codTitolo,-5)<>'00000' and substr(rec.codTitolo,-6)<>'000000' and substr(rec.codTitolo,-7)<>'0000000') then
     -- Il titolo è di tipo XYABCDEF => Eseguo la pesatura vera e propria
     -- a. p=100 per tutti i titoli con corrispondenza esatta
     if(rec.flgConseguito='S' or rec.flgConseguito is null) then
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and pr_studio.CODTITOLO=rec.codTitolo
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO='C'
       );
     else
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and pr_studio.CODTITOLO=rec.codTitolo
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO in ('C','I','A')
       );
     end if;


   -- b. p=p_numPStudioGruppo
   if(p_numPStudioGruppo>0) then
    if(rec.flgConseguito='S' or rec.flgConseguito is null) then
       update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=p_numPStudioGruppo
       where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
          (select app.cdnLavoratore
        from DO_NOMINATIVO_APPOGGIO app
             inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
        where
            (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<p_numPStudioGruppo)
          and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
          and pr_studio.CODMONOSTATO='C'
          and pr_studio.CODTITOLO in (select codTitoloSimile from DE_REL_TITOLO
                          where de_rel_titolo.CODTITOLO=rec.codTitolo
                       and de_rel_titolo.FLGTIPO=1
                )
        );
    else
       update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=p_numPStudioGruppo
       where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
          (select app.cdnLavoratore
        from DO_NOMINATIVO_APPOGGIO app
             inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
        where
            (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<p_numPStudioGruppo)
          and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
          and pr_studio.CODMONOSTATO in ('C','I','A')
          and pr_studio.CODTITOLO in (select codTitoloSimile from DE_REL_TITOLO
                          where de_rel_titolo.CODTITOLO=rec.codTitolo
                       and de_rel_titolo.FLGTIPO=1
                )
        );
    end if;
   end if;
   -- c. p=p_numPStudioAlias
   if(p_numPStudioAlias>0) then
    if(rec.flgConseguito='S' or rec.flgConseguito is null) then
       update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=p_numPStudioAlias
       where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
          (select app.cdnLavoratore
        from DO_NOMINATIVO_APPOGGIO app
             inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
        where
            (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<p_numPStudioAlias)
          and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
          and pr_studio.CODMONOSTATO='C'
          and pr_studio.CODTITOLO in (select codTitoloSimile from DE_REL_TITOLO
                          where de_rel_titolo.CODTITOLO=rec.codTitolo
                       and de_rel_titolo.FLGTIPO=2
                )
        );
    else
       update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=p_numPStudioAlias
       where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
          (select app.cdnLavoratore
        from DO_NOMINATIVO_APPOGGIO app
             inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
        where
            (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<p_numPStudioAlias)
          and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
          and pr_studio.CODMONOSTATO in ('C','I','A')
          and pr_studio.CODTITOLO in (select codTitoloSimile from DE_REL_TITOLO
                          where de_rel_titolo.CODTITOLO=rec.codTitolo
                       and de_rel_titolo.FLGTIPO=2
                )
        );
    end if;
   end if;
  end if;
 END LOOP;
  end if;
  --2. Tutti gli altri vanno messi a zero
  update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=0 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOTITOLO is null;
  commit;

  --*******************************************
  -- MANSIONE ED ESPERIENZA SULLA MANSIONE
  --*******************************************
  select count(DO_MANSIONE.codMansione) into numMansioni
  from DO_MANSIONE where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;
  -- 0. se non sono richieste mansioni p=100 per tutti
  -- caso teorico, non si dovrebbe mai arrivare a questo punto se non ci sono mansioni nella richiesta
  if(numMansioni=0) then
    update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=100
 where prgRosaAppoggio=P_PRGROSAAPPOGGIO and NUMPESOMANSIONE is null and NUMPESOESP is null;
  end if;
  dbms_output.put_line(numMansioni || ' Mansioni Richieste');
  -- 1. Per ogni mansione presente nella richiesta attribuisco al candidato il valore masimo
  -- fra quelli che gli verrebbero attribuiti dalle diverse mansioni indicate nel cv.
  if(numMansioni>0) then
     FOR rec in curMansioni LOOP
        --09/2012 Pegoraro
        --Non esistendo più i grandi gruppi generici (XY.00.00) di mansioni
        --non viene più previsto il caso di corrispondenza della mansione sui primi due digit

        /* if(substr(rec.codMansione,-4)='0000') then
         -- La mansione è di tipo XY0000 => p=100 per tutte le mansioni che iniziano per XY
            -- a. soggetti con corrispondenza esatta per l'esperienza -- se richiesta
            strPesaMansione :=
         'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=100 ' ||
         'where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
           '(select app.cdnLavoratore ' ||
          'from DO_NOMINATIVO_APPOGGIO app ' ||
             'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
            'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
            'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
            'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
          'where ' ||
             '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
            'and substr(pr_mansione.CODMANSIONE,1,2)=substr(''' || rec.codMansione || ''',1,2) ' ||
            'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;
         if(parEsperienza='S' or parEsperienza='P') then
            strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGESPERIENZA=''S'' OR pr_mansione.FLGESPERIENZA=''E'') ';
         end if;

         if (p_checkcm = 0) then
            strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE=''S'') ';
         else
            strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE=''S'' OR pr_mansione.FLGDISPONIBILE=''P'') ';
         end if;

         if(length(inTurni)>0) then
            strPesaMansione := strPesaMansione ||
              ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
             ' (not exists(select * from PR_DIS_TURNO ' ||
             'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
             'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
             rec.codMansione || ''',1,2) ' ||
             ')))';
         end if;
         if(length(inOrari)>0) then
            strPesaMansione := strPesaMansione ||
              ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
             ' (not exists(select * from PR_DIS_ORARIO ' ||
             'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
             'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
             rec.codMansione || ''',1,2) ' ||
             ')))';
         end if;
         if(length(inContratti)>0) then
            strPesaMansione := strPesaMansione ||
              ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
             ' (not exists(select * from PR_DIS_CONTRATTO ' ||
             'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
             'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
             'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
             'pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
             rec.codMansione || ''',1,2) ' ||
             ')))';
         end if;
         strPesaMansione := strPesaMansione || ') ';
         execute immediate strPesaMansione;
         -- b. soggetti senza esperienza -- se richiesta
         if((parEsperienza='S' or parEsperienza='P') and p_numPNoEsperienza>0) then
            strPesaMansione :=
          'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=' || p_numPNoEsperienza ||
          ' where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
            '(select app.cdnLavoratore ' ||
           'from DO_NOMINATIVO_APPOGGIO app ' ||
              'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
             'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
             'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
             'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
           'where ' ||
              '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
             'and (app.NUMPESOESP is null or app.NUMPESOESP <' || p_numPNoEsperienza || ') ' ||
             'and substr(pr_mansione.CODMANSIONE,1,2)=substr(''' || rec.codMansione || ''',1,2) ' ||
             'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;

             if (p_checkcm = 0) then
                strPesaMansione := strPesaMansione || 'and (pr_mansione.FLGDISPONIBILE=''S'') ';
             else
                strPesaMansione := strPesaMansione || 'and (pr_mansione.FLGDISPONIBILE=''S'' OR pr_mansione.FLGDISPONIBILE=''P'') ';
             end if;

          if(length(inTurni)>0) then
             strPesaMansione := strPesaMansione ||
               ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
              ' (not exists(select * from PR_DIS_TURNO ' ||
              'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
              'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
              rec.codMansione || ''',1,2) ' ||
              ')))';
          end if;
          if(length(inOrari)>0) then
             strPesaMansione := strPesaMansione ||
               ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
              ' (not exists(select * from PR_DIS_ORARIO ' ||
              'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
              'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
              rec.codMansione || ''',1,2) ' ||
              ')))';
          end if;
          if(length(inContratti)>0) then
             strPesaMansione := strPesaMansione ||
               ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
              ' (not exists(select * from PR_DIS_CONTRATTO ' ||
              'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
              'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
              'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
              'pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
              rec.codMansione || ''',1,2) ' ||
              ')))';
          end if;
          strPesaMansione := strPesaMansione || ') ';
          execute immediate strPesaMansione;
         end if;
      end if; -- if(substr(rec.codMansione,-4)='0000')*/
      if(substr(rec.codMansione,-2)='00' ) then
         -- La mansione è di tipo XYAB00 => p=100 per tutte le mansioni che iniziano per XYAB
            -- a. soggetti con corrispondenza esatta per l'esperienza -- se richiesta
            strPesaMansione :=
         'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=100 ' ||
         'where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
           '(select app.cdnLavoratore ' ||
          'from DO_NOMINATIVO_APPOGGIO app ' ||
             'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
            'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
            'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
            'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
          'where ' ||
             '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
            'and substr(pr_mansione.CODMANSIONE,1,5)=substr(''' || rec.codMansione || ''',1,5) ' ||
            'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;
         if(parEsperienza='S' or parEsperienza='P') then
            strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGESPERIENZA=''S'' OR pr_mansione.FLGESPERIENZA=''E'') ';
         end if;
         if (p_checkcm = 0) then
            strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE=''S'') ';
         else
            strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE  IN (''S'', ''P'') ) ';
         end if;
         if(length(inTurni)>0) then
            strPesaMansione := strPesaMansione ||
              ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
             ' (not exists(select * from PR_DIS_TURNO ' ||
             'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
             'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
             rec.codMansione || ''',1,5) ' ||
             ')))';
         end if;
         if(length(inOrari)>0) then
            strPesaMansione := strPesaMansione ||
              ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
             ' (not exists(select * from PR_DIS_ORARIO ' ||
             'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
             'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
             rec.codMansione || ''',1,5) ' ||
             ')))';
         end if;
         if(length(inContratti)>0) then
            strPesaMansione := strPesaMansione ||
              ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
             ' (not exists(select * from PR_DIS_CONTRATTO ' ||
             'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
             'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
             'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
             ' pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
             rec.codMansione || ''',1,5) ' ||
             ')))';
         end if;
         strPesaMansione := strPesaMansione || ') ';
         execute immediate strPesaMansione;
         -- b. soggetti senza esperienza -- se richiesta
         if((parEsperienza='S' or parEsperienza='P') and p_numPNoEsperienza>0) then
            strPesaMansione :=
          'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=' || p_numPNoEsperienza ||
          ' where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
            '(select app.cdnLavoratore ' ||
           'from DO_NOMINATIVO_APPOGGIO app ' ||
              'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
             'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
             'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
             'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
           'where ' ||
              '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
             'and (app.NUMPESOESP is null or app.NUMPESOESP <' || p_numPNoEsperienza || ') ' ||
             'and substr(pr_mansione.CODMANSIONE,1,5)=substr(''' || rec.codMansione || ''',1,5) ' ||

             'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;

          if (p_checkcm = 0) then
             strPesaMansione := strPesaMansione || 'and (pr_mansione.FLGDISPONIBILE=''S'') ';
          else
             strPesaMansione := strPesaMansione || 'and (pr_mansione.FLGDISPONIBILE  IN (''S'', ''P'') ) ';
          end if;
          if(length(inTurni)>0) then
             strPesaMansione := strPesaMansione ||
               ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
              ' (not exists(select * from PR_DIS_TURNO ' ||
              'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
              'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
              rec.codMansione || ''',1,5) ' ||
              ')))';
          end if;
          if(length(inOrari)>0) then
             strPesaMansione := strPesaMansione ||
               ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
              ' (not exists(select * from PR_DIS_ORARIO ' ||
              'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
              'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
              rec.codMansione || ''',1,5) ' ||
              ')))';
          end if;
          if(length(inContratti)>0) then
             strPesaMansione := strPesaMansione ||
               ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
              ' (not exists(select * from PR_DIS_CONTRATTO ' ||
              'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
              'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
              'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
              'pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
              rec.codMansione || ''',1,5) ' ||
              ')))';
          end if;
          strPesaMansione := strPesaMansione || ') ';
          execute immediate strPesaMansione;
         end if;
      end if; --if(substr(rec.codMansione,-2)='00' and substr(rec.codMansione,-4)<>'0000')
      if(substr(rec.codMansione,-2)<>'00') then
         -- La mansione è di tipo XYABCD => eseguo la pesatura vera e propria
         -- a. soggetti con corrispondenza esatta per l'esperienza -- se richiesta
            strPesaMansione :=
         'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=100 ' ||
         'where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
           '(select app.cdnLavoratore ' ||
          'from DO_NOMINATIVO_APPOGGIO app ' ||
             'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
            'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
            'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
            'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
          'where ' ||
             '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
            'and pr_mansione.CODMANSIONE=''' || rec.codMansione || ''' ' ||
            'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;
         if(parEsperienza='S' or parEsperienza='P') then
            strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGESPERIENZA=''S'' OR pr_mansione.FLGESPERIENZA=''E'') ';
         end if;
         if (p_checkcm = 0) then
            strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE=''S'') ';
         else
            strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE  IN (''S'', ''P'') ) ';
         end if;
         if(length(inTurni)>0) then
            strPesaMansione := strPesaMansione ||
              ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
             ' (not exists(select * from PR_DIS_TURNO ' ||
             'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
             'where pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
             rec.codMansione || '''))) ';
         end if;
         if(length(inOrari)>0) then
            strPesaMansione := strPesaMansione ||
              ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
             ' (not exists(select * from PR_DIS_ORARIO ' ||
             'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
             'where pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
             rec.codMansione || ''')))';
         end if;
         if(length(inContratti)>0) then
            strPesaMansione := strPesaMansione ||
              ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
             ' (not exists(select * from PR_DIS_CONTRATTO ' ||
             'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
             'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
             'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
             'pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
             rec.codMansione || ''')))';
         end if;
         strPesaMansione := strPesaMansione || ') ';
         execute immediate strPesaMansione;
         -- b. soggetti senza esperienza -- se richiesta
         if((parEsperienza='S' or parEsperienza='P') and p_numPNoEsperienza>0) then
            strPesaMansione :=
          'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=' || p_numPNoEsperienza ||
          ' where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
            '(select app.cdnLavoratore ' ||
           'from DO_NOMINATIVO_APPOGGIO app ' ||
              'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
             'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
             'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
             'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
           'where ' ||
              '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
             'and (app.NUMPESOESP is null or app.NUMPESOESP <' || p_numPNoEsperienza || ') ' ||
             'and pr_mansione.CODMANSIONE=''' || rec.codMansione || ''' ' ||
             'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;

          if (p_checkcm = 0) then
             strPesaMansione := strPesaMansione || 'and (pr_mansione.FLGDISPONIBILE=''S'') ';
          else
             strPesaMansione := strPesaMansione || 'and (pr_mansione.FLGDISPONIBILE IN (''S'', ''P'') ) ';
          end if;
          if(length(inTurni)>0) then
             strPesaMansione := strPesaMansione ||
               ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
              ' (not exists(select * from PR_DIS_TURNO ' ||
              'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
              'where pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
              rec.codMansione || ''')))';
          end if;
          if(length(inOrari)>0) then
             strPesaMansione := strPesaMansione ||
               ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
              ' (not exists(select * from PR_DIS_ORARIO ' ||
              'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
              'where pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
              rec.codMansione || ''')))';
          end if;
          if(length(inContratti)>0) then
             strPesaMansione := strPesaMansione ||
               ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
              ' (not exists(select * from PR_DIS_CONTRATTO ' ||
              'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
              'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
              'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
              'pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
              rec.codMansione || ''')))';
          end if;
          strPesaMansione := strPesaMansione || ') ';
          execute immediate strPesaMansione;
         end if;
         -- c. mansione nel gruppo ed esperienza pesata
         if(p_numPMansioneGruppo>0 and p_numPEsperienzaAlias>0) then
          strPesaMansione :=
           'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=' ||
           p_numPMansioneGruppo ||' , NUMPESOESP=' || p_numPEsperienzaAlias ||
           ' where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
             '(select app.cdnLavoratore ' ||
            'from DO_NOMINATIVO_APPOGGIO app ' ||
               'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
              'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
              'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
              'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
            'where ' ||
               '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<' || p_numPMansioneGruppo ||') ' ||
              'and (app.NUMPESOESP is null or app.NUMPESOESP <' || p_numPEsperienzaAlias || ') ' ||
              'and substr(pr_mansione.CODMANSIONE,1,5)=''' || substr(rec.codMansione,1,5) || ''' ' ||
              'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;
          if(parEsperienza='S' or parEsperienza='P') then
                strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGESPERIENZA=''S'' OR pr_mansione.FLGESPERIENZA=''E'') ';
          end if;
          if (p_checkcm = 0) then
             strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE=''S'') ';
          else
             strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE IN (''S'', ''P'') ) ';
          end if;
          if(length(inTurni)>0) then
              strPesaMansione := strPesaMansione ||
                ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
               ' (not exists(select * from PR_DIS_TURNO ' ||
               'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
               'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=''' ||
               substr(rec.codMansione,1,5) || ''')))';
          end if;
          if(length(inOrari)>0) then
              strPesaMansione := strPesaMansione ||
                ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
               ' (not exists(select * from PR_DIS_ORARIO ' ||
               'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
               'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=''' ||
               substr(rec.codMansione,1,5) || ''')))';
           end if;
           if(length(inContratti)>0) then
              strPesaMansione := strPesaMansione ||
                ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
               ' (not exists(select * from PR_DIS_CONTRATTO ' ||
               'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
               'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
               'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
               'pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=''' ||
               substr(rec.codMansione,1,5) || ''')))';
           end if;
           strPesaMansione := strPesaMansione || ') ';
           execute immediate strPesaMansione;
          end if;
          -- d. mansione simile ed esperienza pesata
          if(p_numPMansioneAlias>0 and p_numPEsperienzaAlias>0) then
           strPesaMansione :=
           'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=' ||
           p_numPMansioneAlias ||' , NUMPESOESP=' || p_numPEsperienzaAlias ||
           ' where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
             '(select app.cdnLavoratore ' ||
            'from DO_NOMINATIVO_APPOGGIO app ' ||
               'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
              'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
              'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
              'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
            'where ' ||
               '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<' || p_numPMansioneAlias ||') ' ||
              'and (app.NUMPESOESP is null or app.NUMPESOESP <' || p_numPEsperienzaAlias || ') ' ||
              'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;
          if(parEsperienza='S' or parEsperienza='P') then
                strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGESPERIENZA=''S'' OR pr_mansione.FLGESPERIENZA=''E'') ';
          end if;
          if (p_checkcm = 0) then
             strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE=''S'') ';
          else
             strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE IN (''S'', ''P'') ) ';
          end if;
          select count(*) into numRelMansioni
          from DE_REL_MANSIONE
          where de_rel_mansione.codMansione=rec.codMansione and flgTipo=2;
          if(numRelMansioni>0) then
          strPesaMansione := strPesaMansione ||
               'and SUBSTR(pr_mansione.codMansione,1,5) in '  ||
               '(select SUBSTR(codGruppo,1,5) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
               rec.codMansione || ''' and flgTipo=2)';
          end if;
          if(length(inTurni)>0) then
              strPesaMansione := strPesaMansione ||
                ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) ';
           if(numRelMansioni>0) then
             strPesaMansione := strPesaMansione || ' or ' ||
               ' (not exists(select * from PR_DIS_TURNO ' ||
               'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
               'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)  in ' ||
                  '(select SUBSTR(codGruppo,1,5) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
                  rec.codMansione || ''' and flgTipo=2)' || '))';
            end if;
            strPesaMansione := strPesaMansione || ')';
          end if;
          if(length(inOrari)>0) then
              strPesaMansione := strPesaMansione ||
                ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) ';
           if(numRelMansioni>0) then
             strPesaMansione := strPesaMansione || ' or ' ||
               ' (not exists(select * from PR_DIS_ORARIO ' ||
               'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
               'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5) in ' ||
                  '(select SUBSTR(codGruppo,1,5) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
                  rec.codMansione || ''' and flgTipo=2)' || '))';
            end if;
            strPesaMansione := strPesaMansione || ')';
          end if;
          if(length(inContratti)>0) then
              strPesaMansione := strPesaMansione ||
                ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) ';
           if(numRelMansioni>0) then
             strPesaMansione := strPesaMansione || ' or ' ||
               ' (not exists(select * from PR_DIS_CONTRATTO ' ||
               'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
               'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
               'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
               'pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5) in ' ||
               '(select SUBSTR(codGruppo,1,5) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
                  rec.codMansione || ''' and flgTipo=2)' || '))';
            end if;
            strPesaMansione := strPesaMansione || ')';
          end if;
          strPesaMansione := strPesaMansione || ') ';
          execute immediate strPesaMansione;
       end if;
      end if;--if(substr(rec.codMansione,-4)<>'0000')
  END LOOP;
  end if;

  -- 2. Tutti gli altri vanno messi a zero
  update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=0, NUMPESOESP=0
  where prgRosaAppoggio=P_PRGROSAAPPOGGIO and NUMPESOMANSIONE is null and NUMPESOESP is null;
  commit;

  -- Il peso sull'età è al momento sospeso
  /*update DO_NOMINATIVO_APPOGGIO
  set decIndiceVicinanza = ((numPesoEta + numPesoTitolo + numPesoMansione + numPesoEsp+ numPesoInfo + numPesoLingua) / 6.0)
  where prgRosaAppoggio=P_PRGROSAAPPOGGIO;*/

  -- Calcolo l'indice di vicinanza
  update DO_NOMINATIVO_APPOGGIO
  set decIndiceVicinanza = ((numPesoTitolo + numPesoMansione + numPesoEsp+ numPesoInfo + numPesoLingua) / 5.0)
  where prgRosaAppoggio=P_PRGROSAAPPOGGIO;
  commit;


  -- 11/01/2006 - Stefy
  -- Il calcolo relativo alla disponibilità territoriale avviene in base ad una nuova funzione
  -- che non fa più uso della vista VW_PR_DIS_TERRITORIO
  /*
  sql_query := 'update DO_NOMINATIVO_APPOGGIO set NUMT=1 ' ||
      'where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO ||
      'and cdnLavoratore in ' ||
        '(select app.cdnLavoratore from DO_NOMINATIVO_APPOGGIO app ' ||
        'inner join PR_MANSIONE prm on (app.CDNLAVORATORE=prm.CDNLAVORATORE) ' ||
        'where app.prgRosaAppoggio=' || P_PRGROSAAPPOGGIO ||
        ' and app.NUMT is null and ' ||
     p_in_where_territorio ||
     ')';
  execute immediate sql_query;
  */
  select count(*) into numComuni from DO_COMUNE where DO_COMUNE.PRGRICHIESTAAZ = p_prgRichiestaAz;
  select count(*) into numProv from DO_PROVINCIA where DO_PROVINCIA.PRGRICHIESTAAZ = p_prgRichiestaAz;

  update DO_NOMINATIVO_APPOGGIO set NUMT=PG_INCROCIO.PDCALCOLONUMT(DO_NOMINATIVO_APPOGGIO.CDNLAVORATORE,p_prgRichiestaAz,p_in_where_territorio,numComuni,numProv)
  where prgRosaAppoggio = P_PRGROSAAPPOGGIO and numt is null;

  if(p_mem=1) then
   -- Memorizzo in locale
 sql_query := 'select distinct app.CDNLAVORATORE,  app.CODCPITIT, ' ||
        'app.NUMPESOETA, app.NUMPESOLINGUA, app.NUMPESOINFO, ' ||
        'app.NUMPESOTITOLO, app.NUMPESOMANSIONE, app.NUMPESOESP, ' ||
        'app.DECINDICEVICINANZA ' ||
     'from do_nominativo_appoggio app, pr_mansione prm ' ||
     'where (app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO || ') ' ||
       ' and (app.CDNLAVORATORE=prm.CDNLAVORATORE) ' ||
       'and (app.DECINDICEVICINANZA>=' || p_numPSogliaRichiesta || ') ' ||
       'and app.NUMT=1';
 execute immediate sql_query bulk collect into p_tab_ris;
 --dbms_output.put_line('Candidati selezionati ' ||p_tab_ris.COUNT);
 -- Memorizzo la rosa temporanea
 FOR i in 1..p_tab_ris.COUNT
 loop
  insert into DO_NOMINATIVO
   (prgRosa, prgNominativo, cdnLavoratore, codCpiTit,
   numPesoEta, numPesoTitolo, numPesoMansione, numPesoEsp,
   numPesoInfo, numPesoLingua, decIndiceVicinanza,
   dtmIns, cdnUtIns)
  values
     (P_IN_PRGROSA, s_do_nominativo.nextVal, p_tab_ris(i).cdnLavoratore, p_tab_ris(i).cpiTit,
     p_tab_ris(i).numPesoEta, p_tab_ris(i).numPesoTitolo, p_tab_ris(i).numPesoMansione, p_tab_ris(i).numPesoEsp,
     p_tab_ris(i).numPesoInfo, p_tab_ris(i).numPesoLingua, p_tab_ris(i).decIndiceVicinanza,
     sysdate, p_cdnUtente);
 end loop;
  --else
    -- in caso di cooperazione applicativa restituisco il recordset
 --OPEN p_cursor FOR sql_query_cur;
  end if;
  -- aggiorno lo stato dell'incrocio
  update do_incrocio set CODSTATOINCROCIO='C',NUMKLOINCROCIO=NUMKLOINCROCIO+1, CDNUTMOD=p_cdnUtente, DTMMOD=sysdate
  where PRGINCROCIO = p_in_prgIncrocio;
  commit;
  --pulisco la tabella di appoggio
  begin
      delete DO_NOMINATIVO_APPOGGIO where PRGROSAAPPOGGIO = P_PRGROSAAPPOGGIO;
    commit;
      exception when others then null;
  end;
  return 0;
  exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line(substr(sqlcode || ' ' || sqlerrm,1,255));
       rollback;
       return -1;
end eseguiIncrocioPesato;

/*********************************************************
* Funzioni per la creazione della Rosa Nominativa Grezza *
*********************************************************/


 /*
 * Funzione per la creazione della Rosa Nominativa Grezza in cui si può definire
 * il commit immeddiato o demandato a chi la invoca
 * per poterlo gestire in transazione
 */
function creaRosaNomGrezzaTrans(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,     -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,      -- utente che effettua l'incrocio
    p_isCommitted number,          -- definisce se la procedura deve essre committata
    p_errCode OUT number,         -- Codice di Errore
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE, -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE    -- progressivo della rosa
) RETURN NUMBER IS
  p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
  p_Originale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;
  numMansioni number;
begin
  -- Controllo che la richiesta non sia stata CHIUSA mentre si accedeva all'incrocio
  SELECT RICH2.PRGRICHIESTAAZ INTO p_Originale
  FROM DO_RICHIESTA_AZ RICH1
         INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
     WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;
  -- Per la rosa nominativa controllo solo la chiusura totale
  SELECT do_evasione.CDNSTATORICH into p_cdnStatoRich
  FROM DO_RICHIESTA_AZ, DO_EVASIONE
  WHERE (DO_RICHIESTA_AZ.PRGRICHIESTAAZ=DO_EVASIONE.PRGRICHIESTAAZ)
  AND DO_RICHIESTA_AZ.PRGRICHIESTAAZ=p_Originale;
  if(p_cdnStatoRich=5) then
   return 2;
  end if;

  -- Controllo che ci sia almeno una MANSIONE
  select count(*) into numMansioni
  from DO_MANSIONE
  where DO_MANSIONE.PRGRICHIESTAAZ = p_Originale;
  if(numMansioni=0) then
   return 1;
  --dbms_output.put_line('Non è possibile effettuare l''incrocio in quanto non è stata specificata nessuna mansione!');
  end if;



  -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;
  --dbms_output.put_line('Prg Incrocio=' || p_out_prgIncrocio || ' - Prg Rosa=' || p_out_prgRosa);
  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgIncrocio, p_prgRichiestaAz, null, 4, 'C',
  p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgRosa, null, p_out_prgIncrocio, 2, p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- NB. Per le rose nomninative NON memorizzo i parametri dell'incrocio

  -- Aggiorno lo stato della richiesta originale e copia lavoro
  UPDATE DO_EVASIONE
     SET   DO_EVASIONE.CDNSTATORICH=2
     WHERE  (DO_EVASIONE.PRGRICHIESTAAZ=p_prgRichiestaAz OR DO_EVASIONE.PRGRICHIESTAAZ=p_originale)
           and DO_EVASIONE.CDNSTATORICH=1;
   if (p_isCommitted=1) then
     commit;
   end if;
  return 0;

  exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
     if (p_isCommitted=1) then
         rollback;
     end if;
       return -1;
end creaRosaNomGrezzaTrans;

 /* Funzione per la creazione della Rosa Nominativa Grezza richiama la creaRosaNomGrezzaTrans con p_isCommitted a true*/
function creaRosaNomGrezza(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,     -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,      -- utente che effettua l'incrocio
    p_errCode OUT number,         -- Codice di Errore
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE, -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE    -- progressivo della rosa
) RETURN NUMBER IS
begin
  return creaRosaNomGrezzaTrans(p_prgRichiestaAz,p_cdnUtente,1,p_errCode, p_out_prgIncrocio,p_out_prgRosa);
end creaRosaNomGrezza;
/****************************************************************************
* Funzione per l'inserimento di un lavoratore in una Rosa Nominativa Grezza *
*****************************************************************************/

/* Funzione per l'inserimento di un lavoratore in una Rosa Nominativa Grezza in cui si può definire il commit immeddiato o demandato a chi la invoca */
function inserisciLavRosaNomGrezzaTrans(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,       -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,     -- progressivo dell'incrocio
    p_prgRosa DO_ROSA.PRGROSA%TYPE,        -- progressivo della rosa
    p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,    -- cdnLavoratore da inserire nella rosa
    p_codCpi DE_CPI.CODCPI%TYPE,         -- il cpi del contatto
    p_prgSpiContatto AN_SPI.PRGSPI%TYPE,       -- il progressivo dell'operatore servizio cpi del contatto
    p_prgTipoContatto DE_TIPO_CONTATTOAG.PRGTIPOCONTATTO%TYPE, -- il tipo di contatto (e-mail, tel etc.)
    p_isCommitted number,          -- definisce se la procedura deve essre committata
    p_errCode OUT number           -- Codice di Errore
 ) RETURN NUMBER IS       --  0: OK

                         --  1: il lavoratore e' gia' presente nella rosa
       --  2: il lavoratore era stato inserito ma cancellato logicamente
       -- -1: errore sql -> p_err_code=sqlCode
 contattoAutomatico number;
 p_prgAzienda AN_AZIENDA.PRGAZIENDA%TYPE;
 p_prgUnita AN_UNITA_AZIENDA.PRGUNITA %TYPE;
 p_anLavoratore AN_LAVORATORE%ROWTYPE;
 p_numAnno DO_RICHIESTA_AZ.NUMANNO%TYPE;
 p_numRichiesta DO_RICHIESTA_AZ.NUMRICHIESTA%TYPE;
 p_numRichiestaOrig DO_RICHIESTA_AZ.NUMRICHIESTAORIG%TYPE;
 --lavoratoreInRosa number;
 p_codTipoCanc do_nominativo.CODTIPOCANC%TYPE;
 p_codDisponilitaRosaPrec DO_DISPONIBILITA.CODDISPONIBILITAROSAPREC%TYPE;
begin
 -- controllo che il lavoratore non sia gia' presente nella rosa
 begin
  select do_nominativo.codTipoCanc
  INTO p_codTipoCanc
  from do_nominativo
  where
   do_nominativo.cdnlavoratore = p_cdnLavoratore
   and do_nominativo.prgRosa = p_prgRosa;
  if (p_codTipoCanc is null) then -- lavoratore nella lista
     return 1;
  else -- lavoratore nella lista ma cancellato logicamente
     return 2;
  end if;
  exception when no_data_found then -- controllo superato: il lavoratore puo' essere inserito nella lista
   null;
 end;
 -- info necessarie per il registrare il contatto
 -- il prgAzienda ed il prgUnita non servono piu'
 select do_richiesta_az.prgAzienda, do_richiesta_az.prgUnita, do_richiesta_az.NUMANNO, do_richiesta_az.NUMRICHIESTA, 
 nvl(do_richiesta_az.NUMRICHIESTAORIG, do_richiesta_az.NUMRICHIESTA) NUMRICHIESTAORIG
 into p_prgAzienda, p_prgUnita, p_numAnno, p_numRichiesta, p_numRichiestaOrig
 from do_richiesta_az
 where do_richiesta_Az.prgRichiestaAz = p_prgRichiestaAZ;
 -- si controlla se per questo cpi si deve creare in automatico il contatto
 select count(*)
 into contattoAutomatico
 from ts_generale
 where ts_generale.FLGCONTATTOAUTOMROSA = 'S';
 if (p_cdnUtente <> 230 and contattoAutomatico=1) then
 
  insert into ag_contatto
      (PRGCONTATTO, CODCPICONTATTO, DATCONTATTO, STRORACONTATTO,
      PRGSPICONTATTO,
      TXTCONTATTO,
      FLGRICONTATTARE, STRIO, DATENTROIL,
      PRGMOTCONTATTO, PRGTIPOCONTATTO, PRGEFFETTOCONTATTO,
      CDNLAVORATORE, CODDISPONIBILITAROSA,
      PRGAZIENDA, PRGUNITA,
      CDNUTINS, DTMINS, CDNUTMOD, DTMMOD)
        values (s_ag_contatto.nextval, p_codCpi,trunc(sysdate), to_char(sysdate,'hh24:mi'),
              p_prgSpiContatto,
      'Rich. ' || p_numRichiestaOrig ||'/'||p_numAnno||' - Rosa '|| p_prgRosa,
      null, 'I', null,
              6,p_prgTipoContatto, 5,
              p_cdnLavoratore,'A',
              null, null,
              p_cdnUtente,sysdate, p_cdnUtente, sysdate);
 end if;
 -- seleziono i dati del lavoratore
 -- mi sembra che non servano.
 -- Ricorda di togliere la definizione della variabile
 /*
 select *
 into p_anLavoratore
 from an_lavoratore
 where  an_lavoratore.cdnLavoratore = p_cdnLavoratore;
 */
 -- inserimento del lavoratore in do_nominativo
 insert into DO_NOMINATIVO
  (prgNominativo, cdnLavoratore, numOrdine, codCpiTit, dtmIns,
  cdnUtIns,prgRosa, datDichiarazione)
 values
  (S_DO_NOMINATIVO.nextVal, p_cdnLavoratore, null,PG_INCROCIO.PDCPITIT(p_cdnLavoratore), sysdate,
  p_cdnUtente, p_prgRosa,PG_INCROCIO.PDDIDLAVO(p_cdnLavoratore)
 );
 -- inserimento automatico disponibilita'
 -- controllo che non esista; in questo caso eseguo una update salvando il codDisponibilitaRosa in modo da
 -- poterlo ripristinare nel caso in cui cancellassi il lavoratore dalla rosa
 begin
   select do_disponibilita.CODDISPONIBILITAROSA
   into p_codDisponilitaRosaPrec --, p_numKloDispRosa
   from do_disponibilita
      where do_disponibilita.PRGRICHIESTAAZ = p_prgRichiestaAz
       and do_disponibilita.cdnLavoratore = p_cdnLavoratore;
   update do_disponibilita set
       CODDISPONIBILITAROSA = 'A',
      CODDISPONIBILITAROSAPREC = p_codDisponilitaRosaPrec,
      DATDISPONIBILITA = trunc(SYSDATE),
      CDNUTMOD = p_cdnUtente,
      DTMMOD = sysdate
   where do_disponibilita.PRGRICHIESTAAZ = p_prgRichiestaAz
       and do_disponibilita.cdnLavoratore = p_cdnLavoratore;
    exception when no_data_found then
   -- la disponibilita' non esiste: la creo ex-novo
   -- modifica 29/01/2007 savino: corretta to_date(sysdate
             Insert into DO_DISPONIBILITA
              (DATDISPONIBILITA, CODDISPONIBILITAROSA,NUMCONTANONRINTRACCIATO,CDNUTINS,DTMINS,
               CDNUTMOD,DTMMOD,PRGRICHIESTAAZ,CDNLAVORATORE)
                 values
             (trunc(sysdate),'A',null, p_cdnUtente,SYSDATE,
         p_cdnUtente,SYSDATE, p_prgRichiestaAz, p_cdnLavoratore);
    end;
    -- fine inserimento lavoratore nella rosa grezza nominativa
    if (p_isCommitted = 1) then
       commit;
    end if;
    return 0;
    exception
 when others then
  p_errCode := sqlcode;
--  dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
  if (p_isCommitted = 1) then
    rollback;
  end if;
  return -1;
end inserisciLavRosaNomGrezzaTrans;

/* Funzione per l'inserimento di un lavoratore in una Rosa Nominativa Grezza richiama la inserisciLavRosaNomGrezzaTrans con p_isCommitted a true*/
function inserisciLavRosaNomGrezza(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,       -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,     -- progressivo dell'incrocio
    p_prgRosa DO_ROSA.PRGROSA%TYPE,        -- progressivo della rosa
    p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,    -- cdnLavoratore da inserire nella rosa
    p_codCpi DE_CPI.CODCPI%TYPE,         -- il cpi del contatto
    p_prgSpiContatto AN_SPI.PRGSPI%TYPE,       -- il progressivo dell'operatore servizio cpi del contatto
    p_prgTipoContatto DE_TIPO_CONTATTOAG.PRGTIPOCONTATTO%TYPE, -- il tipo di contatto (e-mail, tel etc.)
    p_errCode OUT number           -- Codice di Errore
 ) RETURN NUMBER IS       --  0: OK
                         --  1: il lavoratore e' gia' presente nella rosa
                         --  2: il lavoratore era stato inserito ma cancellato logicamente
                         -- -1: errore sql -> p_err_code=sqlCode
     begin
      return inserisciLavRosaNomGrezzaTrans(p_prgRichiestaAz, p_cdnUtente,p_prgIncrocio,p_prgRosa,
                                       p_cdnLavoratore,p_codCpi,p_prgSpiContatto,p_prgTipoContatto, 1, p_errCode);
     end;

/**************************************************************************************
* Funzione per la cancellazione fisica di un lavoratore da una Rosa Nominativa Grezza *
**************************************************************************************/
function delFisicaLavRosaNomGrezza(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,       -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_prgRosa DO_ROSA.PRGROSA%TYPE,        -- progressivo della rosa
    p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,    -- cdnLavoratore da inserire nella rosa
      p_errCode OUT number           -- Codice di Errore
) RETURN NUMBER IS -- 0: OK, -1: errore sql -> p_err_code=sqlCode
 p_codDisponibilitaRosaPrec DO_DISPONIBILITA.CODDISPONIBILITAROSAPREC%TYPE;
 p_codDisponibilitaRosa DO_DISPONIBILITA.CODDISPONIBILITAROSA%TYPE;
 p_dtmInsNominativo DO_NOMINATIVO.DTMINS%TYPE;
 contattoAutomatico integer;
 numeroRoseNom integer;
begin
 -- e' necessario recuperare informazioni dal record del nominativo del lavoratore
 select do_nominativo.dtmIns
 into p_dtmInsNominativo
 from do_nominativo
 where do_nominativo.PRGROSA = p_prgRosa
    and do_nominativo.cdnLavoratore = p_cdnLavoratore;
 -- cancellazione del lavoratore dalla rosa
 delete from do_nominativo
 where do_nominativo.CDNLAVORATORE = p_cdnLavoratore
    and do_nominativo.PRGROSA = p_prgRosa;
 -- cancellazione o ripristino disponibilita'
 begin
  -- controllo se per il lavoratore esiste ancora un record in do_nominativo associato a rose nominative
  -- per la richiesta azienda
  select count(*)
  into numeroRoseNom
  from do_nominativo, do_rosa, do_incrocio
  where
    do_nominativo.PRGROSA = do_rosa.PRGROSA
    and do_rosa.prgIncrocio = do_incrocio.PRGINCROCIO
    and do_incrocio.PRGRICHIESTAAZ = p_prgRichiestaAz
    and do_nominativo.CDNLAVORATORE = p_cdnLavoratore
    and do_incrocio.PRGTIPOINCROCIO = 4;

  select do_disponibilita.CODDISPONIBILITAROSAPREC, do_disponibilita.codDisponibilitaRosa
  into p_codDisponibilitaRosaPrec, p_codDisponibilitaRosa
  from do_disponibilita
  where do_disponibilita.CDNLAVORATORE = p_cdnLavoratore
     and do_disponibilita.PRGRICHIESTAAZ = p_prgRichiestaAz;
  -- aggiorno la disponibilita' solo se sono sicuro che il lavoratore sia presente in un'altra
  -- rosa nominativa (a questo punto il controllo sul p_codDisponibilitaRosaPrec diventa inutile?)
  if (p_codDisponibilitaRosaPrec is not null or numeroRoseNom > 0) then
      if (p_codDisponibilitaRosaPrec is null) then -- aggiorno solo la data e l'utente
      p_codDisponibilitaRosaPrec := p_codDisponibilitaRosa;
   end if;
  -- modifica 29/01/2007 savino:  corretta to_date(sysdate
   update do_disponibilita
   set do_disponibilita.codDisponibilitaRosa = p_codDisponibilitaRosaPrec,
    do_disponibilita.CODDISPONIBILITAROSAPREC = null,
    do_disponibilita.datDisponibilita = trunc(sysdate),
    do_disponibilita.dtmMod = sysdate,
    do_disponibilita.cdnUtMod = p_cdnUtente
   where do_disponibilita.prgRichiestaAz = p_prgRichiestaAz
      and do_disponibilita.cdnLavoratore = p_cdnLavoratore;
  else  -- se la disponibilita' era stata creata con l'inserimento del lavoratore nella rosa nominativa
     -- allora il record puo' essere cancellato
    delete from do_disponibilita
    where do_disponibilita.prgRichiestaAz = p_prgRichiestaAz
      and do_disponibilita.cdnLavoratore = p_cdnLavoratore;
  end if;
  exception when no_data_found then -- se la disponibilita' non esiste si procede oltre (non e' un errore)
        null;
 end;
 -- cancellazione eventuale contatto (se creato con l'inserimento del lavoratore nella rosa nominativa grezza)
 begin
  select count(*)
  into contattoAutomatico
  from ts_generale
  where ts_generale.FLGCONTATTOAUTOMROSA = 'S';
  if (contattoAutomatico=1) then
   delete from ag_contatto -- N.B. il contatto e' letato alla rosa, non ho problemi
   where ag_contatto.cdnLavoratore = p_cdnLavoratore
      and to_char(ag_contatto.DATCONTATTO,'dd/mm/yyyy') = to_char(p_dtmInsNominativo, 'dd/mm/yyyy')
      and ag_contatto.TXTCONTATTO like '%- Rosa ' || p_prgRosa || '%'
      and ag_contatto.STRIO = 'I'
         and ag_contatto.PRGMOTCONTATTO = 6
        and ag_contatto.PRGEFFETTOCONTATTO = 5
         and ag_contatto.CODDISPONIBILITAROSA = 'A'; -- presente solo se creato automaticamente
  end if;
   exception
   -- il contatto non puo' essere cancellato manualmente, per cui avrei dovuto trovarlo. Progago l'errore
      when no_data_found then
          raise;
 end;
 commit;
 return 0;
 exception when others then
      p_errCode := sqlcode;
   rollback;
   return -1;
end delFisicaLavRosaNomGrezza;

/**************************************************************************
* Procedura per l'inserimento nella rosa della data di invio della stessa *
***************************************************************************/
PROCEDURE insDataInvioRosa( pPrgRichAzStr VARCHAR2,
                            pPrgRosaStr   VARCHAR2,
                            pDatInvioStr  VARCHAR2,
                            pCdnUtModStr  VARCHAR2,
       pTutteStr   VARCHAR2,
       pCdnGrpModStr VARCHAR2) IS

pPrgRichAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE;
pPrgRosa   DO_ROSA.PRGROSA%TYPE;
pDatInvio  DO_ROSA.DATINVIO%TYPE;
pCdnUtMod  NUMBER;
pTutte    NUMBER;

vPrgRosa DO_ROSA.PRGROSA%TYPE;
oldrec DO_ROSA%ROWTYPE;


CURSOR prgRosaCur IS
   SELECT DO_ROSA.PRGROSA
     FROM DO_INCROCIO, DO_ROSA
    WHERE DO_INCROCIO.PRGINCROCIO = DO_ROSA.PRGINCROCIO
    AND DO_ROSA.PRGTIPOROSA=3
    AND DO_INCROCIO.PRGRICHIESTAAZ in
         (SELECT RICH2.PRGRICHIESTAAZ
        FROM DO_RICHIESTA_AZ RICH1
           INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA)
       WHERE RICH1.PRGRICHIESTAAZ = pPrgRichAz);

BEGIN
pPrgRichAz := TO_NUMBER(pPrgRichAzStr);
pPrgRosa   := TO_NUMBER(pPrgRosaStr);
pDatInvio  := TO_DATE(pDatInvioStr,'DD/MM/YYYY');
pCdnUtMod  := TO_NUMBER(pCdnUtModStr);
pTutte    := TO_NUMBER(pTutteStr);

 if(pTutte=1) THEN
    OPEN prgRosaCur;

    LOOP
     FETCH prgRosaCur INTO vPrgRosa;
     EXIT WHEN prgRosaCur%NOTFOUND;

     -- memorizzo il record prima dell'update
     select * into oldrec from do_rosa where prgrosa=vPrgRosa;

     UPDATE DO_ROSA
        SET DO_ROSA.DATINVIO = pDatInvio,
            DO_ROSA.CDNUTMOD = pCdnUtMod,
           DO_ROSA.DTMMOD   = SYSDATE,
      DO_ROSA.CDNGRUPPOINVIO = to_number(pCdnGrpModStr),
      DO_ROSA.CDNUTINVIO = pCdnUtMod,
           DO_ROSA.NUMKLOROSA = (SELECT TO_NUMBER(DO_ROSA.NUMKLOROSA+1) FROM DO_ROSA DOS WHERE DOS.PRGROSA = DO_ROSA.PRGROSA)
      WHERE DO_ROSA.PRGROSA = vPrgRosa;

     -- Aggiorno i dati in DO_LAV_STORIA_ROSA
     if((oldrec.datInvio is null and pDatInvio is not null)
     OR (to_char(oldrec.datInvio,'dd/mm/yyyy') <> to_char(pDatInvio,'dd/mm/yyyy'))) then
        PG_STORIA_ROSA.PDAGGSTORIAROSAXINVIO(vPrgRosa, oldrec.prgTipoRosa, pdatInvio);
     end if;

    END LOOP;
 ELSE
     -- memorizzo il record prima dell'update
     select * into oldrec from do_rosa where prgrosa=pPrgRosa;

     UPDATE DO_ROSA
        SET DO_ROSA.DATINVIO = pDatInvio,
            DO_ROSA.CDNUTMOD = pCdnUtMod,
           DO_ROSA.DTMMOD   = SYSDATE,
      DO_ROSA.CDNGRUPPOINVIO = to_number(pCdnGrpModStr),
      DO_ROSA.CDNUTINVIO = pCdnUtMod,
           DO_ROSA.NUMKLOROSA = (SELECT TO_NUMBER(DO_ROSA.NUMKLOROSA+1) FROM DO_ROSA DOS WHERE DOS.PRGROSA = DO_ROSA.PRGROSA)
      WHERE DO_ROSA.PRGROSA = pPrgRosa;

     -- Aggiorno i dati in DO_LAV_STORIA_ROSA
     if((oldrec.datInvio is null and pDatInvio is not null)
     OR (to_char(oldrec.datInvio,'dd/mm/yyyy') <> to_char(pDatInvio,'dd/mm/yyyy'))) then
        PG_STORIA_ROSA.PDAGGSTORIAROSAXINVIO(pPrgRosa, oldrec.prgTipoRosa, pdatInvio);
     end if;

 END IF;

END insDataInvioRosa;


--***********************************************************************************
-- FUNZIONI DI UTILITA'
--***********************************************************************************
--------------------------------------
--***********************************************************************************
-- PDMASTERLAVO
-- Risponde
-- 1 se il lavoratore appartiene alla provincia master (definizione per l'incrocio)
-- 0 altrimenti
--***********************************************************************************
function pdMasterLavo(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type) RETURN NUMBER IS
 pCodProvMaster TS_GENERALE.CODPROVINCIASIL%type;
 varCdnLav AN_LAVORATORE.cdnLavoratore%type;
begin

 --
 begin
  select cdnLavoratore  into varCdnLav
  from an_lav_storia_inf lav, de_cpi, TS_GENERALE
  where lav.CDNLAVORATORE=p_cdnLavoratore
     --and lav.DATFINE is null
  and DECODE("DATFINE",NULL,'S','N') = 'S'
     and (lav.CODMONOTIPOCPI='C' or lav.CODMONOTIPOCPI='T')
     and (lav.CODCPITIT=de_cpi.CODCPI and de_cpi.CODPROVINCIA=codProvinciaSil);
  exception
    when no_data_found then
      varCdnLav := -1;
 end;
 --
 if(varCdnLav=-1) then
  return 0;
 else
  return 1;
 end if;
END pdMasterLavo;

--***********************************************************************************
-- PDSTATOOCC
-- Risponde
-- 1 se il lavoratore risponde ai requisiti di Disoccupazione per l'incrocio
-- 0 altrimenti
--***********************************************************************************
function pdStatoOcc(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type) RETURN NUMBER IS
 varCdnLav AN_LAVORATORE.cdnLavoratore%type;
begin
 begin
  select distinct st.cdnLavoratore into varCdnLav
  from am_stato_occupaz st
  inner join de_stato_occupaz ds on (st.CODSTATOOCCUPAZ=ds.CODSTATOOCCUPAZ)
  where st.CDNLAVORATORE = p_cdnLavoratore
  and st.DATFINE is null
  and (ds.CODSTATOOCCUPAZRAGG = 'D' or ds.CODSTATOOCCUPAZRAGG = 'I')
  and ds.CODSTATOOCCUPAZ <> 'B1';
 exception
    when no_data_found then
      varCdnLav := -1;
 end;
 --
 if(varCdnLav=-1) then
  return 0;
 else
  return 1;
 end if;
END pdStatoOcc;

--***********************************************************************************
-- PDCPITIT
-- Calcola il CPI titolare dei dati del lavoratore
--***********************************************************************************
function pdCpiTit(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type) RETURN varchar IS
 varCpiTit DE_CPI.CODCPI%type;
begin
 begin
  select codCpiTit into varCpiTit
  from an_lav_storia_inf lav
  where (lav.CDNLAVORATORE=p_cdnLavoratore and lav.DATFINE is null);
  exception
    when no_data_found then
      varCpiTit := null;
 end;
 return varCpiTit;
END pdCpiTit;
--***********************************************************************************
-- PDDIDLAVO
-- Calcola la DID del Lavoratore
--***********************************************************************************
function pdDidLavo(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type)
 RETURN do_nominativo.DATDICHIARAZIONE%type IS
  varDid do_nominativo.DATDICHIARAZIONE%type;
begin
 begin
  select dis.DATDICHIARAZIONE into varDid
  from am_elenco_anagrafico el,am_dich_disponibilita dis
  where (el.PRGELENCOANAGRAFICO=dis.PRGELENCOANAGRAFICO)
     and (el.CDNLAVORATORE=p_cdnLavoratore and dis.DATFINE is null)
     and dis.CODSTATOATTO='PR';
  exception
    when no_data_found then
      varDid := null;
 end;
 return varDid;
END pdDidLavo;
--***********************************************************************************
-- PDINDISPAZIENDA
-- Calcola l'indisponibilità del lavoratore a lavorare per una certa azienda
-- Risponde 0 se non c'è l'indisponibilità
-- un numero maggiore di zero se c'è l'indisponibilità
--***********************************************************************************
function pdIndispAzienda(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type,
       p_prgRichiestaAZ DO_RICHIESTA_AZ.PRGRICHIESTAAZ%type) RETURN number IS
 p_prgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%type;
 nro number;
BEGIN

 begin
 select 1 into nro
 from pr_indisponibilita pr
 inner join do_richiesta_az d on d.prgazienda = pr.prgazienda
 where pr.cdnLavoratore=p_cdnLavoratore
 and prgRichiestaAz=p_prgRichiestaAz;
 exception
    when no_data_found then
      nro := 0;
 end;
 --
 return nro;
end pdIndispAzienda;

--***********************************************************************************
-- CHECKGG
-- Risponde
-- 1 se il lavoratore risponde ai requisiti di iscrizione a GG per l'incrocio
-- 0 altrimenti
--***********************************************************************************

function checkGG(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type) RETURN NUMBER IS
 varCdnLav AN_LAVORATORE.cdnLavoratore%type;
begin
 begin
  select distinct lav.cdnLavoratore into varCdnLav
  from an_lavoratore lav
  inner join or_colloquio col on (lav.cdnlavoratore = col.cdnlavoratore)
  inner join or_percorso_concordato perc on (col.prgcolloquio=perc.prgcolloquio)
  inner join ma_azione_tipoattivita ma on (perc.prgazioni=ma.prgazioni)
  inner join de_azione on (perc.prgazioni=de_azione.prgazioni)
  inner join de_azione_ragg ragg on (de_azione.prgazioneragg=ragg.prgazioniragg)
  left join or_percorso_concordato percgg on (perc.prgcolloquioadesione=percgg.prgcolloquio and perc.prgpercorsoadesione=percgg.prgpercorso)
  where ma.codtipoattivita='A02' and ragg.flg_misurayei='S' and lav.cdnlavoratore=p_cdnLavoratore
      and perc.codesito='FC' and nvl(perc.dateffettiva,perc.datstimata) < trunc(sysdate);
 exception
    when no_data_found then
      varCdnLav := -1;
 end;
 --
 if(varCdnLav=-1) then
  return 0;
 else
  return 1;
 end if;
END checkGG;


--***********************************************************************************
-- checkFormProf
-- Risponde
-- where_form_prof != '' se il lavoratore risponde ai requisiti di formazione professionale per l'incrocio
--***********************************************************************************

function checkFormProf(p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,    -- progressivo della Richiesta
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE, p_usaNonInd int) RETURN VARCHAR2 IS 
where_form_prof  varchar2(4000):= ''; 
numFormProf number;
CURSOR curFormProf IS
   select DO_FORMAZIONE_PROF.CODCORSO, DO_FORMAZIONE_PROF.FLGINDISPENSABILE
 from DO_FORMAZIONE_PROF
 where DO_FORMAZIONE_PROF.PRGRICHIESTAAZ = p_prgRichiestaAz 
   and DO_FORMAZIONE_PROF.PRGALTERNATIVA = p_prgAlternativa;

begin
 dbms_output.put_line('p_usaNonInd:' || p_usaNonInd );
 if(p_usaNonInd=1) then
  select count(*) into numFormProf
  from DO_FORMAZIONE_PROF
  where DO_FORMAZIONE_PROF.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_FORMAZIONE_PROF.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numFormProf
  from DO_FORMAZIONE_PROF
  where DO_FORMAZIONE_PROF.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_FORMAZIONE_PROF.PRGALTERNATIVA = p_prgAlternativa
     and DO_FORMAZIONE_PROF.FLGINDISPENSABILE='S';
 end if;
 dbms_output.put_line('Sono richiesti n. ' || numFormProf || ' corsi professionali');
 if(numFormProf>0) then
  where_form_prof := '';
  FOR rec IN curFormProf LOOP
   dbms_output.put_line('rec.flgIndispensabile:' || rec.flgIndispensabile );  
   if((rec.flgIndispensabile='S') or (p_usaNonInd=1)) then
      if(length(where_form_prof)>0) then
         where_form_prof := where_form_prof || ' union ';
      end if;
      where_form_prof := where_form_prof || ' (';
      where_form_prof := where_form_prof ||
             'select cv_corso.cdnLavoratore from PR_CORSO cv_corso ' ||
          'where cv_corso.cdnLavoratore=an.cdnLavoratore and ' ||
          'cv_corso.CODCORSO = ' || '''' || rec.codcorso || '''';
      where_form_prof := where_form_prof || ') ';
   end if;
  END LOOP;
 end if;
 dbms_output.put_line('where_form_prof =' || where_form_prof );
 
 return where_form_prof;
  
END checkFormProf;



function checkGGCresco(p_cdnLavoratore AN_LAVORATORE.cdnLavoratore%type,
              p_datarichiesta DO_RICHIESTA_AZ.DATRICHIESTA%TYPE,
              p_datascadpubbl DO_RICHIESTA_AZ.DATSCADENZAPUBBLICAZIONE%TYPE) RETURN NUMBER IS
 varCdnLav AN_LAVORATORE.cdnLavoratore%type;
begin
 begin
  select distinct lav.cdnLavoratore into varCdnLav
  from an_lavoratore lav
  inner join or_colloquio col on (lav.cdnlavoratore = col.cdnlavoratore)
  inner join or_percorso_concordato perc on (col.prgcolloquio=perc.prgcolloquio)
  inner join ma_azione_tipoattivita ma on (perc.prgazioni=ma.prgazioni)
  inner join de_azione on (perc.prgazioni=de_azione.prgazioni)
  inner join de_azione_ragg ragg on (de_azione.prgazioneragg=ragg.prgazioniragg)
  left join or_percorso_concordato percgg on (perc.prgcolloquioadesione=percgg.prgcolloquio and perc.prgpercorsoadesione=percgg.prgpercorso)
  where ma.codtipoattivita='A02' and ragg.flg_misurayei='S' and lav.cdnlavoratore=p_cdnLavoratore and perc.codesito='FC'
  and nvl(perc.dateffettiva,perc.datstimata) between p_datarichiesta and p_datascadpubbl;
 exception
    when no_data_found then
      varCdnLav := -1;
 end;
 --
 if(varCdnLav=-1) then
  return 0;
 else
  return 1;
 end if;
END checkGGCresco;


--*****************************************************************************************
-- PDTERRSEDEAZ
-- Risponde
-- 1 se il lavoratore risponde ai requisiti di Disponibilità Territoriale per l'incrocio
-- 0 altrimenti
--*****************************************************************************************
/*
function pdTerrSedeAz(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,
        p_codCom AN_UNITA_AZIENDA.CODCOM%TYPE,
       p_strMansione varchar) return number is
  nroCom number;
  nroProv number;
  nroReg number;
  nroStatoIta number;
  varCodProvincia DE_COMUNE.CODPROVINCIA%TYPE;
  varCodRegione DE_PROVINCIA.CODPROVINCIA%TYPE;
begin
     -- Controllo se il lavoratore ha dato disponibilità a lavorare per la mansione nel comune
  -- dell'azienda
  select count(*) into nroCom
  from PR_MANSIONE man,PR_DIS_COMUNE dter
  where (man.PRGMANSIONE=dter.PRGMANSIONE)
      and (man.CODMANSIONE like p_strMansione and man.CDNLAVORATORE=p_cdnLavoratore)
     and dter.CODCOM=p_codCom;
  -- Se nroCom > 0 allora posso terminare qui
  if (nroCom>0) then
      return (1);
  end if;
  -- Controllo se il lavoratore ha dato disponibilità a lavorare per la mansione nella provincia
  -- dell'azienda
  select codProvincia into varCodProvincia from de_comune where codCom=p_codCom;
  select count(*) into nroProv
  from PR_MANSIONE man, PR_DIS_PROVINCIA dprov
  where (man.PRGMANSIONE=dprov.PRGMANSIONE)
      and (man.CODMANSIONE like p_strMansione and man.CDNLAVORATORE=p_cdnLavoratore)
     and dprov.CODPROVINCIA=varCodProvincia;
  -- Se nroProv > 0 allora posso terminare qui
  if (nroProv>0) then
      return (1);
  end if;
  -- Controllo se il lavoratore ha dato disponibilità a lavorare per la mansione nella
  -- regione dell'azienda
  select codRegione into varCodRegione from de_provincia where codProvincia=varCodProvincia;
  select count(*) into nroReg
  from PR_MANSIONE man, PR_DIS_REGIONE dreg
  where (man.PRGMANSIONE=dreg.PRGMANSIONE)
      and (man.CODMANSIONE like p_strMansione and man.CDNLAVORATORE=p_cdnLavoratore)
     and dreg.CODREGIONE=varCodRegione;
  -- Se nroReg > 0 allora posso terminare qui
  if (nroReg>0) then
      return (1);
  end if;
  -- Controllo se il lavoratore ha dato disponibilità a lavorare per la mansione
  -- in Italia
  select count(*) into nroStatoIta
  from PR_MANSIONE man, PR_DIS_STATO dstato
  where (man.PRGMANSIONE=dstato.PRGMANSIONE)
      and (man.CODMANSIONE like p_strMansione and man.CDNLAVORATORE=p_cdnLavoratore)
     and dstato.CODCOM='Z000';
  --
  if(nroStatoIta>0) then
   return 1;
  else
   return 0;
  end if;
end pdTerrSedeAz;
*/
--
--*****************************************************************************************
-- PDTERRRICHIESTAAZ
-- Risponde
-- 1 se il lavoratore risponde ai requisiti di Disponibilità Territoriale per l'incrocio,
-- definita nell'Offerta
-- 0 altrimenti
--*****************************************************************************************
/*
function pdTerrRichiestaAz(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,
        p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
       numComuni number,
       numProvince number,
       p_strMansione varchar) return number is
  nroCom1 number;
  nroProv1 number;
  nroReg1 number;
  --
  nroProv2 number;
  nroReg2 number;
  --
  nroStatoIta number;
begin
  -- Anche qui inseriamo la possibilità di terminare l'elaborazione appena viene soddisfatta
  -- una delle condizioni
  IF(numComuni>0) THEN
   select count(*) into nroCom1
   from PR_MANSIONE man,PR_DIS_COMUNE dter, DO_COMUNE dc
   where (man.PRGMANSIONE=dter.PRGMANSIONE)
       and (man.CODMANSIONE like p_strMansione and man.CDNLAVORATORE=p_cdnLavoratore)
      and (dter.CODCOM=dc.CODCOM)
      and dc.PRGRICHIESTAAZ=p_prgRichiestaAz;
    if(nroCom1>0) then
    return 1;
   end if;
   --
   select count(*) into nroProv1
   from
      DO_COMUNE, DE_COMUNE,
     PR_DIS_PROVINCIA,PR_MANSIONE
   where
      (do_comune.CODCOM=DE_COMUNE.CODCOM)
     and (de_comune.CODPROVINCIA=pr_dis_provincia.CODPROVINCIA)
     and (pr_dis_provincia.PRGMANSIONE=pr_mansione.PRGMANSIONE)
      and (PR_MANSIONE.CODMANSIONE like p_strMansione and PR_MANSIONE.CDNLAVORATORE=p_cdnLavoratore)
     and DO_COMUNE.PRGRICHIESTAAZ=p_prgRichiestaAz;
   if(nroProv1>0) then
    return 1;
   end if;
    --
   select count(*) into nroReg1
   from
      DO_COMUNE, DE_COMUNE, DE_PROVINCIA,
     PR_DIS_REGIONE, PR_MANSIONE
   where
      (do_comune.CODCOM=de_comune.CODCOM) and (de_comune.CODPROVINCIA=de_provincia.CODPROVINCIA)
      and (de_provincia.CODREGIONE=PR_DIS_REGIONE.CODREGIONE)
     and (PR_DIS_REGIONE.PRGMANSIONE=PR_MANSIONE.PRGMANSIONE)
         and (PR_MANSIONE.CODMANSIONE like p_strMansione and PR_MANSIONE.CDNLAVORATORE=p_cdnLavoratore)
     and DO_COMUNE.PRGRICHIESTAAZ=p_prgRichiestaAz;
  if(nroReg1>0) then
    return 1;
   end if;
  ELSE
   nroCom1 := 0;
  nroProv1 := 0;
  nroReg1 := 0;
  END IF;
  --
  IF(numProvince>0) THEN
    select count(*) into nroProv2
   from PR_MANSIONE, PR_DIS_PROVINCIA, DO_PROVINCIA
   where (PR_MANSIONE.PRGMANSIONE=PR_DIS_PROVINCIA.PRGMANSIONE)
       and (PR_MANSIONE.CODMANSIONE like p_strMansione and PR_MANSIONE.CDNLAVORATORE=p_cdnLavoratore)
      and (PR_DIS_PROVINCIA.CODPROVINCIA=DO_PROVINCIA.CODPROVINCIA)
      and DO_PROVINCIA.PRGRICHIESTAAZ=p_prgRichiestaAz;
   if(nroProv2>0) then
    return 1;
   end if;
    --
   select count(*) into nroReg2
   from
      DO_PROVINCIA, DE_PROVINCIA,
      PR_DIS_REGIONE, PR_MANSIONE
   where
      (do_provincia.CODPROVINCIA=de_provincia.CODPROVINCIA)
     and (de_provincia.CODREGIONE=pr_dis_regione.CODREGIONE)
     and (pr_dis_regione.PRGMANSIONE=pr_mansione.PRGMANSIONE)
        and (pr_mansione.CODMANSIONE like p_strMansione and pr_mansione.CDNLAVORATORE=p_cdnLavoratore)
     and do_provincia.PRGRICHIESTAAZ=p_prgRichiestaAz;
   if(nroReg2>0) then
    return 1;
   end if;
  ELSE
    nroProv2 := 0;
   nroReg2 := 0;
  END IF;
  --
  select count(*) into nroStatoIta
  from PR_MANSIONE man, PR_DIS_STATO dstato
  where (man.PRGMANSIONE=dstato.PRGMANSIONE)
      and (man.CODMANSIONE like p_strMansione and man.CDNLAVORATORE=p_cdnLavoratore)
     and dstato.CODCOM='Z000';
  --
  if(nroStatoIta>0) then
   return 1;
  else
   return 0;
  end if;
end pdTerrRichiestaAz;
*/
-- Restituisce la descrizione dello stato della Richiesta Originale dato il progressivo della copia
function pdStatoRichOrig(p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE) RETURN varchar2
IS
   strStato de_stato_richiesta.STRDESCRIZIONE%TYPE := '';
   prgOrig DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;
BEGIN
  SELECT RICH2.PRGRICHIESTAAZ into prgOrig
  FROM DO_RICHIESTA_AZ RICH1
     INNER JOIN DO_RICHIESTA_AZ RICH2
     ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
     WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;
  --
  SELECT de_stato_richiesta.STRDESCRIZIONE into strStato
  from do_evasione
     inner join de_stato_richiesta on (do_evasione.CODMONOSTATORICH=de_stato_richiesta.CODMONOSTATORICH)
  where do_evasione.PRGRICHIESTAAZ=prgOrig;

  return strStato;

  exception
       when others then return '';
END pdStatoRichOrig;
-- Restituisce la descrizione dello stato di Evasione della Richiesta Originale dato il progressivo della copia
function pdStatoEvRichOrig(p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE) RETURN varchar2
IS
   strStatoEV de_stato_ev_rich.STRDESCRIZIONE%TYPE := '';
   prgOrig DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;
BEGIN
  SELECT RICH2.PRGRICHIESTAAZ into prgOrig
  FROM DO_RICHIESTA_AZ RICH1
     INNER JOIN DO_RICHIESTA_AZ RICH2
     ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
     WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;
  --
  SELECT de_stato_ev_rich.STRDESCRIZIONE into strStatoEv
  from do_evasione
     inner join de_stato_ev_rich on (do_evasione.CDNSTATORICH=de_stato_ev_rich.CDNSTATORICH)
  where do_evasione.PRGRICHIESTAAZ=prgOrig;

  return strStatoEv;

  exception
       when others then return '';
END pdStatoEvRichOrig;
--
-- calcola gli anni (non compiuti) del lavoratore
function etaMatchOld(p_dataNasc date) return number is
  eta number;
  data_app date;
begin
  begin
    eta := to_number(to_char(sysdate,'yyyy'))-to_number(to_char(p_dataNasc,'yyyy'));
    data_app := to_date(to_char(p_dataNasc,'dd')||'/'||to_char(p_dataNasc,'mm')||'/'|| to_char(sysdate,'yyyy'), 'dd/mm/yyyy');
    if(trunc(data_app)>trunc(sysdate)) then
     eta := eta - 1;
    end if;

    exception
        when others then
                   eta := 1;
  end;
  --dbms_output.put_line('eta ' || to_char(eta));
  return eta;
end etaMatchOld;

-- calcola gli anni (non compiuti) del lavoratore
-- viene corretto il caso in cui il lavoratore è nato il 29/02
function etaMatch(p_dataNasc date) return number is
  eta number;
  data_app date;
  p_anno_cur number;
  p_giorno_nasc number;
  p_mese_nasc number;
  indicatore_anno_bisestile varchar2(50);
begin
  begin
    eta := to_number(to_char(sysdate,'yyyy'))-to_number(to_char(p_dataNasc,'yyyy'));

    p_anno_cur := to_number(to_char(sysdate,'yyyy'));
    p_giorno_nasc := to_number(to_char(p_dataNasc,'dd'));
    p_mese_nasc := to_number(to_char(p_dataNasc,'mm'));

    select decode(mod(p_anno_cur, 4), 0, decode( mod(p_anno_cur, 400), 0, 'bisestile',
           decode( mod(p_anno_cur, 100), 0, 'no_bisestile', 'bisestile')), 'no_bisestile' )
    into indicatore_anno_bisestile from dual;

    if (p_giorno_nasc = 29 AND p_mese_nasc = 2 AND indicatore_anno_bisestile = 'no_bisestile') then
        data_app := to_date(to_char(p_giorno_nasc-1)||'/'||to_char(p_dataNasc,'mm')||'/'|| to_char(sysdate,'yyyy'), 'dd/mm/yyyy');
    else
        data_app := to_date(to_char(p_dataNasc,'dd')||'/'||to_char(p_dataNasc,'mm')||'/'|| to_char(sysdate,'yyyy'), 'dd/mm/yyyy');
    end if;

    if(trunc(data_app)>trunc(sysdate)) then
     eta := eta - 1;
    end if;

    exception
        when others then
                   eta := 1;
  end;
  --dbms_output.put_line('eta ' || to_char(eta));
  return eta;
end etaMatch;

-- calcola gli anni (non compiuti) del lavoratore
-- viene corretto il caso in cui il lavoratore è nato il 29/02
-- MODIFICA ESPOSITO : L'eta viene ora calcolata non alla data di sistema, ma alla data della chiamata
function etaMatchChiamata(p_dataNasc date, p_dataChiamata date) return number is
  eta number;
  data_app date;
  p_anno_cur number;
  p_giorno_nasc number;
  p_mese_nasc number;
  indicatore_anno_bisestile varchar2(50);
begin
  begin
    eta := to_number(to_char(p_dataChiamata,'yyyy'))-to_number(to_char(p_dataNasc,'yyyy'));

    p_anno_cur := to_number(to_char(p_dataChiamata,'yyyy'));
    p_giorno_nasc := to_number(to_char(p_dataNasc,'dd'));
    p_mese_nasc := to_number(to_char(p_dataNasc,'mm'));

    select decode(mod(p_anno_cur, 4), 0, decode( mod(p_anno_cur, 400), 0, 'bisestile',
           decode( mod(p_anno_cur, 100), 0, 'no_bisestile', 'bisestile')), 'no_bisestile' )
    into indicatore_anno_bisestile from dual;

    if (p_giorno_nasc = 29 AND p_mese_nasc = 2 AND indicatore_anno_bisestile = 'no_bisestile') then
        data_app := to_date(to_char(p_giorno_nasc-1)||'/'||to_char(p_dataNasc,'mm')||'/'|| to_char(p_dataChiamata,'yyyy'), 'dd/mm/yyyy');
    else
        data_app := to_date(to_char(p_dataNasc,'dd')||'/'||to_char(p_dataNasc,'mm')||'/'|| to_char(p_dataChiamata,'yyyy'), 'dd/mm/yyyy');
    end if;

    if(trunc(data_app)>trunc(p_dataChiamata)) then
     eta := eta - 1;
    end if;

  exception
    when others then
      eta := 1;
  end;
  --dbms_output.put_line('eta ' || to_char(eta));
  return eta;
end etaMatchChiamata;


function pdCalcoloNumT(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%TYPE,
        p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
       p_strMansione varchar2,
       numComuni number, numProv number) return number is
  nroCom1 number;
  nroProv1 number;
  nroReg1 number;
  --
  nroProv2 number;
  nroReg2 number;
  --
  nroStatoIta number;
  --
  --numComuni number;
  --numProvince number;
  --
  query_str varchar2(4000);
  --
  codComAz AN_UNITA_AZIENDA.CODCOM%type;

begin
  query_str := '';
  -- Inseriamo la possibilità di terminare l'elaborazione appena viene soddisfatta
  -- una delle condizioni

  if(numComuni=0 and numProv=0) then
   -- nel caso in cui non sia specificato nessun territorio utilizzo il comune
  -- della sede dell'azienda
   begin
      select an_az.CODCOM into codComAz
      from DO_RICHIESTA_AZ daz
       inner join AN_UNITA_AZIENDA an_az
        on (daz.prgAzienda=an_az.prgAzienda and daz.prgUnita=an_az.prgUnita)
      where daz.PRGRICHIESTAAZ = p_prgRichiestaAz;
      exception
      when no_data_found then
         codComAz := null;
  end;
  if(codComAz is not null) then
   begin
       query_str := 'select 1 ' ||
           'from PR_MANSIONE prm,PR_DIS_COMUNE dter ' ||
       'where (prm.PRGMANSIONE=dter.PRGMANSIONE) ' ||
           ' and (' || p_strMansione || ') ' ||
          'and prm.CDNLAVORATORE=' || p_cdnLavoratore ||
       ' and (dter.CODCOM=''' || codComAz || ''') ' ||
          ' and rownum=1';

       execute immediate query_str into nroCom1;
      exception
    when no_data_found then
      nroCom1 := null;
    end;
     if(nroCom1=1) then
     return 1;
    end if;
    --
    begin
        query_str:= 'select 1 ' ||
        'from DE_COMUNE, PR_DIS_PROVINCIA,PR_MANSIONE prm ' ||
        'where (''' || codComAz || '''=DE_COMUNE.CODCOM) ' ||
       'and (de_comune.CODPROVINCIA=pr_dis_provincia.CODPROVINCIA) '||
       'and (pr_dis_provincia.PRGMANSIONE=prm.PRGMANSIONE) ' ||
          ' and (' || p_strMansione || ') ' ||
       'and prm.CDNLAVORATORE=' || p_cdnLavoratore ||
         ' and rownum=1';

       execute immediate query_str into nroProv1;
      exception
       when NO_DATA_FOUND then
             nroProv1 := null;
    end;
    if(nroProv1=1) then
     return 1;
    end if;
     --
    begin
       query_str := 'select 1 ' ||
            'from DE_COMUNE, DE_PROVINCIA, PR_DIS_REGIONE, PR_MANSIONE prm ' ||
         'where (''' || codComAz || '''=de_comune.CODCOM) and (de_comune.CODPROVINCIA=de_provincia.CODPROVINCIA) ' ||
           'and (de_provincia.CODREGIONE=PR_DIS_REGIONE.CODREGIONE) ' ||
          'and (PR_DIS_REGIONE.PRGMANSIONE=prm.PRGMANSIONE) ' ||
              ' and (' || p_strMansione || ') ' ||
        'and prm.CDNLAVORATORE=' || p_cdnLavoratore ||
        'and DO_COMUNE.PRGRICHIESTAAZ=' ||p_prgRichiestaAz || ' and rownum=1';

     execute immediate query_str into nroReg1;
     exception
      when NO_DATA_FOUND then
             nroReg1 := null;
   end;
   if(nroReg1=1) then
     return 1;
    end if;
   else
    nroCom1 := 0;
   nroProv1 := 0;
   nroReg1 := 0;
   end if; --  if(codComAz is not null)
  end if; --fine controllo territorio per comune della sede

  IF(numComuni>0) THEN
      begin
       query_str := 'select 1 ' ||
           'from PR_MANSIONE prm,PR_DIS_COMUNE dter, DO_COMUNE dc ' ||
       'where (prm.PRGMANSIONE=dter.PRGMANSIONE) ' ||
           ' and (' || p_strMansione || ') ' ||
          'and prm.CDNLAVORATORE=' || p_cdnLavoratore ||
       ' and (dter.CODCOM=dc.CODCOM) ' ||
          'and dc.PRGRICHIESTAAZ=' || p_prgRichiestaAz || ' and rownum=1';

       execute immediate query_str into nroCom1;
      exception
    when no_data_found then
      nroCom1 := null;
   end;
    if(nroCom1=1) then
    return 1;
   end if;
   --
   begin
       query_str:= 'select 1 ' ||
       'from DO_COMUNE, DE_COMUNE, PR_DIS_PROVINCIA,PR_MANSIONE prm ' ||
       'where (do_comune.CODCOM=DE_COMUNE.CODCOM) ' ||
      'and (de_comune.CODPROVINCIA=pr_dis_provincia.CODPROVINCIA) '||
      'and (pr_dis_provincia.PRGMANSIONE=prm.PRGMANSIONE) ' ||
         ' and (' || p_strMansione || ') ' ||
      'and prm.CDNLAVORATORE=' || p_cdnLavoratore ||
        'and DO_COMUNE.PRGRICHIESTAAZ=' || p_prgRichiestaAz || ' and rownum=1';

      execute immediate query_str into nroProv1;
     exception
      when NO_DATA_FOUND then
            nroProv1 := null;
   end;
   if(nroProv1=1) then
    return 1;
   end if;
    --
   begin
      query_str := 'select 1 ' ||
           'from DO_COMUNE, DE_COMUNE, DE_PROVINCIA, PR_DIS_REGIONE, PR_MANSIONE prm ' ||
        'where (do_comune.CODCOM=de_comune.CODCOM) and (de_comune.CODPROVINCIA=de_provincia.CODPROVINCIA) ' ||
          'and (de_provincia.CODREGIONE=PR_DIS_REGIONE.CODREGIONE) ' ||
         'and (PR_DIS_REGIONE.PRGMANSIONE=prm.PRGMANSIONE) ' ||
             ' and (' || p_strMansione || ') ' ||
       'and prm.CDNLAVORATORE=' || p_cdnLavoratore ||
       'and DO_COMUNE.PRGRICHIESTAAZ=' ||p_prgRichiestaAz || ' and rownum=1';

    execute immediate query_str into nroReg1;
    exception
     when NO_DATA_FOUND then
            nroReg1 := null;
  end;
  if(nroReg1=1) then
    return 1;
   end if;
  ELSE
   nroCom1 := 0;
  nroProv1 := 0;
  nroReg1 := 0;
  END IF;
  --
  IF(numProv>0) THEN
      begin
        query_str := 'select 1 ' ||
           'from PR_MANSIONE prm, PR_DIS_PROVINCIA, DO_PROVINCIA ' ||
       'where (prm.PRGMANSIONE=PR_DIS_PROVINCIA.PRGMANSIONE) ' ||
           ' and (' || p_strMansione || ') ' ||
       'and prm.CDNLAVORATORE=' || p_cdnLavoratore ||
          'and (PR_DIS_PROVINCIA.CODPROVINCIA=DO_PROVINCIA.CODPROVINCIA) ' ||
       'and DO_PROVINCIA.PRGRICHIESTAAZ=' || p_prgRichiestaAz || ' and rownum=1';

      execute immediate query_str into nroProv2;
     exception
        when NO_DATA_FOUND then
            nroProv2 := null;
   end;
   if(nroProv2=1) then
    return 1;
   end if;
    --
   begin
       query_str:= 'select 1 ' ||
       'from DO_PROVINCIA, DE_PROVINCIA, PR_DIS_REGIONE, PR_MANSIONE prm ' ||
       'where (do_provincia.CODPROVINCIA=de_provincia.CODPROVINCIA) ' ||
        'and (de_provincia.CODREGIONE=pr_dis_regione.CODREGIONE) ' ||
      'and (pr_dis_regione.PRGMANSIONE=prm.PRGMANSIONE) ' ||
           ' and (' || p_strMansione || ') ' ||
      'and prm.CDNLAVORATORE=' || p_cdnLavoratore ||
        'and do_provincia.PRGRICHIESTAAZ=' || p_prgRichiestaAz || ' and rownum=1';

      execute immediate query_str into nroReg2;
     exception
      when NO_DATA_FOUND then
            nroReg2:= null;
   end;
   if(nroReg2=1) then
    return 1;
   end if;
  ELSE
    nroProv2 := 0;
   nroReg2 := 0;
  END IF;
  --
  begin
      query_str := 'select 1 ' ||
          'from PR_MANSIONE prm, PR_DIS_STATO dstato ' ||
       'where (prm.PRGMANSIONE=dstato.PRGMANSIONE) ' ||
          ' and (' || p_strMansione || ') ' ||
      'and prm.CDNLAVORATORE=' || p_cdnLavoratore ||
         'and dstato.CODCOM=''Z000'' and rownum=1';

     execute immediate query_str into nroStatoIta;
    exception
       when NO_DATA_FOUND then
           nroStatoIta := null;
  end;
  if(nroStatoIta=1) then
   return 1;
  else
   return null;
  end if;

  exception when others then return null;
end pdCalcoloNumT;

/*********************************************************
* Funzione per la predisposizione dell'asta per le adesioni *
*********************************************************/
function AScreaRosaNomGrezza(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,     -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_codEvasioneRich DO_EVASIONE.Codevasione%type,
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,      -- utente che effettua l'incrocio
    p_errCode OUT number,         -- Codice di Errore
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE, -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE    -- progressivo della rosa
) RETURN NUMBER IS
  p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
  p_codEvasione DO_EVASIONE.CODEVASIONE%TYPE;
  p_Originale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;
  p_TipoIncrocio DE_TIPO_INCROCIO.PRGTIPOINCROCIO%TYPE;
  p_TipoRosa DO_ROSA.PRGTIPOROSA%TYPE;
  p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE;
  checkIncrocio number;
  p_configNumASONLINE number;
  p_flgAsOnline DO_RICHIESTA_AZ.FLGASONLINE%TYPE;

  -- cursore sui vari tipi di incrocio possibile per la creazione della rosa
  /* possibili valori sono :
      5 Art.16 L.56/87
     6 Riserve ex militari
     7 Riserve ex LSU
     8 Riserve in mobilità (eliminato in questa fase)
   */
  CURSOR tipiIncrocioCursor IS
      SELECT ti.prgTipoIncrocio AS prgTipoIncrocio
      FROM De_Tipo_Incrocio ti
      WHERE ti.prgtipoincrocio IN (5,6,7);

  -- cursore sui tipi di profilo per la richiesta selezionata
  CURSOR tipiProfiliCursor IS
      SELECT al.prgAlternativa AS prgAlternativa
      FROM do_alternativa al
      WHERE al.prgrichiestaaz = p_prgRichiestaAz;

begin

   -- controllo che la richiesta sia relativa all'Art.16
   -- se è diversa dall'art. 16 esco senza dare messaggio di errore (posso trovarmi nel caso
   -- di creazione del profilo)
   SELECT dev.codevasione into p_codEvasione
   FROM DO_EVASIONE dev
   WHERE dev.PRGRICHIESTAAZ = p_prgRichiestaAz;
   -- controllo che la modalità di evasine sia AS così posso creare le rose e gli incroci
   if (p_codEvasioneRich is null) then
      if (p_codEvasione is null OR p_codEvasioneRich = '') then
         return 0;
      elsif (p_codEvasione != 'AS') then
         return 0;
      end if;
   elsif (p_codEvasioneRich = '') then
      return 0;
   elsif (p_codEvasioneRich != 'AS') then
      return 0;
   end if;

   -- Controllo se la configrazione riguardante l'Art16 Online è accesa
   p_configNumASONLINE := getNumConfig('ASONLINE');
   -- Controllo che la richiesta non sia stata CHIUSA mentre si accedeva all'incrocio
  SELECT RICH2.PRGRICHIESTAAZ, RICH2.FLGASONLINE INTO p_Originale, p_flgAsOnline
  FROM DO_RICHIESTA_AZ RICH1
         INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
     WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;
  -- Per la rosa nominativa controllo la chiusura totale e la chiusura
  SELECT do_evasione.CDNSTATORICH into p_cdnStatoRich
  FROM DO_RICHIESTA_AZ, DO_EVASIONE
  WHERE (DO_RICHIESTA_AZ.PRGRICHIESTAAZ=DO_EVASIONE.PRGRICHIESTAAZ)
  AND DO_RICHIESTA_AZ.PRGRICHIESTAAZ=p_Originale;
  if(p_cdnStatoRich=5) then
   return 2;
   elsif (p_cdnStatoRich=4) then
   return 3;
  end if;

   -- verificare se ho già salvato (posso vedere se già esiste per i profili lo stesso prgrichiestaAz)
   -- ciclo sul cursore dei profili per recuperare tutti i profili per quella richiesta
   FOR profilo in tipiProfiliCursor
   LOOP

      p_prgAlternativa :=  profilo.prgAlternativa;

      -- ciclo sul cursor per recuperare i tipi di incrocio possibili per l'Art. 16
      FOR tipiIncrocio in tipiIncrocioCursor
      LOOP
         p_TipoIncrocio := tipiIncrocio.prgTipoIncrocio;

         -- verifico che per la terna di valori prgAlternativa, prgRichiestaAz, prgTipoIncrocio
         -- 1) se esiste nessun record in do_incrocio salto l'insrimento dell'incrocio
         -- 2) se non esiste inserisco l'incrocio e la rosa corrispondente
         SELECT COUNT(inc.prgIncrocio) into checkincrocio FROM do_incrocio inc
         WHERE inc.prgrichiestaaz = p_prgRichiestaAz
         AND inc.prgalternativa = p_prgAlternativa
         AND inc.prgtipoincrocio = p_TipoIncrocio;

         IF (checkincrocio = 0) THEN

           -- a seconda del tipo di incrocio cambia il tipo rosa da inserire in do_rosa
          if p_configNumASONLINE = 1 and nvl(p_flgAsOnline, 'N') = 'S' then
            if (p_TipoIncrocio = 5) then
              p_TipoRosa := 2;
            elsif (p_TipoIncrocio = 6) then
              p_TipoRosa := 1;
            elsif (p_TipoIncrocio = 7) then
             p_TipoRosa := 1;
            end if;
          else
             if (p_TipoIncrocio = 5) then
                p_TipoRosa := 1;
             elsif (p_TipoIncrocio = 6) then
                p_TipoRosa := 1;
             elsif (p_TipoIncrocio = 7) then
               p_TipoRosa := 1;
             end if;
          end if;

          -- Calcolo il progressivo per la rosa e per l'incrocio
          select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
          select S_DO_ROSA.nextVal into p_out_prgRosa from dual;
          --dbms_output.put_line('Prg Incrocio=' || p_out_prgIncrocio || ' - Prg Rosa=' || p_out_prgRosa);
          -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio, inserisce anche il prgAlternativa
          insert into do_incrocio
          (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
          cdnUtIns, dtmIns, cdnUtMod, dtmMod)
          values
          (p_out_prgIncrocio, p_prgRichiestaAz, p_prgAlternativa, p_TipoIncrocio, 'C',
          p_cdnUtente, sysdate, p_cdnUtente, sysdate);
          -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
          insert into do_rosa
          (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod, flgasonline)
          values
          (p_out_prgRosa, null, p_out_prgIncrocio, p_TipoRosa, p_cdnUtente, sysdate, p_cdnUtente, sysdate, p_flgAsOnline);
          -- NB. Per le rose nomninative NON memorizzo i parametri dell'incrocio

         END IF;

     END LOOP;

   END LOOP;

   commit;

  return 0;

  exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;
end AScreaRosaNomGrezza;

/**************************************************************************************
* Funzione per la cancellazione del profilo della rosa e degli incroci corrispondenti *
***************************************************************************************/
function ASdeleteProfiloRosaNomGrezza(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,               -- progressivo della richiesta (originale o copia di lavoro)
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,       -- progressivo del profilo
    p_errCode OUT number           -- Codice di Errore
) RETURN NUMBER IS

 p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
 p_TipoIncrocio DE_TIPO_INCROCIO.PRGTIPOINCROCIO%TYPE;
 checkProfilo number;
 checkTipoRosa DO_ROSA.PRGTIPOROSA%TYPE;

 -- cursore sui vari tipi di incrocio possibile
  /* possibili valori sono :
      5 Art.16 L.56/87
     6 Riserve ex militari
     7 Riserve ex LSU
     8 Riserve in mobilità (eliminato in questa fase)
   */
  CURSOR tipiIncrocioCursor IS
      SELECT ti.prgTipoIncrocio AS prgTipoIncrocio
      FROM De_Tipo_Incrocio ti
      WHERE ti.prgtipoincrocio IN (5,6,7,8,9,13,14,10,11,12);

begin

      -- Per la rosa nominativa controllo la chiusura totale e la chiusura
     SELECT do_evasione.CDNSTATORICH into p_cdnStatoRich
     FROM DO_RICHIESTA_AZ, DO_EVASIONE
     WHERE (DO_RICHIESTA_AZ.PRGRICHIESTAAZ=DO_EVASIONE.PRGRICHIESTAAZ)
     AND DO_RICHIESTA_AZ.PRGRICHIESTAAZ=p_prgRichiestaAz;
     if(p_cdnStatoRich=5) then
       return 2;
      elsif (p_cdnStatoRich=4) then
       return 3;
     end if;


      -- controllo se non esiste nessun nominativo per la rosa da eliminare
      -- la rosa è ancora temporanea
      select max(r.prgtiporosa) into checkTipoRosa
      from do_alternativa a, do_rosa r, do_incrocio i
      where a.prgrichiestaaz = i.prgrichiestaaz
      and a.prgalternativa = i.prgalternativa
      and i.prgincrocio = r.prgincrocio
      and a.prgalternativa = p_prgAlternativa
      and i.prgrichiestaaz = p_prgRichiestaAz;

      -- se la rosa non è ancora temporanea
      if (checkTipoRosa is null) then

        delete from do_alternativa
               where prgRichiestaAz=p_prgRichiestaAz
               and prgAlternativa=p_prgAlternativa;

        commit;

        return 0;

      -- se la rosa è temporanea
      elsif (checkTipoRosa = 1) then

        -- ciclo per recuperare tutti i progressivi dell'incrocio per il profilo da cancellare
        FOR tipiIncrocio in tipiIncrocioCursor
        LOOP
            p_TipoIncrocio := tipiIncrocio.prgTipoIncrocio;

            -- controllo se esiste un profilo associato ad un incrocio per
            -- l'Asta Art.16 e corrispondente rosa
            select count(a.prgalternativa) into checkProfilo
            from do_alternativa a, do_rosa r, do_incrocio i
            where a.prgrichiestaaz = i.prgrichiestaaz
            and a.prgalternativa = i.prgalternativa
            and i.prgincrocio = r.prgincrocio
            and r.prgtiporosa = 1
            and a.prgalternativa = p_prgAlternativa
            and i.prgrichiestaaz = p_prgRichiestaAz
            and i.prgtipoincrocio = p_TipoIncrocio;

           if (checkProfilo > 0) then
               -- cancello le rose corrispondenti al profilo da eliminare
               delete from do_rosa
                   where prgTipoRosa = 1
                   and prgIncrocio =
                   (select inc.prgIncrocio from do_incrocio inc
                    where inc.prgrichiestaaz = p_prgRichiestaAz
                    and inc.prgalternativa = p_prgAlternativa
                    and inc.prgtipoincrocio = p_TipoIncrocio);

               -- cancello gli incroci corrispondenti al profilo da eliminare
               delete from do_incrocio
                   where prgrichiestaaz = p_prgRichiestaAz
                   and prgalternativa = p_prgAlternativa
                   and prgtipoincrocio = p_TipoIncrocio;
          end if;
        END LOOP;

        -- cancello il profilo
        delete from do_alternativa
               where prgRichiestaAz=p_prgRichiestaAz
               and prgAlternativa=p_prgAlternativa;

        commit;

        return 0;

      else
        -- ritorna un errore per indicare che il profilo cercato ha almeno una adesione
        return 1;
      end if;

 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASdeleteProfiloRosaNomGrezza;


/**************************************************************************************
* Funzione per l'inserimento di una adesione per il lavoratore specifico alla richiesta *
***************************************************************************************/
function ASInsertAdesioneLavoratore(
    p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
      p_prgSpiContatto Ag_Contatto.Prgspicontatto%TYPE,                 -- operatore selezionato
      p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
      p_cdnGruppo Ts_Gruppo.Cdngruppo%TYPE,                       -- gruppo a cui fa parte l'utente
      p_errCode OUT number,           -- Codice di Errore
      p_codmonodid   IN      do_nominativo.codmonodid%type, -- Calcolo Did (Da Sil, A prescindere, o escludi)
      p_codmonoisee  IN      do_nominativo.codmonoisee%type, -- Calcolo Isee (Da Sil o escludi)
	  p_numcaricofam IN      do_nominativo.numcaricofam%type,
	  p_flgprofessionalita IN do_nominativo.flgprofessionalita%type,
	  p_flgfamdec      IN     do_nominativo.flgfamdec%type)
 RETURN NUMBER IS

p_out_prgNominativo DO_NOMINATIVO.Prgnominativo%TYPE;
p_prgRichiestaAz DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE;
p_prgincrocio DO_INCROCIO.Prgincrocio%TYPE;
p_prgAlternativa DO_INCROCIO.Prgalternativa%TYPE;
p_prgTipoIncrocio DO_INCROCIO.Prgtipoincrocio%TYPE;
datChiamata do_richiesta_az.datchiamata%type;
p_numvaloreisee number;
p_countisee number;
statorich do_evasione.cdnstatorich%TYPE;
checkInsertContatto number;
checkRosaLSU number;
checkPunteggio number;
checkStoricizzazione number;
checkAdesione number;

begin

  select i.prgtipoincrocio, i.prgincrocio, i.prgrichiestaaz, i.prgalternativa, i.prgtipoincrocio
         into checkRosaLSU, p_prgincrocio, p_prgRichiestaAz, p_prgAlternativa, p_prgTipoIncrocio
  from do_rosa d
  inner join do_incrocio i on i.prgincrocio = d.prgincrocio
  WHERE d.PRGROSA = p_prgRosa;

  -- verifico che si è già inserito l'adesione per quella graduatoria in un proflo diverso
  select count(nom.prgnominativo) into checkAdesione
  from do_nominativo nom
  inner join do_rosa ros on ros.prgrosa = nom.prgrosa
  inner join do_incrocio inc on inc.prgincrocio = ros.prgincrocio
  inner join do_richiesta_az rich on rich.prgrichiestaaz = inc.prgrichiestaaz
  where nom.cdnlavoratore = p_cdnLavoratore
  and inc.prgtipoincrocio = p_prgTipoIncrocio
  and rich.prgrichiestaaz = p_prgRichiestaAz
  and ros.prgrosafiglia is null;

  -- errore non è possibile inserire due adesioni per la stesso tipo di graduatoria e profili diversi
  if (checkAdesione >= 1) then
     rollback;
     return 3;
  end if;

  -- Calcolo il progressivo per il nominativo
  select s_Do_Nominativo.nextVal into p_out_prgNominativo from dual;


  -- 24/04/2020 passo 0
   -- Memorizza il valore ISEE riferito a data chiamata.
    -- Se il dato ISEE riferito a data chiamata non è presente si memorizza il valore -1

  select az.datchiamata into datChiamata
  from do_richiesta_az az
  where az.prgrichiestaaz = p_prgRichiestaAz;

  select count(*) into p_countisee
  from AS_VALORE_ISEE v
  where v.cdnlavoratore = p_cdnLavoratore
  and v.datinizioval <= datChiamata
  and (v.datfineval is null or v.datfineval >= datChiamata);

  if p_countisee >0 then
    select v.numvaloreisee into p_numvaloreisee
    from AS_VALORE_ISEE v
    where v.cdnlavoratore = p_cdnLavoratore
    and v.datinizioval <= datChiamata
    and (v.datfineval is null or v.datfineval >= datChiamata);
  else
    p_numvaloreisee := -1;
  end if;

   -- passo 1. inserisco la nuova adesione in do_nominativo per la rosa specifica
  insert into do_nominativo
  (PRGNOMINATIVO, CDNLAVORATORE, DTMINS, CDNUTINS, PRGROSA,CODMONODID,CODMONOISEE,NUMVALOREISEE, NUMCARICOFAM, FLGPROFESSIONALITA, FLGFAMDEC )
  values
  (p_out_prgNominativo, p_cdnLavoratore, sysdate, p_cdnUtente, p_prgRosa, p_codmonodid, p_codmonoisee, p_numvaloreisee, p_numcaricofam, p_flgprofessionalita, p_flgfamdec);

  -- passo 2. aggiorno la rosa da temporanea a grezza
  UPDATE DO_ROSA
        SET DO_ROSA.PRGTIPOROSA = 2,
           DO_ROSA.NUMKLOROSA = (SELECT TO_NUMBER(DO_ROSA.NUMKLOROSA+1) FROM DO_ROSA DOS WHERE DOS.PRGROSA = DO_ROSA.PRGROSA)
      WHERE DO_ROSA.PRGROSA = p_prgRosa;



   -- passo 3. storicizzo stato occupazionale del lavoratore
  checkStoricizzazione := ASStoricizzaStatoOcc(p_prgRichiestaAz,p_cdnLavoratore,p_prgincrocio,p_cdnUtente);

  if (checkStoricizzazione != 0) then
     -- se non esiste mando in errore la procedura
     rollback;
     return checkStoricizzazione;
  end if;


  if (checkrosalsu != 7) then
     -- passo 3. calcolo il punteggio del lavoratore
     checkPunteggio := calcolopunteggiolavoratore(p_out_prgNominativo, 'AS','N',null, p_cdnUtente, p_errCode);

     if (checkPunteggio < 0) then
      return checkPunteggio;
     end if;

  end if;

  -- richiamo la funzione per l'inserimento del contatto
  checkInsertContatto := ASINSERTCONTATTOADESIONE(p_prgrosa,
                                                  p_out_prgNominativo,
                                                p_cdnLavoratore,
                                                  p_prgSpiContatto,
                                                  p_cdnUtente,
                                                  p_cdngruppo,
                                                p_errCode
                                                 );

   -- cambio lo stato della richiesta ad ELABORAZIONE MATCH solamente se lo stato precedente è "inserita"
   select DO_EVASIONE.CDNSTATORICH into statorich from DO_EVASIONE where DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;

   if (statorich = 1) then
     UPDATE DO_EVASIONE
         SET DO_EVASIONE.CDNSTATORICH = 2,
             DO_EVASIONE.DTMMOD = SYSDATE
         WHERE DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;
   end if;

   if (checkInsertContatto = 0) then
      --commit;
      return 0;
   else
      return -1;
   end if;

 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASInsertAdesioneLavoratore;


/**************************************************************************************
* Funzione per l'aggiornamento di una adesione per il lavoratore specifico alla richiesta *
***************************************************************************************/
function ASUpdateAdesioneLavoratore(
    p_prgNominativo Do_nominativo.Prgnominativo%TYPE,                                   -- progressivo della rosa
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
    p_codmonodid   do_nominativo.codmonodid%type, -- Calcolo Did (Da Sil, A prescindere, o escludi)
    p_codmonoisee  do_nominativo.codmonoisee%type, -- Calcolo Isee (Da Sil o escludi)
	p_numcaricofam IN      do_nominativo.numcaricofam%type,
	p_flgprofessionalita IN do_nominativo.flgprofessionalita%type,
	p_flgfamdec      IN     do_nominativo.flgfamdec%type,
    p_errCode OUT number         -- Codice di Errore
) RETURN NUMBER IS
p_numklodonomi do_nominativo.numklonominativo%type;
queryWhere varchar2(250);
checkPunteggio number;
checktipoincrocio do_incrocio.prgtipoincrocio%type;

begin
  
select inc.prgtipoincrocio
 into checktipoincrocio
 from do_nominativo nom
  inner join do_rosa r on nom.prgrosa = r.prgrosa 
   inner join do_incrocio inc on r.prgincrocio = inc.prgincrocio
   where nom.prgnominativo = p_prgNominativo;

select t.numklonominativo into p_numklodonomi  from do_nominativo t where t.prgnominativo = p_prgNominativo;

    queryWhere :=  ' WHERE prgnominativo = ' || p_prgNominativo;

     PG_LOG.doLog('U', 'DO_NOMINATIVO', p_cdnUtente, queryWhere);



UPDATE DO_NOMINATIVO t
set t.codmonodid = p_codmonodid,
    t.codmonoisee = p_codmonoisee,
	t.numcaricofam = p_numcaricofam,
	t.flgprofessionalita = p_flgprofessionalita,
	t.flgfamdec   = p_flgfamdec,
    t.numklonominativo = p_numklodonomi +1,
    t.cdnutmodcm   = p_cdnUtente,
    t.dtmmodcm     = sysdate
  where t.prgnominativo = p_prgNominativo;

if checktipoincrocio != 7 then
     checkPunteggio := calcolopunteggiolavoratore(p_prgNominativo, 'AS','N',null, p_cdnUtente, p_errCode);
end if;

 return 0;

 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
 --        rollback;
       return -1;

end ASUpdateAdesioneLavoratore;
/**************************************************************************************
* Funzione per la cancellazione di una adesione per il lavoratore specifico           *
* e il cambio dello stato della rosa a temporanea se non vi sono altre adesioni       *
***************************************************************************************/
function ASDeleteAdesioneLavoratore(
    p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
      p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,                  -- progressivo dell'adesione
    p_errCode OUT number           -- Codice di Errore
) RETURN NUMBER IS

p_out_prgTipoRosa DO_ROSA.Prgtiporosa%TYPE;
p_out_dataIns DO_NOMINATIVO.Dtmins%TYPE;
checkAdesioni number;
checkDeleteContatto number;
p_prgRichiestaAz DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE;
p_prgincrocio DO_INCROCIO.PRGINCROCIO%TYPE;
checkNominativi number;
checkDelStoria number;
p_statoRich number;
begin

  select nom.dtmins into p_out_dataIns
  from do_nominativo nom
  where nom.prgnominativo = p_prgNominativo;

  -- richiamo la funzione per la cancellazione del contatto
  checkDeleteContatto := ASDELETECONTATTOADESIONE(p_prgrosa,
                                                      p_prgNominativo,
                                                    p_cdnLavoratore,
                                                      p_out_dataIns,
                                                    p_errCode
                                                     );

  if (checkDeleteContatto = 0) then

    select do_rosa.prgtiporosa, do_rosa.prgincrocio
           into p_out_prgtiporosa, p_prgincrocio
           from do_rosa
           where do_rosa.prgrosa = p_prgRosa;


    -- elimino la storicizzazione dello stato occupazionele
    checkDelStoria := ASDeleteStoriaStatoOcc(p_cdnLavoratore, p_prgincrocio);

    if (p_out_prgtiporosa = 2) then

        -- passo 1: cancello il punteggio riferito al lavoratore
       delete from as_punteggio
                 where PRGNOMINATIVO = p_prgNominativo;

       -- passo 2: cancello l'adesione
       delete from do_nominativo
                 where PRGNOMINATIVO = p_prgNominativo
                 and CDNLAVORATORE = p_cdnLavoratore;


       -- controllo se vi sono altre adesione per la stessa richiesta
       -- per update rosa: non si aggiorna la rosa a temporanea perchè ci sono altre adesioni
       -- errore non bloccante
       select count(n.prgnominativo) into checkAdesioni
              from do_nominativo n
              where n.prgrosa = p_prgRosa
              and n.cdnlavoratore != p_cdnLavoratore;

       if (checkAdesioni = 0) then

         -- passo 2: aggiorno la rosa da grezza a temporanea
         UPDATE DO_ROSA
              SET DO_ROSA.PRGTIPOROSA = 1,
                 DO_ROSA.NUMKLOROSA = (SELECT TO_NUMBER(DO_ROSA.NUMKLOROSA+1) FROM DO_ROSA DOS WHERE DOS.PRGROSA = DO_ROSA.PRGROSA)
            WHERE DO_ROSA.PRGROSA = p_prgRosa;

       end if;

       -- passo 3: aggiorno lo stato di evasione della richiesta a INSERITA
       -- si controlla se vi sono altri nominativi che aderiscono sulla richiesta
       -- si controlla se la richiesta è in stato elaborazione match
       select inc.prgrichiestaaz into p_prgRichiestaAz
         from do_incrocio inc
         inner join do_rosa r on r.prgincrocio = inc.prgincrocio
         where r.prgrosa = p_prgrosa;

       select DO_EVASIONE.CDNSTATORICH into p_statoRich
       from DO_EVASIONE
       WHERE DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;

       if (p_statoRich = 2) then
         select count(n.prgnominativo) into checkNominativi
         from do_nominativo n
         where n.prgrosa IN
         (select r.prgrosa
                 from do_rosa r
                 inner join do_incrocio inc on inc.prgincrocio = r.prgrosa
                 where inc.prgrichiestaaz = p_prgRichiestaAz
                 and r.prgrosafiglia is null
                 and (r.prgtiporosa = 2 or r.prgtiporosa = 3));

         if (checkNominativi = 0) then

           UPDATE DO_EVASIONE
               SET DO_EVASIONE.CDNSTATORICH = 1,
                   DO_EVASIONE.DTMMOD = SYSDATE
               WHERE DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;

          end if;
       end if;

    else
       -- errore tipoRosa: la rosa non è grezza impossibile eliminare l'adesione
       return 1;
    end if;

    commit;

    return 0;

  else
    return -1;
  end if;

 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASDeleteAdesioneLavoratore;


/**************************************************************************************
* Funzione per l'inserimento di un contatto per l'adesione alla richiesta *
***************************************************************************************/
function ASInsertContattoAdesione(
      p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
      p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,                 -- progressivo dell'adesione
    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del lavoratore
      p_prgSpiContatto Ag_Contatto.Prgspicontatto%TYPE,                 -- operatore selezionato
      p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
      p_cdnGruppo Ts_Gruppo.Cdngruppo%TYPE,                       -- gruppo a cui fa parte l'utente
    p_errCode OUT number                                    -- Codice di Errore
) RETURN NUMBER IS

p_out_prgContatto Ag_Contatto.Prgcontatto%TYPE;
p_out_txtcontatto Ag_Contatto.Txtcontatto%TYPE;
p_out_codcpi ts_gruppo.strcodrif%TYPE;
p_out_prgMotContatto ag_contatto.prgmotcontatto%TYPE;
p_out_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE;

begin

  -- Recupero codice CPI
  select g.strcodrif into p_out_codcpi from ts_gruppo g where g.cdngruppo = p_cdngruppo;

  -- recupero il campo txt contatto come l'unione della richiesta/anno/profilo
  -- e il tipo incrocio per sapere il tipo motivo contatto
  select inc.prgtipoincrocio,
  'Rich: '||raz.numrichiesta ||'/'|| raz.numanno ||'/'|| a.prgalternativa || ' - grad.' || p_prgRosa
  into p_out_prgTipoIncrocio, p_out_txtcontatto
  from do_richiesta_az raz
 inner join do_incrocio inc on inc.prgrichiestaaz =raz.prgrichiestaaz
 inner join do_rosa r on r.prgincrocio = inc.prgincrocio
 inner join do_alternativa a on a.prgrichiestaaz = raz.prgrichiestaaz and a.prgalternativa = inc.prgalternativa
  where r.prgrosa = p_prgRosa;

  if (p_out_prgTipoIncrocio = 5) then
     p_out_prgMotContatto := 7;
  else
     p_out_prgMotContatto := 8;
  end if;

  -- Calcolo il progressivo per il contatto
  select s_ag_contatto.nextVal into p_out_prgContatto from dual;

  insert into ag_contatto
  (PRGCONTATTO, CODCPICONTATTO, DATCONTATTO, STRORACONTATTO,
  PRGSPICONTATTO, STRIO, PRGMOTCONTATTO,
  PRGTIPOCONTATTO, PRGEFFETTOCONTATTO, CDNLAVORATORE,
  CDNUTINS, CDNUTMOD, DTMINS, DTMMOD, TXTCONTATTO)
  values
  (p_out_prgContatto, p_out_codcpi, sysdate, to_char(sysdate, 'HH24:MI'),
  p_prgSpiContatto, 'I', p_out_prgMotContatto,
  4, 6, p_cdnLavoratore,
  p_cdnUtente, p_cdnUtente, sysdate, sysdate, p_out_txtcontatto
  );

  return 0;

 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASInsertContattoAdesione;

/**************************************************************************************
* Funzione per la cancellazione di un contatto per l'adesione alla richiesta *
***************************************************************************************/
function ASDeleteContattoAdesione(
      p_prgRosa Do_Rosa.Prgrosa%TYPE,
      p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,                 -- progressivo dell'adesione                                -- progressivo della rosa
    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del lavoratore
     p_dataIns do_nominativo.dtmins%TYPE,                       -- data inserimento adesione
      p_errCode OUT number                                    -- Codice di Errore
) RETURN NUMBER IS

p_out_prgContatto Ag_Contatto.Prgcontatto%TYPE;
p_out_txtcontatto Ag_Contatto.Txtcontatto%TYPE;
p_out_codcpi ts_gruppo.strcodrif%TYPE;
p_out_prgMotContatto ag_contatto.prgmotcontatto%TYPE;
p_out_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE;
p_msgErr varchar2(1000);
begin

  select
  'Rich: '||raz.numrichiesta ||'/'|| raz.numanno ||'/'|| a.prgalternativa || ' - grad.' || p_prgRosa
  into p_out_txtcontatto
  from do_richiesta_az raz
 inner join do_incrocio inc on inc.prgrichiestaaz =raz.prgrichiestaaz
 inner join do_rosa r on r.prgincrocio = inc.prgincrocio
 inner join do_alternativa a on a.prgrichiestaaz = raz.prgrichiestaaz and a.prgalternativa = inc.prgalternativa
  where r.prgrosa = p_prgRosa;

  delete from ag_contatto c
         where c.txtcontatto = p_out_txtcontatto
         and c.cdnlavoratore = p_cdnLavoratore
         and c.prgeffettocontatto = 6
         and c.prgmotcontatto IN (7,8)
         and to_char(c.datcontatto, 'DD/MM/YYYY') = to_char(p_dataIns, 'DD/MM/YYYY')
         ;

  return 0;

 exception
      when others then
         p_errCode := sqlcode;
             p_msgErr := sqlerrm;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASDeleteContattoAdesione;

/***************************************************************************
* Funzione per la verifica del tiporosa nell'aggiornamento della richiesta *
****************************************************************************/
function AScheckTipoRosa(
    p_prgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,       -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
      p_prgTipoIncrocio DO_INCROCIO.PRGTIPOINCROCIO%TYPE,     -- tipo dell'incrocio
    p_errCode OUT number         -- Codice di Errore
) RETURN NUMBER IS

  p_TipoRosa DO_ROSA.PRGTIPOROSA%TYPE;
  p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE;

  -- cursore sui vari tipi di incrocio possibile per la creazione della rosa
  /* possibili valori sono :
      5 Art.16 L.56/87
     6 Riserve ex militari
     7 Riserve ex LSU
     8 Riserve in mobilità (eliminato in questa fase)
   */
  CURSOR tipiIncrocioCursor IS
      SELECT ti.prgTipoIncrocio AS prgTipoIncrocio
      FROM De_Tipo_Incrocio ti
      WHERE ti.prgtipoincrocio IN (5,6,7,8,9,13,14,10,11,12);

  -- cursore sui tipi di profilo per la richiesta selezionata
  CURSOR tipiProfiliCursor IS
      SELECT al.prgAlternativa AS prgAlternativa
      FROM do_alternativa al
      WHERE al.prgrichiestaaz = p_prgRichiestaAz;

begin

   -- verificare se ho già salvato (posso vedere se già esiste per i profili lo stesso prgrichiestaAz)
   -- ciclo sul cursore dei profili per recuperare tutti i profili per quella richiesta
   FOR profilo in tipiProfiliCursor
   LOOP

     p_prgAlternativa :=  profilo.prgAlternativa;

     select r.prgtiporosa into p_tipoRosa
     from do_incrocio i
     inner join do_rosa r on r.prgincrocio = i.prgincrocio
     where i.prgrichiestaaz = p_prgRichiestaAz
     and r.prgrosafiglia is null
     and i.prgtipoincrocio = p_prgTipoIncrocio
     and i.prgalternativa = p_prgAlternativa;

     -- se il tipo rosa è diverso da temporanea setto l'errore
     if (p_tipoRosa = 2) then
        return 1;
     elsif (p_tiporosa = 3) then
        return 1;
     end if;

   END LOOP;

  return 0;

  exception
        when NO_DATA_FOUND then
          return 0;
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;
end AScheckTipoRosa;

/*
vecchia gestione da cancellare
*/
function ASRiaperturaGraduatoria(
      p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa da copiare
      p_numklorosa Do_Rosa.Numklorosa%TYPE,                             -- Numklorosa della rosa da aggiornare
      p_prgIncrocio Do_Incrocio.Prgincrocio%TYPE,                       -- progressivo dell'incricio da copiare
      p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
      p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,               -- progressivo dell'incrocio
      p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE,                        -- progressivo della rosa
      p_errCode OUT number                                             -- Codice di Errore
      ) RETURN NUMBER is

begin

   -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;

  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  select p_out_prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  p_cdnUtente, sysdate, p_cdnUtente, sysdate
   from do_incrocio
   where do_incrocio.prgIncrocio = p_prgIncrocio;

   -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  select p_out_prgRosa, null, p_out_prgIncrocio, 2, p_cdnUtente, sysdate, p_cdnUtente, sysdate
   from do_rosa
   where do_rosa.prgRosa = p_prgRosa
   and do_rosa.prgIncrocio = p_prgIncrocio;

   -- passo 3: insersco tutti i nominativi della rosa madre nella nuova rosa figlia
   insert into do_nominativo
   (PRGNOMINATIVO,
   CDNLAVORATORE,
   NUMORDINE,
   CODCPITIT,
   CODTIPOINS,
   DTMINS,
   CDNUTINS,
   CODTIPOCANC,
   STRMOTIVOCANC,
   DTMCANC,
   CDNUTCANC,
   PRGROSA,
   NUMPESOETA,
   NUMPESOTITOLO,
   NUMPESOMANSIONE,
   NUMPESOESP,
   NUMPESOINFO,
   NUMPESOLINGUA,
   DECINDICEVICINANZA,
   DATDICHIARAZIONE,
   numpunteggio,
   NUMANZIANITALSU,
   FLGPROFESSIONALITA,
   NUMCARICOFAM,
   datiscrart1,
    numannopuntart1,
    strpriorita,
    strnota,
    numreddito,
    numpersone,
    datdichcarico,
    codcmtipoiscr,
    numpercinvalidita,
    datanzianita68,
    dtmpunteggio,
    cdnutmodcm,
    dtmmodcm,
    numpunteggiopres,
    nummesianz)
   select s_Do_Nominativo.Nextval,
   CDNLAVORATORE,
   NUMORDINE,
   CODCPITIT,
   CODTIPOINS,
   sysdate,
   p_cdnUtente,
   CODTIPOCANC,
   STRMOTIVOCANC,
   DTMCANC,
   CDNUTCANC,
   p_out_prgRosa,
   NUMPESOETA,
   NUMPESOTITOLO,
   NUMPESOMANSIONE,
   NUMPESOESP,
   NUMPESOINFO,
   NUMPESOLINGUA,
   DECINDICEVICINANZA,
   DATDICHIARAZIONE,
   numpunteggio,
   NUMANZIANITALSU,
   FLGPROFESSIONALITA,
   NUMCARICOFAM,
   datiscrart1,
    numannopuntart1,
    strpriorita,
    strnota,
    numreddito,
    numpersone,
    datdichcarico,
    codcmtipoiscr,
    numpercinvalidita,
    datanzianita68,
    dtmpunteggio,
    cdnutmodcm,
    dtmmodcm,
    numpunteggiopres,
    nummesianz
   from do_nominativo
   where do_nominativo.prgRosa = p_prgRosa;

   -- passo 4: aggiorno nella rosa madre il prgRosaFiglia con il prgRosa della nuova rosa creata
   UPDATE DO_ROSA
   SET DO_ROSA.PRGROSAFIGLIA = p_out_prgRosa,
   DO_ROSA.NUMKLOROSA = p_numklorosa+1,
   DO_ROSA.Cdnutmod = p_cdnUtente,
   DO_ROSA.DTMMOD = SYSDATE
   WHERE DO_ROSA.PRGROSA = p_prgRosa;

   commit;

   return 0;

  exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;
end ASRiaperturaGraduatoria;

/***************************************************************************
* Funzione per la verifica della presenza della DID alla data di pubblicazione *
****************************************************************************/
function ASPresenzaDispDID(
    p_cdnLavoratore   DO_NOMINATIVO.CDNLAVORATORE%TYPE,       -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_dataPubblicazione DO_RICHIESTA_AZ.DATPUBBLICAZIONE%TYPE,     -- tipo dell'incrocio
    p_dataChiamata      DO_RICHIESTA_AZ.DATCHIAMATA%TYPE,
    p_errCode OUT number         -- Codice di Errore
) RETURN BOOLEAN IS

p_dichdisp number;
BEGIN 

  
select count(*) 
  into p_dichdisp
  from AM_DICH_DISPONIBILITA t 
 inner join am_elenco_anagrafico v on
   t.prgelencoanagrafico = v.prgelencoanagrafico
  inner join am_stato_occupaz ast on v.cdnlavoratore = ast.cdnlavoratore
  inner join de_stato_occupaz dst on (ast.codstatooccupaz = dst.codstatooccupaz) 
  where v.cdnlavoratore = p_cdnLavoratore 
  and t.codstatoatto = 'PR'
   and trunc(t.datdichiarazione) < trunc(p_dataPubblicazione)
  and (trunc(nvl(t.datfine,p_dataPubblicazione)) >= trunc(p_dataPubblicazione))
  and trunc(ast.datinizio) <= trunc(p_dataPubblicazione)
  and (trunc(nvl(ast.datfine, p_dataPubblicazione)) >= trunc(p_dataPubblicazione))
  and dst.codstatooccupazragg in ('D', 'I')
  and dst.codstatooccupaz != 'B1'
  ;  

 if p_dichdisp > 0 then
    return true;
 else 
   return false;
 end if;
 
 

  exception
        when NO_DATA_FOUND then
          return false;
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       return false;
end ASPresenzaDispDID;


/***************************************************************************
* Funzione per la verifica dello Stato Occupazionale Disoccupato o Inoccupato a Data Chiamata *
****************************************************************************/
function ASStatoOccDataChiam(
    p_cdnLavoratore   DO_NOMINATIVO.CDNLAVORATORE%TYPE,       -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_dataChiamata      DO_RICHIESTA_AZ.DATCHIAMATA%TYPE,
    p_dataPubblicazione DO_RICHIESTA_AZ.DATPUBBLICAZIONE%TYPE,
    p_config            Ts_Config_Loc.num%type,
    p_errCode OUT number         -- Codice di Errore
) RETURN BOOLEAN IS

p_dichdisp number;
BEGIN 

if p_config = 3 then  
	select count(*)
	  into p_dichdisp
	  from  an_lavoratore v
	  inner join am_stato_occupaz ast on v.cdnlavoratore = ast.cdnlavoratore
	  inner join de_stato_occupaz dst on (ast.codstatooccupaz = dst.codstatooccupaz)
	  where v.cdnlavoratore = p_cdnLavoratore
	  and trunc(ast.datinizio) <= trunc(p_dataPubblicazione)
	  and (trunc(nvl(ast.datfine, p_dataPubblicazione)) >= trunc(p_dataPubblicazione))
	  and dst.codstatooccupazragg in ('D', 'I')
	  and dst.codstatooccupaz != 'B1' ;

	 if p_dichdisp > 0 then
		return true;
	 else 
	   return false;
	 end if;
elsif p_config = 2 then
	 	select count(*)
		into p_dichdisp
		from  an_lavoratore v
    inner join am_stato_occupaz ast on v.cdnlavoratore = ast.cdnlavoratore
		inner join de_stato_occupaz dst on (ast.codstatooccupaz = dst.codstatooccupaz)
		where v.cdnlavoratore = p_cdnLavoratore
		and trunc(ast.datinizio) < trunc(p_dataPubblicazione)
    and (trunc(nvl(ast.datfine, p_dataPubblicazione)) >= trunc(p_dataPubblicazione)-1)
		and dst.codstatooccupazragg in ('D', 'I')
		and dst.codstatooccupaz != 'B1' ;


	 if p_dichdisp > 0 then
		return true;
	 else 
	   return false;
	 end if;
else
   	return false;
end if;	


  exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       return false;
end ASStatoOccDataChiam;

/***************************************************************************
* Funzione per la verifica dello stato Occupazionale a Data Chiamata per maggiorazione punteggio Art.16 in caso Fam.Deceduto sul lavoro *
****************************************************************************/
function ASStatoOccupazFamDec(
    p_prgnominativo   DO_NOMINATIVO.PRGNOMINATIVO%TYPE,       -- progressivo della richiesta (copia di lavoro se abilitata, opp. originale)
    p_errCode OUT number         -- Codice di Errore
) RETURN NUMBER IS

p_statoccupaz number;
incrementoPunteggio number :=0;
BEGIN 

  
select count(*) 
  into p_statoccupaz
  from DO_NOMINATIVO nom 
   inner join DO_ROSA ro on (nom.prgrosa = ro.prgrosa)
   inner join AS_STORIA_STATO_OCC ast on (ro.prgincrocio = ast.prgincrocio
                                          and nom.cdnlavoratore = ast.cdnlavoratore)
  inner join de_stato_occupaz dst on (ast.codstatooccupaz = dst.codstatooccupaz) 
  where nom.prgnominativo = p_prgnominativo 
  and dst.codstatooccupazragg in ('O');
--  and dst.codstatooccupaz != 'B1' 

 if p_statoccupaz > 0 then
    select cl.num into incrementoPunteggio
     from ts_config_punteggio cl
     where cl.codtipoconfig = 'AS'
     and cl.strvalore = 'FAM_DEC';
 end if;

return incrementoPunteggio; 
 

  exception
       when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       return incrementoPunteggio;
end ASStatoOccupazFamDec;



/*****************************************************************************************
* Avvia tutti i candidati passati nell'ARRAY                                             *
* la procedura si occupa dell'inserimento di tutti i cndLavoratori presenti nell'ARRAY   *
* passato.                                                                               *
******************************************************************************************/
FUNCTION ASInsertCandidatiGraduatoria(inputCdnLavoratore IN INT_ARRAY,
                        inputPrgRichiestaAz DO_INCROCIO.PRGRICHIESTAAZ%TYPE,
                        inputPrgTipoIncrocio DO_INCROCIO.PRGTIPOINCROCIO%TYPE,
                        p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                        p_prgAvvio OUT AS_AVVIO.Prgavvio%TYPE)
                        RETURN NUMBER IS

checkLavoratoreAvviato number;
checkGiorniPubblicazione number;
countMansione number;
p_codMansione do_mansione.codmansione%TYPE;
countContratto number;
p_codContratto DO_CONTRATTO.CODCONTRATTO%TYPE;
p_numOrdine Do_Nominativo.Numordine%TYPE;

BEGIN

 -- eliminato controllo: viene gestito sul pulsante

 -- controllo 1: veifica periodo pubblicazione max 6 mesi
 -- select to_date(sysdate, 'dd/mm/yy') -
 -- to_date(add_months(r.datpubblicazione, 6), 'dd/mm/yy')
 -- as d into checkGiorniPubblicazione
 -- from do_richiesta_az r
 -- where r.prgrichiestaaz = inputPrgRichiestaAz;

 -- if (checkGiorniPubblicazione > 0) then
     -- errore 1 := data di avviamento superiore ai 6 mesi
 --    return 1;

 -- else

      -- verifica mansione solo se esiste una sola viene inserita nell'avviamento
      select count(m.codMansione) into countMansione
      from do_mansione m
      inner join de_mansione man on man.codMansione=m.codMansione
      inner join de_mansione man_p on man_p.codMansione=substr(m.codMansione, 1, 5) || '00'
      inner join do_richiesta_az raz on m.prgRichiestaAz=raz.PRGRICHIESTAAZ
      where m.prgRichiestaAz = inputPrgRichiestaAz;

      if (countMansione = 1) then
         select m.codMansione into p_codMansione
          from do_mansione m
          inner join de_mansione man on man.codMansione=m.codMansione
          inner join de_mansione man_p on man_p.codMansione=substr(m.codMansione, 1, 5) || '00'
          inner join do_richiesta_az raz on m.prgRichiestaAz=raz.PRGRICHIESTAAZ
          where m.prgRichiestaAz = inputPrgRichiestaAz;
      else
         p_codMansione := null;
      end if;

      -- verifica contratto solo se esiste una sola viene inserita nell'avviamento
      SELECT count(DO_CONTRATTO.CODCONTRATTO) into countContratto
      FROM DO_CONTRATTO
      WHERE DO_CONTRATTO.PRGRICHIESTAAZ = inputPrgRichiestaAz;

      if (countContratto = 1) then
         SELECT DO_CONTRATTO.CODCONTRATTO into p_codContratto
          FROM DO_CONTRATTO
          WHERE DO_CONTRATTO.PRGRICHIESTAAZ = inputPrgRichiestaAz;
      else
         p_codContratto := null;
      end if;

      -- recupero il prgAvvio e inserisco il record in AS_AVVIO
      select s_as_avvio.nextval into p_prgAvvio from dual;

      insert into as_avvio
             (prgAvvio,
             cdnutins,
             dtmins)
             VALUES
             (p_prgAvvio,
             p_cdnUtente,
             sysdate);

      for i in 1 .. inputCdnLavoratore.count
        loop

         select count(avv.cdnlavoratore) into checkLavoratoreAvviato
         from as_avv_selezione avv
         where avv.prgrichiestaaz = inputPrgRichiestaAz
         and avv.cdnlavoratore = inputCdnLavoratore(i);

         if (checkLavoratoreAvviato = 0) then

            select min(n.numordine) into p_numOrdine
            from do_nominativo n
            inner join do_rosa r on r.prgrosa = n.prgrosa
            inner join do_incrocio i on i.prgincrocio = r.prgincrocio
            where --n.numordine is not null
            n.cdnlavoratore = inputCdnLavoratore(i)
            and n.codtipocanc is null
            and r.prgrosafiglia is null
            and i.prgrichiestaaz = inputPrgRichiestaAz
            and i.prgtipoincrocio = inputPrgTipoIncrocio;

            insert into as_avv_selezione
               (PRGAVVSELEZIONE,
               PRGAVVIO,
               CDNLAVORATORE,
               PRGRICHIESTAAZ,
               prgtipoincrocio,
               NUMORDINE,
               DATAVVIAMENTO,
               CODESITOAVVSEL,
               codmansione,
               codcontratto,
               cdnUtIns,
               dtmIns,
               cdnutmod,
               dtmMod
               )
               VALUES
               (s_as_avv_selezione.Nextval,
                p_prgAvvio,
                inputCdnLavoratore(i),
                inputPrgRichiestaAz,
                inputPrgTipoIncrocio,
                p_numOrdine,
                sysdate,
                'A',
                p_codMansione,
                p_codContratto,
                p_cdnUtente,
                sysdate,
                p_cdnUtente,
                sysdate
                );

         end if;

       end loop;

       return 0;

  -- end if;

   exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

END ASInsertCandidatiGraduatoria;

/**************************************************************************************
* Avvia i primi N (numero di candidati passati) candidati presenti nella graduatoria  *
* questa funzione inserisce nella tabella di selezione i primi N candidati ciclando   *
* sui possibili profili per la richiesta selezionata                                  *
***************************************************************************************/
function ASAvviaPrimiNCandidati(p_numCandidati number,                                            -- numero di candidati da avviare
                                p_prgRichiesta Do_Richiesta_Az.Prgrichiestaaz%TYPE,               -- progressivo della richiesta
                                p_prgTipoIncrocio Do_Incrocio.Prgtipoincrocio%TYPE,               -- progressivo del tipo di incrocio
                                p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                p_errCode OUT number,                                             -- Codice di Errore
                                p_prgAvvio OUT AS_AVVIO.Prgavvio%TYPE
                                ) RETURN NUMBER is

     p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE;
     p_prgRosa Do_Rosa.Prgrosa%TYPE;

     arrayCandidati INT_ARRAY := INT_ARRAY(p_numCandidati);
     numArray number;
     totArray number;
     checkLavoratoreInserito number;
     checkAvvia number;

     CURSOR roseDaAvviareCursor IS
           select r.prgrosa
              from do_richiesta_az rich
              inner join do_incrocio i on i.prgrichiestaaz = rich.prgrichiestaaz
              inner join do_rosa r on i.prgincrocio = r.prgincrocio
              where rich.prgrichiestaaz = p_prgRichiesta
              and r.prgTipoRosa = 3
              and i.prgtipoincrocio = p_prgTipoIncrocio
                  and r.prgrosafiglia is null
              order by prgalternativa;

begin

  numArray := 1;
  totArray := arrayCandidati.count;

  FOR rosa in roseDaAvviareCursor
   LOOP

     p_prgRosa := rosa.prgrosa;

     DECLARE
      CURSOR candidatiRosa IS
             select r.cdnlavoratore
             from do_nominativo r
              inner join do_rosa on (r.PRGROSA=do_rosa.PRGROSA)
              inner join do_incrocio on (do_rosa.PRGINCROCIO=do_incrocio.PRGINCROCIO)
              inner join do_richiesta_az rich1 on (do_incrocio.PRGRICHIESTAAZ=rich1.PRGRICHIESTAAZ)
             where do_rosa.prgRosa = p_prgRosa
              and rich1.prgrichiestaaz = p_prgRichiesta
              and do_rosa.prgTipoRosa = 3
              and do_incrocio.prgtipoincrocio = p_prgTipoIncrocio
              and do_rosa.prgrosafiglia is null
              and r.codtipocanc is null
              and r.cdnlavoratore not in
              (select avv.cdnlavoratore
              from as_avv_selezione avv
              where avv.prgrichiestaaz = p_prgRichiesta)
              order by prgalternativa, numordine, cdnlavoratore;
    BEGIN
      OPEN candidatiRosa;
           LOOP
               FETCH candidatiRosa INTO p_cdnLavoratore;
               EXIT WHEN candidatiRosa%NOTFOUND;

               checkLavoratoreInserito := 0;

               -- verifica che il lavoratore non sia stato già inserito nell'INT_ARRAY
               for i in 1 .. arrayCandidati.count
               loop

                     if (p_cdnLavoratore =  arrayCandidati(i)) then
                        checkLavoratoreInserito := 1;
                        EXIT;
                     end if;

               end loop;

               if (checkLavoratoreInserito = 0) then

                   -- aggiungo il lavoratore nell'array
                   if (p_numCandidati < numArray) then
                       EXIT;
                   else
                       arrayCandidati.Extend;
                       arrayCandidati(numArray) := p_cdnLavoratore;

                       numArray := numArray + 1;

                   end if;

              end if;

           END LOOP;
      CLOSE candidatiRosa;
    END;

   END LOOP;

   arrayCandidati.Trim();

   numArray := arrayCandidati.count;

   -- funzione che avvia il lavoratore
   checkAvvia := ASInsertCandidatiGraduatoria(arrayCandidati,p_prgRichiesta, p_prgTipoIncrocio, p_cdnUtente, p_prgAvvio);

   return checkAvvia;


  exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASAvviaPrimiNCandidati;

/********************************************************************************************
* Batch di aggiornamento degli avvii a selezione consultamndo gli avviamenti nei movimenti  *
*********************************************************************************************/

procedure ASBatch_AvvASelezioneDaMov_old(p_result OUT Varchar2,
                                    p_numMaxMesi number,
                                    p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                   ) IS

retDaCorreggere number;
retDaNotificare number;
p_res1 varchar2(100);
p_res2 varchar2(100);
begin
    retDaCorreggere := ASAvvASelezioneDaMov(p_res1, p_numMaxMesi, p_cdnUtente, 'C');

    retDaNotificare := ASAvvASelezioneDaMov(p_res2, p_numMaxMesi, p_cdnUtente, 'N');

    if length(p_res1) is not null and length(p_res2) is not null then
        p_result := p_res1 || ' - ' || p_res2;
    elsif length(p_res1) is not null then
        p_result := p_res1;
    elsif length(p_res2) is not null then
        p_result := p_res2;
    else
        p_result := 'Nessun aggiornamento necessario';
    end if;

    if retDaCorreggere = 0 and retDaNotificare = 0 then
        commit;
    else
        rollback;
    end if;

end ASBatch_AvvASelezioneDaMov_old;

procedure ASBatch_AvvASelezioneDaMov(p_result OUT Varchar2,
                                    p_numMaxMesi number,
                                    p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                   ) IS

retDaCorreggere number;
retDaNotificare number;
p_res1 varchar2(100);
p_res2 varchar2(100);
begin

retDaCorreggere := ASAvvASelezioneDaMov_new(p_res1, p_numMaxMesi, p_cdnUtente);

p_result := p_res1;

if length(p_result) <= 1 then
 p_result := 'Nessun aggiornamento necessario';
end if;

if retDaCorreggere = 0 then
    commit;
else
    rollback;
end if;

end ASBatch_AvvASelezioneDaMov;

function ASAvvASelezioneDaMov(p_res OUT Varchar2,
                              p_numMaxMesi number,
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                              p_tipo_avv char
                                   ) RETURN NUMBER is

p_prgAvvSel as_avv_selezione.PRGAVVSELEZIONE%type;
p_descEsitoAvvASel de_esito_avv_sel.STRDESCRIZIONE%type;
p_datAvvSel as_avv_selezione.DATAVVIAMENTO%type;
p_LavAvvSel as_avv_selezione.CDNLAVORATORE%type;
p_AzAvvSel  do_richiesta_az.PRGAZIENDA%type;
p_UniAvvSel do_richiesta_az.PRGUNITA%type;
p_CodFiscAz AN_AZIENDA.STRCODICEFISCALE%type;
p_RagSocAz AN_AZIENDA.STRRAGIONESOCIALE%type;
prgtipoev AN_EVIDENZA.PRGTIPOEVIDENZA%type;
strev AN_EVIDENZA.STREVIDENZA%type;
checkAvv number;
checkEvid number;
queryavvASelezioneCursor varchar2(600);
type avvASelezioneRefCursor is REF CURSOR;
avvASelezioneCursor avvASelezioneRefCursor;
contaCorr number;
contaEvid number;

BEGIN
  queryavvASelezioneCursor := 'SELECT avv_sel.PRGAVVSELEZIONE, de_es.STRDESCRIZIONE, avv_sel.DATAVVIAMENTO, avv_sel.CDNLAVORATORE, ' ||
            'rich_az.PRGAZIENDA, rich_az.PRGUNITA, az.STRCODICEFISCALE, az.STRRAGIONESOCIALE ' ||
            'FROM as_avv_selezione avv_sel ' ||
            'inner join do_richiesta_az rich_az on rich_az.PRGRICHIESTAAZ = avv_sel.PRGRICHIESTAAZ ' ||
            'inner join de_esito_avv_sel de_es on de_es.codesitoavvsel = avv_sel.CODESITOAVVSEL ' ||
            'inner join an_azienda az on az.prgAzienda = rich_az.prgAzienda ' ||
            'WHERE nvl(avv_sel.CODESITOAVVSEL, ''A'') ';

  if p_tipo_avv = 'C' then
    queryavvASelezioneCursor := queryavvASelezioneCursor || '= ''A''';
  elsif p_tipo_avv = 'N' then
    queryavvASelezioneCursor := queryavvASelezioneCursor || 'in (''C'',''E'',''F'',''G'',''H'',''I'',''J'',''K'',''L'',''N'',''U'')';

    select prgTipoEvidenza
    into prgtipoev
    from DE_TIPO_EVIDENZA
    where codtipoevidenza = 'R2';
  end if;

  contaCorr := 0;
  contaEvid := 0;

  OPEN avvASelezioneCursor for queryavvASelezioneCursor;
       LOOP
           FETCH avvASelezioneCursor INTO p_prgAvvSel, p_descEsitoAvvASel, p_datAvvSel, p_LavAvvSel,
                                            p_AzAvvSel, p_UniAvvSel, p_CodFiscAz, p_RagSocAz;
           EXIT WHEN avvASelezioneCursor%NOTFOUND;

           SELECT count(1) INTO checkAvv
           FROM AM_MOVIMENTO
           WHERE CODTIPOMOV = 'AVV'
           and PRGMOVIMENTOPREC is null
           and CODSTATOATTO = 'PR'
           and CDNLAVORATORE = p_LavAvvSel
           and PRGAZIENDA = p_AzAvvSel
           and PRGUNITA = p_UniAvvSel
           and DATINIZIOMOV >= p_datAvvSel
           and months_between(DATINIZIOMOV,p_datAvvSel) <= p_numMaxMesi;

           IF checkAvv > 0 THEN
               if p_tipo_avv = 'C' then

                    update as_avv_selezione
                    set
                        CODESITOAVVSEL = 'Z',
                        CDNUTMOD = p_cdnUtente,
                        DTMMOD = sysdate,
                        NUMKLOAVVSELEZIONE = NUMKLOAVVSELEZIONE + 1
                    where PRGAVVSELEZIONE = p_prgAvvSel;

                    contaCorr := contaCorr + 1;

               elsif p_tipo_avv = 'N' then

                    strev := 'Il lavoratore risulta avere un esito di avviamento a selezione di questo tipo ' ||
                              p_descEsitoAvvASel || ' presso l''azienda ' ||
                              p_CodFiscAz || ' ' || p_RagSocAz ||
                              ' e risulta avere un movimento di assunzione presso la stessa azienda in tempi compatibili.';

                    SELECT count(1) INTO checkEvid
                    FROM AN_EVIDENZA
                    WHERE CDNLAVORATORE = p_LavAvvSel
                    and STREVIDENZA = strev
                    and PRGTIPOEVIDENZA = prgtipoev;

                    if checkEvid = 0 then
                        insert into AN_EVIDENZA
                            (PRGEVIDENZA, CDNLAVORATORE, DATDATASCAD, STREVIDENZA,
                            PRGTIPOEVIDENZA, CDNUTINS, DTMINS, CDNUTMOD, DTMMOD)
                        values
                            (S_AN_EVIDENZA.nextVal, p_LavAvvSel, trunc(sysdate+365), strev,
                            prgtipoev, p_cdnUtente, sysdate, p_cdnUtente, sysdate);

                        contaEvid := contaEvid + 1;
                    end if;

               end if;
           END IF;

       END LOOP;
  CLOSE avvASelezioneCursor;

  IF contaCorr > 0 THEN
    p_res := 'Sono stati aggiornati '||contaCorr||' avviamenti a selezioni';
  end if;

  IF contaEvid > 0 THEN
    p_res := 'Sono state inserite '||contaEvid||' evidenze';
  end if;

  return 0;

exception
  when others then
     p_res := 'Si è verificato un errore nella stored : ' || sqlcode;
     return -1;

end ASAvvASelezioneDaMov;

function ASAvvASelezioneDaMov_New(p_res OUT Varchar2,
                              p_numMaxMesi number,
                              p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                   ) RETURN NUMBER is

prgtipoev AN_EVIDENZA.PRGTIPOEVIDENZA%type;
strev AN_EVIDENZA.STREVIDENZA%type;
checkAvv number;
checkEvid number;
contaCorr number;
contaEvid number;
p_res1 Varchar2(1000);
p_res2 Varchar2(1000);

TYPE avvASelezione_rec IS RECORD (PRGAVVSELEZIONE as_avv_selezione.prgavvselezione%TYPE,
                                 STRDESCRIZIONE de_esito_avv_sel.Strdescrizione%TYPE,
                                 DATAVVIAMENTO as_avv_selezione.datavviamento%TYPE,
                                 CDNLAVORATORE as_avv_selezione.CDNLAVORATORE%TYPE,
                                 PRGAZIENDA an_azienda.Prgazienda%TYPE,
                                 PRGUNITA do_richiesta_az.Prgunita%TYPE,
                                 STRCODICEFISCALE an_azienda.Strcodicefiscale%TYPE,
                                 STRRAGIONESOCIALE an_azienda.Strragionesociale%TYPE,
                                 CODESITOAVVSEL as_avv_selezione.CODESITOAVVSEL%type
                             );
TYPE avvASelezione_tab IS TABLE OF avvASelezione_rec;
avvASelezione avvASelezione_tab;

 CURSOR avvASelezioneCursor IS
        SELECT avv_sel.PRGAVVSELEZIONE, de_es.STRDESCRIZIONE, avv_sel.DATAVVIAMENTO, avv_sel.CDNLAVORATORE,
            rich_az.PRGAZIENDA, rich_az.PRGUNITA, az.STRCODICEFISCALE, az.STRRAGIONESOCIALE, nvl(avv_sel.CODESITOAVVSEL, 'A') as CODESITOAVVSEL
            FROM as_avv_selezione avv_sel
            inner join do_richiesta_az rich_az on rich_az.PRGRICHIESTAAZ = avv_sel.PRGRICHIESTAAZ
            inner join de_esito_avv_sel de_es on de_es.codesitoavvsel = avv_sel.CODESITOAVVSEL
            inner join an_azienda az on az.prgAzienda = rich_az.prgAzienda
            WHERE nvl(avv_sel.CODESITOAVVSEL, 'A')
            in ('A', 'C','E','F','G','H','I','J','K','L','N','U')
            and exists (
                SELECT m.prgmovimento
               FROM AM_MOVIMENTO m
               WHERE m.CODTIPOMOV = 'AVV'
               and m.PRGMOVIMENTOPREC is null
               and m.CODSTATOATTO = 'PR'
               and m.CDNLAVORATORE = avv_sel.CDNLAVORATORE
               and m.PRGAZIENDA = rich_az.PRGAZIENDA
               and m.PRGUNITA =  rich_az.PRGUNITA
               and trunc(m.DATINIZIOMOV) >= trunc(avv_sel.DATAVVIAMENTO)
               and months_between(trunc(m.DATINIZIOMOV),trunc(avv_sel.DATAVVIAMENTO)) <= p_numMaxMesi
            );

BEGIN

   select prgTipoEvidenza
    into prgtipoev
    from DE_TIPO_EVIDENZA
    where codtipoevidenza = 'R2';

  contaCorr := 0;
  contaEvid := 0;

  OPEN avvASelezioneCursor;
     LOOP
     FETCH avvASelezioneCursor BULK COLLECT INTO avvASelezione;
         FOR i IN 1 .. avvASelezione.COUNT
             LOOP

              if avvASelezione(i).CODESITOAVVSEL = 'A' then

                    update as_avv_selezione
                    set
                        CODESITOAVVSEL = 'Z',
                        CDNUTMOD = p_cdnUtente,
                        DTMMOD = sysdate,
                        NUMKLOAVVSELEZIONE = NUMKLOAVVSELEZIONE + 1
                    where PRGAVVSELEZIONE = avvASelezione(i).PRGAVVSELEZIONE;

                    contaCorr := contaCorr + 1;

               else

                    strev := 'Il lavoratore risulta avere un esito di avviamento a selezione di questo tipo ' ||
                              avvASelezione(i).STRDESCRIZIONE || ' presso l''azienda ' ||
                              avvASelezione(i).STRCODICEFISCALE || ' ' || avvASelezione(i).STRRAGIONESOCIALE ||
                              ' e risulta avere un movimento di assunzione presso la stessa azienda in tempi compatibili.';

                    SELECT count(1) INTO checkEvid
                    FROM AN_EVIDENZA
                    WHERE CDNLAVORATORE = avvASelezione(i).CDNLAVORATORE
                    and STREVIDENZA = strev
                    and PRGTIPOEVIDENZA = prgtipoev;

                    if checkEvid = 0 then
                        insert into AN_EVIDENZA
                            (PRGEVIDENZA, CDNLAVORATORE, DATDATASCAD, STREVIDENZA,
                            PRGTIPOEVIDENZA, CDNUTINS, DTMINS, CDNUTMOD, DTMMOD)
                        values
                            (S_AN_EVIDENZA.nextVal, avvASelezione(i).CDNLAVORATORE, trunc(sysdate+365), strev,
                            prgtipoev, p_cdnUtente, sysdate, p_cdnUtente, sysdate);

                        contaEvid := contaEvid + 1;
                    end if;

               end if;

             END LOOP;
     EXIT WHEN avvASelezioneCursor%NOTFOUND;
     END LOOP;
  CLOSE avvASelezioneCursor;

  IF contaCorr > 0 THEN
    p_res1 := 'Sono stati aggiornati '||contaCorr||' avviamenti a selezioni';
  end if;

  IF contaEvid > 0 THEN
    p_res2 := 'Sono state inserite '||contaEvid||' evidenze';
  end if;

  p_res := p_res1 || ' ' || p_res2;

  return 0;

exception
  when others then
     p_res := 'Si è verificato un errore nella stored : ' || sqlcode;
     return -1;

end ASAvvASelezioneDaMov_New;


/********************************************************************************
* utility per testing
* utilizzata per inserire i candidati presenti nel range dato nella rosa passata *
*********************************************************************************/
PROCEDURE ASRiempiRosaPerProve(p_prgRosa Do_Rosa.Prgrosa%TYPE,
                               p_cdnlavoratoreDa number,
                               p_cdnlavoratoreA number)

IS

CURSOR candidatiCursor IS
       select l.cdnlavoratore from an_lavoratore l where l.cdnlavoratore > p_cdnlavoratoreDa and l.cdnlavoratore < p_cdnlavoratoreA;

begin

FOR candidato in candidatiCursor
   LOOP

      insert into do_nominativo
      (PRGNOMINATIVO, CDNLAVORATORE, DTMINS, CDNUTINS, PRGROSA)
      values
      (s_Do_Nominativo.nextVal,
      candidato.cdnlavoratore,
      sysdate,
      363,
       p_prgRosa);

   END LOOP;

end ASRiempiRosaPerProve;

/******************************************************************************************
* funzione che verifica se siamo in RER e restituisce S o N                               *
********************************************************************************************/
function isRer       RETURN varchar2 IS
valueReturn   varchar2(1);
codRegione    VARCHAR2(8);
codRegioneRER VARCHAR2(8) := '8';
  begin
  select p.codregione into codRegione
  from ts_generale g, de_provincia p
  where g.codprovinciasil = p.codprovincia;

  if (codRegione = codRegioneRER) then valueReturn :='S'; else valueReturn := 'N';  end if;

  return valueReturn;
end ;

/******************************************************************************************
* funzione che verifica se siamo in VDA e restituisce true o false                               *
********************************************************************************************/
function isVda   RETURN boolean IS
valueReturn   boolean;      
codRegione    VARCHAR2(8);     

begin
 select codregionesil into codRegione
  from ts_generale
  where prggenerale = 1;
 
  if (codRegione = '2') then
     valueReturn := true; 
  else 
     valueReturn := false;
  end if;
  
  return valueReturn;
end ;   

/******************************************************************************************
* funzione che calcola il punteggio del lavoratore passato                                 *
* il punteggio finale = punteggioIniziale - punteggioISEE + punteggioDID + punteggioEta    *
* la funzione si occupa di inserire il punteggio finale nella tabella do_nominativo        *
* e i singoli punteggi calcolati nella tabella AS_PUNTEGGIO                                *
********************************************************************************************/
function calcoloPunteggioLavoratore(p_prgNominativo number,
                                     tipoGraduatoria varchar2,
									 p_flagAsOnline varchar2,
									 p_iseeAsOnline do_nominativo.numvaloreisee%type,
                                     p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                     p_errCode OUT number )
                         RETURN NUMBER IS


p_prgConfigPunteggio number;
dataNascita date;
dataPubblicazione do_richiesta_az.datpubblicazione%type;
datChiamata do_richiesta_az.datchiamata%type;
cdnLav number;
p_datanzianitadisoc am_stato_occupaz.datanzianitadisoc%type;
punteggioIniziale number;
punteggioISEE number;
valoreISEE number;
checkValoreISEE number;
euroISEE_OGNI number;
puntiEuroISEE_MENO number;
puntiISEE_MAX number;
punteggioDID number;
punteggioEta number;
etaLavoratore number;
punteggioFinale number;
valueReturn number;
p_codmonotipogradcm  number;
p_codmonoisee  do_nominativo.codmonoisee%type;
p_codmonodid   do_nominativo.codmonodid%type;
configSezioneASATTR Ts_Config_Loc.strvalore%type;
configNumASATTR Ts_Config_Loc.num%type;
p_flgfamdec  do_nominativo.flgfamdec%type;
codProvinciaSil  TS_GENERALE.CODPROVINCIASIL%TYPE;
punteggioFamDec number;
v_prgIncrocio do_incrocio.prgincrocio%type;
checkAggiornaStoricizzazione number;
v_anzianitaDis do_nominativo.stranzianita%type;
p_prgConfigPunteggioDID number;
v_prgrichiestaaz  do_richiesta_az.prgrichiestaAz%type;
punteggioEsp number;
v_mesiEsp number;

--cuorsore parametrico degli stati occupazionali non 297 nell'intervallo data pubblicazione e data chiamata
cursor cursorStatiOccNon297(cdnLav1 number, datChiamata1 do_richiesta_az.datchiamata%type,
          dataPubblicazione1 do_richiesta_az.datpubblicazione%type) is
select aso.datInizio, aso.datFine
from am_stato_occupaz aso
inner join de_stato_occupaz dso on dso.codstatooccupaz = aso.codstatooccupaz
where dso.codstatooccupazragg in ('A', 'O')
and aso.cdnlavoratore = cdnLav1
and trunc(aso.datinizio) <= trunc(datChiamata1)
and trunc(NVL(aso.datfine, SYSDATE)) >= trunc(dataPubblicazione1) - 1;

rec_StatiOccNon297 cursorStatiOccNon297%ROWTYPE;
dataInizioSOcc am_stato_occupaz.datInizio%type;
dataFineSOcc am_stato_occupaz.datFine%type;
nSOccCopre number;
statoOccCoperto boolean := true;
numStatiNo297 number;
presenzaDid boolean := false;
rer varchar2(1) := isRer;

begin
        -- prendo il tipo graduatoria
        select codmonotipogradcm into p_codmonotipogradcm from ts_generale;
        --recupero la data di pubblicazione e data chiamata della richesta
        --serve per sapere se il candidato ha una DID
        select raz.datpubblicazione, raz.datchiamata, nom.cdnlavoratore, i.prgincrocio, raz.prgrichiestaaz
               into dataPubblicazione, datChiamata, cdnLav, v_prgIncrocio, v_prgrichiestaaz
        from do_nominativo nom
        inner join do_rosa r on r.prgrosa = nom.prgrosa
        inner join do_incrocio i on i.prgincrocio = r.prgincrocio
        inner join do_richiesta_az raz on raz.prgrichiestaaz = i.prgrichiestaaz
        where nom.prgnominativo = p_prgNominativo;

        --recupero info del candidato selezionato
        select l.datnasc
               into dataNascita
        from do_nominativo n
        inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
        where n.prgnominativo = p_prgNominativo;
        
      select t.codmonodid, t.codmonoisee, t.flgfamdec
       into p_codmonodid, p_codmonoisee, p_flgfamdec
        from do_nominativo t
       where t.prgnominativo = p_prgNominativo;
       
       -- controllo configurazione per Attribuzione Punti DID e ISEE

        
 --    select nvl( (select ts_config_loc.strvalore from ts_config_loc
--                inner join de_tipo_config on (ts_config_loc.codtipoconfig = de_tipo_config.codtipoconfig)
	--		   			    where ts_config_loc.strcodrif=(select ts_generale.codprovinciasil from ts_generale where prggenerale = 1)
   --               and de_tipo_config.codtipoconfig='ASATTRIB' 
   --               and trunc(sysdate) between trunc(de_tipo_config.datinizioval)
 --                 and trunc(de_tipo_config.datfineval)) , '0') AS strvaloreconfig,
  --              (select TS_GENERALE.CODPROVINCIASIL 
  --                     from TS_GENERALE where prggenerale = 1) AS codProvinciaSil
 --               into configSezioneASATTR, codProvinciaSil
 --        from DUAL;
 
  configNumASATTR := getNumConfig('ASATTRIB');  ---Prendo il tipo di configurazione
 
  -- modifica donato 22/05/2007: viene verificata l'esistenza del valorwe ISEE alla datra chiamata asta
        select count(v.numvaloreisee) into checkValoreISEE
        from AS_VALORE_ISEE v
        where v.cdnlavoratore = cdnLav
        and v.datinizioval <= datChiamata
        and (v.datfineval >= datChiamata or v.datfineval is null);
  -- modifica savino 22/01/2007: non si distingue il caso: valoreisee = 0 o non esistente
        if (checkValoreISEE != 0) then
            select v.numvaloreisee into valoreISEE
            from AS_VALORE_ISEE v
            where v.cdnlavoratore = cdnLav
            and v.datinizioval <= datChiamata
            and (v.datfineval >= datChiamata or v.datfineval is null);
        else
  -- modifica savino 22/01/2007: era = 0
             valoreISEE := null;
        end if;
        
     ---Aggiorno il valore dell'Isee nella Do_Nominativo  
		if(p_flagAsOnline = 'S') then
			valoreISEE := p_iseeAsOnline;
		end if;
        ASUpdateValoreISEE(p_prgNominativo,valoreISEE,p_cdnUtente, p_errCode); 
    
        --calcolo l'eta del candidato
  -- MODIFICA ESPOSITO : L'eta viene ora calcolata non alla data di sistema, ma alla data della chiamata
  
        if configNumASATTR = 1 then ----Per RER l'eta del lavoratore si calcola dalla data di pubblicazione
          etaLavoratore := etaMatchChiamata(dataNascita,dataPubblicazione);
        else
          etaLavoratore := etaMatchChiamata(dataNascita,datChiamata);
        end if;

        if ( (dataPubblicazione is not null) and (datChiamata is not null) and (trunc(dataPubblicazione) <= trunc(datChiamata)) ) then
          if configNumASATTR = 1 then 
             if nvl(p_codmonodid, 'S') = 'S' then
               presenzaDid := ASPresenzaDispDID(cdnLav, dataPubblicazione, datChiamata,p_errCode);
             elsif p_codmonodid = 'R' then
               presenzaDid := true;
             else
               presenzaDid := false;
             end if;
          
          else   
            if configNumASATTR = 2 or configNumASATTR = 3	  then
               presenzaDid := ASStatoOccDataChiam(cdnLav,datChiamata, dataPubblicazione, configNumASATTR, p_errCode);
            else
              --verifico se nel periodo tra la data pubblicazione e la data chiamata il lavoratore non è in 297
              open cursorStatiOccNon297(cdnLav, datChiamata, dataPubblicazione);
                numStatiNo297 := 0;
              loop
                fetch cursorStatiOccNon297 into rec_StatiOccNon297;
                exit when (cursorStatiOccNon297%NOTFOUND or statoOccCoperto = false);
                dataInizioSOcc := rec_StatiOccNon297.datInizio;
                dataFineSOcc := rec_StatiOccNon297.datFine;
                numStatiNo297 := numStatiNo297 + 1;
                --verifico per ogni stato occuapazionale A o O se esiste uno stato occ.
                --che lo ricopre tramite l'anzianità
                select count(*) into nSOccCopre
                from am_stato_occupaz aso
                inner join de_stato_occupaz dso on dso.codstatooccupaz = aso.codstatooccupaz
                where dso.codstatooccupazragg in ('I', 'D')
                and aso.cdnlavoratore = cdnLav
                and decode(aso.datanzianitadisoc,
										null, trunc(aso.datinizio),
										   trunc(aso.datanzianitadisoc)) <= trunc(dataInizioSOcc)
                and trunc(NVL(aso.datfine, SYSDATE)) >= trunc(NVL(dataFineSOcc, SYSDATE))
                and dso.codstatooccupaz not in (decode(rer,'S','B1','NOFILTRO')) --> se sono in RER escludo lo stato occupazionale B1
                ;
                --se nSOccCopre = 0, allora lo stato occupazionale A,O non è coperto da
                --uno stato occupazionale D,I tramite l'anzianità
                if (nSOccCopre = 0) then
                  statoOccCoperto := false;
                end if;
              end loop;
              --se non esistono stati occupazionali A,O tra la data pubblicazione e la data chiamata,
              --oppure tutti gli stati occupazionale A,O
              --sono coperti da almeno uno stato occupazionale D,I tramite l'anzianità,
              --allora il lavoratore risulta D o I tra la data pubblicazione e la data chiamata

              if (numStatiNo297 = 0) then
               --se il lavoratore non ha stati occupazionali non 297 nell'intervallo
              --data pubblicazione e data chiamata, allora verifico che nell'intervallo risulta D o I

                select count(*) into nSOccCopre
							  from am_stato_occupaz aso
							  inner join de_stato_occupaz dso on dso.codstatooccupaz = aso.codstatooccupaz
							  where dso.codstatooccupazragg in ('I', 'D')
							  and aso.cdnlavoratore = cdnLav
							  and decode(aso.datanzianitadisoc,
											null, trunc(aso.datinizio),
											   trunc(aso.datanzianitadisoc)) <= trunc(dataPubblicazione) - 1
							  and trunc(NVL(aso.datfine, SYSDATE)) >= trunc(datChiamata)
							  and dso.codstatooccupaz not in (decode(rer,'S','B1','NOFILTRO')) --> se sono in RER escludo lo stato occupazionale B1
                ;
                
                if (nSOccCopre > 0) then
                  presenzaDid := true;
							  end if;

              else

						   if (statoOccCoperto = true) then
                presenzaDid := true;
						   end if;

              end if;
             
            end if;
          
          end if;
        else
          --codice di ritorno = -2 (data pubblicazione e/o data chiamata non corrette)
          return -2;
        end if;

        -----Se la configurazione AS_STOCC = 1 allora prevedere l'aggiornamento nella tabella AS_STORIA_STATO_OCC (passare il CDNLAVORATORE, DATA, PRGINCROCIO)
      if getNumConfig('AS_STOCC')  = 1 then
        checkAggiornaStoricizzazione := ASAggiornaStatoOcc(datchiamata, datapubblicazione, configNumASATTR, cdnLav, v_prgIncrocio, p_cdnUtente);
      end if; 


      --calcolo il punteggio iniziale per la graduatoria

			punteggioIniziale := calcolopunteggioiniziale(tipoGraduatoria, 'INI');
			
			if punteggioIniziale <> 0 then
				p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'INI');
				Asupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, punteggioIniziale, p_cdnUtente);
			end if;

        --calcolo il punteggio ISEE da sottrarre
        -- modifica savino 22/01/2007: era valoreISEE != 0
        if (valoreISEE is not null) and NVL(p_codmonoisee, 'S') = 'S' then
                puntiEuroISEE_MENO := calcolopunteggioisee_meno(tipograduatoria);
                puntiISEE_MAX := calcolopuntiisee_max(tipograduatoria);
                euroISEE_OGNI := calcolopuntiisee_ogni(tipograduatoria);

                punteggioISEE := calcolopuntiisee(valoreISEE, euroISEE_OGNI, puntiEuroISEE_MENO, puntiISEE_MAX);
        else
                punteggioISEE := calcoloPuntiISEE_NO(tipoGraduatoria);
        end if;

        p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'ISEE');
        Asupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, punteggioISEE, p_cdnUtente);
		
		
        --calcolo il punteggio presenza DID e Età
		if configNumASATTR = 2 then
			  punteggioEta := incrementopuntieta(tipoGraduatoria,  etaLavoratore);
			  if (presenzaDid = true) then
				v_anzianitaDis := PG_MOVIMENTI.CalcolaAnzianita(cdnLav, to_char(trunc(dataPubblicazione)-1, 'DD/MM/YYYY'));
				ASAggiornaAnzianita(p_prgNominativo, v_anzianitaDis, p_cdnUtente, p_errCode);
				punteggioDID := incrementopuntididAnzianita(tipoGraduatoria, v_anzianitaDis, configNumASATTR,p_prgConfigPunteggioDID);
			  else
				punteggioDID := 0;
			  end if;
		else
       if configNumASATTR = 3 then
         if (presenzaDid = true) then
           v_anzianitaDis := PG_MOVIMENTI.CalcolaAnzianita(cdnLav, to_char(trunc(dataPubblicazione), 'DD/MM/YYYY'));
           ASAggiornaAnzianita(p_prgNominativo, v_anzianitaDis, p_cdnUtente, p_errCode);
           punteggioDID := incrementopuntididAnzianita(tipoGraduatoria, v_anzianitaDis, configNumASATTR,p_prgConfigPunteggioDID);
           punteggioEta := 0;
         else
          punteggioDID:=0;
          punteggioEta := 0;
         end if;
		   else
			  if (presenzaDid = true) then
				  punteggioDID := incrementopuntidid(tipoGraduatoria);
				  --calcolo il punteggio in base all'età solo se si ha una DID
				  punteggioEta := incrementopuntieta(tipoGraduatoria,  etaLavoratore);
			  else
				  punteggioDID := 0;
				  if (p_codmonotipogradcm = 2) then
					 punteggioEta := incrementopuntieta(tipoGraduatoria, etaLavoratore);

				  else
					 punteggioEta := 0;
				  end if;
			  end if;
		   end if;
		end if;
------ Calcolo per Calabria i mesi di esperienza maturati per la mansione richiesta
		if configNumASATTR = 3 then
		  v_mesiEsp := ASCalcolaEsperienza(cdnLav, v_prgIncrocio, v_prgrichiestaaz, p_cdnUtente);
		  ASAggiornaMesiEsp(p_prgNominativo, v_mesiEsp, p_cdnUtente, p_errCode);
		  punteggioEsp := incrementoPuntiEsperienza(tipoGraduatoria,v_mesiEsp);
		  p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'ESP');
      Asupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, punteggioEsp, p_cdnUtente);
		else
		  punteggioEsp := 0;
		end if;
		  
		if  configNumASATTR = 2 then
		  if nvl(p_flgfamdec, 'N') = 'S' then
			punteggioFamDec := ASStatoOccupazFamDec(p_prgNominativo, p_errCode);
		  else
			punteggioFamDec :=0;
		  end if;
		  p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'FAM_DEC');
          Asupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, punteggioFamDec, p_cdnUtente);
		else
		  punteggioFamDec := 0;
		end if;

			p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'PT297');
			Asupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, punteggioDID, p_cdnUtente);

		if configNumASATTR <> 3 then
			p_prgConfigPunteggio := checkprgconfigpunteggio(tipograduatoria, 'ETA');
			Asupdatepunteggio(p_prgNominativo, p_prgConfigPunteggio, punteggioEta, p_cdnUtente);
		end if;


        --calcolo punteggio finale
        punteggioFinale := punteggioIniziale-punteggioISEE+punteggioDID+punteggioEta+punteggioFamDec+punteggioEsp;

        -- inserisco il punteggio finale nella tabella do_nominativo
        valueReturn := Asupdatepunteggiolavoratore(p_prgNominativo, punteggioFinale, p_Cdnutente);

        --commit;

        return valueReturn;

        exception
      when others then
           p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end calcoloPunteggioLavoratore;

/*****************************************************************
* recupero il punteggio iniziale dalla tabella di configurazione *
******************************************************************/
function calcoloPunteggioIniziale(tipoGraduatoria varchar2,
                         p_strValore ts_config_punteggio.strvalore%TYPE)
                         RETURN NUMBER IS

punteggioIniziale number;
begin

        select cl.num into punteggioIniziale
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = p_strValore;

        return punteggioIniziale;

        exception
      when no_data_found then
               return 0;

end calcoloPunteggioIniziale;

/******************************************************************************
* recupero il valore dei punti da sottrarre per ogni tot euro del valore ISEE *
* dalla tabella di configurazione                                             *
*******************************************************************************/
function calcoloPunteggioISEE_MENO(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggioSottrarre number;
begin

        select cl.num into punteggioSottrarre
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'ISEE_MENO';

        return punteggioSottrarre;

        exception
      when no_data_found then
               return 0;

end calcoloPunteggioISEE_MENO;

/******************************************************************************
* recupero il valore di quanti euro del valore ISEE vanno sottratti i punti   *
* dalla tabella di configurazione                                             *
*******************************************************************************/
function calcoloPuntiISEE_OGNI(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

totEuro number;
begin

        select cl.num into totEuro
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'ISEE_OGNI';

        return totEuro;

        exception
      when no_data_found then
               return 0;

end calcoloPuntiISEE_OGNI;


/******************************************************
* recupero il valore massimo di punti da sottrarre    *
* dalla tabella di configurazione                     *
*******************************************************/
function calcoloPuntiISEE_MAX(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggioMassimoSottratto number;
begin

        select cl.num into punteggioMassimoSottratto
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'ISEE_MAX';

        return punteggioMassimoSottratto;

        exception
      when no_data_found then
               return 0;

end calcoloPuntiISEE_MAX;

/********************************************************************************
* recupero il valore di punti se il candidato non ha inserito il valore ISEE    *
* dalla tabella di configurazione                                               *
*********************************************************************************/
function calcoloPuntiISEE_NO(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

punteggioSenzaISEE number;
begin

        select cl.num into punteggioSenzaISEE
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'ISEE_NO';

        return punteggioSenzaISEE;

        exception
      when no_data_found then
               return 0;

end calcoloPuntiISEE_NO;

/*********************************************************************
* calcolo i punti riferiti al valore ISEE del lavoratore             *
* y punti per ogni z Euro, dato ISEE, fino a k punti massimo.        *
* Si sottraggono n punti alla persona che non presenti il dato ISEE  *
*********************************************************************/
function calcoloPuntiISEE(valoreISEE number,
                          euroISEE_OGNI number,
                          puntiEuroISEE_MENO number,
                          puntiISEE_MAX number)
                              RETURN NUMBER IS
punteggio number;
moduloValore number;
valoreArrotondatoISEE number;
valoreAggiugere number;
begin
        if valoreISEE < euroISEE_OGNI then
          punteggio := 0;
        else
          moduloValore := MOD(valoreISEE, euroISEE_OGNI);

          --calcolo l'approssimazione
          if (moduloValore > 500) then
             valoreAggiugere := euroISEE_OGNI - moduloValore;
             valoreArrotondatoISEE :=  valoreISEE + valoreAggiugere;
          else
             valoreArrotondatoISEE:= valoreISEE - moduloValore;
          end if;

          --calcolo il numero di punti da sottrare per ogni tot euro
          punteggio := (valoreArrotondatoISEE/euroISEE_OGNI)*puntiEuroISEE_MENO;

          if (punteggio > puntiISEE_MAX) then
             punteggio := puntiISEE_MAX;
          end if;
        end if;

        return punteggio;

        exception
      when no_data_found then
               return 0;

end calcoloPuntiISEE;

/*********************************************************************
* calcolo i punti riferiti al valore ISEE del lavoratore             *
* y punti per ogni z Euro, dato ISEE, fino a k punti massimo.        *
* Si sottraggono n punti alla persona che non presenti il dato ISEE, *
* infine eseguo l'inserimento           *
*********************************************************************/
procedure calcoloPunteggioISEE(valoreISEE number,
            tipoGraduatoria varchar2,
            cdnlavoratore varchar2,
            inizio varchar2,
            fine varchar2,
            numanno varchar2,
            strnote varchar2,
            cdnutins varchar2,
                        cdnutmod varchar2,
            p_strIbanNazione as_valore_isee.strIbanNazione%TYPE,
            p_strIbanControllo as_valore_isee.strIbanControllo%TYPE,
            p_strCinLavoratore as_valore_isee.strCinLavoratore%TYPE,
            p_strAbiLavoratore as_valore_isee.strAbiLavoratore%TYPE,
            p_strCabLavoratore as_valore_isee.strCabLavoratore%TYPE,
            p_strCCLavoratore as_valore_isee.strCCLavoratore%TYPE)
                                 IS
punteggio number;
risultato number;
moduloValore number;
valoreArrotondatoISEE number;
valoreAggiugere number;
puntiEuroISEE_MENO number;
puntiISEE_MAX number;
euroISEE_OGNI number;
str varchar2(6000);
begin

        puntiEuroISEE_MENO := calcolopunteggioisee_meno(tipograduatoria);
        puntiISEE_MAX := calcolopuntiisee_max(tipograduatoria);
        euroISEE_OGNI := calcolopuntiisee_ogni(tipograduatoria);
        
        if valoreISEE < euroISEE_OGNI then
          punteggio := 0;
        else

          moduloValore := MOD(valoreISEE, euroISEE_OGNI);
          
          --calcolo l'approssimazione
          if (moduloValore > 500) then
             valoreAggiugere := euroISEE_OGNI - moduloValore;
             valoreArrotondatoISEE :=  valoreISEE + valoreAggiugere;
          else
             valoreArrotondatoISEE:= valoreISEE - moduloValore;
          end if;

          --calcolo il numero di punti da sottrare per ogni tot euro
          punteggio := (valoreArrotondatoISEE/euroISEE_OGNI)*puntiEuroISEE_MENO;

          if (punteggio > puntiISEE_MAX) then
             punteggio := puntiISEE_MAX;
          end if;
        end if;
  -- 01/02/2007 sostituita la insert: era costruita su una stringa ed eseguita tramite execute immediate
  INSERT INTO AS_VALORE_ISEE (
    PRGVALOREISEE, CDNLAVORATORE, NUMANNO,
    NUMVALOREISEE, DATINIZIOVAL, DATFINEVAL,
    NUMPUNTIISEE, STRNOTA, strIbanNazione, strIbanControllo,
    strCinLavoratore, strAbiLavoratore, strCabLavoratore, strCCLavoratore,
    CDNUTINS, DTMINS, CDNUTMOD, DTMMOD)
  VALUES (
    S_AS_VALORE_ISEE.NEXTVAL, cdnlavoratore, numanno,
    valoreISEE, to_date(inizio, 'DD/MM/YYYY'), to_date(fine, 'DD/MM/YYYY'),
    punteggio, strnote, p_strIbanNazione, p_strIbanControllo,
    p_strCinLavoratore, p_strAbiLavoratore, p_strCabLavoratore, p_strCCLavoratore,
    cdnutins, sysdate, cdnutmod, sysdate );

end calcoloPunteggioISEE;


/*********************************************************************
* ricalcolo del puteggio del valore ISEE in fase di aggiornamento    *
*                         *
*                    *
*********************************************************************/
procedure aggiornamentoPunteggioISEE(p_cdnlavoratore varchar2,
      p_valoreISEE number,
      p_datainizioval varchar2,
      p_datafineval varchar2,
      p_numanno varchar2,
      p_strnote varchar2,
      p_codmonomotivomodifica varchar2,
      p_cdnutins varchar2,
      p_cdnutmod varchar2,
      p_prgValIsee number,
      p_tipoGraduatoria varchar2,
      p_numKloValoreIsee number,
      p_strIbanNazione as_valore_isee.strIbanNazione%TYPE,
      p_strIbanControllo as_valore_isee.strIbanControllo%TYPE,
      p_strCinLavoratore as_valore_isee.strCinLavoratore%TYPE,
      p_strAbiLavoratore as_valore_isee.strAbiLavoratore%TYPE,
      p_strCabLavoratore as_valore_isee.strCabLavoratore%TYPE,
      p_strCCLavoratore as_valore_isee.strCCLavoratore%TYPE, p_storicizza varchar2)
                        IS

punteggio number;
risultato number;
moduloValore number;
valoreArrotondatoISEE number;
valoreAggiugere number;
puntiEuroISEE_MENO number;
puntiISEE_MAX number;
euroISEE_OGNI number;
str varchar2(6000);
queryWhere VARCHAR2(255);
datafineval date := null;
begin

        puntiEuroISEE_MENO := calcolopunteggioisee_meno(p_tipograduatoria);
        puntiISEE_MAX := calcolopuntiisee_max(p_tipograduatoria);
        euroISEE_OGNI := calcolopuntiisee_ogni(p_tipograduatoria);
        if p_valoreISEE < euroISEE_OGNI then
          punteggio := 0;
        else
          moduloValore := MOD(p_valoreISEE, euroISEE_OGNI);
          
          --calcolo l'approssimazione
          if (moduloValore > 500) then
             valoreAggiugere := euroISEE_OGNI - moduloValore;
             valoreArrotondatoISEE :=  p_valoreISEE + valoreAggiugere;
          else
             valoreArrotondatoISEE:= p_valoreISEE - moduloValore;
          end if;

          --calcolo il numero di punti da sottrare per ogni tot euro
          punteggio := (valoreArrotondatoISEE/euroISEE_OGNI)*puntiEuroISEE_MENO;

          if (punteggio > puntiISEE_MAX) then
             punteggio := puntiISEE_MAX;
          end if;
        end if;
    -- storicizzazione nella tabella di LOG
  if (p_storicizza = 'TRUE') then

    -- salvare la riga corrente nello storico  AS_VALORE_ISEE_STORICO
    INSERT INTO as_valore_isee_storico (
      prgvaliseestorico,
      prgvaloreisee,
      numanno,
      numvaloreisee,
      datinizioval,
      datfineval,
      numpuntiisee,
      strnota,
      cdnutins,
      dtmins,
      cdnutmod,
      dtmmod,
      stribannazione,
      stribancontrollo,
      strcinlavoratore,
      strabilavoratore,
      strcablavoratore,
      strcclavoratore,
      codmonomotivomodifica,
      cdnutsto,
      dtmsto
    )
    select
    S_AS_VALORE_ISEE_STORICO.NEXTVAL,
    PRGVALOREISEE,
    NUMANNO,
    NUMVALOREISEE,
    DATINIZIOVAL,
    DATFINEVAL,
    NUMPUNTIISEE,
    STRNOTA,
    CDNUTINS,
    DTMINS,
    CDNUTMOD,
    DTMMOD,
    STRIBANNAZIONE,
    STRIBANCONTROLLO,
    STRCINLAVORATORE,
    STRABILAVORATORE,
    STRCABLAVORATORE,
    STRCCLAVORATORE,
    p_codmonomotivomodifica,
    p_cdnutmod,
    sysdate
    from AS_VALORE_ISEE
    where PRGVALOREISEE = p_prgValIsee;

  end if;

    if p_datafineval is not null and p_datafineval = ''  then
       datafineval := null;
    else
      datafineval := to_date(p_datafineval, 'dd/mm/yyyy');
    end if;

  queryWhere :=  ' WHERE PRGVALOREISEE = ' || p_prgValIsee;

    PG_LOG.doLog('U', 'AS_VALORE_ISEE', p_cdnutmod, queryWhere);

    -- 01/02/2007 sostituita la update: era costruita su una stringa ed eseguita tramite execute immediate
  UPDATE AS_VALORE_ISEE SET
  CDNLAVORATORE     = p_cdnlavoratore,
  NUMVALOREISEE     = p_valoreISEE,
  NUMPUNTIISEE      = punteggio,
  DATINIZIOVAL      = to_date(p_datainizioval, 'dd/mm/yyyy'),
  DATFINEVAL        = datafineval,
  NUMANNO           = p_numanno,
  STRNOTA           = p_strnote,
  CDNUTMOD          = p_cdnutmod,
  DTMMOD            = SYSDATE,
  strIbanNazione    = p_strIbanNazione,
  strIbanControllo  = p_strIbanControllo,
  strCinLavoratore  = p_strCinLavoratore,
  strAbiLavoratore  = p_strAbiLavoratore,
  strCabLavoratore  = p_strCabLavoratore,
  strCCLavoratore   = p_strCCLavoratore,
  NUMKLOVALOREISEE  = p_numKloValoreIsee +1
  WHERE PRGVALOREISEE = p_prgValIsee;

end aggiornamentoPunteggioISEE;

/************************************************************
* recupero il valore di punti se il candidato ha una DID    *
* dalla tabella di configurazione                           *
************************************************************/
function incrementoPuntiDID(tipoGraduatoria varchar2)
                              RETURN NUMBER IS

incrementoPunteggio number;
begin

        select cl.num into incrementoPunteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = 'PT297';

        return incrementoPunteggio;

        exception
      when no_data_found then
               return 0;

end incrementoPuntiDID;

/************************************************************
* recupero il valore di punti se il candidato ha una DID    *
* dalla tabella di configurazione                           *
************************************************************/
function incrementoPuntiDIDAnzianita(tipoGraduatoria varchar2,
                                     p_anzianita do_nominativo.stranzianita%type,
									 p_config  Ts_Config_Loc.num%type,  
									 p_prgConfigPunteggioDID  OUT number )
                              RETURN NUMBER IS

incrementoPunteggio number;
mesiAnzianita number;
giorniAnzianita number;
p_punt_did number;
p_punt_did_max number;
p_punt_did_ogni number;


begin

     mesiAnzianita := to_number(substr(p_anzianita, 1, instr(p_anzianita, '-', 1)-1));
	 giorniAnzianita := to_number(substr(p_anzianita, instr(p_anzianita, '-', 1)+1));
	 if p_config = 2 then   -----VDA
		if mesiAnzianita = 0 then
		  incrementoPunteggio := 0;
		else
			select num, prgconfigpunteggio into incrementoPunteggio, p_prgConfigPunteggioDID
			 from (
				 select to_number(substr(strvalore, 1, instr(strvalore, '-', 1)-1)) as mesiconfig,
				 to_number(substr(strvalore, instr(strvalore, '-', 1)+1)) as giorniconfig,
				 num,
				 prgconfigpunteggio
				  from ts_config_punteggio cp
				  where cp.codtipoconfig=tipoGraduatoria ||'_PT297' and (
				   (to_number(substr(strvalore, 1, instr(strvalore, '-', 1)-1)) < mesiAnzianita) or
				   (to_number(substr(strvalore, 1, instr(strvalore, '-', 1)-1)) = mesiAnzianita and giorniAnzianita >= to_number(substr(strvalore, instr(strvalore, '-', 1)+1)))
				)
				  order by mesiconfig desc, giorniconfig desc)
			where rownum = 1;
		end if;
	  elsif p_config = 3 then  ----CALABRIA
	    select num into p_punt_did
		 from ts_config_punteggio
		  where codtipoconfig = tipoGraduatoria
			and strvalore = 'ANZDID';

		select num  into p_punt_did_max
		 from ts_config_punteggio
		  where codtipoconfig = tipoGraduatoria
			and strvalore = 'ANZ_MAX';

		select num  into p_punt_did_ogni
		 from ts_config_punteggio
		  where codtipoconfig = tipoGraduatoria
			and strvalore = 'ANZ_OGNI';

        incrementoPunteggio := (mesiAnzianita/p_punt_did_ogni) * p_punt_did; 
		if incrementoPunteggio > p_punt_did_max then
			incrementoPunteggio := p_punt_did_max;
		end if;
	  else
	    incrementoPunteggio :=0;
	  end if;

        return incrementoPunteggio;

exception
  when no_data_found then
   return 0;

end incrementoPuntiDIDAnzianita;

/************************************************************
* recupero il valore di punti se il candidato ha una DID    *
* dalla tabella di configurazione                           *
************************************************************/
function incrementoPuntiEsperienza(tipoGraduatoria varchar2,
                                     p_mesiEsp number
									  )
                              RETURN NUMBER IS

incrementoPunteggio number;
p_punt_esp number;
p_punt_esp_max number;
p_punt_esp_ogni number;


begin

select num into p_punt_esp
 from ts_config_punteggio
  where codtipoconfig = tipoGraduatoria
    and strvalore = 'ESP';

select num 	into p_punt_esp_max
 from ts_config_punteggio
  where codtipoconfig = tipoGraduatoria
    and strvalore = 'ESP_MAX';
	
select num 	into p_punt_esp_ogni
 from ts_config_punteggio
  where codtipoconfig = tipoGraduatoria
    and strvalore = 'ESP_OGNI';	

incrementoPunteggio := (p_mesiEsp/p_punt_esp_ogni) * p_punt_esp;

if incrementoPunteggio >  p_punt_esp_max then
  	incrementoPunteggio := p_punt_esp_max;
end if;

        return incrementoPunteggio;

exception
  when no_data_found then
   return 0;

end incrementoPuntiEsperienza;


/*****************************************************************
* recupero il valore di punti a seconda dell'età del candidato   *
* dalla tabella di configurazione                                *
*****************************************************************/
function incrementoPuntiEta(tipoGraduatoria varchar2,
                            etaCandidato number)
                              RETURN NUMBER IS

incrementoPunteggio number;
tipo varchar2(100);
v_Eta1 varchar2(3);
v_Eta2 varchar2(3);
v_postrattino number;
begin
       tipo := tipoGraduatoria ||'_ETA';
	   
	  if getNumConfig('ASATTRIB') = 2 then  ---configurazione per VDA
	    for curEta in (select cl.* from ts_config_punteggio cl
		                where cl.codtipoconfig = tipo) loop
			v_postrattino := 0;
			v_postrattino := instr(curEta.strvalore, '-');			
			if v_postrattino > 0 then
			  v_Eta1 := substr(curEta.strvalore, 1, v_postrattino-1);
			  v_Eta2 := substr(curEta.strvalore, v_postrattino+1);
			  if  etaCandidato >= to_number(v_Eta1) and etaCandidato <= to_number(v_Eta2) then
			      incrementoPunteggio := curEta.num;  
			    exit;
			  end if;
			else
			 if  etaCandidato >= to_number(curEta.strvalore) then
			   incrementoPunteggio := curEta.num;
			   exit;
			 end if;
			end if;
		end loop;
	  else
        select nvl(max(cl.num),0) into incrementoPunteggio
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipo
        and to_number(cl.strvalore) <= etaCandidato;
	  end if;

        return incrementoPunteggio;

        exception
      when no_data_found then
               return 0;

end incrementoPuntiEta;

/*****************************************************************
* recupero il prgConfigPunteggio a seconda della stringa passata *
* dalla tabella di configurazione                                *
*****************************************************************/
function checkPrgConfigPunteggio(tipoGraduatoria varchar2,
                                 p_strValore ts_config_punteggio.strvalore%TYPE)
                              RETURN NUMBER IS
p_prg number;
begin
        select cl.prgconfigpunteggio into p_prg
        from ts_config_punteggio cl
        where cl.codtipoconfig = tipoGraduatoria
        and cl.strvalore = p_strValore;

        return p_prg;

        exception
      when no_data_found then
               return 0;

end checkPrgConfigPunteggio;


/*********************************************************************
* esegue l'inserimento o l'aggiornamento nella tabella AS_PUNTEGGIO  *
* dei singoli punteggi che danno il punteggio completo               *
**********************************************************************/
procedure ASUpdatePunteggio(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                           p_prgConfigPunteggio Ts_Config_Punteggio.Prgconfigpunteggio%TYPE,
                           p_punteggio number,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                    ) IS

checkPunteggio number;
queryWhere VARCHAR2(255);
begin

  select count(ap.prgNominativo) into checkPunteggio from as_punteggio ap
  where ap.prgnominativo = p_prgNominativo
  and ap.prgconfigpunteggio = p_prgConfigPunteggio;

  if (checkPunteggio = 0) then

     insert into as_punteggio
     (prgnominativo, prgconfigpunteggio, numpunteggio, cdnutins, dtmins)
     values
     (p_prgNominativo, p_prgConfigPunteggio, p_punteggio, p_cdnUtente, sysdate);

  else

     -- storicizzazione nella tabella di LOG
     queryWhere :=  ' WHERE prgnominativo = ' || p_prgNominativo ||
             'AND prgconfigpunteggio = ' || p_prgConfigPunteggio || ' ';

     PG_LOG.doLog('U', 'AS_PUNTEGGIO', p_cdnUtente, queryWhere);

     update as_punteggio
     set
     numpunteggio = p_punteggio,
     cdnutins = p_cdnUtente,
     dtmins = sysdate
     where
     prgnominativo = p_prgNominativo
     and prgconfigpunteggio = p_prgConfigPunteggio;

  end if;

 exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;

end ASUpdatePunteggio;

/*********************************************************************
* esegue l'aggiornamento nella tabella DO_NOMINATIVO  *
* con ValoreIsee alla data chiamata                   *
**********************************************************************/
procedure ASUpdateValoreISEE(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                           p_ValoreIsee Do_Nominativo.Numvaloreisee%TYPE,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                           p_CodeOut OUT number
                           ) IS

checkPunteggio number;
queryWhere VARCHAR2(255);
numklonom do_nominativo.numklonominativo%type;
ValoreIsee do_nominativo.numvaloreisee%type;

begin

select t.numklonominativo into numklonom from do_nominativo t where t.prgnominativo = p_prgNominativo;

     queryWhere :=  ' WHERE prgnominativo = ' || p_prgNominativo;

     PG_LOG.doLog('U', 'DO_NOMINATIVO', p_cdnUtente, queryWhere);

if p_ValoreIsee is null then
  ValoreIsee := -1;
else
  ValoreIsee := p_ValoreIsee;
end if;

UPDATE DO_NOMINATIVO t
  SET t.numvaloreisee = ValoreIsee,
     t.numklonominativo = numklonom + 1,
     t.cdnutmodcm   = p_cdnUtente,
     t.dtmmodcm     = sysdate
 WHERE t.prgnominativo = p_prgNominativo;

 exception
      when others then
       p_CodeOut := sqlcode;
       dbms_output.put_line('Errore ASUpdateValoreISEE= ' || sqlcode || ' ' || sqlerrm);
         rollback;

end ASUpdateValoreISEE;


--********************************************************************
-- Funzione che gestisce l'inserimento ISEE in caso di istanze grad.Art.16 Online
--********************************************************************

function ASGestioneIseeOnline(p_cdnLavoratore IN NUMBER,
                                                 p_dataIstanza IN VARCHAR2, 
                                                 p_valoreIsee IN NUMBER,
                                                 p_annoRiferimento IN NUMBER,
                                                 p_cdnutente IN NUMBER,
                                                 p_prgrosa IN do_rosa.prgrosa%type,
                                                 p_prgRichAz IN do_richiesta_Az.prgrichiestaaz%type)
                                                 return number IS


v_numRec NUMBER;
v_DATINIZIOVAL      as_valore_isee.DATINIZIOVAL%type;
v_DATFINEVAL        as_valore_isee.DATFINEVAL%type;
v_PRGVALOREISEE     as_valore_isee.PRGVALOREISEE%type;
v_NUMKLOVALOREISEE  as_valore_isee.NUMKLOVALOREISEE%type;
v_RecValIsee        AS_VALORE_ISEE%rowtype;
v_DataIniPeriodo            date;
v_annoRiferimento  NUMBER;


begin
  
  
  select count(*) into v_numRec   ----Caso0 : lavoratore non ha nessun valore Isee a sistema
  from AS_VALORE_ISEE
  where CDNLAVORATORE=p_cdnLavoratore;
  
  
  if v_numRec = 0 then
    PG_INCROCIO.calcoloPunteggioISEE(p_valoreIsee, 'AS', p_cdnLavoratore, p_dataIstanza, null,
                                          p_annoRiferimento, null, to_char(p_cdnutente), to_char(p_cdnutente), null, null, null, null, null, null);
  else 
    select count(*) into v_numRec   ----Caso1 : data inizio a sistema uguale a data di riferimento istanza
    from AS_VALORE_ISEE
    where CDNLAVORATORE=p_cdnLavoratore 
    AND TRUNC (DATINIZIOVAL) = to_date(p_dataIstanza, 'dd/mm/yyyy') ;


    if v_numRec > 0 then    
      select vIsee.*  into v_RecValIsee 
       from AS_VALORE_ISEE vIsee
      where CDNLAVORATORE=p_cdnLavoratore 
      AND TRUNC (DATINIZIOVAL) = to_date(p_dataIstanza, 'dd/mm/yyyy') ;
      
      if p_annoRiferimento is null then
        v_annoRiferimento := v_RecValIsee.NUMANNO;
      else 
        v_annoRiferimento := p_annoRiferimento;
      end if;
        
      PG_INCROCIO.AggiornamentoPunteggioIsee(to_char(p_cdnLavoratore), p_valoreIsee, p_dataIstanza, to_char(v_RecValIsee.DATFINEVAL, 'DD/MM/YYYY'),
                                             to_char(v_annoRiferimento), v_RecValIsee.STRNOTA,
                                             'A', to_char(v_RecValIsee.cdnutins), to_char(p_cdnutente), v_RecValIsee.PRGVALOREISEE, 'AS', v_RecValIsee.NUMKLOVALOREISEE, v_RecValIsee.strIbanNazione, 
                                             v_RecValIsee.strIbanControllo, v_RecValIsee.strCinLavoratore, v_RecValIsee.strAbiLavoratore, v_RecValIsee.strCabLavoratore,
                                             v_RecValIsee.strCCLavoratore, 'TRUE');

    else
      SELECT count(*) into v_numRec  ----Caso2 : data di riferimento istanza nell'intervallo di un valore già presente a sistema
        FROM AS_VALORE_ISEE vIsee
      WHERE CDNLAVORATORE=p_cdnLavoratore 
      AND  to_date(p_dataIstanza, 'dd/mm/yyyy') > TRUNC(DATINIZIOVAL) AND to_date(p_dataIstanza, 'dd/mm/yyyy') <= nvl(TRUNC(DATFINEVAL),trunc(sysdate)) ;
      if v_numRec > 0 then   
        SELECT vIsee.* into v_RecValIsee 
          FROM AS_VALORE_ISEE vIsee
        WHERE CDNLAVORATORE=p_cdnLavoratore 
        AND  to_date(p_dataIstanza, 'dd/mm/yyyy') > TRUNC(DATINIZIOVAL) AND to_date(p_dataIstanza, 'dd/mm/yyyy') <= nvl(TRUNC(DATFINEVAL),to_date(p_dataIstanza, 'dd/mm/yyyy')) ;
        --- Procedura da creare per aggiornamento record isee già esistente ma con datafinevalidità = dataistanza - 1
        PG_INCROCIO.aggiornaDtFineRecordPrecedente(to_char( to_date( p_dataIstanza, 'DD/MM/YYYY')-1, 'dd/mm/yyyy') , p_cdnutente, v_RecValIsee.prgvaloreisee);
        PG_INCROCIO.calcoloPunteggioISEE(p_valoreIsee, 'AS', p_cdnLavoratore, p_dataIstanza, to_char(v_RecValIsee.DATFINEVAL, 'DD/MM/YYYY'),
                                          p_annoRiferimento, null, to_char(p_cdnutente), to_char(p_cdnutente), null, null, null, null, null, null);
      else
        BEGIN
          SELECT datInizioSucc into v_DataIniPeriodo  ----Caso4 : data di riferimento istanza < a periodo di validità esistente e non incrocia nessun altro intervallo          
          from ( select trunc(datinizioval) as datInizioSucc
                from AS_VALORE_ISEE
                where CDNLAVORATORE=p_cdnLavoratore --and DATFINEVAL IS NOT NULL
                 AND  TRUNC(DATINIZIOVAL) > to_date(p_dataIstanza, 'dd/mm/yyyy')
                order by DATINIZIOVAL asc
            ) where  rownum =1;
            
          PG_INCROCIO.calcoloPunteggioISEE(p_valoreIsee, 'AS', p_cdnLavoratore, p_dataIstanza, to_char(v_DataIniPeriodo -1, 'DD/MM/YYYY'),
                                            p_annoRiferimento, null, to_char(p_cdnutente), to_char(p_cdnutente), null, null, null, null, null, null);
        EXCEPTION 
          WHEN NO_DATA_FOUND THEN   ----Caso3 : data di riferimento istanza > ultimo periodo di validità a sistema
          PG_INCROCIO.calcoloPunteggioISEE(p_valoreIsee, 'AS', p_cdnLavoratore, p_dataIstanza, null,
                                          p_annoRiferimento, null, to_char(p_cdnutente), to_char(p_cdnutente), null, null, null, null, null, null);
        END;
      end if;
    end if;
  end if;
   return 0;
exception
    when others then
    ---Procedura di inserimento nella tabella AS_VALORE_ISEE_SCARTO
    PG_INCROCIO.ASInserisciScartoIsee(p_cdnLavoratore, p_dataIstanza, p_valoreIsee, p_annoRiferimento, p_cdnutente, p_prgrosa,p_prgRichAz);
    return -1;
end ASGestioneIseeOnline;


--*********************************************************************

procedure ASInserisciScartoIsee(p_cdnLavoratore IN NUMBER,
                                                 p_dataIstanza IN VARCHAR2, 
                                                 p_valoreIsee IN NUMBER,
                                                 p_annoRiferimento IN NUMBER,
                                                 p_cdnutente IN NUMBER,
                                                 p_prgrosa IN do_rosa.prgrosa%type,
                                                 p_prgRichAz IN do_richiesta_Az.prgrichiestaaz%type)
                     IS
PRAGMA AUTONOMOUS_TRANSACTION;                     
                     
BEGIN                      
                                               
  insert into AS_ISEE_SCARTO (PRGISEESCARTO, 
                              CDNLAVORATORE,                                                 
                              NUMVALOREISEE,
                              DATRIFERIMENTO,
                              NUMANNO,
                              PRGROSA,
                              CDNUTINS,
                              DTMINS,
                              PRGRICHIESTAAZ)
        values
                              (S_AS_ISEE_SCARTO.nextval,
                              p_cdnLavoratore,
                              p_valoreIsee,
                              to_date(p_dataIstanza,'dd/mm/yyyy'),
                              p_annoRiferimento,
                              p_prgrosa,
                              p_cdnutente,
                              sysdate,
                              p_prgRichAz);
  commit;
EXCEPTION  
  WHEN OTHERS THEN
       rollback;  
end ASInserisciScartoIsee;                            

/*********************************************************************
* esegue l'aggiornamento nella tabella DO_NOMINATIVO  *
* con STRANZIANITA alla data Pubblicazione                   *
**********************************************************************/
procedure ASAggiornaAnzianita(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                           p_Anzianita Do_Nominativo.STRANZIANITA%TYPE,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                           p_CodeOut OUT number
                           ) IS

queryWhere VARCHAR2(255);
numklonom do_nominativo.numklonominativo%type;


begin

select t.numklonominativo into numklonom from do_nominativo t where t.prgnominativo = p_prgNominativo;

     queryWhere :=  ' WHERE prgnominativo = ' || p_prgNominativo;

     PG_LOG.doLog('U', 'DO_NOMINATIVO', p_cdnUtente, queryWhere);


UPDATE DO_NOMINATIVO t
  SET t.STRANZIANITA = p_Anzianita,
     t.numklonominativo = numklonom + 1,
     t.cdnutmodcm   = p_cdnUtente,
     t.dtmmodcm     = sysdate
 WHERE t.prgnominativo = p_prgNominativo;

 exception
      when others then
       p_CodeOut := sqlcode;
       dbms_output.put_line('Errore ASAggiornaAnzianita= ' || sqlcode || ' ' || sqlerrm);
         rollback;

end ASAggiornaAnzianita;

/*********************************************************************
* esegue l'aggiornamento nella tabella DO_NOMINATIVO  *
* con Numero Mesi Esperienza alla data Pubblicazione                   *
**********************************************************************/
procedure ASAggiornaMesiEsp(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                           p_NumMesiEsp Do_Nominativo.NUMMESIESP%TYPE,
                           p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                           p_CodeOut OUT number
                           ) IS

queryWhere VARCHAR2(255);
numklonom do_nominativo.numklonominativo%type;


begin

select t.numklonominativo into numklonom from do_nominativo t where t.prgnominativo = p_prgNominativo;

     queryWhere :=  ' WHERE prgnominativo = ' || p_prgNominativo;

     PG_LOG.doLog('U', 'DO_NOMINATIVO', p_cdnUtente, queryWhere);


UPDATE DO_NOMINATIVO t
  SET t.NUMMESIESP = p_NumMesiEsp,
     t.numklonominativo = numklonom + 1,
     t.cdnutmodcm   = p_cdnUtente,
     t.dtmmodcm     = sysdate
 WHERE t.prgnominativo = p_prgNominativo;

 exception
      when others then
       p_CodeOut := sqlcode;
       dbms_output.put_line('Errore ASAggiornaMesiEsp= ' || sqlcode || ' ' || sqlerrm);
         rollback;

end ASAggiornaMesiEsp;


/*************************************************************************************
* esegue l'aggiornamento del numpunteggio del lavoratore nella graduatoria specifica *
*************************************************************************************/
function ASUpdatePunteggioLavoratore(p_prgNominativo Do_Nominativo.Prgnominativo%TYPE,
                                     p_punteggio number,
                                     p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                    ) RETURN NUMBER IS

checkPunteggio number;
begin

     update do_nominativo
     set
     numpunteggio = p_punteggio,
     numklonominativo = numklonominativo+1
     where
     prgnominativo = p_prgNominativo;

     return 0;

 exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
             return -1;

end ASUpdatePunteggioLavoratore;

/*************************************************************************************
* esegue l'aggiornamento del numpunteggio del lavoratore nella graduatoria specifica *
*************************************************************************************/

function ASCalcolaEsperienza(p_cdnlavoratore Do_Nominativo.cdnLavoratore%TYPE,
                             p_prgIncrocio  do_incrocio.prgincrocio%type,
							 p_prgRichiestaAZ do_richiesta_az.prgRichiestaAz%type,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                    ) RETURN NUMBER IS
nummeseinizio number;
numannoinizio number;
nummesefine   number;
numannofine   number;
v_espok       number;
nummesi      pr_esp_lavoro.nummesi%type; 
nummesiesp    number :=0;
numanni       number;

cursor EspMansione is 
   
   select nvl(pel.nummeseinizio, 0) as nummeseinizio,
          pel.numannoinizio as numannoinizio,
      nvl(pel.nummesefine,0) as nummesefine,
      nvl(pel.numannofine,0) as numannofine,
      nvl(pel.nummesi,0)  as nummesi
      from pr_esp_lavoro pel
     inner join pr_mansione pr_man on (pel.prgmansione = pr_man.prgmansione)
     inner join do_mansione do_man on (do_man.codmansione = pr_man.codmansione or
                                         (substr(do_man.codmansione, -2, 2) = '00' and
                                          substr(do_man.codmansione,1,5) = substr(pr_man.codmansione,1,5))
                                        and do_man.prgalternativa =1)
       inner join do_richiesta_az az on  (do_man.prgrichiestaAz = az.prgrichiestaaz)
            where pr_man.cdnLavoratore = p_cdnlavoratore
               and az.prgrichiestaaz = p_prgRichiestaAZ
                order by pel.numannoinizio, pel.nummeseinizio, pel.numannofine, pel.nummesefine  ;				

begin

for curEsp in EspMansione loop

		if curEsp.nummesi > 0 then
			nummesiesp := nummesiesp + curEsp.nummesi;
		else
			if  curEsp.numannofine = 0 or curEsp.nummesefine = 0 or curEsp.nummeseinizio = 0 or curEsp.numannoinizio > curEsp.numannofine then
				nummesiesp := 0;		
			else 
				if 	curEsp.numannoinizio <> curEsp.numannofine then
					numanni := curEsp.numannofine - curEsp.numannoinizio -1;
					nummesiesp := nummesiesp + (12*numanni +(12 - curEsp.nummeseinizio +1) + curEsp.nummesefine);
				else
					nummesiesp := nummesiesp + (curEsp.nummesefine - curEsp.nummeseinizio +1);
				end if;
			end if;
		end if;
end loop;

     return nummesiesp;

 exception
      when others then
       dbms_output.put_line('Errore ASCalcolaEsperienza= ' || sqlcode || ' ' || sqlerrm);
         rollback;
             return -1;

end ASCalcolaEsperienza;



/******************************************************************************************
* esegue l'aggiornamento del numOrdine di tutti i lavoratori per la graduatoria specifica *
*******************************************************************************************/
function ASCalcolaPosizione(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                            p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE)
                             RETURN NUMBER IS

i number;
prioritaLSU varchar2(10);

begin

  i := 0;

  if (p_prgTipoIncrocio = 7) then

    select rich.codtipolsu into prioritaLSU
    from do_richiesta_az rich where rich.prgrichiestaaz = p_prgRichiestaAz;

    if (prioritaLSU = 'B') then
       DECLARE
        CURSOR nominativiLsuBasseCursor IS
          select n.numordine, n.prgnominativo, n.NUMANZIANITALSU, n.FLGPROFESSIONALITA,
                 n.NUMCARICOFAM, a.prgalternativa, l.datnasc
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
          order by prgalternativa, decode(NUMANZIANITALSU, null, 0) desc,
                   decode(NUMCARICOFAM, null, 0) desc, datnasc desc;
      BEGIN
         i := 0;
         FOR nominativi IN nominativiLsuBasseCursor
         LOOP
            i := i+1;

            update do_nominativo
            set numordine = i,
                numklonominativo = numklonominativo+1
            where do_nominativo.prgnominativo = nominativi.prgnominativo;

         END LOOP;
      END;
    elsif (prioritaLSU = 'M') then
      DECLARE
        CURSOR nominativiLsuAlteCursor IS
          select n.numordine, n.prgnominativo, n.NUMANZIANITALSU, n.FLGPROFESSIONALITA,
                 n.NUMCARICOFAM, a.prgalternativa, l.datnasc
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
          order by prgalternativa, decode(FLGPROFESSIONALITA, 'S', '2', 'N', '1', null, '0') desc,
                   decode(NUMCARICOFAM, null, 0) desc, datnasc desc;
      BEGIN
         i := 0;
         FOR nominativi IN nominativiLsuAlteCursor
         LOOP
            i := i+1;

            update do_nominativo
            set numordine = i,
                numklonominativo = numklonominativo+1
            where do_nominativo.prgnominativo = nominativi.prgnominativo;

         END LOOP;
      END;
    end if;
  elsif (p_prgTipoIncrocio = 8 or p_prgTipoIncrocio = 13) then

    -- dona 19/10/2007 svuoto la posizione per tutti i lavoratori delle graduatoria mobilità
    DECLARE
       CURSOR nominativiGradCursor IS
          select n.prgnominativo
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa;
    BEGIN
       FOR nominativiGrad IN nominativiGradCursor
       LOOP

          update do_nominativo
          set numordine = null,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativiGrad.prgnominativo;

       END LOOP;
    END;

    -- setto la posizione solo per i lavoratori in mobilità
    DECLARE
       CURSOR nominativiCursor IS
          select n.prgnominativo, a.prgalternativa, l.datnasc, mob.prgmobilitaiscr,
          mob.datfinemov, mob.datiniziomov, mob.flgscheda
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          inner join am_mobilita_iscr mob on mob.cdnlavoratore = n.cdnlavoratore
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
          and (mob.datinizio <= to_date(to_char(rich.datpubblicazione, 'dd/mm/yyyy'), 'dd/mm/yyyy')
               and (mob.datfine >= to_date(to_char(rich.datpubblicazione, 'dd/mm/yyyy'), 'dd/mm/yyyy')
               or mob.datfine is null))
          order by prgalternativa, flgscheda desc NULLS LAST,
          datfinemov NULLS LAST, datiniziomov NULLS LAST, datnasc desc;
    BEGIN
       i := 0;
       FOR nominativi IN nominativiCursor
       LOOP
          i := i+1;

          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;
    END;

  elsif (p_prgTipoIncrocio = 9 or p_prgTipoIncrocio = 14) then
  --senza aternativa
    DECLARE
       CURSOR nominativiCursor IS
          select n.prgnominativo, l.datnasc, mob.prgmobilitaiscr,
                 mob.datfinemov, mob.datiniziomov, mob.flgscheda, r.prgrosa
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          inner join am_mobilita_iscr mob on mob.cdnlavoratore = n.cdnlavoratore
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and (mob.datinizio <= to_date(to_char(rich.datpubblicazione, 'dd/mm/yyyy'), 'dd/mm/yyyy')
               and (mob.datfine >= to_date(to_char(rich.datpubblicazione, 'dd/mm/yyyy'), 'dd/mm/yyyy')
               or mob.datfine is null))
          order by flgscheda desc NULLS LAST,
          datfinemov NULLS LAST, datiniziomov NULLS LAST, datnasc desc;
    BEGIN
       i := 0;
       FOR nominativi IN nominativiCursor
       LOOP
          i := i+1;

          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo
          and do_nominativo.prgrosa = nominativi.prgrosa;

       END LOOP;
    END;
  elsif (p_prgTipoIncrocio = 5 or p_prgTipoIncrocio = 6) and getNumConfig('ASATTRIB') = 2 then ---per VDA
	 DECLARE
       CURSOR nominativiCursorFamDec IS
       select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, n.flgfamdec, 
              st.codstatooccupaz, n.NUMCARICOFAM, l.strcodicefiscale
           from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
         inner join AS_STORIA_STATO_OCC st on ( inc.prgincrocio = st.prgincrocio
		                                        and l.cdnlavoratore = st.cdnlavoratore)
          inner join de_stato_occupaz d_stato_occupaz on (d_stato_occupaz.codstatooccupaz = st.codstatooccupaz)
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
          and nvl(n.flgfamdec, 'N') = 'S'
          and n.CODTIPOCANC is null
		  and d_stato_occupaz.CODSTATOOCCUPAZRAGG in ('D', 'I')
          and d_stato_occupaz.codstatooccupaz != 'B1'
          order by a.prgalternativa, n.numpunteggio desc, nvl(n.NUMCARICOFAM,0) desc, l.datnasc asc;
     
        CURSOR nominativiCursorQualDisIn IS  
        select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, n.flgfamdec, 
              st.codstatooccupaz, n.NUMCARICOFAM, n.FLGPROFESSIONALITA, l.strcodicefiscale
           from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
         inner join AS_STORIA_STATO_OCC st on (inc.prgincrocio = st.prgincrocio
		                                        and l.cdnlavoratore = st.cdnlavoratore)
          inner join de_stato_occupaz d_stato_occupaz on (d_stato_occupaz.codstatooccupaz = st.codstatooccupaz)
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
          and nvl(n.flgfamdec, 'N') = 'N'
           and (d_stato_occupaz.codstatooccupazragg in ('D','I'))
           and d_stato_occupaz.codstatooccupaz != 'B1'
          and  nvl(n.FLGPROFESSIONALITA, 'N') = 'S'
          and n.CODTIPOCANC is null
        order by a.prgalternativa, n.numpunteggio desc, nvl(n.NUMCARICOFAM,0) desc,l.datnasc asc;

        CURSOR nominativiCursorQualSospAnz IS  
			select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, n.flgfamdec, 
				  st.codstatooccupaz, n.NUMCARICOFAM, n.FLGPROFESSIONALITA, l.strcodicefiscale
			   from do_richiesta_az rich
			  inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
			  inner join do_rosa r on r.prgincrocio = inc.prgincrocio
			  inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
			  inner join do_nominativo n on n.prgrosa = r.prgrosa
			  inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
			   inner join AS_STORIA_STATO_OCC st on (inc.prgincrocio = st.prgincrocio
		                                        and l.cdnlavoratore = st.cdnlavoratore)
			  inner join de_stato_occupaz d_stato_occupaz on (d_stato_occupaz.codstatooccupaz = st.codstatooccupaz)
			  where rich.prgrichiestaaz = p_prgRichiestaAz
			  and inc.prgtipoincrocio = p_prgTipoIncrocio
			  and r.prgrosafiglia is null
			  and r.prgtiporosa != 3
			  and a.prgalternativa = inc.prgalternativa
			   and d_stato_occupaz.codstatooccupaz = 'B1'
         and n.CODTIPOCANC is null
			  and  nvl(n.FLGPROFESSIONALITA, 'N') = 'S'
			order by a.prgalternativa, n.numpunteggio desc, nvl(n.NUMCARICOFAM,0) desc,l.datnasc asc ;         
              
        CURSOR nominativiCursorNonQualDisIn IS  
        select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, n.flgfamdec, 
				  st.codstatooccupaz, n.NUMCARICOFAM, n.FLGPROFESSIONALITA, l.strcodicefiscale
           from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
         inner join AS_STORIA_STATO_OCC st on (inc.prgincrocio = st.prgincrocio
		                                        and l.cdnlavoratore = st.cdnlavoratore)
          inner join de_stato_occupaz d_stato_occupaz on (d_stato_occupaz.codstatooccupaz = st.codstatooccupaz)
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
           and (d_stato_occupaz.codstatooccupazragg in ('D','I'))
           and d_stato_occupaz.codstatooccupaz <> 'B1' 
           and nvl(n.flgfamdec, 'N') = 'N'
          and  nvl(n.FLGPROFESSIONALITA, 'N') = 'N'  
          and n.CODTIPOCANC is null
        order by a.prgalternativa, n.numpunteggio desc, nvl(n.NUMCARICOFAM,0) desc,l.datnasc asc;

        CURSOR nominativiCursorNonQualSospAnz IS  
        select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, n.flgfamdec, 
				  st.codstatooccupaz, n.NUMCARICOFAM, n.FLGPROFESSIONALITA, l.strcodicefiscale
           from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
         inner join AS_STORIA_STATO_OCC st on (inc.prgincrocio = st.prgincrocio
		                                        and l.cdnlavoratore = st.cdnlavoratore)
          inner join de_stato_occupaz d_stato_occupaz on (d_stato_occupaz.codstatooccupaz = st.codstatooccupaz)
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
           and d_stato_occupaz.codstatooccupaz = 'B1'
          and nvl(n.FLGPROFESSIONALITA, 'N') = 'N'
          and n.CODTIPOCANC is null
        order by a.prgalternativa, n.numpunteggio desc, nvl(n.NUMCARICOFAM,0) desc,l.datnasc asc     ;         
 
        CURSOR nominativiCursorQualOcc IS  
        select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, n.flgfamdec, 
				  st.codstatooccupaz, n.NUMCARICOFAM, n.FLGPROFESSIONALITA, l.strcodicefiscale
           from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          inner join AS_STORIA_STATO_OCC st on (inc.prgincrocio = st.prgincrocio
		                                        and l.cdnlavoratore = st.cdnlavoratore)
          inner join de_stato_occupaz d_stato_occupaz on (d_stato_occupaz.codstatooccupaz = st.codstatooccupaz)
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
          and (d_stato_occupaz.codstatooccupazragg = 'O')
          and  nvl(n.FLGPROFESSIONALITA, 'N') = 'S'  
          and n.CODTIPOCANC is null
        order by a.prgalternativa, n.numpunteggio desc, nvl(n.NUMCARICOFAM,0) desc,l.datnasc asc  ;
 
       CURSOR nominativiCursorNonQualOcc IS  
        select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, n.flgfamdec, 
				  st.codstatooccupaz, n.NUMCARICOFAM, n.FLGPROFESSIONALITA, l.strcodicefiscale
           from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
         inner join AS_STORIA_STATO_OCC st on (inc.prgincrocio = st.prgincrocio
		                                        and l.cdnlavoratore = st.cdnlavoratore)
          inner join de_stato_occupaz d_stato_occupaz on (d_stato_occupaz.codstatooccupaz = st.codstatooccupaz)
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
           and (d_stato_occupaz.codstatooccupazragg = 'O')
          and  nvl(n.FLGPROFESSIONALITA, 'N') = 'N'  
          and n.CODTIPOCANC is null
        order by a.prgalternativa, n.numpunteggio desc, nvl(n.NUMCARICOFAM,0) desc,l.datnasc asc
              ;              
       CURSOR nominativiCursorAltri IS  
        select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc, n.flgfamdec, 
				  st.codstatooccupaz, n.NUMCARICOFAM, n.FLGPROFESSIONALITA, l.strcodicefiscale
           from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          left join AS_STORIA_STATO_OCC st on (inc.prgincrocio = st.prgincrocio
		                                        and l.cdnlavoratore = st.cdnlavoratore)
          left join de_stato_occupaz d_stato_occupaz on (d_stato_occupaz.codstatooccupaz = st.codstatooccupaz)
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
          and nvl(d_stato_occupaz.codstatooccupazragg, 'A') = 'A'
          and n.CODTIPOCANC is null
         order by a.prgalternativa, n.numpunteggio desc, nvl(n.NUMCARICOFAM,0) desc,l.datnasc asc
              ;                            
              
           
    BEGIN
       i := 0;
       FOR nominativi IN nominativiCursorFamDec
       LOOP
          i := i+1;
          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;
       
       FOR nominativi IN nominativiCursorQualDisIn
         LOOP
          i := i+1;
          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;

     FOR nominativi IN nominativiCursorQualSospAnz
         LOOP
          i := i+1;
          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;

       FOR nominativi IN nominativiCursorNonQualDisIn
         LOOP
          i := i+1;
          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;       
       
     FOR nominativi IN nominativiCursorNonQualSospAnz
         LOOP
          i := i+1;
          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;       
       
       FOR nominativi IN nominativiCursorQualOcc
         LOOP
          i := i+1;
          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;
       FOR nominativi IN nominativiCursorNonQualOcc
         LOOP
          i := i+1;
          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;       
       
       FOR nominativi IN nominativiCursorAltri
         LOOP
          i := i+1;
          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;              
    END;
  elsif (p_prgTipoIncrocio = 5 or p_prgTipoIncrocio = 6) and getNumConfig('ASATTRIB') = 3 then ---per CALABRIA
    DECLARE
       CURSOR nominativiCursor IS
          select n.prgnominativo, n.numpunteggio, n.numcaricofam, a.prgalternativa, l.datnasc
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
          and n.CODTIPOCANC is null
          order by prgalternativa, numpunteggio desc, nvl(n.NUMCARICOFAM,0) desc, datnasc desc;
    BEGIN
       i := 0;
       FOR nominativi IN nominativiCursor
       LOOP
          i := i+1;

          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;
    END;    	
  else

    DECLARE
       CURSOR nominativiCursor IS
          select n.prgnominativo, n.numpunteggio, a.prgalternativa, l.datnasc
          from do_richiesta_az rich
          inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
          inner join do_rosa r on r.prgincrocio = inc.prgincrocio
          inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
          inner join do_nominativo n on n.prgrosa = r.prgrosa
          inner join an_lavoratore l on l.cdnlavoratore = n.cdnlavoratore
          where rich.prgrichiestaaz = p_prgRichiestaAz
          and inc.prgtipoincrocio = p_prgTipoIncrocio
          and r.prgrosafiglia is null
          and r.prgtiporosa != 3
          and a.prgalternativa = inc.prgalternativa
          and n.CODTIPOCANC is null
          order by prgalternativa, numpunteggio desc, datnasc desc;
    BEGIN
       i := 0;
       FOR nominativi IN nominativiCursor
       LOOP
          i := i+1;

          update do_nominativo
          set numordine = i,
              numklonominativo = numklonominativo+1
          where do_nominativo.prgnominativo = nominativi.prgnominativo;

       END LOOP;
    END;

  end if;

   commit;

   return 0;

   exception
   when others then
    dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
     rollback;
         return -1;

end ASCalcolaPosizione;


/***************************************************************************************************
* rende definitive tutte le graduatorie di quel tipo e ricalcola la posizione di ciascun lavoratore*
***************************************************************************************************/
function ASSetGraduatoriaDefinitiva(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                                    p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE)
                                   RETURN NUMBER IS

retNumber number;
p_cdnStatoRich number;

CURSOR roseCursor IS
    select r.prgrosa
    from do_richiesta_az rich
    inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
    inner join do_rosa r on r.prgincrocio = inc.prgincrocio
    inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
    where rich.prgrichiestaaz = p_prgRichiestaAz
    and inc.prgtipoincrocio = p_prgTipoIncrocio
    and r.prgrosafiglia is null
    and r.prgtiporosa = 2
    and a.prgalternativa = inc.prgalternativa;

CURSOR roseNoAlternativeCursor IS
    select r.prgrosa
    from do_richiesta_az rich
    inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
    inner join do_rosa r on r.prgincrocio = inc.prgincrocio
    where rich.prgrichiestaaz = p_prgRichiestaAz
    and inc.prgtipoincrocio = p_prgTipoIncrocio
    and r.prgrosafiglia is null
    and r.prgtiporosa = 2;

begin

   retNumber := ASCalcolaPosizione(p_prgRichiestaAz, p_prgTipoIncrocio);

   if (retnumber = 0) then

     if (p_prgTipoIncrocio = 9 or p_prgTipoIncrocio = 14) then
          FOR rose IN roseNoAlternativeCursor
          LOOP
               update do_rosa
               set do_rosa.prgTipoRosa = 3,
               do_rosa.NUMKLOROSA = NUMKLOROSA+1
                   where do_rosa.prgRosa = rose.prgrosa;

          END LOOP;
     else
          FOR rose IN roseCursor
          LOOP
               update do_rosa
               set do_rosa.prgTipoRosa = 3,
               do_rosa.NUMKLOROSA = NUMKLOROSA+1
                   where do_rosa.prgRosa = rose.prgrosa;

          END LOOP;
     end if;



     SELECT DO_EVASIONE.CDNSTATORICH into p_cdnStatoRich
     FROM DO_EVASIONE, DO_RICHIESTA_AZ
     WHERE DO_EVASIONE.PRGRICHIESTAAZ = DO_RICHIESTA_AZ.PRGRICHIESTAAZ
     AND DO_RICHIESTA_AZ.Prgrichiestaaz = p_prgRichiestaAz
     AND DO_RICHIESTA_AZ.NUMSTORICO = 0;

     if (p_cdnStatoRich = 2) then
       -- setto lo stato di evasione ad elaborata
       UPDATE DO_EVASIONE
       SET DO_EVASIONE.CDNSTATORICH = 3,
           DO_EVASIONE.DTMMOD = SYSDATE
       WHERE DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;
     end if;
   end if;

   commit;

   return retNumber;

   exception
    when others then
    dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
     rollback;
         return -1;

end ASSetGraduatoriaDefinitiva;


/***************************************************************************************************
* gestisce la riapertura di una graduatoria:                                                       *
* inserisce il motivo di riapertura                                                                *
* per ogni graduatoria definitiva dello stesso tipo viene creata una nuova graduatoria grezza      *
***************************************************************************************************/
function ASRiapriGraduatorie(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                             p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                             p_prgRosa Do_Rosa.Prgrosa%TYPE,
                             p_motivo varchar2,
                             cdnutmod varchar2,
                             p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,               -- progressivo dell'incrocio
                             p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE,                        -- progressivo della rosa
                             p_errCode OUT number                                             -- Codice di Errore
                             )
                            RETURN NUMBER IS

checkNumber number;
p_cdnStatoRich number;
p_out_prgMotivo number;

CURSOR roseCursor IS
    select r.prgrosa, r.numklorosa, inc.prgincrocio
    from do_richiesta_az rich
    inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
    inner join do_rosa r on r.prgincrocio = inc.prgincrocio
    inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
    where rich.prgrichiestaaz = p_prgRichiestaAz
    and inc.prgtipoincrocio = p_prgTipoIncrocio
    and r.prgrosafiglia is null
    and r.prgtiporosa = 3
    and a.prgalternativa = inc.prgalternativa;

CURSOR roseNoAlternativaCursor IS
    select r.prgrosa, r.numklorosa, inc.prgincrocio
    from do_richiesta_az rich
    inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
    inner join do_rosa r on r.prgincrocio = inc.prgincrocio
    where rich.prgrichiestaaz = p_prgRichiestaAz
    and inc.prgtipoincrocio = p_prgTipoIncrocio
    and r.prgrosafiglia is null
    and r.prgtiporosa = 3;

begin

     -- Calcolo il progressivo per la motivazione
     select S_AS_MOTIVO_APERTURAGRAD.nextVal into p_out_prgMotivo from dual;

     -- inserisco il motivo nella tabella AS_MOTIVO_APERTURAGRAD
     insert into as_motivo_aperturagrad
     (prgmotivoaperturagrad, strmotivo, cdnutins, dtmins)
     values
     (p_out_prgMotivo, p_motivo, cdnutmod, sysdate);

     if (p_prgTipoIncrocio = 9 or p_prgTipoIncrocio = 14) then
          FOR rose IN roseNoAlternativaCursor
          LOOP
              -- manca l'inserimento della motivazione
              checkNumber := ASGestioneRiapertura(rose.prgrosa,
                                                rose.numklorosa,
                                                rose.prgIncrocio,
                                                cdnutmod,
                                                p_out_prgMotivo
                                                );

              if (checknumber = 1) then
                 return checknumber;
              end if;

          END LOOP;
     else
          FOR rose IN roseCursor
          LOOP
              -- manca l'inserimento della motivazione
              checkNumber := ASGestioneRiapertura(rose.prgrosa,
                                                rose.numklorosa,
                                                rose.prgIncrocio,
                                                cdnutmod,
                                                p_out_prgMotivo
                                                );

              if (checknumber = 1) then
                 return checknumber;
              end if;

          END LOOP;
     end if;

     -- recupero i nuovi prgrosa e prgincrocio della rosa riaperta che sto visualizzando
     select ros.prgrosafiglia into p_out_prgRosa
     from do_rosa ros
     where ros.prgrosa = p_prgRosa;

     select ros.prgincrocio into p_out_prgIncrocio
     from do_rosa ros
     where ros.prgrosa = p_out_prgRosa;

    commit;

    return 0;

    exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASRiapriGraduatorie;

/***************************************************************************************************
* gestisce le operazione per la riapertura di una graduatoria                                      *
*(viene chiamata all'interno della funzione precedente)                                            *
***************************************************************************************************/
function ASGestioneRiapertura(p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa da copiare
                                p_numklorosa Do_Rosa.Numklorosa%TYPE,                             -- Numklorosa della rosa da aggiornare
                                p_prgIncrocio Do_Incrocio.Prgincrocio%TYPE,                       -- progressivo dell'incricio da copiare
                                p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
                                p_prgMotivo AS_MOTIVO_APERTURAGRAD.Prgmotivoaperturagrad%TYPE
                                ) RETURN NUMBER is

p_out_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE;
p_out_prgRosa DO_ROSA.PRGROSA%TYPE;
p_out_prgNominativo DO_NOMINATIVO.PRGNOMINATIVO%TYPE;
p_old_prgNominativo DO_NOMINATIVO.PRGNOMINATIVO%TYPE;

CURSOR nominativiCursor IS
   select PRGNOMINATIVO,
   CDNLAVORATORE
   from do_nominativo
   where do_nominativo.prgRosa = p_prgRosa;

begin

   -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;

  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  select p_out_prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  p_cdnUtente, sysdate, p_cdnUtente, sysdate
   from do_incrocio
   where do_incrocio.prgIncrocio = p_prgIncrocio;

   -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  select p_out_prgRosa, null, p_out_prgIncrocio, 2, p_cdnUtente, sysdate, p_cdnUtente, sysdate
   from do_rosa
   where do_rosa.prgRosa = p_prgRosa
   and do_rosa.prgIncrocio = p_prgIncrocio;

  -- storicizzo lo stato occupazionale per il nuovo incrocio
  insert into as_storia_stato_occ
  (prgstoriastatoocc, cdnlavoratore, datinizio, codstatooccupaz, codmonoprovenienza, codcategoria181,
  datanzianitadisoc, numanzianitaprec297, codmonocalcoloanzianitaprec297, nummesisosp, datcalcoloanzianita,
  datcalcolomesisosp, numreddito, strnumatto, datatto, datrichrevisione, codstatoatto, datricorsogiurisdiz,
  flgindennizzato, flgpensionato, datfine, strnote, cdnutinsstoria, dtminsstoria, cdnutmodstoria, dtmmodstoria,
  cdnutins, dtmins, prgincrocio)
  select s_as_storia_stato_occ.nextval, ss.cdnlavoratore, ss.datinizio, ss.codstatooccupaz, ss.codmonoprovenienza, ss.codcategoria181,
  ss.datanzianitadisoc, ss.numanzianitaprec297, ss.codmonocalcoloanzianitaprec297, ss.nummesisosp, ss.datcalcoloanzianita,
  ss.datcalcolomesisosp, ss.numreddito, ss.strnumatto, ss.datatto, ss.datrichrevisione, ss.codstatoatto, ss.datricorsogiurisdiz,
  ss.flgindennizzato, ss.flgpensionato, ss.datfine, ss.strnote, ss.cdnutinsstoria, ss.dtminsstoria, ss.cdnutmodstoria, ss.dtmmodstoria,
  p_cdnUtente, sysdate, p_out_prgIncrocio
  from as_storia_stato_occ ss
  where ss.prgincrocio = p_prgIncrocio;

  FOR nominativi IN nominativiCursor
  LOOP
      p_old_prgNominativo := nominativi.PRGNOMINATIVO;

      select s_do_nominativo.nextVal into p_out_prgNominativo from dual;

      -- passo 3: insersco tutti i nominativi della rosa madre nella nuova rosa figlia
      insert into do_nominativo
     (PRGNOMINATIVO,
     CDNLAVORATORE,
     NUMORDINE,
     CODCPITIT,
     CODTIPOINS,
     DTMINS,
     CDNUTINS,
     CODTIPOCANC,
     STRMOTIVOCANC,
     DTMCANC,
     CDNUTCANC,
     PRGROSA,
     NUMPESOETA,
     NUMPESOTITOLO,
     NUMPESOMANSIONE,
     NUMPESOESP,
     NUMPESOINFO,
     NUMPESOLINGUA,
     DECINDICEVICINANZA,
     DATDICHIARAZIONE,
     numpunteggio,
     NUMANZIANITALSU,
     FLGPROFESSIONALITA,
     NUMCARICOFAM,
     datiscrart1,
      numannopuntart1,
      strpriorita,
      strnota,
      numreddito,
      numpersone,
      datdichcarico,
      codcmtipoiscr,
      numpercinvalidita,
      datanzianita68,
      dtmpunteggio,
      cdnutmodcm,
      dtmmodcm,
      numpunteggiopres,
      nummesianz,
      numvaloreisee,
      codmonodid,
      codmonoisee,
	  flgfamdec,
	  STRANZIANITA,
	  NUMMESIESP)
     select p_out_prgNominativo,
     CDNLAVORATORE,
     NUMORDINE,
     CODCPITIT,
     CODTIPOINS,
     sysdate,
     p_cdnUtente,
     CODTIPOCANC,
     STRMOTIVOCANC,
     DTMCANC,
     CDNUTCANC,
     p_out_prgRosa,
     NUMPESOETA,
     NUMPESOTITOLO,
     NUMPESOMANSIONE,
     NUMPESOESP,
     NUMPESOINFO,
     NUMPESOLINGUA,
     DECINDICEVICINANZA,
     DATDICHIARAZIONE,
     numpunteggio,
     NUMANZIANITALSU,
     FLGPROFESSIONALITA,
     NUMCARICOFAM,
     datiscrart1,
      numannopuntart1,
      strpriorita,
      strnota,
      numreddito,
      numpersone,
      datdichcarico,
      codcmtipoiscr,
      numpercinvalidita,
      datanzianita68,
      dtmpunteggio,
      cdnutmodcm,
      dtmmodcm,
      numpunteggiopres,
      nummesianz,
      numvaloreisee,
      codmonodid,
      codmonoisee,
	  flgfamdec,
	  STRANZIANITA,
	  NUMMESIESP
     from do_nominativo
     where do_nominativo.prgRosa = p_prgRosa
     and do_nominativo.prgNominativo = p_old_prgNominativo;

     -- storicizza il punteggio del nominativo in graduatoria
     insert into as_punteggio
      (prgnominativo, prgconfigpunteggio, numpunteggio, cdnutins, dtmins)
      select p_out_prgNominativo, p.prgconfigpunteggio, p.numpunteggio, p_cdnUtente, sysdate
      from as_punteggio p
      where p.prgnominativo = p_old_prgNominativo;

  END LOOP;

   -- passo 3: insersco tutti i nominativi della rosa madre nella nuova rosa figlia
/*   insert into do_nominativo
   (PRGNOMINATIVO,
   CDNLAVORATORE,
   NUMORDINE,
   CODCPITIT,
   CODTIPOINS,
   DTMINS,
   CDNUTINS,
   CODTIPOCANC,
   STRMOTIVOCANC,
   DTMCANC,
   CDNUTCANC,
   PRGROSA,
   NUMPESOETA,
   NUMPESOTITOLO,
   NUMPESOMANSIONE,
   NUMPESOESP,
   NUMPESOINFO,
   NUMPESOLINGUA,
   DECINDICEVICINANZA,
   DATDICHIARAZIONE,
   numpunteggio,
   NUMANZIANITALSU,
   FLGPROFESSIONALITA,
   NUMCARICOFAM)
   select s_Do_Nominativo.Nextval,
   CDNLAVORATORE,
   NUMORDINE,
   CODCPITIT,
   CODTIPOINS,
   sysdate,
   p_cdnUtente,
   CODTIPOCANC,
   STRMOTIVOCANC,
   DTMCANC,
   CDNUTCANC,
   p_out_prgRosa,
   NUMPESOETA,
   NUMPESOTITOLO,
   NUMPESOMANSIONE,
   NUMPESOESP,
   NUMPESOINFO,
   NUMPESOLINGUA,
   DECINDICEVICINANZA,
   DATDICHIARAZIONE,
   numpunteggio,
   NUMANZIANITALSU,
   FLGPROFESSIONALITA,
   NUMCARICOFAM
   from do_nominativo
   where do_nominativo.prgRosa = p_prgRosa;
*/
   -- passo 4: aggiorno nella rosa madre il prgRosaFiglia con il prgRosa della nuova rosa creata
   UPDATE DO_ROSA
   SET DO_ROSA.PRGROSAFIGLIA = p_out_prgRosa,
   DO_ROSA.NUMKLOROSA = p_numklorosa+1,
   DO_ROSA.Cdnutmod = p_cdnUtente,
   DO_ROSA.DTMMOD = SYSDATE,
   DO_ROSA.Prgmotivoaperturagrad = p_prgMotivo
   WHERE DO_ROSA.PRGROSA = p_prgRosa;

   return 0;

  exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASGestioneRiapertura;


/***************************************************************************************************
* gestione dei dati dell'approvazione di una graduatoria                                           *
***************************************************************************************************/
function ASSalvaApprovazGrad(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                             p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE,
                             p_prgapprovazionegrad as_approvazione_grad.prgapprovazionegrad%TYPE,
                             p_numDetermina varchar2,
                             p_datProtocollazione varchar2,
                             p_datPubblicazione varchar2,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                ) RETURN NUMBER is

new_prgapprovazionegrad as_approvazione_grad.prgapprovazionegrad%TYPE;

begin

     if(p_prgapprovazionegrad = 0) then
         -- caso di inserimento
         select s_as_approvazione_grad.nextVal into new_prgapprovazionegrad from dual;

         insert into as_approvazione_grad
         (prgapprovazionegrad,
          numdetermina, datpubblicazionegrad,
          datprotocollo, cdnutins, dtmins, cdnutmod, dtmmod)
          values
          (new_prgapprovazionegrad,
          p_numDetermina,
          to_date(p_datPubblicazione, 'dd/mm/yyyy'),
          to_date(p_datProtocollazione, 'dd/mm/yyyy'),
          p_cdnUtente, sysdate, p_cdnUtente, sysdate);

     else
         -- caso di aggiornamento
         new_prgapprovazionegrad := p_prgapprovazionegrad;

         update as_approvazione_grad
         set
         numdetermina = p_numDetermina,
         datpubblicazionegrad = to_date(p_datPubblicazione, 'dd/mm/yyyy'),
         datprotocollo = to_date(p_datProtocollazione, 'dd/mm/yyyy'),
         cdnutmod = p_cdnUtente,
         dtmmod = sysdate
         where prgapprovazionegrad = new_prgapprovazionegrad;

     end if;


     if (p_prgTipoIncrocio = 9 OR p_prgTipoIncrocio = 14) then
       update do_rosa
       set
       prgapprovazionegrad = new_prgapprovazionegrad,
       numklorosa = numklorosa + 1
       where prgrosa IN
       (select r.prgrosa
        from do_richiesta_az rich
        inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
        inner join do_rosa r on r.prgincrocio = inc.prgincrocio
        where rich.prgrichiestaaz = p_prgRichiestaAz
        and inc.prgtipoincrocio = p_prgTipoIncrocio
        and r.prgrosafiglia is null
        and r.prgtiporosa = 3);
     else
       update do_rosa
       set
       prgapprovazionegrad = new_prgapprovazionegrad,
       numklorosa = numklorosa + 1
       where prgrosa IN
       (select r.prgrosa
        from do_richiesta_az rich
        inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
        inner join do_rosa r on r.prgincrocio = inc.prgincrocio
        inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
        where rich.prgrichiestaaz = p_prgRichiestaAz
        and inc.prgtipoincrocio = p_prgTipoIncrocio
        and r.prgrosafiglia is null
        and r.prgtiporosa = 3
        and a.prgalternativa = inc.prgalternativa);
     end if;

  return 0;

  exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASSalvaApprovazGrad;

/***************************************************************************************************
* verifica che per la richiesta e l'alternativa data vi sia un contratto a tempo determinato       *
***************************************************************************************************/
function checkControlloAdesione(p_prgRichiestaAz DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE,
                                p_prgAlternativa DO_ALTERNATIVA.Prgalternativa%TYPE)
                         RETURN NUMBER IS

checkContrattoDet number;
checkLavoroAperto number;
checkControllo number;
begin

      checkcontrollo := 0;

      SELECT count(DO_CONTRATTO.PRGCONTRATTO) into checkContrattoDet
      FROM DO_CONTRATTO JOIN TS_UTENTE ON (TS_UTENTE.CDNUT = DO_CONTRATTO.CDNUTINS),
           DE_CONTRATTO
      WHERE DO_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO AND
            DO_CONTRATTO.PRGRICHIESTAAZ = p_prgRichiestaAz
            AND DO_CONTRATTO.PRGALTERNATIVA=p_prgAlternativa
            AND DO_CONTRATTO.CODCONTRATTO = 'LT';

      /*
      if (checkContrattoDet > 0) then

          select count(prgmovimento) into checkLavoroAperto
          from am_movimento
          where cdnlavoratore = p_cdnlavoratore
          and codstatoatto='PR'
          and codtipocontratto not in ('C.01.00','C.02.00')
          and nvl(datfinemoveffettiva,to_date('31/12/2100','dd/mm/yyyy')) >
          (select raz.datchiamata from do_richiesta_az raz where raz.prgrichiestaaz = p_prgRichiestaAz)
          and codtipomov <> 'CES';

      end if;
      */

      if (checkContrattoDet > 0) then
            checkcontrollo := 1;
      end if;

      return checkcontrollo;

end checkControlloAdesione;

/***************************************************************************************************
* verifica che per quel lavoratore vi sia un rapporto di                                           *
* lavoro aperto alla data chiamata della richiesta                                                 *
***************************************************************************************************/
function checkControlloMovimento(p_prgRichiestaAz DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE,
                                p_cdnLavoratore DO_NOMINATIVO.CDNLAVORATORE%TYPE)
                         RETURN NUMBER IS

checkContrattoDet number;
checkLavoroAperto number;
checkControllo number;
begin

      checkcontrollo := 0;

      select count(prgmovimento) into checkLavoroAperto
          from am_movimento
   where cdnlavoratore = p_cdnLavoratore
   and codstatoatto='PR'
   and codtipocontratto not in ('C.01.00','C.02.00')
   and (datfinemoveffettiva is null or
          datfinemoveffettiva >
          (select raz.datchiamata from do_richiesta_az raz where raz.prgrichiestaaz = p_prgRichiestaAz)
        )
   and codtipomov <> 'CES';

      if (checkLavoroAperto > 0) then
            checkcontrollo := 1;
      end if;

      return checkcontrollo;

end checkControlloMovimento;

/***************************************************************************************************
* gestione storicizzazione dei dati dello stato occupazione del lavoratore per l'incrocio passato  *
***************************************************************************************************/
function ASStoricizzaStatoOcc(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                             p_cdnLavoratore am_stato_occupaz.cdnlavoratore%TYPE,
                             p_prgIncrocio do_incrocio.prgincrocio%TYPE,
                             p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                ) RETURN NUMBER is

checkNumStatoOcc number;
p_datarif do_richiesta_az.datchiamata%type;

begin

    select trunc(raz.datchiamata) into p_datarif 
    from do_richiesta_az raz where raz.prgrichiestaaz = p_prgRichiestaAz;
    
    if getNumConfig('ASATTRIB') = 1 then
      select trunc(raz.datpubblicazione) into p_datarif 
      from do_richiesta_az raz where raz.prgrichiestaaz = p_prgRichiestaAz;
    else
      if getNumConfig('ASATTRIB') = 2 then
        select trunc(raz.datpubblicazione)-1 into p_datarif 
        from do_richiesta_az raz where raz.prgrichiestaaz = p_prgRichiestaAz;
      end if;
    end if;
    
    
    select count(t.prgstatooccupaz) into checkNumStatoOcc
    from am_stato_occupaz t
    where t.cdnlavoratore = p_cdnLavoratore
    and trunc(t.datinizio) <= p_datarif
    and (t.datfine is null or trunc(t.datfine) >= p_datarif);
    
    if (checkNumStatoOcc = 1) then
       -- inserimento storico
       insert into as_storia_stato_occ
       (PRGSTORIASTATOOCC,
        CDNLAVORATORE,
        DATINIZIO,
        CODSTATOOCCUPAZ,
        CODMONOPROVENIENZA,
        CODCATEGORIA181,
        DATANZIANITADISOC,
        NUMANZIANITAPREC297,
        CODMONOCALCOLOANZIANITAPREC297,
        NUMMESISOSP,
        DATCALCOLOANZIANITA,
        DATCALCOLOMESISOSP,
        NUMREDDITO,
        STRNUMATTO,
        DATATTO,
        DATRICHREVISIONE,
        CODSTATOATTO,
        DATRICORSOGIURISDIZ,
        FLGINDENNIZZATO,
        FLGPENSIONATO,
        DATFINE,
        STRNOTE,
        CDNUTINSSTORIA,
        DTMINSSTORIA,
        CDNUTMODSTORIA,
        DTMMODSTORIA,
        CDNUTINS,
        DTMINS,
        PRGINCROCIO)
       select
          s_as_storia_stato_occ.nextval,
          CDNLAVORATORE,
          DATINIZIO,
          CODSTATOOCCUPAZ,
          CODMONOPROVENIENZA,
          CODCATEGORIA181,
          DATANZIANITADISOC,
          NUMANZIANITAPREC297,
          CODMONOCALCOLOANZIANITAPREC297,
          NUMMESISOSP,
          DATCALCOLOANZIANITA,
          DATCALCOLOMESISOSP,
          NUMREDDITO,
          STRNUMATTO,
          DATATTO,
          DATRICHREVISIONE,
          CODSTATOATTO,
          DATRICORSOGIURISDIZ,
          FLGINDENNIZZATO,
          FLGPENSIONATO,
          DATFINE,
          STRNOTE,
          CDNUTINS,
          DTMINS,
          CDNUTMOD,
          DTMMOD,
          p_cdnutente,
          sysdate,
          p_prgIncrocio
      from am_stato_occupaz t
      where t.cdnlavoratore = p_cdnLavoratore
      and trunc(t.datinizio) <= p_datarif
              and (t.datfine is null or
              trunc(t.datfine) >= p_datarif);

       return 0;

    else
        -- errore: ci deve essere almeno un record da storicizzare
        return 2;
    end if;

  exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASStoricizzaStatoOcc;


/***************************************************************************************************
* gestione storicizzazione dei dati dello stato occupazione del lavoratore per l'incrocio passato  *
***************************************************************************************************/
function ASAggiornaStatoOcc(p_dataChiamata do_richiesta_az.datchiamata%TYPE,
                            p_dataPubblicazione do_richiesta_az.datpubblicazione%type,
                            p_config            Ts_Config_Loc.num%type,
                            p_cdnLavoratore am_stato_occupaz.cdnlavoratore%TYPE,
                            p_prgIncrocio do_incrocio.prgincrocio%TYPE,
                            p_cdnUtente TS_UTENTE.CDNUT%TYPE
                                ) RETURN NUMBER is

checkNumStatoOcc number;
v_StatoOccupaz am_stato_occupaz%rowtype;
v_numklo as_storia_stato_occ.NUMKLOSTORIASTATOOCC%type;
p_datarif do_richiesta_az.datchiamata%type;

begin

    p_datarif := trunc(p_dataChiamata);
    
    if (p_config = 1 or p_config = 3) then
      p_datarif := trunc(p_dataPubblicazione);
    else
      if (p_config = 2) then
        p_datarif := trunc(p_dataPubblicazione)-1;
      end if;
    end if;


    select count(t.prgstatooccupaz) into checkNumStatoOcc
    from am_stato_occupaz t
    where t.cdnlavoratore = p_cdnLavoratore
    and trunc(t.datinizio) <=
        p_datarif
    and (t.datfine is null or
    trunc(t.datfine) >= p_datarif);

    if (checkNumStatoOcc = 1) then

      -- aggiornamento storico
     
     select * into v_StatoOccupaz
      from am_stato_occupaz t
          where t.cdnlavoratore = p_cdnLavoratore
          and trunc(t.datinizio) <= p_datarif
          and (t.datfine is null or trunc(t.datfine) >= p_datarif); 
     
     select NUMKLOSTORIASTATOOCC into v_numklo from as_storia_stato_occ where CDNLAVORATORE = p_cdnLavoratore and PRGINCROCIO   = p_prgincrocio;
     
     update as_storia_stato_occ
      set CDNLAVORATORE   = p_cdnLavoratore,
        DATINIZIO       = v_StatoOccupaz.DATINIZIO,
        CODSTATOOCCUPAZ = v_StatoOccupaz.CODSTATOOCCUPAZ,
        CODMONOPROVENIENZA                =   v_StatoOccupaz.CODMONOPROVENIENZA,                        
        CODCATEGORIA181                   =   v_StatoOccupaz.CODCATEGORIA181,               
        DATANZIANITADISOC                 =   v_StatoOccupaz.DATANZIANITADISOC,             
        NUMANZIANITAPREC297               =   v_StatoOccupaz.NUMANZIANITAPREC297,           
        CODMONOCALCOLOANZIANITAPREC297    =   v_StatoOccupaz.CODMONOCALCOLOANZIANITAPREC297,
        NUMMESISOSP                       =   v_StatoOccupaz.NUMMESISOSP,                   
        DATCALCOLOANZIANITA               =   v_StatoOccupaz.DATCALCOLOANZIANITA,           
        DATCALCOLOMESISOSP                =   v_StatoOccupaz.DATCALCOLOMESISOSP,            
        NUMREDDITO                        =   v_StatoOccupaz.NUMREDDITO,                    
        STRNUMATTO                        =   v_StatoOccupaz.STRNUMATTO,                    
        DATATTO                           =   v_StatoOccupaz.DATATTO,                       
        DATRICHREVISIONE                  =   v_StatoOccupaz.DATRICHREVISIONE,              
        CODSTATOATTO                      =   v_StatoOccupaz.CODSTATOATTO,                  
        DATRICORSOGIURISDIZ               =   v_StatoOccupaz.DATRICORSOGIURISDIZ,           
        FLGINDENNIZZATO                   =   v_StatoOccupaz.FLGINDENNIZZATO,               
        FLGPENSIONATO                     =   v_StatoOccupaz.FLGPENSIONATO,                 
        DATFINE                           =   v_StatoOccupaz.DATFINE,                       
        STRNOTE                           =   v_StatoOccupaz.STRNOTE,                       
        CDNUTINSSTORIA                    =   v_StatoOccupaz.CDNUTINS,                      
        DTMINSSTORIA                      =   v_StatoOccupaz.DTMINS,                        
        CDNUTMODSTORIA                    =   p_cdnUtente,                      
        DTMMODSTORIA                      =   sysdate,                        
        CDNUTINS                          =   v_StatoOccupaz.CDNUTINS,                   
        DTMINS                            =   v_StatoOccupaz.DTMINS, 
        NUMKLOSTORIASTATOOCC              =   v_numklo +1,	  
        PRGINCROCIO                       =   p_prgincrocio 
         where  CDNLAVORATORE = p_cdnLavoratore
           and 	PRGINCROCIO   = p_prgincrocio;		  

         return 0;

       else
          -- errore: ci deve essere almeno un record da storicizzare
          return 2;
       end if;
    
  exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASAggiornaStatoOcc;

/*****************************************************************************************************
* gestione eliminazione dello stoto occupazione storicizzato per la medesima adesione del lavoratore *
*****************************************************************************************************/
function ASDeleteStoriaStatoOcc(p_cdnLavoratore am_stato_occupaz.cdnlavoratore%TYPE,
                             p_prgIncrocio do_incrocio.prgincrocio%TYPE
                                ) RETURN NUMBER is

begin

  delete from as_storia_stato_occ c
         where c.cdnlavoratore = p_cdnLavoratore
         and c.prgincrocio = p_prgIncrocio;

  return 0;

  exception
      when others then
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
         rollback;
       return -1;

end ASDeleteStoriaStatoOcc;

/*********************************************************************
  Matching esatto
  restituisce le 4 stringhe che compongono lo statement da utilizzare per
  eseguire il matching esatto date una richiesta e ad una determinata alternativa.
  Se p_usaPref = 1 allora nel matching si devono
  considerare i parametri indicati come preferibili (flag='P')
  come se fossero obbligatori.
  Se p_usaNonInd = 1 allora nel matching si devono
  considerare i parametri indicati come non indispensabili
  come se fossero obbligatori.
  Se p_flagDI = 1 allora la ricerca va ristretta a tutti coloro che
  sono in stato di disoccupazione e di inoccupazione.
  p_db indica la base dati sulla quale eseguire il matching:
      1 - la ricerca va ristretta ai lavoratori iscritti all'elenco
        anagrafico del CPI il cui codice è passato come parametro in p_codCpi
    2 - la ricerca viene fatta a livello provinciale, quindi non servono ulteriori filtri
    3 - Regione ---> entra in gioco la cooperazione applicativa
  Il codice di ritorno vale:
  0 - se è tutto ok
  1 - non è stata specificata nessuna mansione, per cui non si può eseguire il matching
  2 - la richiesta è stata chiusa
  -1 - si è verificata una eccezione
*********************************************************************/
function Matching_esatto_CM(
    p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
    p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
    p_statoCv DE_STATO_SCHEDALAV.CODSTATOLAV%TYPE,    -- stato del CV (opzionale - non usato per ora)
    p_usaPref int,            -- utilizza anche i parametri con richiesta "preferibile"
    p_usaNonInd int,            -- utilizza anche i parametri con richiesta "non indispensabile"
    p_flagDI int,             -- solo Disoccupati/Inoccupati
    p_flagIncMir int,         -- flag collocamento mirato
    p_db int,                -- base dati da utilizzare
    p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_dataValCV  varchar2,          -- data in base alla quale considerare valido un CV
    p_checkCM  number,              -- interruttore per il collocamento mirato
    encrypterKey varchar2,
    p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
  p_flagGG int,             -- solo Garanzia Giovani
    p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
    p_out_query_select OUT varchar2,
    p_out_query_from OUT varchar2,
    p_out_query_join OUT varchar2,
    p_out_query_where OUT long,
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE       -- progressivo della rosa
    ) return number IS

  p_sql_query long;
  query_select varchar2(100);
  query_from varchar2(100);
  query_join varchar2(4000);
  query_where long;
  p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
  p_Originale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;
  p_flgpubbcresco DO_EVASIONE.FLGPUBBCRESCO%TYPE;
  p_flgpubblicata DO_RICHIESTA_AZ.FLGPUBBLICATA%TYPE;
  p_datarichiesta varchar2(10);
  p_datascadpubbl varchar2(10);

  -- MASTER
  -- DONA 22/04/2008
  --where_cpi_master varchar2(500) := ' and (PG_INCROCIO.PDMASTERLAVO(an.cdnLavoratore)=1) ';
  -- CPI DI APPARTENENZA -----------------------------------------------------------------------------------------------------------------------------------------------
  -- per ora escluso, rifare come cpi_master se da inserire
  where_cpi varchar2(500) := '';
  -- STATO DI DISOCCUPAZIONE ---------------------------------------------------------------------------------------------------------------------------
  where_stato_occ varchar(100) := ' and (PG_INCROCIO.PDSTATOOCC(an.cdnLavoratore)=1) ';
  ------------------------------------------------------------------------------------------------------------------------------------------------------

  -- GARANZIA GIOVANI ---------------------------------------------------------------------------------------------------------------------------
  where_garanzia_giovani varchar(100) := ' and (PG_INCROCIO.CHECKGG(an.cdnLavoratore)=1) ';
  ------------------------------------------------------------------------------------------------------------------------------------------------------

  --where_mansione varchar2(4000) := '';
  where_mansione long := '';
  query_agevolazioni varchar2(2000) := '';
  like_mansione varchar2(20);
  where_titoli varchar2(4000) := '';
  where_form_prof varchar2(4000) := '';
  like_titolo varchar(8);
  where_luogo varchar2(2000) := '';
  recRichiesta DO_RICHIESTA_AZ%ROWTYPE;
  numComuni number;
  numProv number;
  codComAz AN_UNITA_AZIENDA.CODCOM%TYPE;
  strMansione varchar2(100);
  recAlternativa DO_ALTERNATIVA%ROWTYPE;
  numAnniEsp DO_ALTERNATIVA.NUMANNIESPERIENZA%TYPE;
  bFuoriSede boolean;
  numConLinguistiche number;
  numConLinIta number;
  numCompetenze number;
  numConInformatiche number;
  numAbilitazioni number;
  numMobilita number;
  numCollocMirato number;
  numDisocc number;
  numApprendistato number;
  numTitoli number;
  numMansioni number;
  abilitatoIDO number;
  -- Parametri
  parPrgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;
  parAutomunito DO_RICHIESTA_AZ.FLGAUTOMUNITO%TYPE;
  parMotomunito DO_RICHIESTA_AZ.FLGMOTOMUNITO%TYPE;
  parTrasferta DO_RICHIESTA_AZ.CODTRASFERTA%TYPE;
  parMilitare DO_RICHIESTA_AZ.FLGMILITE%TYPE;
  parFuoriSede DO_RICHIESTA_AZ.FLGFUORISEDE%TYPE;
  parMezziPub AN_UNITA_AZIENDA.FLGMEZZIPUB%TYPE;
  parEsperienza DO_ALTERNATIVA.FLGESPERIENZA%TYPE;
  parFormProf DO_ALTERNATIVA.FLGFORMAZIONEPROF%TYPE;
  -- Parametri impliciti
  par_impliciti varchar2(1000);
  par_impl_p_stato_begin varchar2(1000);
  par_impl_p_stato_end varchar2(300);
  par_statoIN varchar2(15);
  -- Indisponibilità
  -- DONA 22/04/2008
  --par_indisponibilita_az varchar(100) := ' and (PG_INCROCIO.pdIndispAzienda(an.cdnLavoratore,' || p_prgRichiestaAz || ')=0) ';

  patenteB number;
  -- Cursori
  CURSOR curMansioni IS
     select DO_MANSIONE.codMansione
   from DO_MANSIONE
   where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_MANSIONE.PRGALTERNATIVA = p_prgAlternativa;
  CURSOR curTurni IS
     select DO_TURNO.CODTURNO from DO_TURNO where DO_TURNO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curOrari IS
     select DO_ORARIO.CODORARIO from DO_ORARIO where DO_ORARIO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curContratti IS
     select DO_CONTRATTO.CODCONTRATTO from DO_CONTRATTO
   where DO_CONTRATTO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_CONTRATTO.PRGALTERNATIVA = p_prgAlternativa;
  CURSOR curTitoli IS
     select DO_STUDIO.CODTITOLO, DO_STUDIO.FLGINDISPENSABILE, DO_STUDIO.FLGCONSEGUITO
   from DO_STUDIO
   where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
  -- Clausole IN
  inTurni varchar2(2000) := '';
  inOrario varchar2(2000) := '';
  inMansioni varchar2(2000) := '';
  inContratti varchar2(2000) := '';
  -- Informazioni da memorizzare in DO_PARAMETRI_INCROCIO
  rflgPref char(1);
  rflgNonInd char(1);
  rflgDis char(1);
  rflgGG char(1);
  rflgIncMir char(1);
  rNumCand number;
  -- Debug
  lenStr number;
  tmpStr char(255);
  j number;
  k number;
BEGIN
 if(p_prgRosa is null) then
  query_select := 'select distinct an.CDNLAVORATORE ';
  query_from := 'from AN_LAVORATORE an ';
  query_where := '';
  -- DONA 22/04/2008
  --query_where := where_cpi_master;
 else
  query_select := 'select distinct an.CDNLAVORATORE ';
  query_from := 'from do_nominativo ';
  query_join := 'inner join an_lavoratore an on (do_nominativo.CDNLAVORATORE=an.CDNLAVORATORE) ';
  query_where := ' and (do_nominativo.PRGROSA=' || p_prgRosa || ') ';
 end if;
 query_join := query_join || 'inner join PR_MANSIONE prm on (an.cdnLavoratore = prm.cdnLavoratore) ';
-- per l'incrocio del collocamento mirato non viene presa in considerazione la validità del curriculum
-- query_join := query_join || 'inner join PR_VALIDITA on (an.CDNLAVORATORE=PR_VALIDITA.CDNLAVORATORE) ';
 query_join := query_join || 'inner join Pr_Dispo_L68 on Pr_Dispo_L68.cdnLavoratore = an.cdnLavoratore and Pr_Dispo_L68.codmonodispol8 = ''S'' ';
 query_join := query_join || 'left outer join PR_MOBIL_GEOGR on (prm.prgMansione=PR_MOBIL_GEOGR.PRGMANSIONE) ';
 query_join := query_join || 'left outer join PR_DIS_TURNO on (prm.prgMansione=PR_DIS_TURNO.PRGMANSIONE) ';
 query_join := query_join || 'left outer join PR_DIS_ORARIO on (prm.prgMansione=PR_DIS_ORARIO.PRGMANSIONE) ';
 query_join := query_join || 'left outer join PR_DIS_CONTRATTO on (prm.prgMansione=PR_DIS_CONTRATTO.PRGMANSIONE) ';

 -- dona 24/01/2008
 -- devono essere considerati solamente i lavoratori disponibili e occupabili in pr_dispo_l68
 query_join := query_join || 'inner join DE_GRADO_OCC on PR_DISPO_L68.CODGRADOOCC = DE_GRADO_OCC.CODGRADOOCC and DE_GRADO_OCC.FLGINCROCIO = ''S'' ';

  -- Controllo che ci sia almeno una MANSIONE
  select count(*) into numMansioni
  from DO_MANSIONE
  where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_MANSIONE.PRGALTERNATIVA = p_prgAlternativa;
  if(numMansioni=0) then
   return 1;
  --dbms_output.put_line('Non è possibile effettuare l''incrocio in quanto non è stata specificata nessuna mansione!');
  end if;
  -- Controllo che la richiesta non sia stata CHIUSA mentre si accedeva all'incrocio
  SELECT RICH2.PRGRICHIESTAAZ INTO p_Originale
  FROM DO_RICHIESTA_AZ RICH1
         INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
     WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;

  SELECT ev.CDNSTATORICH, nvl(ev.FLGPUBBCRESCO, 'N'), nvl(ric.FLGPUBBLICATA, 'N'), to_char(ric.DATRICHIESTA,'dd/mm/yyyy'), to_char(nvl(ric.DATSCADENZAPUBBLICAZIONE, SYSDATE),'dd/mm/yyyy')
      into p_cdnStatoRich, p_flgpubbcresco, p_flgpubblicata, p_datarichiesta, p_datascadpubbl
  FROM DO_RICHIESTA_AZ ric, DO_EVASIONE ev
  WHERE (ric.PRGRICHIESTAAZ = ev.PRGRICHIESTAAZ)
  AND ric.PRGRICHIESTAAZ = p_Originale;

  if(p_cdnStatoRich=4 OR p_cdnStatoRich=5) then
   return 2;
  end if;

 -- Se devo estrarre i candidati di competenza di un certo CpI
 -- al momento sospeso
 /*
 if((p_codCpi is not null) and (p_db=1)) then
  query_where := query_where || where_cpi;
 end if;
 */
 -- Se devo estrarre solamente i candidati Disoccupati/Inoccupati
 if((p_flagDI is not null) and (p_flagDI=1)) then
  if((p_flgpubbcresco = 'S') and (p_flgpubblicata = 'S')) then
  query_where := query_where ||
              ' and (an.cdnlavoratore in (select st.cdnLavoratore ' ||
              ' from am_stato_occupaz st ' ||
              ' inner join de_stato_occupaz ds on (st.CODSTATOOCCUPAZ=ds.CODSTATOOCCUPAZ) ' ||
              ' where st.CDNLAVORATORE = an.cdnlavoratore ' ||
              ' and (ds.CODSTATOOCCUPAZRAGG = ''D'' or ds.CODSTATOOCCUPAZRAGG = ''I'') ' ||
              ' and ds.CODSTATOOCCUPAZ <> ''B1'' ' ||
              ' and st.datinizio <= to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy'') ' ||
              ' and to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy'') <= nvl(st.datfine, sysdate)) ' ||
              ' or an.cdnlavoratore in (select cdnLavoratore from am_movimento mov ' ||
              ' where mov.CDNLAVORATORE = an.cdnlavoratore and mov.codContratto = ''LI'' ' ||
              ' and mov.codStatoAtto = ''PR'' and mov.codTipoMov = ''AVV'' ' ||
              ' and mov.datiniziomov <= to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy'') ' ||
              ' and to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy'') <= nvl(PG_ANAGRAFICA_PROFESSIONALE_RP.GetDataFineMovEffForRp(mov.PRGMOVIMENTO), sysdate))) ';
  else
  query_where := query_where || where_stato_occ;
  end if;
 end if;

 -- Se devo estrarre solamente i candidati in GG
 if((p_flagGG is not null) and (p_flagGG=1)) then
  if((p_flgpubbcresco = 'S') and (p_flgpubblicata = 'S')) then
  query_where := query_where || ' and (PG_INCROCIO.CHECKGGCRESCO(an.cdnLavoratore, to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy''), to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy''))=1) ';
  else
  query_where := query_where || where_garanzia_giovani;
  end if;
 end if;

  -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;
  dbms_output.put_line('Prg Incrocio=' || p_out_prgIncrocio || ' - Prg Rosa=' || p_out_prgRosa);
  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgIncrocio, p_prgRichiestaAz, p_prgAlternativa, 1, 'E',
  p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgRosa, null, p_out_prgIncrocio, 1, p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 3: memorizzo i parametri dell'incrocio
  if(p_usaPref=1) then
   rflgPref := 'S';
  else
   rflgPref := 'N';
  end if;
  if(p_usaNonInd=1) then
   rflgNonInd := 'S';
  else
   rflgNonInd := 'N';
  end if;
  if(p_flagDI=1) then
   rflgDis := 'S';
  else
   rflgDis := 'N';
  end if;
  if(p_flagGG=1) then
   rflgGG := 'S';
  else
   rflgGG := 'N';
  end if;
  if(p_flagIncMir=1) then
   rflgIncMir := 'S';
  else
   rflgIncMir := 'N';
  end if;
  -- vengono registrati i parametri dell'incrocio
  insert into do_parametri_incrocio
  (PRGPARAMETRIINCROCIO, PRGINCROCIO, CODSTATOLAV, DATSTATOLAV, CODTERRITORIO, PRGROSA, FLGPREFERIBILE,
  FLGNONINDISPENSABILE, FLGSOLODISOCCUPATO,FLGINCROCIOMIRATO, CODMONOCMCATEGORIA, FLGGARANZIAGIOVANI)
  values
  (S_DO_PARAMETRI_INCROCIO.nextval, p_out_prgIncrocio, p_statoCv, to_date(p_dataValCV, 'dd/mm/yyyy'),
  p_db, p_out_prgRosa, rflgPref, rflgNonInd, rflgDis, rflgIncMir, p_codmonocmcategoria, rflgGG);
/*******************************************************************************************************/
 select * into recRichiesta from DO_RICHIESTA_AZ where DO_RICHIESTA_AZ.PRGRICHIESTAAZ = p_prgRichiestaAz;
 parAutomunito := recRichiesta.flgAutomunito;
 parMotomunito := recRichiesta.flgMotomunito;
 parTrasferta := recRichiesta.codTrasferta;
 parMilitare := recRichiesta.flgMilite;
 parFuoriSede := recRichiesta.flgFuoriSede;
 parPrgAzienda := recRichiesta.prgAzienda;
 --

 --dbms_output.put_line('Azienda raggiungibile con mezzi pubblici = ' ||parMezziPub);
 if(p_prgAlternativa is not null) then
    select * into recAlternativa from DO_ALTERNATIVA
    where DO_ALTERNATIVA.PRGRICHIESTAAZ = p_prgRichiestaAz
    and DO_ALTERNATIVA.PRGALTERNATIVA = p_prgAlternativa;
    parEsperienza := recAlternativa.flgEsperienza;
    numAnniEsp := recAlternativa.numAnniEsperienza;
    parFormProf := recAlternativa.flgFormazioneProf;
 end if;
/*******************************************************************************************************/
 select count(*) into numComuni from DO_COMUNE where DO_COMUNE.PRGRICHIESTAAZ = p_prgRichiestaAz;
 select count(*) into numProv from DO_PROVINCIA where DO_PROVINCIA.PRGRICHIESTAAZ = p_prgRichiestaAz;
 if((parFuoriSede='S') or (numComuni>0) or (numProv>0)) then
    bFuoriSede := true;
 else
    bFuoriSede := false;
 end if;
 if(numComuni=0 and numProv=0) then
  select an_az.CODCOM into codComAz
  from DO_RICHIESTA_AZ daz
    inner join AN_UNITA_AZIENDA an_az on (daz.prgAzienda=an_az.prgAzienda and daz.prgUnita=an_az.prgUnita)
  where daz.PRGRICHIESTAAZ = p_prgRichiestaAz;
 end if;
 -- Popolo la stringa con l'insieme dei codici dei turni
 FOR rec in curTurni LOOP
  if(length(inTurni)>0) then
     inTurni := inTurni ||',';
  end if;
  inTurni := inTurni || '''' || rec.codTurno || '''';
 END LOOP;
 --dbms_output.put_line('Turni IN (' || inTurni || ')');
 -- Popolo la stringa con l'insieme dei codici degli orari
 FOR rec in curOrari LOOP
  if(length(inOrario)>0) then
     inOrario := inOrario ||',';
  end if;
  inOrario:= inOrario || '''' || rec.codOrario || '''';
 END LOOP;
 --dbms_output.put_line('Orari IN (' || inOrario || ')');
 -- Popolo la stringa con l'insieme dei codici dei contratti
 if(p_prgAlternativa is not null) then
  FOR rec in curContratti LOOP
   if(length(inContratti)>0) then
      inContratti := inContratti ||',';
   end if;
   inContratti:= inContratti || '''' || rec.codContratto || '''';
  END LOOP;
 end if;
 --dbms_output.put_line('Contratti IN (' || inContratti || ')');
 /********************************************************************
 * Mansione (dipende dall'Alternativa e parametri collegati          *
 * alle mansioni:                                                    *
 * - automunito (Preferibili)                                        *
 * - motomunito (Preferibili)                                        *
 * - formazione                                                      *
 * - sede raggiungibile con mezzi pubblici (fuori sede) --> sospeso  *
 * - turno                                                           *
 * - orario                                                          *
 * - contratto e agevolazione apprendistato                          *
 * - trasferte                                                       *
 * - esperienza                                                      *
 * - Luogo di Lavoro                                                 *
 ********************************************************************/
 /* Va gestito il raggruppamento xy0000, xyab00, xyabcd */
 FOR rec IN curMansioni LOOP
  if(where_mansione='' or (where_mansione is null)) then
    dbms_output.put_line('');
  else
     where_mansione := where_mansione || ' or ';
  end if;
  --if(SUBSTR(rec.codMansione,-4)='0000') then
   --strMansione := '(SUBSTR(prm.codMansione,1,2)=''' || SUBSTR(rec.codMansione,1,2) || ''') ';
  --else
    if(SUBSTR(rec.codMansione,-2)='00') then
     strMansione := '(SUBSTR(prm.codMansione,1,5)=''' || SUBSTR(rec.codMansione,1,5) || ''') ';
    else
       strMansione := '(prm.codMansione=''' || rec.codMansione || ''') ';
    end if;
  --end if;
  --where_mansione := where_mansione || '(' || strMansione || ' ';

  where_mansione := where_mansione || '(' || strMansione || ' and (prm.FLGDISPONIBILE IN (''S'', ''L'') ) ';

  like_mansione :=
   case
    --when substr(rec.codMansione,-4)='0000' then substr(rec.codMansione,1,2) || '%'
    when substr(rec.codMansione,-2)='00' then substr(rec.codMansione,1,5) || '%'
    else rec.codMansione
   end;
  --Automunito
  if( (parAutomunito='P' and p_usaPref=1) or (parAutomunito='S') ) then
   where_mansione := where_mansione ||
            ' and (PR_MOBIL_GEOGR.FLGDISPAUTO=''S'' ) ';
--         '(PR_MOBIL_GEOGR.FLGDISPAUTO is null and PR_NOTA_LAV.FLGAUTOMUNITO=''S'') )';
  end if;
  -- Motomunito
  if( (parMotomunito='P' and p_usaPref=1) or (parMotomunito='S') ) then
   where_mansione := where_mansione ||
            ' and (PR_MOBIL_GEOGR.FLGDISPMOTO=''S'' ) ';
--         '(PR_MOBIL_GEOGR.FLGDISPMOTO is null and PR_NOTA_LAV.FLGMOTOMUNITO=''S'') )';
  end if;
  -- formazione
  if (parFormProf='S' or (parFormProf='P' and p_usaPref=1)) then
   where_mansione := where_mansione ||
         ' and (prm.flgEspForm=''S'')';
  end if;

  -- Turno
  if(length(inTurni)>0) then
   where_mansione := where_mansione ||
            ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
         ' (an.CDNLAVORATORE not in (select pm.CDNLAVORATORE from PR_DIS_TURNO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
         'where pm.cdnLavoratore=an.cdnLavoratore and pm.codMansione like ''' || like_mansione ||
         ''')))';
  end if;
  -- Orario
  if(length(inOrario)>0) then
   where_mansione := where_mansione ||
            ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrario || ')) or ' ||
         ' (an.CDNLAVORATORE not in (select pm.CDNLAVORATORE from PR_DIS_ORARIO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
         'where pm.cdnLavoratore=an.cdnLavoratore and pm.codMansione like ''' || like_mansione ||
         ''')))';
  end if;
  -- Contratto
  -- Apprendistato (Indispensabile e dipendente dall'alternativa) --> SOSPESO
     -- 'APP' --> 'I' oppure 'L', ma dalla richiesta mi dovrebbe arrivare solo 'I'
  if(p_usaNonInd=1) then
   select count(*) into numApprendistato
   from DO_AGEVOLAZIONE
   where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
      and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
      and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='D0' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='A0');
  else
   select count(*) into numApprendistato
   from DO_AGEVOLAZIONE
   where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
      and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
      and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='D0' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='A0')
      and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
  end if;


  if (numApprendistato>0) then
     if(length(inContratti)>0) then
      inContratti := inContratti ||',';
   end if;
   inContratti:= inContratti || '''AP''';
  end if;
  if(length(inContratti)>0) then
   where_mansione := where_mansione ||
            ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
         ' (an.CDNLAVORATORE not in (select pm.CDNLAVORATORE from PR_DIS_CONTRATTO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
         'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
         'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
         'pm.cdnLavoratore=an.cdnLavoratore and pm.codMansione like ''' || like_mansione ||
         ''')))';
  end if;
  -- Trasferte
  if(parTrasferta is not null and (to_number(parTrasferta)<>1)) then
   where_mansione := where_mansione ||
            ' and to_number(PR_MOBIL_GEOGR.CODTRASFERTA)>=' || parTrasferta || ' ';
  end if;
  -- Esperienza
  if((parEsperienza='P' and p_usaPref=1) or (parEsperienza='S')) then
   where_mansione := where_mansione ||
            ' and (prm.FLGESPERIENZA=''S'' OR prm.FLGESPERIENZA=''E'') ';
  end if;
  -- Luogo di Lavoro
  if(numComuni=0 and numProv=0) then
   -- come riferimento prendo il comune della sede dell'azienda
   where_mansione := where_mansione ||
            ' and ( an.CDNLAVORATORE in (select dter.CDNLAVORATORE from VW_PR_DIS_TERRITORIO_CM dter ' ||
         'where dter.cdnLavoratore=an.cdnLavoratore and ' ||
         'dter.codMansione like ' || '''' || like_mansione || '''' || ' and ' ||
         'dter.codCom=' || '''' || codComAz || ''') OR ' ||
         'an.CDNLAVORATORE in (select pm.CDNLAVORATORE from pr_mansione pm ' ||
         'inner join pr_dis_stato on (pr_dis_stato.PRGMANSIONE=pm.PRGMANSIONE) ' ||
         'where pm.CDNLAVORATORE=an.CDNLAVORATORE ' ||
         'and pr_dis_stato.CODCOM=''Z000'' and ' ||
         'pm.CODMANSIONE=prm.codMansione)' ||
          ') ';
  else
   where_mansione := where_mansione || ' and (';
   -- Esistenza disponibilità per l'intero stato italiano
   where_mansione := where_mansione ||
         'an.CDNLAVORATORE in (select pm.CDNLAVORATORE from pr_mansione pm ' ||
         'inner join pr_dis_stato on (pr_dis_stato.PRGMANSIONE=pm.PRGMANSIONE) ' ||
         'where pm.CDNLAVORATORE=an.CDNLAVORATORE ' ||
         'and pr_dis_stato.CODCOM=''Z000'' and ' ||
         'pm.CODMANSIONE=prm.codMansione)';
   -- Disponibilità per i comuni
   if(numComuni>0) then
        where_mansione := where_mansione || ' OR an.CDNLAVORATORE in (' ||
         'select dter.cdnLavoratore from VW_PR_DIS_TERRITORIO_CM dter ' ||
         'inner join DO_COMUNE oter on (oter.codCom=dter.codCom) ' ||
         'where dter.cdnLavoratore=an.cdnLavoratore and ' ||
         'dter.codMansione like ' || '''' || like_mansione || '''' || ' and ' ||
         'oter.prgRichiestaAz=' || p_prgRichiestaAz || ') ';
   end if;
   -- Disponibilità per le province
   if(numProv>0) then
        where_mansione := where_mansione || ' OR an.CDNLAVORATORE in (' ||
         'select dter.cdnLavoratore from VW_PR_DIS_PROVINCIA_CM dter ' ||
         'inner join DO_PROVINCIA oter on (oter.codProvincia=dter.codProvincia) ' ||
         'where dter.cdnLavoratore=an.cdnLavoratore and ' ||
         'dter.codMansione like ' || '''' || like_mansione || '''' || ' and ' ||
         'oter.prgRichiestaAz=' || p_prgRichiestaAz || ') ';
   end if;
   where_mansione := where_mansione || ' ) ';
  end if;
  -- Fine where_mansione
  where_mansione := where_mansione || ') ';
 END LOOP;
 query_where := query_where || ' and (' || where_mansione || ') ';
 /*---------------------------------- FINE MANSIONE ------------------------------------*/
 -- Servizio Militare / Servizio Civile (Preferibili)
 if( (parMilitare='P' and p_usaPref=1) or (parMilitare='S')) then
  query_where := query_where ||
        ' and ((an.STRSESSO=''M'' and an.FLGMILITE=''S'') or (an.STRSESSO=''F'')) ';
 end if;
 -- Conoscenze Linguistiche (Indispensabili - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numConLinguistiche
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numConLinguistiche
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
  and DO_LINGUA.FLGINDISPENSABILE='S';
 end if;
 if(numConLinguistiche>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_LINGUA cv_lin inner join ' ||
       'DO_LINGUA o_lin on (' ||
          'cv_lin.codLingua = o_lin.codLingua and ' ||
       'nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and ' ||
       'nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and ' ||
       'nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1)) ' ||
       'where (cv_lin.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_lin.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
       'o_lin.prgAlternativa=' || p_prgAlternativa || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_lin.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) ' ||
        '>= ' || numConLinguistiche; -- || ') ';
  -- Controllo se è richiesta la lingua italiana
  if(p_usaNonInd=1) then
     select count(*) into numConLinIta
     from DO_LINGUA
     where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
        and DO_LINGUA.codLingua='003';
  else
     select count(*) into numConLinIta
     from DO_LINGUA
     where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
        and DO_LINGUA.FLGINDISPENSABILE='S'
     and DO_LINGUA.CODLINGUA='003';
  end if;
  -- se e' richiesta la conoscenza della lingua italiana allora numConLinIta > 0
  if(numConLinIta>0) then
     if(numConLinguistiche=1) then
      -- è richiesta la sola conoscenza della lingua italiana
      query_where := query_where || ' OR (an.codCittadinanza=''000'' or an.codCittadinanza2=''000'')';
     else
         query_where := query_where || ' OR ' ||
              '(select count(*) from PR_LINGUA cv_lin inner join ' ||
          'DO_LINGUA o_lin on (' ||
          'cv_lin.codLingua = o_lin.codLingua and ' ||
       'nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and ' ||
       'nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and ' ||
       'nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1)) ' ||
       'where (cv_lin.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_lin.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
       'o_lin.prgAlternativa=' || p_prgAlternativa || ' and o_lin.codLingua<>''003'' ' ||
       'and (an.codCittadinanza=''000'' or an.codCittadinanza2=''000'')';
      if(p_usaNonInd=0 or (p_usaNonInd is null)) then
         query_where := query_where || 'and o_lin.flgIndispensabile=''S'' ';
      end if;
         query_where := query_where || ')) >= ' || (numConLinguistiche - numConLinIta);
      end if;
  end if;
  query_where := query_where || ') ';
 end if;
 -- Competenze (Indispensabili e dipendono dall'alternativa - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numCompetenze
  from DO_COMPETENZA
  where DO_COMPETENZA.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_COMPETENZA.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numCompetenze
  from DO_COMPETENZA
  where DO_COMPETENZA.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_COMPETENZA.PRGALTERNATIVA = p_prgAlternativa
     and DO_COMPETENZA.FLGINDISPENSABILE='S';
 end if;
 if(numCompetenze>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_COMPETENZA cv_comp inner join ' ||
       'DO_COMPETENZA o_comp on (' ||
          'cv_comp.codCompetenza = o_comp.codCompetenza) ' ||
       'where (cv_comp.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_comp.prgRichiestaAz=' || p_prgRichiestaAz ||
       ' and o_comp.prgAlternativa=' || p_prgAlternativa || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_comp.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) >= ' || numCompetenze ||
        ') ';
 end if;
 -- Conoscenze Informatiche (Indispensabili e dipendenti dall'alternativa - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numConInformatiche
  from DO_INFO
  where DO_INFO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_INFO.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numConInformatiche
  from DO_INFO
  where DO_INFO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_INFO.PRGALTERNATIVA = p_prgAlternativa
     and DO_INFO.FLGINDISPENSABILE='S';
 end if;
 if(numConInformatiche>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_INFO cv_inf inner join ' ||
       'DO_INFO o_inf on (' ||
          'cv_inf.codDettInfo = o_inf.codDettInfo and ' ||
       'cv_inf.codTipoInfo = o_inf.codTipoInfo and ' ||
       'nvl(cv_inf.cdnGrado,1) >= nvl(o_inf.cdnGrado,1)) ' ||
       'where (cv_inf.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_inf.prgRichiestaAz=' || p_prgRichiestaAz || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_inf.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where ||
       'and o_inf.prgAlternativa=' || p_prgAlternativa ||
        ')) >= ' || numConInformatiche ||
        ') ';
 end if;
 -- Abilitazioni (Indispensabili  - condizioni in AND)
 -- Es. patente specifica, patentino specifico, ....
 if(p_usaNonInd=1) then
  select count(*) into numAbilitazioni
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN<>'PGB';

  select count(*) into patenteB
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN='PGB';
 else
  select count(*) into numAbilitazioni
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.FLGINDISPENSABILE='S'
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN<>'PGB';

  select count(*) into patenteB
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.FLGINDISPENSABILE='S'
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN='PGB';
 end if;
 if(numAbilitazioni>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_ABILITAZIONE cv_abi inner join ' ||
       'DO_ABILITAZIONE_GEN o_abi on (' ||
          'cv_abi.codAbilitazioneGen = o_abi.codAbilitazioneGen) ' ||
       'where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_abi.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
       'o_abi.codAbilitazioneGen <> ''PGB'' ' ;
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_abi.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) >= ' || numAbilitazioni ||
        ') ';
    end if;
 if(patenteB>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_ABILITAZIONE cv_abi ' ||
       'where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
         '(cv_abi.codAbilitazioneGen = ''PGB'' or cv_abi.codAbilitazioneGen = ''PGC'' or cv_abi.codAbilitazioneGen = ''PGD'') ';
  query_where := query_where || ')) >= 1 ' ||
        ') ';
 end if;
 -- Titoli di Studio (Indispensabili e dipendenti dall'alternativa - condizioni in OR)
 -- /* Va gestito il raggruppamento xy0000, xyab00, xyabcd */
 if(p_usaNonInd=1) then
  select count(*) into numTitoli
  from DO_STUDIO
  where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numTitoli
  from DO_STUDIO
  where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa
     and DO_STUDIO.FLGINDISPENSABILE='S';
 end if;
 dbms_output.put_line('Sono richiesti n. ' || numTitoli || ' Titoli di Studio');
 if(numTitoli>0) then
  --dbms_output.put_line('I Titoli sono in OR e va gestito il raggruppamento XY0000, XYAB00, XYABCD');
  where_titoli := '';
  FOR rec IN curTitoli LOOP
   if((rec.flgIndispensabile='S') or (p_usaNonInd=1)) then
      if(length(where_titoli)>0) then
         where_titoli := where_titoli || ' union ';
      end if;
      where_titoli := where_titoli || ' (';
     -- modifica TITOLI FASE 3
     -- Le codifiche dei titoli di studio sono composte di 8 digit
     like_titolo :=
     case
      when substr(rec.codTitolo, -7)='0000000' then substr(rec.codTitolo,1,1) || '%'
      when substr(rec.codTitolo, -6)='000000' then substr(rec.codTitolo,1,2) || '%'
      when substr(rec.codTitolo, -5)='00000' then substr(rec.codTitolo,1,3) || '%'
      when substr(rec.codTitolo, -3)='000' then substr(rec.codTitolo,1,5) || '%'
      else rec.codTitolo
     end;
      where_titoli := where_titoli ||
             'select cv_tit.cdnLavoratore from PR_STUDIO cv_tit ' ||
          'where cv_tit.cdnLavoratore=an.cdnLavoratore and ' ||
          'cv_tit.CODTITOLO like ' || '''' || like_titolo || '''' || ' and ';
      if(rec.flgConseguito='S' or (rec.flgConseguito is null)) then
         where_titoli := where_titoli ||
            'cv_tit.CODMONOSTATO=''C'' ';
      else
          if(rec.flgConseguito='N') then
          where_titoli := where_titoli ||
                   'cv_tit.CODMONOSTATO in (''A'',''I'',''C'') ';
       end if;
      end if;
      where_titoli := where_titoli || ') ';
   end if;
  END LOOP;
 end if;
 --dbms_output.put_line('WhereTitoli=' || where_titoli);
 if(length(where_titoli)>0) then
    query_where := query_where || ' and an.CDNLAVORATORE in (' || where_titoli || ') ';
 end if;

 -- Corsi di Formazione 
select count(*) into abilitatoIDO
from ts_config_loc, de_tipo_config, ts_generale
where  ts_generale.prggenerale = 1
and ts_generale.codprovinciasil = ts_config_loc.strcodrif
and de_tipo_config.codtipoconfig = ts_config_loc.codtipoconfig
and trunc(sysdate) between trunc(de_tipo_config.datinizioval)
and trunc(de_tipo_config.datfineval)
and ts_config_loc.num=1
and upper(ts_config_loc.codtipoconfig) = 'IDOFPRO';

if(abilitatoIDO>0) then
	where_form_prof:= PG_INCROCIO.checkFormProf(p_prgRichiestaAZ ,p_prgAlternativa,p_usaNonInd);
    if(length(where_form_prof)>0) then
       query_where := query_where || ' and an.CDNLAVORATORE in (' || where_form_prof  || ') ';
    end if;
end if;

/*****************************************************
 *            AGEVOLAZIONI                            *
 * Sono indispensabili e dipendenti dall'alternativa. *
 * Vanno considerate in OR fra loro                   *
 * Il Collocamento Mirato viene trattato in modo      *
 * speciale: se è presente nella richiesta allora va  *
 * aggiunta una clausola in OR assieme alle altre     *
 * agevolazioni, mentre se non viene richiesto si deve*
 * aggiungere una clausola in AND alle altre condizio-*
 * ni della query.                                    *
 * Le agevolazioni considerate sono:                  *
 * - Mobilità                                         *
 * - Collocamento Mirato                              *
 * - Disoccupazione L. 407/90                         *
 * - Apprendistato                                    *
 *****************************************************/
 query_agevolazioni := '';
 -- In Mobilità (Indispensabile e dipendente dall'alternativa --> fa parte delle agevolazioni )
 -- 'MOB' --> 'A'
 if(p_usaNonInd=1) then
  select count(*) into numMobilita
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S5', 'S6', 'S7', '75', '76', '77');
 else
  select count(*) into numMobilita
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S5', 'S6', 'S7', '75', '76', '77')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 if(numMobilita>0) then
     if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || ' OR ';
  end if;
  -- aggiungo il join con AM_MOBILITA_ISCR
  query_join := query_join ||
          'left outer join AM_MOBILITA_ISCR on (an.cdnLavoratore=AM_MOBILITA_ISCR.CDNLAVORATORE) and (AM_MOBILITA_ISCR.FLGNONIMPRENDITORE is null or AM_MOBILITA_ISCR.FLGNONIMPRENDITORE = ''N'') ';
  -- fare un controllo sul formato delle date in questa tabella
  query_agevolazioni := query_agevolazioni ||
        ' (trunc(AM_MOBILITA_ISCR.DATINIZIO) <= trunc(sysdate) and ' ||
        '(AM_MOBILITA_ISCR.DATFINE is null or trunc(sysdate) <= trunc(AM_MOBILITA_ISCR.DATFINE)))';
 end if;
 -- Collocamento Mirato (Indispensabile e dipendente dall'alternativa --> fa parte delle agevolazioni)
 -- 'CLM' --> 'R' oppure 'S'
 if(p_usaNonInd=1) then
  select count(*) into numCollocMirato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE = '66' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='67');
 else
  select count(*) into numCollocMirato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE = '66' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='67')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 -- aggiungo il join con AM_CM_ISCR
 -- donato: cifratura cdnLavoratore
 --query_join := query_join ||
 --        'left outer join AM_CM_ISCR on (an.cdnLavoratore=DECRYPT(AM_CM_ISCR.CDNLAVORATORE, '''|| encrypterkey ||''')) ';


 -- inserisco i lavoratori CM in una tabella globale
 -- dona 28/01/2008
 /*
 if(numCollocMirato>0) then
  if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || ' OR ';
  end if;

  query_join := query_join || ' left outer join global_cm on (an.cdnlavoratore=global_cm.cdnlavoratore) ';

  query_agevolazioni := query_agevolazioni  || ' global_cm.cdncrypt is not null ';

 else
     query_where := query_where;
 end if;
*/

  query_join := query_join || ' inner join global_cm on (an.cdnlavoratore=global_cm.cdnlavoratore) ';

  query_agevolazioni := query_agevolazioni  || ' global_cm.cdncrypt is not null ';

 -- Disoccupazione L. 407/90 (Indispensabile e dipendente dall'alternativa)
 -- 'DIS' --> 'D'
 if(p_usaNonInd=1) then
  select count(*) into numDisocc
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S8', '58');
 else
  select count(*) into numDisocc
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S8', '58')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 if(numDisocc>0) then
  if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || ' OR ';
  end if;
  query_join := query_join ||
          'left outer join VW_AM_LAV_SITUAZ_AMMIN on (an.cdnLavoratore=VW_AM_LAV_SITUAZ_AMMIN.CDNLAVORATORE) ';
  query_agevolazioni := query_agevolazioni || ' (VW_AM_LAV_SITUAZ_AMMIN.flg40790=''S'') ';
 end if;

 if(length(query_agevolazioni)>0) then
  query_where := query_where || ' and (' || query_agevolazioni || ') ';
 end if;
 -- Ricavo la query sql da eseguire


 -- DONA 22/04/2008
 --query_where := query_where || par_indisponibilita_az;
 query_where:= ltrim(query_where, 'and ');
 p_sql_query := query_select ||
       query_from ||
       query_join || ' where ' ||
       query_where;
 /********************************
 Check dei parametri di Ritorno
 ********************************/
 if(p_out_prgIncrocio is null or p_out_prgRosa is null) then
    rollback;
    return -1;
 end if;
 if(length(query_select)=0 or length(query_from)=0 or length(query_join)=0 or length(query_where)=0) then
    rollback;
    return -1;
 end if;
 -- Preparo i parametri di Output
 p_out_query_select := query_select;
 p_out_query_from := query_from;
 p_out_query_join := query_join;
 p_out_query_where := ' where ' || query_where;
 return 0;
 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       return -1;
END Matching_esatto_CM;

function Matching_esatto_no_mansione_CM(
    p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
    p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
    p_statoCv DE_STATO_SCHEDALAV.CODSTATOLAV%TYPE,    -- stato del CV (opzionale - non usato per ora)
    p_usaPref int,            -- utilizza anche i parametri con richiesta "preferibile"
    p_usaNonInd int,            -- utilizza anche i parametri con richiesta "non indispensabile"
    p_flagDI int,             -- solo Disoccupati/Inoccupati
    p_flagIncMir int,         -- flag collocamento mirato
    p_db int,                -- base dati da utilizzare
    p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_dataValCV  varchar2,          -- data in base alla quale considerare valido un CV
    p_checkCM  number,              -- interruttore per il collocamento mirato
    encrypterKey varchar2,
    p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
  p_flagGG int,             -- solo Garanzia Giovani
    p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
    p_out_query_select OUT varchar2,
    p_out_query_from OUT varchar2,
    p_out_query_join OUT varchar2,
    p_out_query_where OUT long,
    p_out_cm_query_join OUT varchar2,
    p_out_cm_query_where OUT varchar2,
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE       -- progressivo della rosa
    ) return number IS

  p_sql_query long;
  query_select varchar2(100);
  query_from varchar2(100);
  query_join varchar2(4096);
  query_where long;
  cm_query_join varchar2(255);
  cm_query_where varchar2(255);
  p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
  p_Originale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;
  p_flgpubbcresco DO_EVASIONE.FLGPUBBCRESCO%TYPE;
  p_flgpubblicata DO_RICHIESTA_AZ.FLGPUBBLICATA%TYPE;
  p_datarichiesta varchar2(10);
  p_datascadpubbl varchar2(10);

  -- MASTER
  -- DONA 22/04/2008
  --where_cpi_master varchar2(500) := ' and (PG_INCROCIO.PDMASTERLAVO(an.cdnLavoratore)=1) ';
  -- CPI DI APPARTENENZA -----------------------------------------------------------------------------------------------------------------------------------------------
  -- per ora escluso, rifare come cpi_master se da inserire
  where_cpi varchar2(500) := '';
  -- STATO DI DISOCCUPAZIONE ---------------------------------------------------------------------------------------------------------------------------
  where_stato_occ varchar(100) := ' and (PG_INCROCIO.PDSTATOOCC(an.cdnLavoratore)=1) ';
  ------------------------------------------------------------------------------------------------------------------------------------------------------

  -- GARANZIA GIOVANI ---------------------------------------------------------------------------------------------------------------------------
  where_garanzia_giovani varchar(100) := ' and (PG_INCROCIO.CHECKGG(an.cdnLavoratore)=1) ';
  ------------------------------------------------------------------------------------------------------------------------------------------------------

  --where_mansione varchar2(4000) := '';
  where_mansione long := '';
  query_agevolazioni varchar2(2000) := '';
  like_mansione varchar2(20);
  where_titoli varchar2(4000) := '';
  where_form_prof varchar2(4000) := '';
  like_titolo varchar(8);
  where_luogo varchar2(2000) := '';
  recRichiesta DO_RICHIESTA_AZ%ROWTYPE;
  numComuni number;
  numProv number;
  codComAz AN_UNITA_AZIENDA.CODCOM%TYPE;
  strMansione varchar2(100);
  recAlternativa DO_ALTERNATIVA%ROWTYPE;
  numAnniEsp DO_ALTERNATIVA.NUMANNIESPERIENZA%TYPE;
  bFuoriSede boolean;
  numConLinguistiche number;
  numConLinIta number;
  numCompetenze number;
  numConInformatiche number;
  numAbilitazioni number;
  numMobilita number;
  numCollocMirato number;
  numDisocc number;
  numApprendistato number;
  numTitoli number;
  numMansioni number;
  abilitatoIDO number;
  -- Parametri
  parPrgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;
  parAutomunito DO_RICHIESTA_AZ.FLGAUTOMUNITO%TYPE;
  parMotomunito DO_RICHIESTA_AZ.FLGMOTOMUNITO%TYPE;
  parTrasferta DO_RICHIESTA_AZ.CODTRASFERTA%TYPE;
  parMilitare DO_RICHIESTA_AZ.FLGMILITE%TYPE;
  parFuoriSede DO_RICHIESTA_AZ.FLGFUORISEDE%TYPE;
  parMezziPub AN_UNITA_AZIENDA.FLGMEZZIPUB%TYPE;
  parEsperienza DO_ALTERNATIVA.FLGESPERIENZA%TYPE;
  parFormProf DO_ALTERNATIVA.FLGFORMAZIONEPROF%TYPE;
  -- Parametri impliciti
  par_impliciti varchar2(1000);
  par_impl_p_stato_begin varchar2(1000);
  par_impl_p_stato_end varchar2(300);
  par_statoIN varchar2(15);
  -- Indisponibilità
  -- DONA 22/04/2008
  --par_indisponibilita_az varchar(100) := ' and (PG_INCROCIO.pdIndispAzienda(an.cdnLavoratore,' || p_prgRichiestaAz || ')=0) ';

  patenteB number;
  -- Cursori
  CURSOR curTurni IS
     select DO_TURNO.CODTURNO from DO_TURNO where DO_TURNO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curOrari IS
     select DO_ORARIO.CODORARIO from DO_ORARIO where DO_ORARIO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curContratti IS
     select DO_CONTRATTO.CODCONTRATTO from DO_CONTRATTO
   where DO_CONTRATTO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_CONTRATTO.PRGALTERNATIVA = p_prgAlternativa;
  CURSOR curTitoli IS
     select DO_STUDIO.CODTITOLO, DO_STUDIO.FLGINDISPENSABILE, DO_STUDIO.FLGCONSEGUITO
   from DO_STUDIO
   where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
  -- Clausole IN
  inTurni varchar2(2000) := '';
  inOrario varchar2(2000) := '';
  inMansioni varchar2(2000) := '';
  inContratti varchar2(2000) := '';
  -- Informazioni da memorizzare in DO_PARAMETRI_INCROCIO
  rflgPref char(1);
  rflgNonInd char(1);
  rflgDis char(1);
  rflgGG char(1);
  rflgIncMir char(1);
  rNumCand number;
  -- Debug
  lenStr number;
  tmpStr char(255);
  j number;
  k number;
  crlf VARCHAR2( 2 ):= CHR( 13 ) || CHR( 10 );
BEGIN
 if(p_prgRosa is null) then
  --query_select := 'select distinct an.CDNLAVORATORE, an.STRCOGNOME, an.STRNOME ';
  query_select := 'select distinct an.CDNLAVORATORE ';
  query_from := 'from AN_LAVORATORE an ';
  query_where := '';
  -- DONA 22/04/2008
  --query_where := where_cpi_master;
 else
  --query_select := 'select distinct an.CDNLAVORATORE, an.STRCOGNOME, an.STRNOME ';
  query_select := 'select distinct an.CDNLAVORATORE, null ';
  query_from := 'from do_nominativo ';
  query_join := 'inner join an_lavoratore an on (do_nominativo.CDNLAVORATORE=an.CDNLAVORATORE) ';
  query_where := ' and (do_nominativo.PRGROSA=' || p_prgRosa || ') ';
 end if;
 query_join := query_join || 'inner join PR_MANSIONE prm on (an.cdnLavoratore = prm.cdnLavoratore) ';
 query_join := query_join || 'inner join Pr_Dispo_L68 on Pr_Dispo_L68.cdnLavoratore = an.cdnLavoratore and Pr_Dispo_L68.codmonodispol8 = ''S'' ';

 -- dona 24/01/2008
 -- devono essere considerati solamente i lavoratori disponibili e occupabili in pr_dispo_l68
 query_join := query_join || 'inner join DE_GRADO_OCC on PR_DISPO_L68.CODGRADOOCC = DE_GRADO_OCC.CODGRADOOCC and DE_GRADO_OCC.FLGINCROCIO = ''S'' ';

  -- Il controllo che ci sia almeno una MANSIONE in questo tipo di matching non ha senso, per cui non viene fatto
  -- Controllo che la richiesta non sia stata CHIUSA mentre si accedeva all'incrocio
  SELECT RICH2.PRGRICHIESTAAZ INTO p_Originale
  FROM DO_RICHIESTA_AZ RICH1
         INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
     WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;

  SELECT ev.CDNSTATORICH, nvl(ev.FLGPUBBCRESCO, 'N'), nvl(ric.FLGPUBBLICATA, 'N'), to_char(ric.DATRICHIESTA,'dd/mm/yyyy'), to_char(nvl(ric.DATSCADENZAPUBBLICAZIONE, SYSDATE),'dd/mm/yyyy')
      into p_cdnStatoRich, p_flgpubbcresco, p_flgpubblicata, p_datarichiesta, p_datascadpubbl
  FROM DO_RICHIESTA_AZ ric, DO_EVASIONE ev
  WHERE (ric.PRGRICHIESTAAZ = ev.PRGRICHIESTAAZ)
  AND ric.PRGRICHIESTAAZ = p_Originale;

  if(p_cdnStatoRich=4 OR p_cdnStatoRich=5) then
   return 2;
  end if;

 -- Se devo estrarre i candidati di competenza di un certo CpI
 -- al momento sospeso
 /*
 if((p_codCpi is not null) and (p_db=1)) then
  query_where := query_where || where_cpi;
 end if;
 */
 -- Se devo estrarre solamente i candidati Disoccupati/Inoccupati
 if((p_flagDI is not null) and (p_flagDI=1)) then
  if((p_flgpubbcresco = 'S') and (p_flgpubblicata = 'S')) then
  query_where := query_where ||
              ' and (an.cdnlavoratore in (select st.cdnLavoratore ' ||
              ' from am_stato_occupaz st ' ||
              ' inner join de_stato_occupaz ds on (st.CODSTATOOCCUPAZ=ds.CODSTATOOCCUPAZ) ' ||
              ' where st.CDNLAVORATORE = an.cdnlavoratore ' ||
              ' and (ds.CODSTATOOCCUPAZRAGG = ''D'' or ds.CODSTATOOCCUPAZRAGG = ''I'') ' ||
              ' and ds.CODSTATOOCCUPAZ <> ''B1'' ' ||
              ' and st.datinizio <= to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy'') ' ||
              ' and to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy'') <= nvl(st.datfine, sysdate)) ' ||
              ' or an.cdnlavoratore in (select cdnLavoratore from am_movimento mov ' ||
              ' where mov.CDNLAVORATORE = an.cdnlavoratore and mov.codContratto = ''LI'' ' ||
              ' and mov.codStatoAtto = ''PR'' and mov.codTipoMov = ''AVV'' ' ||
              ' and mov.datiniziomov <= to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy'') ' ||
              ' and to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy'') <= nvl(PG_ANAGRAFICA_PROFESSIONALE_RP.GetDataFineMovEffForRp(mov.PRGMOVIMENTO), sysdate))) ';
  else
  query_where := query_where || where_stato_occ;
  end if;
 end if;

 -- Se devo estrarre solamente i candidati in GG
 if((p_flagGG is not null) and (p_flagGG=1)) then
  if((p_flgpubbcresco = 'S') and (p_flgpubblicata = 'S')) then
  query_where := query_where || ' and (PG_INCROCIO.CHECKGGCRESCO(an.cdnLavoratore, to_date(''' || p_datarichiesta || ''',''dd/mm/yyyy''), to_date(''' || p_datascadpubbl || ''',''dd/mm/yyyy''))=1) ';
  else
  query_where := query_where || where_garanzia_giovani;
  end if;
 end if;

  -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;
  dbms_output.put_line('Prg Incrocio=' || p_out_prgIncrocio || ' - Prg Rosa=' || p_out_prgRosa);
  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgIncrocio, p_prgRichiestaAz, p_prgAlternativa, 1, 'E',
  p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgRosa, null, p_out_prgIncrocio, 1, p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 3: memorizzo i parametri dell'incrocio
  if(p_usaPref=1) then
   rflgPref := 'S';
  else
   rflgPref := 'N';
  end if;
  if(p_usaNonInd=1) then
   rflgNonInd := 'S';
  else
   rflgNonInd := 'N';
  end if;
  if(p_flagDI=1) then
   rflgDis := 'S';
  else
   rflgDis := 'N';
  end if;
  if(p_flagGG=1) then
   rflgGG := 'S';
  else
   rflgGG := 'N';
  end if;
  if(p_flagIncMir=1) then
   rflgIncMir := 'S';
  else
   rflgIncMir := 'N';
  end if;
  -- vengono registrati i parametri dell'incrocio
  insert into do_parametri_incrocio
  (PRGPARAMETRIINCROCIO, PRGINCROCIO, CODSTATOLAV, DATSTATOLAV, CODTERRITORIO, PRGROSA, FLGPREFERIBILE,
  FLGNONINDISPENSABILE, FLGSOLODISOCCUPATO,FLGNOMANSIONE,FLGINCROCIOMIRATO, CODMONOCMCATEGORIA, FLGGARANZIAGIOVANI)
  values
  (S_DO_PARAMETRI_INCROCIO.nextval, p_out_prgIncrocio, p_statoCv, to_date(p_dataValCV, 'dd/mm/yyyy'),
  p_db, p_out_prgRosa, rflgPref, rflgNonInd, rflgDis, 'S', rflgIncMir, p_codmonocmcategoria, rflgGG);
/***********      avvio della generazione della query    ****************************************************/
    -- selezione dei parametri della richiesta
 select * into recRichiesta from DO_RICHIESTA_AZ where DO_RICHIESTA_AZ.PRGRICHIESTAAZ = p_prgRichiestaAz;
 parAutomunito := recRichiesta.flgAutomunito;
 parMotomunito := recRichiesta.flgMotomunito;
 parTrasferta := recRichiesta.codTrasferta;
 parMilitare := recRichiesta.flgMilite;
 parFuoriSede := recRichiesta.flgFuoriSede;
 parPrgAzienda := recRichiesta.prgAzienda;

 if(p_prgAlternativa is not null) then
    select * into recAlternativa from DO_ALTERNATIVA
    where DO_ALTERNATIVA.PRGRICHIESTAAZ = p_prgRichiestaAz
    and DO_ALTERNATIVA.PRGALTERNATIVA = p_prgAlternativa;
    parEsperienza := recAlternativa.flgEsperienza;
    numAnniEsp := recAlternativa.numAnniEsperienza;
    parFormProf := recAlternativa.flgFormazioneProf;
 end if;
/*******************************************************************************************************/
 select count(*) into numComuni from DO_COMUNE where DO_COMUNE.PRGRICHIESTAAZ = p_prgRichiestaAz;
 select count(*) into numProv from DO_PROVINCIA where DO_PROVINCIA.PRGRICHIESTAAZ = p_prgRichiestaAz;
 if((parFuoriSede='S') or (numComuni>0) or (numProv>0)) then
    bFuoriSede := true;
 else
    bFuoriSede := false;
 end if;
 if(numComuni=0 and numProv=0) then
  select an_az.CODCOM into codComAz
  from DO_RICHIESTA_AZ daz
    inner join AN_UNITA_AZIENDA an_az on (daz.prgAzienda=an_az.prgAzienda and daz.prgUnita=an_az.prgUnita)
  where daz.PRGRICHIESTAAZ = p_prgRichiestaAz;
 end if;
 -- Popolo la stringa con l'insieme dei codici dei turni
 FOR rec in curTurni LOOP
  if(length(inTurni)>0) then
     inTurni := inTurni ||',';
  end if;
  inTurni := inTurni || '''' || rec.codTurno || '''';
 END LOOP;
 --dbms_output.put_line('Turni IN (' || inTurni || ')');
 -- Popolo la stringa con l'insieme dei codici degli orari
 FOR rec in curOrari LOOP
  if(length(inOrario)>0) then
     inOrario := inOrario ||',';
  end if;
  inOrario:= inOrario || '''' || rec.codOrario || '''';
 END LOOP;
 --dbms_output.put_line('Orari IN (' || inOrario || ')');
 -- Popolo la stringa con l'insieme dei codici dei contratti
 if(p_prgAlternativa is not null) then
  FOR rec in curContratti LOOP
   if(length(inContratti)>0) then
      inContratti := inContratti ||',';
   end if;
   inContratti:= inContratti || '''' || rec.codContratto || '''';
  END LOOP;
 end if;
 --dbms_output.put_line('Contratti IN (' || inContratti || ')');
 /********************************************************************
 * - automunito (Preferibili)                                        *
 * - motomunito (Preferibili)                                        *
 * - formazione                                                      *
 * - sede raggiungibile con mezzi pubblici (fuori sede) --> sospeso  *
 * - turno                                                           *
 * - orario                                                          *
 * - contratto                                                       *
 * - trasferte                                                       *
 * - esperienza                                                      *
 * - Luogo di Lavoro                                                 *
 ********************************************************************/
 if(where_mansione='' or (where_mansione is null)) then
   dbms_output.put_line('');
 else
    where_mansione := where_mansione || ' or ';
 end if;

 where_mansione := where_mansione || crlf || '( (prm.FLGDISPONIBILE IN (''S'', ''L'') ) ';

    --where_mansione := where_mansione || ' (1=1 ';
 --Automunito
 if( (parAutomunito='P' and p_usaPref=1) or (parAutomunito='S') ) then
  where_mansione := where_mansione ||
    crlf ||   ' and an.CDNLAVORATORE in (select PR_MANSIONE.CDNLAVORATORE from PR_MOBIL_GEOGR inner join PR_MANSIONE on (PR_MANSIONE.prgMansione=PR_MOBIL_GEOGR.PRGMANSIONE)' ||
        '             where PR_MANSIONE.cdnLavoratore=an.cdnLavoratore and PR_MOBIL_GEOGR.FLGDISPAUTO=''S'' )';
 end if;
 -- Motomunito
 if( (parMotomunito='P' and p_usaPref=1) or (parMotomunito='S') ) then
  where_mansione := where_mansione ||
    crlf ||   ' and an.CDNLAVORATORE in (select PR_MANSIONE.CDNLAVORATORE from PR_MOBIL_GEOGR inner join PR_MANSIONE on (PR_MANSIONE.prgMansione=PR_MOBIL_GEOGR.PRGMANSIONE)' ||
        '             where PR_MANSIONE.cdnLavoratore=an.cdnLavoratore and PR_MOBIL_GEOGR.FLGDISPMOTO=''S'' )';
 end if;
 -- formazione
 if (parFormProf='S' or (parFormProf='P' and p_usaPref=1)) then
     p_out_cm_query_join := p_out_cm_query_join || ' inner join VW_MATCH_NRO_FLAG_MAN_CM vwef on (global_cm.cdnlavoratore = vwef.cdnlavoratore) ';
     p_out_cm_query_where := p_out_cm_query_where || ' and vwef.nroFormazione>0';

 end if;

 -- Turno
 if(length(inTurni)>0) then

     where_mansione := where_mansione || crlf ||
      ' and ( an.CDNLAVORATORE in (select PR_MANSIONE.CDNLAVORATORE from PR_MANSIONE inner join PR_DIS_TURNO on (PR_MANSIONE.prgMansione=PR_DIS_TURNO.PRGMANSIONE) '||
   '             where PR_MANSIONE.cdnlavoratore = an.cdnLavoratore and PR_DIS_TURNO.codTurno in ('|| inTurni ||') )' ||
   ' or an.CDNLAVORATORE in (select vm.CDNLAVORATORE from VW_MATCH_NRO_X_MANSIONE_CM vm where vm.cdnLavoratore = an.cdnLavoratore and vm.nroturni=0)) ';
 end if;
 -- Orario
 if(length(inOrario)>0) then
  where_mansione := where_mansione || crlf ||
           ' and ( an.CDNLAVORATORE in (select PR_MANSIONE.CDNLAVORATORE from PR_MANSIONE inner join PR_DIS_ORARIO on (PR_MANSIONE.prgMansione=PR_DIS_ORARIO.PRGMANSIONE) ' ||
       '              where PR_DIS_ORARIO.CODORARIO in (' || inOrario || ')' ||
    '                  and PR_MANSIONE.CDNLAVORATORE = an.cdnlavoratore ) ' ||
    ' or an.CDNLAVORATORE in (select vm.CDNLAVORATORE from VW_MATCH_NRO_X_MANSIONE_CM vm where vm.cdnLavoratore = an.cdnLavoratore and vm.nroOrari=0)) ';
 end if;
 -- Contratto

 -- Apprendistato (Indispensabile e dipendente dall'alternativa) --> SOSPESO
 -- 'APP' --> 'I' oppure 'L', ma dalla richiesta mi dovrebbe arrivare solo 'I'
 if(p_usaNonInd=1) then
  select count(*) into numApprendistato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='D0' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='A0');
 else
  select count(*) into numApprendistato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE='D0' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='A0')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 if (numApprendistato>0) then
     if(length(inContratti)>0) then
      inContratti := inContratti ||',';
     end if;
     inContratti:= inContratti || '''AP''';
 end if;

 if(length(inContratti)>0) then
    where_mansione := where_mansione || crlf ||
           ' and (an.CDNLAVORATORE in (select PR_MANSIONE.CDNLAVORATORE from PR_MANSIONE inner join PR_DIS_CONTRATTO on (PR_MANSIONE.prgMansione=PR_DIS_CONTRATTO.PRGMANSIONE) ' ||
        '              where PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')'||
        '                  and PR_MANSIONE.CDNLAVORATORE = an.cdnlavoratore ) '||
                 ' or an.CDNLAVORATORE in (select vm.CDNLAVORATORE from VW_MATCH_NRO_X_MANSIONE_CM vm where vm.cdnLavoratore = an.cdnLavoratore and vm.nroContratti=0)) ';
 end if;
 -- Trasferte
 if(parTrasferta is not null and (to_number(parTrasferta)<>1)) then
  where_mansione := where_mansione || crlf ||
           ' and an.CDNLAVORATORE in (select PR_MANSIONE.CDNLAVORATORE from PR_MOBIL_GEOGR inner join PR_MANSIONE on (PR_MANSIONE.prgMansione=PR_MOBIL_GEOGR.PRGMANSIONE)' ||
        '             where PR_MANSIONE.cdnLavoratore=an.cdnLavoratore  ' ||
        '                 and to_number(PR_MOBIL_GEOGR.CODTRASFERTA)>=' || parTrasferta || ' ) ';
 end if;
 -- Esperienza
 if((parEsperienza='P' and p_usaPref=1) or (parEsperienza='S')) then
  if (parFormProf='S' or (parFormProf='P' and p_usaPref=1)) then
     p_out_cm_query_join := p_out_cm_query_join;
  else
     p_out_cm_query_join := p_out_cm_query_join || ' inner join VW_MATCH_NRO_FLAG_MAN_CM vwef on (global_cm.cdnlavoratore = vwef.cdnlavoratore) ';
  end if;
  p_out_cm_query_where := p_out_cm_query_where || ' and vwef.nroEsperienze>0 ';

 end if;
 -- Luogo di Lavoro
 if(numComuni=0 and numProv=0) then
  -- come riferimento prendo il comune della sede dell'azienda
  where_mansione := where_mansione || crlf ||
           ' and ( an.CDNLAVORATORE in (select dter.CDNLAVORATORE from VW_PR_DIS_TERRITORIO_CM dter ' ||
        '           where dter.cdnLavoratore=an.cdnLavoratore and ' ||
        '               dter.codCom=' || '''' || codComAz || ''')  ' ||
        '     or an.CDNLAVORATORE in (select pm.CDNLAVORATORE from pr_mansione pm ' ||
                       'inner join pr_dis_stato on (pr_dis_stato.PRGMANSIONE=pm.PRGMANSIONE) ' ||
                       'where pm.CDNLAVORATORE=an.CDNLAVORATORE ' ||
                       'and pr_dis_stato.CODCOM=''Z000'' and ' ||
                       'pm.CODMANSIONE=prm.codMansione)' ||
        ' ) ';
 else
     where_mansione := where_mansione || crlf ||  ' and (';
  -- Esistenza disponibilità per l'intero stato italiano
  where_mansione := where_mansione ||
         'an.CDNLAVORATORE in (select pm.CDNLAVORATORE from pr_mansione pm ' ||
         'inner join pr_dis_stato on (pr_dis_stato.PRGMANSIONE=pm.PRGMANSIONE) ' ||
         'where pm.CDNLAVORATORE=an.CDNLAVORATORE ' ||
         'and pr_dis_stato.CODCOM=''Z000'' and ' ||
         'pm.CODMANSIONE=prm.codMansione)';
  -- Disponibilità per i comuni
  if(numComuni>0) then
       where_mansione := where_mansione || crlf || '    '|| ' OR an.CDNLAVORATORE in (' ||
        'select dter.cdnLavoratore from VW_PR_DIS_TERRITORIO_CM dter ' ||
        'inner join DO_COMUNE oter on (oter.codCom=dter.codCom) ' ||
        'where dter.cdnLavoratore=an.cdnLavoratore  ' ||
        '   and oter.prgRichiestaAz=' || p_prgRichiestaAz ||
        '   and dter.CODMANSIONE=prm.codMansione) ';
  end if;
  -- Disponibilità per le province
  if(numProv>0) then
       where_mansione := where_mansione || crlf || '    '|| ' OR an.CDNLAVORATORE in (' ||
        'select dter.cdnLavoratore from VW_PR_DIS_PROVINCIA_CM dter ' ||
        'inner join DO_PROVINCIA oter on (oter.codProvincia=dter.codProvincia) ' ||
        'where dter.cdnLavoratore=an.cdnLavoratore ' ||
        '   and oter.prgRichiestaAz=' || p_prgRichiestaAz ||
        '   and dter.CODMANSIONE=prm.codMansione) ';
  end if;
  where_mansione := where_mansione || ' ) ';
 end if;
 where_mansione := where_mansione || crlf ||') ';
 query_where := query_where || ' and (' || where_mansione || crlf || ') ';
 /*---------------------------------- FINE MANSIONE ------------------------------------*/
 -- Servizio Militare / Servizio Civile (Preferibili)
 if( (parMilitare='P' and p_usaPref=1) or (parMilitare='S')) then
  query_where := query_where || crlf ||
        ' and ((an.STRSESSO=''M'' and an.FLGMILITE=''S'') or (an.STRSESSO=''F'')) ';
 end if;
 -- Conoscenze Linguistiche (Indispensabili - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numConLinguistiche
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numConLinguistiche
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
  and DO_LINGUA.FLGINDISPENSABILE='S';
 end if;
 if(numConLinguistiche>0) then
  query_where := query_where || crlf ||
        ' and (' ||
        '  (select count(*) from PR_LINGUA cv_lin inner join ' ||
        '   DO_LINGUA o_lin on (' ||
          'cv_lin.codLingua = o_lin.codLingua and ' ||
       'nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and ' ||
       'nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and ' ||
       'nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1)) ' ||
       'where (cv_lin.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_lin.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
       'o_lin.prgAlternativa=' || p_prgAlternativa || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_lin.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) >= ' || numConLinguistiche;
  -- Controllo se è richiesta la lingua italiana
  if(p_usaNonInd=1) then
     select count(*) into numConLinIta
     from DO_LINGUA
     where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
        and DO_LINGUA.codLingua='003';
  else
     select count(*) into numConLinIta
     from DO_LINGUA
     where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
        and DO_LINGUA.FLGINDISPENSABILE='S'
     and DO_LINGUA.CODLINGUA='003';
  end if;
  -- se numConLinIta >0  allora e' richiesta la lingua intaliana
  if(numConLinIta>0) then
     if(numConLinguistiche=1) then
      -- è richiesta la sola conoscenza della lingua italiana
      query_where := query_where || ' OR (an.codCittadinanza=''000'' or an.codCittadinanza2=''000'')';
     else
         query_where := query_where || ' OR ' ||
              '(select count(*) from PR_LINGUA cv_lin inner join ' ||
          'DO_LINGUA o_lin on (' ||
          'cv_lin.codLingua = o_lin.codLingua and ' ||
       'nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and ' ||
       'nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and ' ||
       'nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1)) ' ||
       'where (cv_lin.cdnLavoratore = an.cdnLavoratore and ' ||
       'o_lin.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
       'o_lin.prgAlternativa=' || p_prgAlternativa || ' and o_lin.codLingua<>''003'' ' ||
       'and (an.codCittadinanza=''000'' or an.codCittadinanza2=''000'')';
      if(p_usaNonInd=0 or (p_usaNonInd is null)) then
         query_where := query_where || 'and o_lin.flgIndispensabile=''S'' ';
      end if;
         query_where := query_where || ')) ' ||
        '>= ' || (numConLinguistiche - numConLinIta);
     end if;
  end if;
  query_where := query_where || ') ';
 end if;
 -- Competenze (Indispensabili e dipendono dall'alternativa - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numCompetenze
  from DO_COMPETENZA
  where DO_COMPETENZA.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_COMPETENZA.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numCompetenze
  from DO_COMPETENZA
  where DO_COMPETENZA.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_COMPETENZA.PRGALTERNATIVA = p_prgAlternativa
     and DO_COMPETENZA.FLGINDISPENSABILE='S';
 end if;
 if(numCompetenze>0) then
  query_where := query_where || crlf ||
        ' and (' ||
        '   (select count(*) from PR_COMPETENZA cv_comp inner join DO_COMPETENZA o_comp on (' ||
        '       cv_comp.codCompetenza = o_comp.codCompetenza) ' ||
        '    where (cv_comp.cdnLavoratore = an.cdnLavoratore and ' ||
        '       o_comp.prgRichiestaAz=' || p_prgRichiestaAz ||
        '       and o_comp.prgAlternativa=' || p_prgAlternativa || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_comp.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) >= ' || numCompetenze || ') ';
 end if;
 -- Conoscenze Informatiche (Indispensabili e dipendenti dall'alternativa - condizioni in AND)
 if(p_usaNonInd=1) then
  select count(*) into numConInformatiche
  from DO_INFO
  where DO_INFO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_INFO.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numConInformatiche
  from DO_INFO
  where DO_INFO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_INFO.PRGALTERNATIVA = p_prgAlternativa
     and DO_INFO.FLGINDISPENSABILE='S';
 end if;
 /*************************************************************
   DA QUESTO PUNTO SI UTILIZZERA' LA VARIABILE 'query_where'
 **************************************************************/
 if(numConInformatiche>0) then
  query_where := query_where || crlf ||
        ' and (' ||
        '   (select count(*) from PR_INFO cv_inf inner join DO_INFO o_inf on (' ||
        '       cv_inf.codDettInfo = o_inf.codDettInfo and ' ||
        '       cv_inf.codTipoInfo = o_inf.codTipoInfo and ' ||
        '       nvl(cv_inf.cdnGrado,1) >= nvl(o_inf.cdnGrado,1)) ' ||
        '    where (cv_inf.cdnLavoratore = an.cdnLavoratore and ' ||
           '       o_inf.prgRichiestaAz=' || p_prgRichiestaAz || ' ';
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_inf.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where ||
       'and o_inf.prgAlternativa=' || p_prgAlternativa ||
        ')) >= ' || numConInformatiche ||
        ') ';
 end if;
 -- Abilitazioni (Indispensabili  - condizioni in AND)
 -- Es. patente specifica, patentino specifico, ....
 if(p_usaNonInd=1) then
  select count(*) into numAbilitazioni
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN<>'PGB';

  select count(*) into patenteB
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN='PGB';
 else
  select count(*) into numAbilitazioni
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.FLGINDISPENSABILE='S'
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN<>'PGB';

  select count(*) into patenteB
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.FLGINDISPENSABILE='S'
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN='PGB';
 end if;
 if(numAbilitazioni>0) then
  query_where := query_where || crlf ||
        ' and (' ||
        '    (select count(*) from PR_ABILITAZIONE cv_abi inner join DO_ABILITAZIONE_GEN o_abi on (' ||
        '        cv_abi.codAbilitazioneGen = o_abi.codAbilitazioneGen) ' ||
        '     where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
        '        o_abi.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
        '        o_abi.codAbilitazioneGen <> ''PGB'' ' ;
  if(p_usaNonInd=0 or (p_usaNonInd is null)) then
   query_where := query_where || 'and o_abi.flgIndispensabile=''S'' ';
  end if;
  query_where := query_where || ')) >= ' || numAbilitazioni || ') ';
    end if;
 if(patenteB>0) then
  query_where := query_where || crlf ||
        ' and (' ||
        '    (select count(*) from PR_ABILITAZIONE cv_abi ' ||
        '     where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
           '        (cv_abi.codAbilitazioneGen = ''PGB'' or '||
        '         cv_abi.codAbilitazioneGen = ''PGC'' or '||
        '         cv_abi.codAbilitazioneGen = ''PGD'') ';
  query_where := query_where || ')) >= 1 ' || ') ';
 end if;
 -- Titoli di Studio (Indispensabili e dipendenti dall'alternativa - condizioni in OR)
 if(p_usaNonInd=1) then
  select count(*) into numTitoli
  from DO_STUDIO
  where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
 else
  select count(*) into numTitoli
  from DO_STUDIO
  where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa
     and DO_STUDIO.FLGINDISPENSABILE='S';
 end if;
 dbms_output.put_line('Sono richiesti n. ' || numTitoli || ' Titoli di Studio');
 if(numTitoli>0) then
  --dbms_output.put_line('I Titoli sono in OR e va gestito il raggruppamento XY0000, XYAB00, XYABCD');
  FOR rec IN curTitoli LOOP
   if((rec.flgIndispensabile='S') or (p_usaNonInd=1)) then
      if(length(where_titoli)>0) then
         where_titoli := where_titoli || ' union ';
      else
         where_titoli := '' || crlf;
      end if;
      where_titoli := where_titoli || ' (';
     -- modifica TITOLI FASE 3
     -- Le codifiche dei titoli di studio sono composte di 8 digit
     like_titolo :=
     case
      when substr(rec.codTitolo, -7)='0000000' then substr(rec.codTitolo,1,1) || '%'
      when substr(rec.codTitolo, -6)='000000' then substr(rec.codTitolo,1,2) || '%'
      when substr(rec.codTitolo, -5)='00000' then substr(rec.codTitolo,1,3) || '%'
      when substr(rec.codTitolo, -3)='000' then substr(rec.codTitolo,1,5) || '%'
      else rec.codTitolo
     end;
      where_titoli := where_titoli ||
             'select cv_tit.cdnLavoratore from PR_STUDIO cv_tit ' ||
          'where cv_tit.cdnLavoratore=an.cdnLavoratore and ' ||
          'cv_tit.CODTITOLO like ' || '''' || like_titolo || '''' || ' and ';
      if(rec.flgConseguito='S' or (rec.flgConseguito is null)) then
         where_titoli := where_titoli ||
            'cv_tit.CODMONOSTATO=''C'' ';
      else
          if(rec.flgConseguito='N') then
          where_titoli := where_titoli ||
                   'cv_tit.CODMONOSTATO in (''A'',''I'',''C'') ';
       end if;
      end if;
      where_titoli := where_titoli || ') ';
   end if;
  END LOOP;
 end if;
 --dbms_output.put_line('WhereTitoli=' || where_titoli);
 if(length(where_titoli)>0) then
    query_where := query_where || ' and an.CDNLAVORATORE in (' || where_titoli || ') ';
 end if;
 -- Corsi di Formazione 
select count(*) into abilitatoIDO
from ts_config_loc, de_tipo_config, ts_generale
where  ts_generale.prggenerale = 1
and ts_generale.codprovinciasil = ts_config_loc.strcodrif
and de_tipo_config.codtipoconfig = ts_config_loc.codtipoconfig
and trunc(sysdate) between trunc(de_tipo_config.datinizioval)
and trunc(de_tipo_config.datfineval)
and ts_config_loc.num=1
and upper(ts_config_loc.codtipoconfig) = 'IDOFPRO';

if(abilitatoIDO>0) then
	where_form_prof:= PG_INCROCIO.checkFormProf(p_prgRichiestaAZ ,p_prgAlternativa,p_usaNonInd);
    if(length(where_form_prof)>0) then
       query_where := query_where || ' and an.CDNLAVORATORE in (' || where_form_prof  || ') ';
    end if;
end if;

/*****************************************************
 *            AGEVOLAZIONI                            *
 * Sono indispensabili e dipendenti dall'alternativa. *
 * Vanno considerate in OR fra loro                   *
 * Il Collocamento Mirato viene trattato in modo      *
 * speciale: se è presente nella richiesta allora va  *
 * aggiunta una clausola in OR assieme alle altre     *
 * agevolazioni, mentre se non viene richiesto si deve*
 * aggiungere una clausola in AND alle altre condizio-*
 * ni della query.                                    *
 * Le agevolazioni considerate sono:                  *
 * - Mobilità                                         *
 * - Collocamento Mirato                              *
 * - Disoccupazione L. 407/90                         *
 * - Apprendistato                                    *
 *****************************************************/
 query_agevolazioni := '';
 -- In Mobilità (Indispensabile e dipendente dall'alternativa --> fa parte delle agevolazioni )
 -- 'MOB' --> 'A'
 if(p_usaNonInd=1) then
  select count(*) into numMobilita
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S5', 'S6', 'S7', '75', '76', '77');
 else
  select count(*) into numMobilita
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S5', 'S6', 'S7', '75', '76', '77')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 if(numMobilita>0) then
     if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || crlf || ' OR ';
  else
     query_agevolazioni := query_agevolazioni || crlf;
  end if;
  -- aggiungo il join con AM_MOBILITA_ISCR
  query_join := query_join ||
          'left outer join AM_MOBILITA_ISCR on (an.cdnLavoratore=AM_MOBILITA_ISCR.CDNLAVORATORE) and (AM_MOBILITA_ISCR.FLGNONIMPRENDITORE is null or AM_MOBILITA_ISCR.FLGNONIMPRENDITORE = ''N'') ';
  -- fare un controllo sul formato delle date in questa tabella
  query_agevolazioni := query_agevolazioni ||
        ' (trunc(AM_MOBILITA_ISCR.DATINIZIO) <= trunc(sysdate) and ' ||
        '(AM_MOBILITA_ISCR.DATFINE is null or trunc(sysdate) <= trunc(AM_MOBILITA_ISCR.DATFINE))) ';
 end if;
 -- Collocamento Mirato (Indispensabile e dipendente dall'alternativa --> fa parte delle agevolazioni)
 -- 'CLM' --> 'R' oppure 'S'
 if(p_usaNonInd=1) then
  select count(*) into numCollocMirato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE = '66' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='67');
 else
  select count(*) into numCollocMirato
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and (DO_AGEVOLAZIONE.CODAGEVOLAZIONE = '66' or DO_AGEVOLAZIONE.CODAGEVOLAZIONE='67')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 -- aggiungo il join con AM_CM_ISCR

  if(length(query_agevolazioni)>0) then
       query_agevolazioni := query_agevolazioni || crlf || ' OR ';
  else
       query_agevolazioni := query_agevolazioni || crlf;
  end if;

  query_agevolazioni := query_agevolazioni || '1 = 1';

 if(p_usaNonInd=1) then
  select count(*) into numDisocc
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S8', '58');
 else
  select count(*) into numDisocc
  from DO_AGEVOLAZIONE
  where DO_AGEVOLAZIONE.PRGRICHIESTAAZ = p_prgRichiestaAz
     and DO_AGEVOLAZIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_AGEVOLAZIONE.CODAGEVOLAZIONE IN ('S8', '58')
     and DO_AGEVOLAZIONE.FLGINDISPENSABILE = 'S';
 end if;
 if(numDisocc>0) then
  if(length(query_agevolazioni)>0) then
   query_agevolazioni := query_agevolazioni || ' OR ';
  end if;
  query_join := query_join ||
          'left outer join VW_AM_LAV_SITUAZ_AMMIN on (an.cdnLavoratore=VW_AM_LAV_SITUAZ_AMMIN.CDNLAVORATORE) ';
  query_agevolazioni := query_agevolazioni || ' (VW_AM_LAV_SITUAZ_AMMIN.flg40790=''S'') ';
 end if;

 if(length(query_agevolazioni)>0) then
  query_where := query_where || crlf || ' and (' || query_agevolazioni || crlf || '   ) ';
 end if;
 -- Ricavo la query sql da eseguire

 -- DONA 22/04/2008
 --query_where := query_where || par_indisponibilita_az;
 /* se la clausola where inizia con un 'and' allora bisogna toglierla         */
 query_where:= ltrim(query_where, ' and ');
 /***************  non serve a niente: ***************************/
 p_sql_query := query_select ||
       query_from ||
       query_join || ' where ' ||
       query_where;
 /********************************
 Check dei parametri di Ritorno
 ********************************/
 if(p_out_prgIncrocio is null or p_out_prgRosa is null) then
    rollback;
    return -1;
 end if;
 if(length(query_select)=0 or length(query_from)=0 or length(query_join)=0 or length(query_where)=0) then
    rollback;
    return -1;
 end if;
 -- Preparo i parametri di Output
 p_out_query_select := 'insert into global_cm ' || query_select;
 p_out_query_from := query_from;
 p_out_query_join := query_join;
 p_out_query_where := ' where ' || query_where;

 p_out_cm_query_join := p_out_cm_query_join;
 p_out_cm_query_where := p_out_cm_query_where;

 return 0;
 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       /* se si verificano errori puo' essere comodo ritornare alcune informazioni per il debuggin

        p_out_query_select := 'length p_sql_query: ' ||length(p_sql_query);
     p_out_query_from := 'length query_where: ' || length(query_where);
      p_out_query_join := '';
         p_out_query_where := sqlerrm;
     */
       return -1;
END Matching_esatto_no_mansione_CM;

function Matching_Pesato_PEsatti_CM(
    p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
    p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
    p_db int,                -- base dati da utilizzare
    p_dataValCV  varchar2,          -- data in base alla quale considerare valido un CV
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_numPFasciaEtaPrima number,         -- peso associato alla prima fascia di età estesa
    p_numPFasciaEtaSec number,         -- peso associato alla seconda fascia di età estesa
    p_numPStudioGruppo number,         -- peso associato a un titolo di studio nel gruppo
    p_numPStudioAlias number,          -- peso associato a un titolo di studio associato
    p_numPMansioneGruppo number,         -- peso associato a una mansione nel gruppo
    p_numPMansioneAlias number,         -- peso associato a una mansione associata
    p_numPNoEsperienza number,         -- peso associato alla mansione senza esperienza
    p_numPEsperienzaAlias number,         -- peso associato all'esperienza in una mansione simile
    p_numPInfoMin number,           -- peso associato alla conoscenza info con grado minore
    p_numPInfoGruppo number,          -- peso associato a una conoscenza info nello stesso gruppo
    p_numPInfoGruppoMIn number,         -- peso associato a una conoscenza info nello stesso gruppo e grado minore
    p_numPLinguaInf number,           -- peso associato a una conoscenza linguistica con grado minore
    p_numPSogliaRichiesta number,         -- valore di soglia entro il quale estrarre i candidati
    p_flagIncMir int,         -- flag collocamento mirato
    p_checkCM  number,              -- interruttore per il collocamento mirato
    p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
    p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
    p_out_query_select OUT varchar2,
    p_out_query_from OUT varchar2,
    p_out_query_join OUT varchar2,
    p_out_query_where OUT long,
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE,       -- progressivo della rosa
    p_out_where_territorio OUT varchar2
    ) return number IS
  p_sql_query long;
  query_select varchar2(100);
  query_from varchar2(100);
  query_join varchar2(4000);
  query_where varchar2(6000);
  p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
  p_Originale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;

  -- MASTER -------questo in realtà non verrà usato
  --where_cpi_master varchar2(500) := ' and (PG_INCROCIO.PDMASTERLAVO(an.cdnLavoratore)=1) ';
  ------------------------------------------------
  --where_mansione varchar2(6000) := '';
  where_mansione long := '';
  where_test varchar2(6000) := '';
  where_territorio varchar2(6000) := '';
  like_mansione varchar2(20);
  where_luogo varchar2(2000) := '';
  -- Indisponibilità ---------------------------------
  par_indisponibilita_az varchar(100) := ' and (PG_INCROCIO.pdIndispAzienda(an.cdnLavoratore,' || p_prgRichiestaAz || ')=0) ';
  ----------------------------------------------------
  recRichiesta DO_RICHIESTA_AZ%ROWTYPE;
  parPrgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;
  parAutomunito DO_RICHIESTA_AZ.FLGAUTOMUNITO%TYPE;
  numComuni number;
  numProv number;
  codComAz AN_UNITA_AZIENDA.CODCOM%TYPE;
  strMansione varchar2(2000);
  numMansioni number;
  numRelMansioni number;
  p_prgMansione DE_MANSIONE.CODMANSIONE%TYPE;
  numAbilitazioni number;
  patenteB number;

  rflgIncMir char(1);

  -- Parametri impliciti------------------------------------------
/*  par_impliciti varchar2(500) := ' (pr_validita.CODTIPOVALIDITA = ''DL'' and PR_VALIDITA.CODSTATOLAV=''COM'' and ' ||
          'trunc(sysdate) between ' ||
       'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
       'trunc(PR_VALIDITA.DATFINECURR)) ';
  par_impliciti_valCV varchar2(500) := ' (pr_validita.CODTIPOVALIDITA = ''DL'' and PR_VALIDITA.CODSTATOLAV=''COM'' and ' ||
          'to_date(''' || p_dataValCv || ''',''dd/mm/yyyy'') between ' ||
       'trunc(PR_VALIDITA.DATINIZIOCURR) and ' ||
       'trunc(PR_VALIDITA.DATFINECURR)) ';
*/
 -----------------------------------------------------------------

  -- Cursori
  CURSOR curMansioni IS
     select DO_MANSIONE.codMansione
   from DO_MANSIONE
   where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_MANSIONE.PRGALTERNATIVA = p_prgAlternativa;
  -- Debug
  lenStr number;
  tmpStr char(255);
  j number;
  k number;
  -- Tipo del record per la tabella di appoggio -- Debug
  type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
             strCognome AN_LAVORATORE.STRCOGNOME%TYPE,
        strNome AN_LAVORATORE.STRNOME%TYPE
              );
  type tab_ris is table of p_rec_ris;
  p_tab_ris tab_ris;
BEGIN
 if(p_prgRosa is null) then
  --query_select := 'select distinct an.CDNLAVORATORE, an.STRCOGNOME, an.STRNOME ';
  query_select := 'select distinct an.CDNLAVORATORE ';
  query_from := 'from AN_LAVORATORE an ';
    --query_where := '';
  --query_where := where_cpi_master; --SOSTITUITO
  query_join := query_join || 'inner join an_lav_storia_inf i on (an.cdnlavoratore=i.cdnlavoratore)';
   query_join := query_join || 'inner join de_cpi on (i.CODCPITIT=de_cpi.CODCPI)';
   query_where := ' and (DECODE(i.DATFINE,NULL,''S'',''N'') = ''S'' and i.codmonotipocpi in (''C'',''T'') ';
   query_where :=query_where || ' and de_cpi.codprovincia = (select codProvinciaSil from ts_generale where rownum=1) )';

 else
  --query_select := 'select distinct an.CDNLAVORATORE, an.STRCOGNOME, an.STRNOME ';
  query_select := 'select distinct an.CDNLAVORATORE ';
  query_from := 'from do_nominativo ';
  query_join := 'inner join an_lavoratore an on (do_nominativo.CDNLAVORATORE=an.CDNLAVORATORE) ';
  query_where := ' and (do_nominativo.PRGROSA=' || p_prgRosa || ') ';
 end if;
  query_join := query_join || 'inner join PR_MANSIONE prm on (an.cdnLavoratore = prm.cdnLavoratore) ';
  query_join := query_join || 'inner join Pr_Dispo_L68 on Pr_Dispo_L68.cdnLavoratore = an.cdnLavoratore and Pr_Dispo_L68.codmonodispol8 = ''S'' ';
  query_join := query_join || 'left outer join PR_MOBIL_GEOGR on (prm.prgMansione=PR_MOBIL_GEOGR.PRGMANSIONE) ';

  -- dona 24/01/2008
  -- devono essere considerati solamente i lavoratori disponibili e occupabili in pr_dispo_l68
  query_join := query_join || ' inner join DE_GRADO_OCC on PR_DISPO_L68.CODGRADOOCC = DE_GRADO_OCC.CODGRADOOCC and DE_GRADO_OCC.FLGINCROCIO = ''S'' ';
  query_join := query_join || ' inner join global_cm on (an.cdnlavoratore=global_cm.cdnlavoratore) ';


  -- Controllo che ci sia almeno una mansione
  select count(*) into numMansioni from DO_MANSIONE where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;
  if(numMansioni=0) then
 return 1;
 dbms_output.put_line('Non è possibile effettuare l''incrocio in quanto non è stata specificata nessuna mansione!');
  end if;
  -- Controllo che la richiesta non sia stata CHIUSA mentre si accedeva all'incrocio
  SELECT RICH2.PRGRICHIESTAAZ INTO p_Originale
  FROM DO_RICHIESTA_AZ RICH1
        INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
  WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;

  SELECT do_evasione.CDNSTATORICH into p_cdnStatoRich
  FROM DO_RICHIESTA_AZ, DO_EVASIONE
  WHERE (DO_RICHIESTA_AZ.PRGRICHIESTAAZ=DO_EVASIONE.PRGRICHIESTAAZ)
    AND DO_RICHIESTA_AZ.PRGRICHIESTAAZ=p_Originale;
  if(p_cdnStatoRich=4 OR p_cdnStatoRich=5) then
  return 2;
  end if;

  -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;
  dbms_output.put_line('Prg Incrocio=' || p_out_prgIncrocio || ' - Prg Rosa=' || p_out_prgRosa);
  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgIncrocio, p_prgRichiestaAz, p_prgAlternativa, 2, 'E',
  p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgRosa, null, p_out_prgIncrocio, 1, p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 3: memorizzo i parametri dell'incrocio  -> li memorizzo nella Function di esecuzione
  if(p_flagIncMir=1) then
   rflgIncMir := 'S';
  else
   rflgIncMir := 'N';
  end if;

  insert into do_parametri_incrocio
  (PRGPARAMETRIINCROCIO, PRGINCROCIO, CODTERRITORIO, PRGROSA, DATSTATOLAV,
  NUMPFASCIAETAESATTA, NUMPFASCIAETAPRIMA, NUMPFASCIAETASEC,
  NUMPSTUDIO, NUMPSTUDIOGRUPPO, NUMPSTUDIOALIAS,
  NUMPMANSIONE, NUMPMANSIONEGRUPPO, NUMPMANSIONEALIAS,
  NUMPESPERIENZA, NUMPNOESPERIENZA, NUMPESPERIENZAALIAS,
  NUMPINFO, NUMPINFOMIN, NUMPINFOGRUPPO, NUMPINFOGRUPPOMIN,
  NUMPLINGUA, NUMPLINGUAINF,
  DECSOGLIARICHIESTA,
  FLGINCROCIOMIRATO, CODMONOCMCATEGORIA)
  values
  (S_DO_PARAMETRI_INCROCIO.nextval, p_out_prgIncrocio, p_db, p_out_prgRosa, to_date(p_dataValCV, 'dd/mm/yyyy'),
  100, p_numPFasciaEtaPrima, p_numPFasciaEtaSec,
  100, p_numPStudioGruppo, p_numPStudioAlias,
  100, p_numPMansioneGruppo, p_numPMansioneAlias,
  100, p_numPNoEsperienza, p_numPEsperienzaAlias,
  100, p_numPInfoMin, p_numPInfoGruppo, p_numPInfoGruppoMin,
  100, p_numPLinguaInf,
  p_numPSogliaRichiesta,
  rflgIncMir, p_codmonocmcategoria);
  -- INDISPONIBILITA'
  select * into recRichiesta from DO_RICHIESTA_AZ where DO_RICHIESTA_AZ.PRGRICHIESTAAZ = p_prgRichiestaAz;
  parPrgAzienda := recRichiesta.prgAzienda;
  parAutomunito := recRichiesta.flgAutomunito;
  -- TERRITORIO
  select count(*) into numComuni from DO_COMUNE where DO_COMUNE.PRGRICHIESTAAZ = p_prgRichiestaAz;
  select count(*) into numProv from DO_PROVINCIA where DO_PROVINCIA.PRGRICHIESTAAZ = p_prgRichiestaAz;
  if(numComuni=0 and numProv=0) then
  select an_az.CODCOM into codComAz
  from DO_RICHIESTA_AZ daz
    inner join AN_UNITA_AZIENDA an_az on (daz.prgAzienda=an_az.prgAzienda and daz.prgUnita=an_az.prgUnita)
  where daz.PRGRICHIESTAAZ = p_prgRichiestaAz;
  end if;
 /*********************************************************
 * Mansione e parametri collegati alle mansioni:          *
 * - Automunito                                           *
 * - Luogo di Lavoro                                      *
 *********************************************************/
 /* Va gestito il raggruppamento xy0000, xyab00, xyabcd */
 FOR rec IN curMansioni LOOP
  if(where_mansione='' or (where_mansione is null)) then
    dbms_output.put_line('');
  else
     where_mansione := where_mansione || ' or ';
  end if;

  if(where_test='' or (where_test is null)) then
     dbms_output.put_line('');
  else
     where_test := where_test || ' or ';
  end if;

  --if(SUBSTR(rec.codMansione,-4)='0000') then
   --strMansione := '(SUBSTR(prm.codMansione,1,2)=''' || SUBSTR(rec.codMansione,1,2) || ''') ';
  -- like_mansione := SUBSTR(rec.codMansione,1,2) || '%';
  --else
    if(SUBSTR(rec.codMansione,-2)='00') then
     strMansione := '(SUBSTR(prm.codMansione,1,5)=''' || SUBSTR(rec.codMansione,1,5) || ''') ';
    like_mansione := SUBSTR(rec.codMansione,1,5) || '%';
    else
       --strMansione := '(prm.codMansione=''' || rec.codMansione || ''') ';
    like_mansione := rec.codMansione;
    strMansione := '(prm.codMansione=''' || rec.codMansione || ''' or ' ||
          'SUBSTR(prm.codMansione,1,5)=''' || SUBSTR(rec.codMansione,1,5) || ''' ';
    select count(*) into numRelMansioni
    from DE_REL_MANSIONE
    where de_rel_mansione.codMansione=rec.codMansione and flgTipo=2;
    if(numRelMansioni>0) then
     p_prgMansione := rec.codMansione;
     strMansione := strMansione || ' or ' ||
          'SUBSTR(prm.codMansione,1,5) in '  ||
          '(select SUBSTR(codGruppo,1,5) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
          p_prgMansione || ''' and flgTipo=2)';
    end if;
    strMansione := strMansione || ') ';
    end if;
  --end if;

  where_mansione := where_mansione || '(' || strMansione || ' and (prm.FLGDISPONIBILE IN (''S'', ''L'') ) ';
  where_test := where_test || '(' || strMansione || ' and (prm.FLGDISPONIBILE IN (''S'', ''L'') ) ';

  like_mansione :=
   case
    --when substr(rec.codMansione,-4)='0000' then substr(rec.codMansione,1,2) || '%'
    when substr(rec.codMansione,-2)='00' then substr(rec.codMansione,1,5) || '%'
    else rec.codMansione
   end;

  --Automunito
  if( (parAutomunito='P') or (parAutomunito='S') ) then
   where_mansione := where_mansione ||
            ' and (PR_MOBIL_GEOGR.FLGDISPAUTO=''S'' ) ';
--         '(PR_MOBIL_GEOGR.FLGDISPAUTO is null and PR_NOTA_LAV.FLGAUTOMUNITO=''S'') )';
  end if;


  -- Fine where_mansione
  where_mansione := where_mansione || ') ';
  where_test := where_test || ') ';
  --where_territorio := where_territorio || ') ';
 END LOOP;
 query_where := query_where || ' and (' || where_mansione || ') ';

 --11/01/2006 - Stefy
 -- Invece dell'intera query di verifica sulle disp. territoriali passo alla seconda funzione solamente
 -- la parte che riguarda la mansione
 where_territorio := where_test;


 -- Abilitazioni (Vengono considerate TUTTE Indispensabili  - condizioni in AND)
 -- Si controllano solamente le patenti di guida
 select count(*) into numAbilitazioni
 from DO_ABILITAZIONE_GEN inner join DE_ABILITAZIONE_GEN on
    (DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN = DE_ABILITAZIONE_GEN.CODABILITAZIONEGEN)
 where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
    and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN<>'PGB'
   and DE_ABILITAZIONE_GEN.CODTIPOABILITAZIONEGEN = 'PG' ;
 --
  select count(*) into patenteB
  from DO_ABILITAZIONE_GEN
  where DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_ABILITAZIONE_GEN.CODABILITAZIONEGEN='PGB';
 --
 if(numAbilitazioni>0) then
  query_where := query_where ||
         ' and (' ||
         '(select count(*) from PR_ABILITAZIONE cv_abi ' ||
      'inner join DO_ABILITAZIONE_GEN o_abi on (cv_abi.codAbilitazioneGen = o_abi.codAbilitazioneGen) ' ||
       'inner join DE_ABILITAZIONE_GEN on (o_abi.CODABILITAZIONEGEN = DE_ABILITAZIONE_GEN.CODABILITAZIONEGEN)' ||
      ' where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
      ' DE_ABILITAZIONE_GEN.CODTIPOABILITAZIONEGEN=''PG'' and ' ||
      ' o_abi.prgRichiestaAz=' || p_prgRichiestaAz || ' and ' ||
      ' o_abi.codAbilitazioneGen <> ''PGB'')' ;
  query_where := query_where || ')>=' || numAbilitazioni ||
        ') ';
  end if;
 if(patenteB>0) then
  query_where := query_where ||
        ' and (' ||
          '(select count(*) from PR_ABILITAZIONE cv_abi ' ||
       'where (cv_abi.cdnLavoratore = an.cdnLavoratore and ' ||
         '(cv_abi.codAbilitazioneGen = ''PGB'' or cv_abi.codAbilitazioneGen = ''PGC'' or cv_abi.codAbilitazioneGen = ''PGD'') ';
  query_where := query_where || ')) >= 1 ' ||
        ') ';
 end if;

  query_where := query_where || par_indisponibilita_az;
  query_where:= ltrim(query_where, 'and ');
  p_sql_query := query_select ||
          query_from ||
     query_join || ' where ' ||
     query_where;
   /********************************
 Check dei parametri di Ritorno
 ********************************/
 if(p_out_prgIncrocio is null or p_out_prgRosa is null) then
    rollback;
    return -1;
 end if;
 if(length(query_select)=0 or length(query_from)=0 or length(query_join)=0 or length(query_where)=0) then
    rollback;
    return -1;
 end if;
 -- Preparo i parametri di Output
 p_out_query_select := query_select;
 p_out_query_from := query_from;
 p_out_query_join := query_join;
 p_out_query_where := ' where ' || query_where;
 p_out_where_territorio := where_territorio;
 return 0;
 rollback;
 exception
      when no_data_found then
          null;
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       return -1;
END Matching_Pesato_PEsatti_CM;

/**
gestione incrocio senza mansione collocamento mirato
*/
function ESEGUIINCROCIOCM_NOMANSIONE(
   p_query_select varchar2,
   p_query_from varchar2,
   p_query_join varchar2,
   p_query_where varchar2,
   p_cm_query_join varchar2,
   p_cm_query_where varchar2,
   p_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,  -- progressivo dell'incrocio
   p_prgRosa DO_ROSA.PRGROSA%TYPE,     -- progressivo della rosa
   p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
   p_mem char,
   encrypterkey varchar2,
   p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
   p_ErrCode OUT number
   --p_cursor OUT t_cursor
   ) return number  IS

  type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type);
  type tab_ris is table of p_rec_ris;
  p_tab_ris tab_ris;
  sql_query CLOB;
  sql_query_cand long;
  rCpiTit DE_CPI.CODCPI%type;
  rDid DO_NOMINATIVO.DATDICHIARAZIONE%type;
  nro number;
  p_categoriaCM do_richiesta_az.codmonocmcategoria%type;
  p_prgRichiestaAz do_incrocio.prgrichiestaaz%type;
begin

-- donato popolo la global_cm con i lavoratori iscritti al collocamento
 sql_query := p_query_select;
 sql_query := sql_query || ', null ' ;
 sql_query := sql_query || p_query_from;
 sql_query := sql_query || p_query_join;
 sql_query := sql_query || p_query_where;

-- è una query di insert
execute immediate to_char(sql_query);


update global_cm
set cdncrypt=encrypt(cdnlavoratore,encrypterkey);

if (p_codmonocmcategoria = 'D' OR p_codmonocmcategoria = 'A') then
  update global_cm
  set cdncrypt=null
  where cdncrypt not in
  (select i.cdnlavoratore
  from am_cm_iscr i
  inner join de_cm_tipo_iscr dc on dc.codcmtipoiscr = i.codcmtipoiscr
  INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
  INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
  where
  DOC.CODSTATOATTO = 'PR' AND DOC.CDNLAVORATORE = decrypt(i.cdnlavoratore, encrypterkey)
  and DECODE(i.DATDATAFINE,NULL,'S','N') = 'S'
  and dc.codmonotiporagg = p_codmonocmcategoria
  );
else
  update global_cm
  set cdncrypt=null
  where cdncrypt not in
  (select i.cdnlavoratore
  from am_cm_iscr i
  INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
  INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
  where
  DOC.CODSTATOATTO = 'PR' AND DOC.CDNLAVORATORE = decrypt(i.cdnlavoratore, encrypterkey)
  and DECODE(i.DATDATAFINE,NULL,'S','N') = 'S'
  );
end if;

 select inc.prgrichiestaaz into p_prgRichiestaAz
 from do_incrocio inc
 where inc.prgincrocio = p_prgIncrocio;

sql_query_cand := 'select global_cm.cdnlavoratore from global_cm ' ||
               p_cm_query_join ||
               ' where cdncrypt is not null ' ||
               p_cm_query_where;

execute immediate sql_query_cand bulk collect into p_tab_ris;
 dbms_output.put_line('');
 dbms_output.put_line('Elenco Candidati');
 if(p_mem=1) then
   FOR i in 1..p_tab_ris.COUNT
    loop
      --dbms_output.put_line(p_tab_ris(i).cdnLavoratore ||';' || p_tab_ris(i).strCognome || ';' || p_tab_ris(i).strNome);
     -- Inserimento del candidato in do_nominativo
     --rDid := PG_INCROCIO.PDDIDLAVO(p_tab_ris(i).cdnLavoratore);
     rCpiTit := PG_INCROCIO.PDCPITIT(p_tab_ris(i).cdnLavoratore);
     /*
     insert into DO_NOMINATIVO
     (prgNominativo, cdnLavoratore, numOrdine, codCpiTit, dtmIns, cdnUtIns, prgRosa, datDichiarazione)
     values
     (S_DO_NOMINATIVO.nextVal, p_tab_ris(i).cdnLavoratore, null,
     PG_INCROCIO.PDCPITIT(p_tab_ris(i).cdnLavoratore), sysdate, p_cdnUtente, p_prgRosa,
     PG_INCROCIO.PDDIDLAVO(p_tab_ris(i).cdnLavoratore));
     */

     if(p_prgRosa is null) then
        if (((PG_INCROCIO.PDMASTERLAVO(p_tab_ris(i).cdnLavoratore)=1))) then
           if ((PG_INCROCIO.pdIndispAzienda(p_tab_ris(i).cdnLavoratore, p_prgRichiestaAz)=0)) then
             insert into DO_NOMINATIVO
             (prgNominativo, cdnLavoratore, numOrdine, codCpiTit, dtmIns, cdnUtIns, prgRosa)
             values
             (S_DO_NOMINATIVO.nextVal, p_tab_ris(i).cdnLavoratore, null,
             rCpiTit, sysdate, p_cdnUtente, p_prgRosa);
           end if;
        end if;
     else
        if ((PG_INCROCIO.pdIndispAzienda(p_tab_ris(i).cdnLavoratore, p_prgRichiestaAz)=0)) then
           insert into DO_NOMINATIVO
           (prgNominativo, cdnLavoratore, numOrdine, codCpiTit, dtmIns, cdnUtIns, prgRosa)
           values
           (S_DO_NOMINATIVO.nextVal, p_tab_ris(i).cdnLavoratore, null,
           rCpiTit, sysdate, p_cdnUtente, p_prgRosa);
        end if;
     end if;
    end loop;
  --else
    --OPEN p_cursor FOR sql_query;
  end if;
  -- aggiorno lo stato dell'incrocio
  update do_incrocio set CODSTATOINCROCIO='C',NUMKLOINCROCIO=NUMKLOINCROCIO+1, CDNUTMOD=p_cdnUtente,
            DTMMOD=sysdate
    where PRGINCROCIO =  p_prgIncrocio;
  commit;
  return 0;
  exception
      --when no_data_found then
     --     rCpiTit := null;
      when others then
         p_errCode := sqlcode;
       --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       return -1;

end ESEGUIINCROCIOCM_NOMANSIONE;

-- Funzione che esegue la query per l'incrocio pesato
function eseguiIncrocioPesato_CM(
   p_in_query_select varchar2,
   p_in_query_from varchar2,
   p_in_query_join varchar2,
   p_in_query_where long,
   p_in_where_territorio varchar2,
   p_prgRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%type, -- progressivo della richiesta
   p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%type, -- progressivo dell'alternativa
   p_in_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,  -- progressivo dell'incrocio
   p_in_prgRosa DO_ROSA.PRGROSA%TYPE,      -- progressivo della rosa
   p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
   p_mem char,
   p_numPFasciaEtaPrima number,         -- peso associato alla prima fascia di età estesa
   p_numPFasciaEtaSec number,         -- peso associato alla seconda fascia di età estesa
   p_numPStudioGruppo number,         -- peso associato a un titolo di studio nel gruppo
   p_numPStudioAlias number,          -- peso associato a un titolo di studio associato
   p_numPMansioneGruppo number,         -- peso associato a una mansione nel gruppo
   p_numPMansioneAlias number,         -- peso associato a una mansione associata
   p_numPNoEsperienza number,         -- peso associato alla mansione senza esperienza
   p_numPEsperienzaAlias number,         -- peso associato all'esperienza in una mansione simile
   p_numPInfoMin number,           -- peso associato alla conoscenza info con grado minore
   p_numPInfoGruppo number,          -- peso associato a una conoscenza info nello stesso gruppo
   p_numPInfoGruppoMIn number,         -- peso associato a una conoscenza info nello stesso gruppo e grado minore
   p_numPLinguaInf number,           -- peso associato a una conoscenza linguistica con grado minore
   p_numPSogliaRichiesta number,         -- valore di soglia entro il quale estrarre i candidati
   p_flagIncMir int,                 -- flag collocamento mirato
   p_checkCM  number,              -- interruttore per il collocamento mirato
   encrypterKey varchar2,
   p_codmonocmcategoria do_richiesta_az.codmonocmcategoria%type,
   p_ErrCode OUT number
   --p_cursor OUT t_cursor
   ) return number  IS
  P_PRGROSAAPPOGGIO number;
  sql_query_cur varchar2(2000) := 'select P_IN_PRGROSA, s_do_nominativo.nextVal, app.CDNLAVORATORE,  ' ||
               'app.NUMPESOETA, app.NUMPESOTITOLO, app.NUMPESOMANSIONE, app.NUMPESOESP, ' ||
          'app.NUMPESOINFO, app.NUMPESOLINGUA, app.DECINDICEVICINANZA ' ||
          'from do_nominativo_appoggio app ' ||
          'where app.PRGROSAAPPOGGIO=';
  -- Tipo del record per la tabella di appoggio debug 1a parte
  /*type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
                strCognomeNome AN_LAVORATORE.STRCOGNOME%TYPE,
       strNome AN_LAVORATORE.STRNOME%type);*/
  --type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type);
  type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
             cpiTit DE_CPI.CODCPI%type,
        numPesoEta DO_NOMINATIVO_APPOGGIO.NUMPESOETA%TYPE,
        numPesoLingua DO_NOMINATIVO_APPOGGIO.NUMPESOLINGUA%type,
        numPesoInfo DO_NOMINATIVO_APPOGGIO.NUMPESOINFO%type,
        numPesoTitolo DO_NOMINATIVO_APPOGGIO.NUMPESOTITOLO%type,
        numPesoMansione DO_NOMINATIVO_APPOGGIO.NUMPESOMANSIONE%type,
        numPesoEsp DO_NOMINATIVO_APPOGGIO.NUMPESOESP%type,
        decIndiceVicinanza DO_NOMINATIVO_APPOGGIO.DECINDICEVICINANZA%type);
  type tab_ris is table of p_rec_ris;
  p_tab_ris tab_ris;
  -- Tipo del record per la tabella di appoggio debug 2a parte
  type t_app_rec is record ( cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type,
                 strCognome AN_LAVORATORE.STRCOGNOME%type,
        strNome AN_LAVORATORE.STRNOME%type,
        cpiTit DE_CPI.CODCPI%type,
        numPesoEta DO_NOMINATIVO_APPOGGIO.NUMPESOETA%TYPE,
        numPesoLingua DO_NOMINATIVO_APPOGGIO.NUMPESOLINGUA%type,
        numPesoInfo DO_NOMINATIVO_APPOGGIO.NUMPESOINFO%type,
        numPesoTitolo DO_NOMINATIVO_APPOGGIO.NUMPESOTITOLO%type,
        numPesoMansione DO_NOMINATIVO_APPOGGIO.NUMPESOMANSIONE%type,
        numPesoEsp DO_NOMINATIVO_APPOGGIO.NUMPESOESP%type,
        decIndiceVicinanza DO_NOMINATIVO_APPOGGIO.DECINDICEVICINANZA%type);
  type t_tab_app is table of t_app_rec;
  tab_app t_tab_app;
  --------------------------------------------------------------------------------
  sql_query_insert varchar2(4000) := 'select do_nominativo_appoggio.CDNLAVORATORE, ' ||
                 'an_lavoratore.STRCOGNOME, an_lavoratore.STRNOME, ' ||
          'PG_INCROCIO.PDCPITIT(do_nominativo_appoggio.CDNLAVORATORE), ' ||
          'do_nominativo_appoggio.NUMPESOLINGUA, ' ||
          'do_nominativo_appoggio.NUMPESOINFO, ' ||
          'do_nominativo_appoggio.NUMPESOTITOLO, ' ||
          'do_nominativo_appoggio.NUMPESOMANSIONE, ' ||
          'do_nominativo_appoggio.NUMPESOESP, ' ||
          'do_nominativo_appoggio.DECINDICEVICINANZA ' ||
          'from DO_NOMINATIVO_APPOGGIO ' ||
          'inner join an_lavoratore on (do_nominativo_appoggio.cdnLavoratore=an_lavoratore.cdnLavoratore) ' ||
          'where do_nominativo_appoggio.PRGROSAAPPOGGIO = ';
  --////////////////////////////////////////////////////////////////////--
  sql_query long;
  rCpiTit DE_CPI.CODCPI%type;

  numConLinguistiche number;
  numConLinIta number;
  numConInformatiche number;
  numTitoli number;
  numMansioni number;
  numRelMansioni number;
  nroCpi number;
  --numCompetenze number;
  --numAbilitazioni number;
  parEsperienza DO_ALTERNATIVA.FLGESPERIENZA%type;
  strPesaMansione varchar2(8000);
  -- Cursori
  CURSOR curTitoli IS
     select DO_STUDIO.CODTITOLO, DO_STUDIO.FLGINDISPENSABILE, DO_STUDIO.FLGCONSEGUITO
   from DO_STUDIO
   where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
 CURSOR curMansioni IS
     select DO_MANSIONE.codMansione from DO_MANSIONE
   where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_MANSIONE.PRGALTERNATIVA = p_prgAlternativa;
 CURSOR curTurni IS
     select DO_TURNO.CODTURNO from DO_TURNO where DO_TURNO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curOrari IS
     select DO_ORARIO.CODORARIO from DO_ORARIO where DO_ORARIO.PRGRICHIESTAAZ = p_prgRichiestaAz;
  CURSOR curContratti IS
     select DO_CONTRATTO.CODCONTRATTO from DO_CONTRATTO
   where DO_CONTRATTO.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_CONTRATTO.PRGALTERNATIVA = p_prgAlternativa;
  -- Clausole IN
  inTurni varchar2(2000) := '';
  inOrari varchar2(2000) := '';
  inContratti varchar2(2000) := '';

  numComuni number;
  numProv number;
BEGIN

-- donato popolo la global_cm con i lavoratori iscritti al collocamento
if (p_codmonocmcategoria = 'D' OR p_codmonocmcategoria = 'A') then
  insert into global_cm
  select distinct decrypt(i.cdnlavoratore, encrypterkey), i.cdnlavoratore
  from am_cm_iscr i
  inner join de_cm_tipo_iscr dc on dc.codcmtipoiscr = i.codcmtipoiscr
  INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
  INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
  where
  DOC.CODSTATOATTO = 'PR' AND DOC.CDNLAVORATORE = decrypt(i.cdnlavoratore, encrypterkey)
  and DECODE(i.DATDATAFINE,NULL,'S','N') = 'S'
  and dc.codmonotiporagg = p_codmonocmcategoria;
else
  insert into global_cm
  select distinct decrypt(i.cdnlavoratore, encrypterkey), i.cdnlavoratore
  from am_cm_iscr i
  INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
  INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
  where
  DOC.CODSTATOATTO = 'PR' AND DOC.CDNLAVORATORE = decrypt(i.cdnlavoratore, encrypterkey)
  and DECODE(i.DATDATAFINE,NULL,'S','N') = 'S';
end if;


  ---------------------------------------------------------------------------------------
  select S_DO_NOMINATIVO_APPOGGIO_2.nextVal into P_PRGROSAAPPOGGIO from dual;
  sql_query_cur := sql_query_cur || P_PRGROSAAPPOGGIO || ' and app.DECINDICEVICINANZA>=' || p_numPSogliaRichiesta;

  sql_query :=   'insert into global_rosa ' ||
       P_IN_QUERY_SELECT ||
     P_IN_QUERY_FROM ||
     P_IN_QUERY_JOIN ||
     P_IN_QUERY_WHERE;
  execute immediate sql_query;
  --
  insert into DO_NOMINATIVO_APPOGGIO
  (prgRosaAppoggio, prgNominativo, prgRosa, cdnLavoratore, codCpiTit)
  select
    P_PRGROSAAPPOGGIO, S_DO_NOMINATIVO_APPOGGIO.nextVal, P_IN_PRGROSA,
  global_rosa.cdnLavoratore, PG_INCROCIO.PDCPITIT(global_rosa.cdnLavoratore)
  from global_rosa;
  -- NEW --
  commit;

  -- Popolo la stringa con l'insieme dei codici dei turni
 FOR rec in curTurni LOOP
  if(length(inTurni)>0) then
     inTurni := inTurni ||',';
  end if;
  inTurni := inTurni || '''' || rec.codTurno || '''';
 END LOOP;
 dbms_output.put_line('Turni IN (' || inTurni || ')');
 -- Popolo la stringa con l'insieme dei codici degli orari
 FOR rec in curOrari LOOP
  if(length(inOrari)>0) then
     inOrari := inOrari ||',';
  end if;
  inOrari:= inOrari || '''' || rec.codOrario || '''';
 END LOOP;
 dbms_output.put_line('Orari IN (' || inOrari || ')');
 -- Popolo la stringa con l'insieme dei codici dei contratti
 if(p_prgAlternativa is not null) then
  FOR rec in curContratti LOOP
   if(length(inContratti)>0) then
      inContratti := inContratti ||',';
   end if;
   inContratti:= inContratti || '''' || rec.codContratto || '''';
  END LOOP;
 end if;
 dbms_output.put_line('Contratti IN (' || inContratti || ')');
 -- Parametro sull'esperienza
 select DO_ALTERNATIVA.FLGESPERIENZA into parEsperienza
 from DO_ALTERNATIVA
 where DO_ALTERNATIVA.PRGRICHIESTAAZ=p_prgRichiestaAz and DO_ALTERNATIVA.PRGALTERNATIVA=p_prgAlternativa;
  /********************************************************************
  *      PESATURA DEI PARAMETRI SUI CANDIDATI SELEZIONATI          *
  *********************************************************************/
  -- NOTA: flgIndispensabile non piu' utilizzato
  -----------------------------------------------------------------------
  -- CONOSCENZE LINGUISTICHE (Indispensabili - condizioni in AND)
  select count(*) into numConLinguistiche
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ
  and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa; --and DO_LINGUA.FLGINDISPENSABILE='S';
  --
  select count(*) into numConLinIta
  from DO_LINGUA
  where DO_LINGUA.PRGRICHIESTAAZ = p_prgRichiestaAZ
  and DO_LINGUA.PRGALTERNATIVA = p_prgAlternativa
  and DO_LINGUA.CODLINGUA='003';
  -- 0. Se non vengono richieste Conoscenze Linguistiche p=100 per tutti
  if(numConLinguistiche=0) then
  update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=100 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOLINGUA is null;
  end if;
  -- 1. Matching esatto e livello maggiore o uguale a quello richiesto
  if(numConLinguistiche>0) then
     if(numConLinIta = 0) then
   -- Non è richiesta la conoscenza della lingua Italiana
  update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=100
  where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
  (select app.cdnLavoratore
   from DO_NOMINATIVO_APPOGGIO app
       inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
   where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
       (select count(*) from PR_LINGUA cv_lin
     inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua and
               nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and
           nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and
           nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1))
     where (cv_lin.cdnLavoratore = app.cdnLavoratore
       and o_lin.prgRichiestaAz=p_prgRichiestaAz
     and o_lin.prgAlternativa=p_prgAlternativa
     --and o_lin.flgIndispensabile='S'
     )
     ) >= numConLinguistiche
   );
     else
   -- E' richiesta la conoscenza della lingua Italiana
     if(numConLinguistiche=1) then
      -- E' richiesta la SOLA conoscenza della lingua Italiana
   update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=100
   where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
   (select app.cdnLavoratore
    from DO_NOMINATIVO_APPOGGIO app
         inner join an_lavoratore an on (app.cdnLavoratore=an.CDNLAVORATORE)
        --inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
    where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
       (
      (select count(*) from PR_LINGUA cv_lin
      inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua and
                nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and
            nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and
            nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1))
      where (cv_lin.cdnLavoratore = app.cdnLavoratore
        and o_lin.prgRichiestaAz=p_prgRichiestaAz
      and o_lin.prgAlternativa=p_prgAlternativa
      --and o_lin.flgIndispensabile='S'
      --and o_lin.codLingua='4'
      )
      ) >= numConLinguistiche
      OR
      (an.codCittadinanza='000' or an.codCittadinanza2='000')
     )
    );
  else
   update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=100
   where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
   (select app.cdnLavoratore
    from DO_NOMINATIVO_APPOGGIO app
         inner join an_lavoratore an on (app.cdnLavoratore=an.CDNLAVORATORE)
        inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
    where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
       (
      (select count(*) from PR_LINGUA cv_lin
      inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua and
                nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and
            nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and
            nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1))
      where (cv_lin.cdnLavoratore = app.cdnLavoratore
        and o_lin.prgRichiestaAz=p_prgRichiestaAz
      and o_lin.prgAlternativa=p_prgAlternativa
      --and o_lin.flgIndispensabile='S'
      )
      ) >= numConLinguistiche
      OR
      (select count(*) from PR_LINGUA cv_lin
      inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua and
                nvl(cv_lin.cdnGradoLetto,1) >= nvl(o_lin.cdnGradoLetto,1) and
            nvl(cv_lin.cdnGradoScritto,1) >= nvl(o_lin.cdnGradoScritto,1) and
            nvl(cv_lin.cdnGradoParlato,1) >= nvl(o_lin.cdnGradoParlato,1))
      where (cv_lin.cdnLavoratore = app.cdnLavoratore
        and o_lin.prgRichiestaAz=p_prgRichiestaAz
      and o_lin.prgAlternativa=p_prgAlternativa
      --and o_lin.flgIndispensabile='S'
      and o_lin.codLingua<>'003'
      and (an.codCittadinanza='000' or an.codCittadinanza2='000')
      )
      ) >= (numConLinguistiche - numConLinIta)
    )
    );
  end if;
  end if;
  end if;
  -- 2. Matching esatto e livello inferiore a quello richiesto
  if(numConLinguistiche>0 and p_numPLinguaInf>0) then
     if(numConLinIta=0) then
     -- Non è richiesta la conoscenza della lingua Italiana
  update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=p_numPLinguaInf
  where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
  (select app.cdnLavoratore
   from DO_NOMINATIVO_APPOGGIO app
       inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
   where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
       (select count(*) from PR_LINGUA cv_lin
     inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua)
     where (cv_lin.cdnLavoratore = app.cdnLavoratore
       and o_lin.prgRichiestaAz=p_prgRichiestaAz
     and o_lin.prgAlternativa=p_prgAlternativa
     --and o_lin.flgIndispensabile='S'
     )
     ) >= numConLinguistiche
   );
  else
     -- E' richiesta la conoscenza della lingua Italiana
  if(numConLinguistiche=1) then
     -- E' richiesta la SOLA conoscenza della lingua Italiana
     update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=p_numPLinguaInf
     where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
     (select app.cdnLavoratore
      from DO_NOMINATIVO_APPOGGIO app
       --inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
     inner join an_lavoratore an on (app.cdnLavoratore=an.cdnLavoratore)
    where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
        (
         (select count(*) from PR_LINGUA cv_lin
          inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua)
       where (cv_lin.cdnLavoratore = app.cdnLavoratore
           and o_lin.prgRichiestaAz=p_prgRichiestaAz
         and o_lin.prgAlternativa=p_prgAlternativa
         --and o_lin.flgIndispensabile='S'
        )
         ) >= numConLinguistiche
         OR
       (an.codCittadinanza='000' or an.codCittadinanza2='000')
      )
     );
  else
     update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=p_numPLinguaInf
     where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
        (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
              inner join PR_LINGUA  on (app.CDNLAVORATORE=PR_LINGUA.CDNLAVORATORE)
       where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOLINGUA is null and
          (
         (select count(*) from PR_LINGUA cv_lin
          inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua)
          where (cv_lin.cdnLavoratore = app.cdnLavoratore
            and o_lin.prgRichiestaAz=p_prgRichiestaAz
        and o_lin.prgAlternativa=p_prgAlternativa
        --and o_lin.flgIndispensabile='S'
        )
        ) >= numConLinguistiche
        OR
          (select count(*) from PR_LINGUA cv_lin
         inner join an_lavoratore an on (cv_lin.cdnLavoratore=an.CDNLAVORATORE)
         inner join DO_LINGUA o_lin on (cv_lin.codLingua = o_lin.codLingua)
         where (cv_lin.cdnLavoratore = app.cdnLavoratore
             and o_lin.prgRichiestaAz=p_prgRichiestaAz
          and o_lin.prgAlternativa=p_prgAlternativa
          --and o_lin.flgIndispensabile='S'
          and o_lin.codLingua<>'003'
          and (an.codCittadinanza='000' or an.codCittadinanza2='000')
          )
        ) >= (numConLinguistiche - numConLinIta)
            )
        );
  end if;
  end if;
  end if;
  --3. Tutti gli altri vanno messi a zero
  update DO_NOMINATIVO_APPOGGIO set NUMPESOLINGUA=0 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOLINGUA is null;
  commit;
  --
  -- CONOSCENZE INFORMATICHE (Indispensabili e dipendenti dall'alternativa - condizioni in AND)
  select count(*) into numConInformatiche
  from DO_INFO
  where DO_INFO.PRGRICHIESTAAZ = p_prgRichiestaAZ
    and DO_INFO.PRGALTERNATIVA = p_prgAlternativa; -- and DO_INFO.FLGINDISPENSABILE='S';
  -- 0. Se non vengono richieste Conoscenze Informatiche p=100 per tutti
  if(numConInformatiche=0) then
  update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=100 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOINFO is null;
  end if;
  -- 1. Matching esatto e livello maggiore o uguale a quello richiesto
  if(numConInformatiche>0) then
 update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=100
 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
 (select app.cdnLavoratore
  from DO_NOMINATIVO_APPOGGIO app
      inner join PR_INFO on (app.CDNLAVORATORE=PR_INFO.CDNLAVORATORE)
  where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOINFO is null and
      (select count(*) from PR_INFO cv_inf
      inner join DO_INFO o_inf on (cv_inf.codDettInfo = o_inf.codDettInfo and
               cv_inf.codTipoInfo = o_inf.codTipoInfo and
          nvl(cv_inf.cdnGrado,1) >= nvl(o_inf.cdnGrado,1))
     where (cv_inf.cdnLavoratore = app.cdnLavoratore
        and o_inf.prgRichiestaAz=p_prgRichiestaAz
     --and o_inf.flgIndispensabile='S'
     and o_inf.prgAlternativa=p_prgAlternativa)
   ) >= numConInformatiche
 );
  end if;
  --2. Matching esatto e livello minore a quello richiesto
  if(numConInformatiche>0 and p_numPInfoMin>0) then
 update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=p_numPInfoMin
 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
 (select app.cdnLavoratore
  from DO_NOMINATIVO_APPOGGIO app
      inner join PR_INFO on (app.CDNLAVORATORE=PR_INFO.CDNLAVORATORE)
  where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOINFO is null and
      (select count(*) from PR_INFO cv_inf
      inner join DO_INFO o_inf on (cv_inf.codDettInfo = o_inf.codDettInfo and
               cv_inf.codTipoInfo = o_inf.codTipoInfo
          --and nvl(cv_inf.cdnGrado,1) <= nvl(o_inf.cdnGrado,1)
          )
     where (cv_inf.cdnLavoratore = app.cdnLavoratore
        and o_inf.prgRichiestaAz=p_prgRichiestaAz
     --and o_inf.flgIndispensabile='S'
     and o_inf.prgAlternativa=p_prgAlternativa)
   ) >= numConInformatiche
 );
  end if;
  --3. Matching con conoscenze nello stesso gruppo e livello maggiore o uguale a quello richiesto
  if(numConInformatiche>0 and p_numPInfoGruppo>0) then
 update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=p_numPInfoGruppo
 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
 (select app.cdnLavoratore
  from DO_NOMINATIVO_APPOGGIO app
      inner join PR_INFO on (app.CDNLAVORATORE=PR_INFO.CDNLAVORATORE)
  where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOINFO is null and
      (select count(distinct(cv_inf.CODTIPOINFO)) from PR_INFO cv_inf
      inner join DO_INFO o_inf on (cv_inf.codTipoInfo = o_inf.codTipoInfo and
          nvl(cv_inf.cdnGrado,1) >= nvl(o_inf.cdnGrado,1))
     where (cv_inf.cdnLavoratore = app.cdnLavoratore
        and o_inf.prgRichiestaAz=p_prgRichiestaAz
     --and o_inf.flgIndispensabile='S'
     and o_inf.prgAlternativa=p_prgAlternativa)
   ) >= (select count(distinct(DO_INFO.CODTIPOINFO))
        from DO_INFO where prgRichiestaAz = p_prgRichiestaAz
      and prgAlternativa = p_prgAlternativa
      --and flgIndispensabile='S'
      )
 );
  end if;
  --4. Matching con conoscenze nello stesso gruppo e livello minore a quello richiesto
  if(numConInformatiche>0 and p_numPInfoGruppoMin>0) then
 update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=p_numPInfoGruppoMin
 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and cdnLavoratore in
 (select app.cdnLavoratore
  from DO_NOMINATIVO_APPOGGIO app
      inner join PR_INFO on (app.CDNLAVORATORE=PR_INFO.CDNLAVORATORE)
  where app.prgRosaAppoggio=P_PRGROSAAPPOGGIO and app.NUMPESOINFO is null and
      (select count(distinct(cv_inf.CODTIPOINFO)) from PR_INFO cv_inf
      inner join DO_INFO o_inf on (cv_inf.codTipoInfo = o_inf.codTipoInfo
          --and nvl(cv_inf.cdnGrado,1) <= nvl(o_inf.cdnGrado,1)
          )
     where (cv_inf.cdnLavoratore = app.cdnLavoratore
        and o_inf.prgRichiestaAz=p_prgRichiestaAz
     --and o_inf.flgIndispensabile='S'
     and o_inf.prgAlternativa=p_prgAlternativa)
   ) >= (select count(distinct(DO_INFO.CODTIPOINFO))
        from DO_INFO where prgRichiestaAz = p_prgRichiestaAz
      and prgAlternativa = p_prgAlternativa
      --and flgIndispensabile='S'
      )
 );
  end if;
  --5. Tutti gli altri vanno messi a zero
  update DO_NOMINATIVO_APPOGGIO set NUMPESOINFO=0 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOINFO is null;
  commit;

  -- Titoli di Studio (Indispensabili e dipendenti dall'alternativa - condizioni in OR)
  -- /* Va gestito il raggruppamento xy0000, xyab00, xyabcd */
  select count(*) into numTitoli
  from DO_STUDIO
  where DO_STUDIO.PRGRICHIESTAAZ = p_prgRichiestaAZ
     and DO_STUDIO.PRGALTERNATIVA = p_prgAlternativa;
  -- 0. Se non vengono richiesti Titoli p=100 per tutti
  if(numTitoli=0) then
  update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOTITOLO is null;
  end if;
  -- 1. Per ogni titolo presente nella richiesta attribuisco al candidato il valore massimo
  -- fra quelli che gli verrebbero attribuiti dai diversi titoli di studio che ha indicato nel CV.
  if(numTitoli>0) then
 FOR rec IN curTitoli LOOP
  if(substr(rec.codTitolo,-7)='0000000') then
     -- Il titolo è di tipo X0000000 => p=100 per tutti i titoli che iniziano per XY
     if(rec.flgConseguito='S' or rec.flgConseguito is null) then
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,1)=substr(rec.codTitolo,1,1)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO='C'
       );
     else
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,1)=substr(rec.codTitolo,1,1)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO in ('C','I','A')
       );
     end if;
  end if;
  if(substr(rec.codTitolo,-6)='000000') then
     -- Il titolo è di tipo XY000000 => p=100 per tutti i titoli che iniziano per XY
     if(rec.flgConseguito='S' or rec.flgConseguito is null) then
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,2)=substr(rec.codTitolo,1,2)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO='C'
       );
     else
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,2)=substr(rec.codTitolo,1,2)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO in ('C','I','A')
       );
     end if;
  end if;
  if(substr(rec.codTitolo,-5)='00000') then
     -- Il titolo è di tipo XYA00000 => p=100 per tutti i titoli che iniziano per XY
     if(rec.flgConseguito='S' or rec.flgConseguito is null) then
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,3)=substr(rec.codTitolo,1,3)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO='C'
       );
     else
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,3)=substr(rec.codTitolo,1,3)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO in ('C','I','A')
       );
     end if;
  end if;
  if(substr(rec.codTitolo,-3)='000') then
     -- Il titolo è di tipo XYABC000 => p=100 per tutti i titoli che iniziano per XY
     if(rec.flgConseguito='S' or rec.flgConseguito is null) then
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,5)=substr(rec.codTitolo,1,5)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO='C'
       );
     else
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and substr(pr_studio.CODTITOLO,1,5)=substr(rec.codTitolo,1,5)
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO in ('C','I','A')
       );
     end if;
  end if;
  if(substr(rec.codTitolo,-3)<>'000' and substr(rec.codTitolo,-5)<>'00000' and substr(rec.codTitolo,-6)<>'000000' and substr(rec.codTitolo,-7)<>'0000000') then
     -- Il titolo è di tipo XYABCDEF => Eseguo la pesatura vera e propria
     -- a. p=100 per tutti i titoli con corrispondenza esatta
     if(rec.flgConseguito='S' or rec.flgConseguito is null) then
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and pr_studio.CODTITOLO=rec.codTitolo
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO='C'
       );
   else
      update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=100
      where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
         (select app.cdnLavoratore
       from DO_NOMINATIVO_APPOGGIO app
            inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
       where
           (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<100)
         and pr_studio.CODTITOLO=rec.codTitolo
         and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
         and pr_studio.CODMONOSTATO in ('C','I','A')
       );
   end if;
   -- b. p=p_numPStudioGruppo
   if(p_numPStudioGruppo>0) then
    if(rec.flgConseguito='S' or rec.flgConseguito is null) then
       update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=p_numPStudioGruppo
       where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
          (select app.cdnLavoratore
        from DO_NOMINATIVO_APPOGGIO app
             inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
        where
            (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<p_numPStudioGruppo)
          and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
          and pr_studio.CODMONOSTATO='C'
          and pr_studio.CODTITOLO in (select codTitoloSimile from DE_REL_TITOLO
                          where de_rel_titolo.CODTITOLO=rec.codTitolo
                       and de_rel_titolo.FLGTIPO=1
                )
        );
    else
       update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=p_numPStudioGruppo
       where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
          (select app.cdnLavoratore
        from DO_NOMINATIVO_APPOGGIO app
             inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
        where
            (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<p_numPStudioGruppo)
          and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
          and pr_studio.CODMONOSTATO in ('C','I','A')
          and pr_studio.CODTITOLO in (select codTitoloSimile from DE_REL_TITOLO
                          where de_rel_titolo.CODTITOLO=rec.codTitolo
                       and de_rel_titolo.FLGTIPO=1
                )
        );
    end if;
   end if;
   -- c. p=p_numPStudioAlias
   if(p_numPStudioAlias>0) then
    if(rec.flgConseguito='S' or rec.flgConseguito is null) then
       update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=p_numPStudioAlias
       where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
          (select app.cdnLavoratore
        from DO_NOMINATIVO_APPOGGIO app
             inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
        where
            (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<p_numPStudioAlias)
          and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
          and pr_studio.CODMONOSTATO='C'
          and pr_studio.CODTITOLO in (select codTitoloSimile from DE_REL_TITOLO
                          where de_rel_titolo.CODTITOLO=rec.codTitolo
                       and de_rel_titolo.FLGTIPO=2
                )
        );
    else
       update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=p_numPStudioAlias
       where prgRosaAppoggio=P_PRGROSAAPPOGGIO and cdnLavoratore in
          (select app.cdnLavoratore
        from DO_NOMINATIVO_APPOGGIO app
             inner join pr_studio on (app.CDNLAVORATORE=pr_studio.CDNLAVORATORE)
        where
            (app.NUMPESOTITOLO is null or app.NUMPESOTITOLO<p_numPStudioAlias)
          and app.prgRosaAppoggio=P_PRGROSAAPPOGGIO
          and pr_studio.CODMONOSTATO in ('C','I','A')
          and pr_studio.CODTITOLO in (select codTitoloSimile from DE_REL_TITOLO
                          where de_rel_titolo.CODTITOLO=rec.codTitolo
                       and de_rel_titolo.FLGTIPO=2
                )
        );
    end if;
   end if;
  end if;
 END LOOP;
  end if;
  --2. Tutti gli altri vanno messi a zero
  update DO_NOMINATIVO_APPOGGIO set NUMPESOTITOLO=0 where prgRosaAppoggio = P_PRGROSAAPPOGGIO and NUMPESOTITOLO is null;
  commit;

  --*******************************************
  -- MANSIONE ED ESPERIENZA SULLA MANSIONE
  --*******************************************
  select count(DO_MANSIONE.codMansione) into numMansioni
  from DO_MANSIONE where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;
  -- 0. se non sono richieste mansioni p=100 per tutti
  -- caso teorico, non si dovrebbe mai arrivare a questo punto se non ci sono mansioni nella richiesta
  if(numMansioni=0) then
    update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=100
 where prgRosaAppoggio=P_PRGROSAAPPOGGIO and NUMPESOMANSIONE is null and NUMPESOESP is null;
  end if;
  dbms_output.put_line(numMansioni || ' Mansioni Richieste');
  -- 1. Per ogni mansione presente nella richiesta attribuisco al candidato il valore masimo
  -- fra quelli che gli verrebbero attribuiti dalle diverse mansioni indicate nel cv.
  if(numMansioni>0) then
     FOR rec in curMansioni LOOP
   /*  Con l'adeguamento mansioni  CP11 il caso xy0000 non esiste più
   if(substr(rec.codMansione,-4)='0000') then
     -- La mansione è di tipo XY0000 => p=100 per tutte le mansioni che iniziano per XY
        -- a. soggetti con corrispondenza esatta per l'esperienza -- se richiesta
        strPesaMansione :=
     'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=100 ' ||
     'where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
       '(select app.cdnLavoratore ' ||
      'from DO_NOMINATIVO_APPOGGIO app ' ||
         'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
        'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
        'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
        'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
      'where ' ||
         '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
        'and substr(pr_mansione.CODMANSIONE,1,2)=substr(''' || rec.codMansione || ''',1,2) ' ||
        'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;
     if(parEsperienza='S' or parEsperienza='P') then
        strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGESPERIENZA=''S'' OR pr_mansione.FLGESPERIENZA=''E'') ';
     end if;

     strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE=''S'' OR pr_mansione.FLGDISPONIBILE=''L'') ';

     if(length(inTurni)>0) then
        strPesaMansione := strPesaMansione ||
          ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
         ' (not exists(select * from PR_DIS_TURNO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
         'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
         rec.codMansione || ''',1,2) ' ||
         ')))';
     end if;
     if(length(inOrari)>0) then
        strPesaMansione := strPesaMansione ||
          ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
         ' (not exists(select * from PR_DIS_ORARIO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
         'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
         rec.codMansione || ''',1,2) ' ||
         ')))';
     end if;
     if(length(inContratti)>0) then
        strPesaMansione := strPesaMansione ||
          ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
         ' (not exists(select * from PR_DIS_CONTRATTO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
         'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
         'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
         'pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
         rec.codMansione || ''',1,2) ' ||
         ')))';
     end if;
     strPesaMansione := strPesaMansione || ') ';
     execute immediate strPesaMansione;
     -- b. soggetti senza esperienza -- se richiesta
     if((parEsperienza='S' or parEsperienza='P') and p_numPNoEsperienza>0) then
        strPesaMansione :=
      'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=' || p_numPNoEsperienza ||
      ' where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
        '(select app.cdnLavoratore ' ||
       'from DO_NOMINATIVO_APPOGGIO app ' ||
          'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
         'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
         'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
         'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
       'where ' ||
          '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
         'and (app.NUMPESOESP is null or app.NUMPESOESP <' || p_numPNoEsperienza || ') ' ||
         'and substr(pr_mansione.CODMANSIONE,1,2)=substr(''' || rec.codMansione || ''',1,2) ' ||
         'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;

      strPesaMansione := strPesaMansione || 'and (pr_mansione.FLGDISPONIBILE=''S'' OR pr_mansione.FLGDISPONIBILE=''L'') ';

      if(length(inTurni)>0) then
         strPesaMansione := strPesaMansione ||
           ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
          ' (not exists(select * from PR_DIS_TURNO ' ||
          'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
          'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
          rec.codMansione || ''',1,2) ' ||
          ')))';
      end if;
      if(length(inOrari)>0) then
         strPesaMansione := strPesaMansione ||
           ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
          ' (not exists(select * from PR_DIS_ORARIO ' ||
          'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
          'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
          rec.codMansione || ''',1,2) ' ||
          ')))';
      end if;
      if(length(inContratti)>0) then
         strPesaMansione := strPesaMansione ||
           ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
          ' (not exists(select * from PR_DIS_CONTRATTO ' ||
          'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
          'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
          'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
          'pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,2)=substr(''' ||
          rec.codMansione || ''',1,2) ' ||
          ')))';
      end if;
      strPesaMansione := strPesaMansione || ') ';
      execute immediate strPesaMansione;
     end if;
  end if; -- if(substr(rec.codMansione,-4)='0000')
  */
  if(substr(rec.codMansione,-2)='00' ) then
     -- La mansione è di tipo XYABC00 => p=100 per tutte le mansioni che iniziano per XYABC
        -- a. soggetti con corrispondenza esatta per l'esperienza -- se richiesta
        strPesaMansione :=
     'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=100 ' ||
     'where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
       '(select app.cdnLavoratore ' ||
      'from DO_NOMINATIVO_APPOGGIO app ' ||
         'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
        'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
        'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
        'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
      'where ' ||
         '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
        'and substr(pr_mansione.CODMANSIONE,1,5)=substr(''' || rec.codMansione || ''',1,5) ' ||
        'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;
     if(parEsperienza='S' or parEsperienza='P') then
        strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGESPERIENZA=''S'' OR pr_mansione.FLGESPERIENZA=''E'') ';
     end if;

     strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE IN (''S'', ''L'') ) ';

     if(length(inTurni)>0) then
        strPesaMansione := strPesaMansione ||
          ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
         ' (not exists(select * from PR_DIS_TURNO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
         'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
         rec.codMansione || ''',1,5) ' ||
         ')))';
     end if;
     if(length(inOrari)>0) then
        strPesaMansione := strPesaMansione ||
          ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
         ' (not exists(select * from PR_DIS_ORARIO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
         'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
         rec.codMansione || ''',1,5) ' ||
         ')))';
     end if;
     if(length(inContratti)>0) then
        strPesaMansione := strPesaMansione ||
          ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
         ' (not exists(select * from PR_DIS_CONTRATTO ' ||
         'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
         'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
         ' pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
         rec.codMansione || ''',1,5) ' ||
         ')))';
     end if;
     strPesaMansione := strPesaMansione || ') ';
     execute immediate strPesaMansione;
     -- b. soggetti senza esperienza -- se richiesta
     if((parEsperienza='S' or parEsperienza='P') and p_numPNoEsperienza>0) then
        strPesaMansione :=
      'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=' || p_numPNoEsperienza ||
      ' where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
        '(select app.cdnLavoratore ' ||
       'from DO_NOMINATIVO_APPOGGIO app ' ||
          'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
         'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
         'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
         'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
       'where ' ||
          '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
         'and (app.NUMPESOESP is null or app.NUMPESOESP <' || p_numPNoEsperienza || ') ' ||
         'and substr(pr_mansione.CODMANSIONE,1,5)=substr(''' || rec.codMansione || ''',1,5) ' ||

         'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;

      strPesaMansione := strPesaMansione || 'and (pr_mansione.FLGDISPONIBILE IN (''S'', ''L'') ) ';

      if(length(inTurni)>0) then
         strPesaMansione := strPesaMansione ||
           ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
          ' (not exists(select * from PR_DIS_TURNO ' ||
          'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
          'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
          rec.codMansione || ''',1,5) ' ||
          ')))';
      end if;
      if(length(inOrari)>0) then
         strPesaMansione := strPesaMansione ||
           ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
          ' (not exists(select * from PR_DIS_ORARIO ' ||
          'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
          'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
          rec.codMansione || ''',1,5) ' ||
          ')))';
      end if;
      if(length(inContratti)>0) then
         strPesaMansione := strPesaMansione ||
           ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
          ' (not exists(select * from PR_DIS_CONTRATTO ' ||
          'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
          'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
          'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
          'pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=substr(''' ||
          rec.codMansione || ''',1,5) ' ||
          ')))';
      end if;
      strPesaMansione := strPesaMansione || ') ';
      execute immediate strPesaMansione;
     end if;
  end if; --if(substr(rec.codMansione,-2)='00' and substr(rec.codMansione,-4)<>'0000')
  if(substr(rec.codMansione,-2)<>'00') then
     -- La mansione è di tipo XYABCDE => eseguo la pesatura vera e propria
     -- a. soggetti con corrispondenza esatta per l'esperienza -- se richiesta
        strPesaMansione :=
     'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=100 ' ||
     'where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
       '(select app.cdnLavoratore ' ||
      'from DO_NOMINATIVO_APPOGGIO app ' ||
         'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
        'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
        'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
        'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
      'where ' ||
         '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
        'and pr_mansione.CODMANSIONE=''' || rec.codMansione || ''' ' ||
        'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;
     if(parEsperienza='S' or parEsperienza='P') then
        strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGESPERIENZA=''S'' OR pr_mansione.FLGESPERIENZA=''E'') ';
     end if;

     strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE IN (''S'', ''L'') ) ';

     if(length(inTurni)>0) then
        strPesaMansione := strPesaMansione ||
          ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
         ' (not exists(select * from PR_DIS_TURNO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
         'where pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
         rec.codMansione || '''))) ';
     end if;
     if(length(inOrari)>0) then
        strPesaMansione := strPesaMansione ||
          ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
         ' (not exists(select * from PR_DIS_ORARIO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
         'where pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
         rec.codMansione || ''')))';
     end if;
     if(length(inContratti)>0) then
        strPesaMansione := strPesaMansione ||
          ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
         ' (not exists(select * from PR_DIS_CONTRATTO ' ||
         'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
         'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
         'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
         'pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
         rec.codMansione || ''')))';
     end if;
     strPesaMansione := strPesaMansione || ') ';
     execute immediate strPesaMansione;
     -- b. soggetti senza esperienza -- se richiesta
     if((parEsperienza='S' or parEsperienza='P') and p_numPNoEsperienza>0) then
        strPesaMansione :=
      'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=100, NUMPESOESP=' || p_numPNoEsperienza ||
      ' where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
        '(select app.cdnLavoratore ' ||
       'from DO_NOMINATIVO_APPOGGIO app ' ||
          'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
         'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
         'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
         'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
       'where ' ||
          '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<100) ' ||
         'and (app.NUMPESOESP is null or app.NUMPESOESP <' || p_numPNoEsperienza || ') ' ||
         'and pr_mansione.CODMANSIONE=''' || rec.codMansione || ''' ' ||
         'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;

      strPesaMansione := strPesaMansione || 'and (pr_mansione.FLGDISPONIBILE IN (''S'', ''L'') ) ';

      if(length(inTurni)>0) then
         strPesaMansione := strPesaMansione ||
           ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
          ' (not exists(select * from PR_DIS_TURNO ' ||
          'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
          'where pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
          rec.codMansione || ''')))';
      end if;
      if(length(inOrari)>0) then
         strPesaMansione := strPesaMansione ||
           ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
          ' (not exists(select * from PR_DIS_ORARIO ' ||
          'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
          'where pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
          rec.codMansione || ''')))';
      end if;
      if(length(inContratti)>0) then
         strPesaMansione := strPesaMansione ||
           ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
          ' (not exists(select * from PR_DIS_CONTRATTO ' ||
          'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
          'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
          'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
          'pm.cdnLavoratore=app.cdnLavoratore and pm.codMansione=''' ||
          rec.codMansione || ''')))';
      end if;
      strPesaMansione := strPesaMansione || ') ';
      execute immediate strPesaMansione;
     end if;
     -- c. mansione nel gruppo ed esperienza pesata
     if(p_numPMansioneGruppo>0 and p_numPEsperienzaAlias>0) then
      strPesaMansione :=
       'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=' ||
       p_numPMansioneGruppo ||' , NUMPESOESP=' || p_numPEsperienzaAlias ||
       ' where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
         '(select app.cdnLavoratore ' ||
        'from DO_NOMINATIVO_APPOGGIO app ' ||
           'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
          'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
          'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
          'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
        'where ' ||
           '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<' || p_numPMansioneGruppo ||') ' ||
          'and (app.NUMPESOESP is null or app.NUMPESOESP <' || p_numPEsperienzaAlias || ') ' ||
          'and substr(pr_mansione.CODMANSIONE,1,5)=''' || substr(rec.codMansione,1,5) || ''' ' ||
          'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;
      if(parEsperienza='S' or parEsperienza='P') then
            strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGESPERIENZA=''S'' OR pr_mansione.FLGESPERIENZA=''E'') ';
      end if;

      strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE IN (''S'', ''L'') ) ';

      if(length(inTurni)>0) then
          strPesaMansione := strPesaMansione ||
            ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) or ' ||
           ' (not exists(select * from PR_DIS_TURNO ' ||
           'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
           'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=''' ||
           substr(rec.codMansione,1,5) || ''')))';
      end if;
      if(length(inOrari)>0) then
          strPesaMansione := strPesaMansione ||
            ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) or ' ||
           ' (not exists(select * from PR_DIS_ORARIO ' ||
           'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
           'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=''' ||
           substr(rec.codMansione,1,5) || ''')))';
       end if;
       if(length(inContratti)>0) then
          strPesaMansione := strPesaMansione ||
            ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) or ' ||
           ' (not exists(select * from PR_DIS_CONTRATTO ' ||
           'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
           'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
           'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
           'pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)=''' ||
           substr(rec.codMansione,1,5) || ''')))';
       end if;
       strPesaMansione := strPesaMansione || ') ';
       execute immediate strPesaMansione;
      end if;
      -- d. mansione simile ed esperienza pesata
      if(p_numPMansioneAlias>0 and p_numPEsperienzaAlias>0) then
       strPesaMansione :=
       'update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=' ||
       p_numPMansioneAlias ||' , NUMPESOESP=' || p_numPEsperienzaAlias ||
       ' where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO || ' and cdnLavoratore in ' ||
         '(select app.cdnLavoratore ' ||
        'from DO_NOMINATIVO_APPOGGIO app ' ||
           'inner join PR_MANSIONE on (app.CDNLAVORATORE=PR_MANSIONE.CDNLAVORATORE) ' ||
          'left outer join pr_dis_turno on (pr_mansione.PRGMANSIONE=pr_dis_turno.PRGMANSIONE) ' ||
          'left outer join pr_dis_orario on (pr_mansione.PRGMANSIONE=pr_dis_orario.PRGMANSIONE) ' ||
          'left outer join pr_dis_contratto on (pr_mansione.PRGMANSIONE=pr_dis_contratto.PRGMANSIONE) ' ||
        'where ' ||
           '(app.NUMPESOMANSIONE is null or app.NUMPESOMANSIONE<' || p_numPMansioneAlias ||') ' ||
          'and (app.NUMPESOESP is null or app.NUMPESOESP <' || p_numPEsperienzaAlias || ') ' ||
          'and app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO;
      if(parEsperienza='S' or parEsperienza='P') then
            strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGESPERIENZA=''S'' OR pr_mansione.FLGESPERIENZA=''E'') ';
      end if;

      strPesaMansione := strPesaMansione || ' and (pr_mansione.FLGDISPONIBILE IN (''S'', ''L'') ) ';

      select count(*) into numRelMansioni
      from DE_REL_MANSIONE
      where de_rel_mansione.codMansione=rec.codMansione and flgTipo=2;
      if(numRelMansioni>0) then
      strPesaMansione := strPesaMansione ||
           'and SUBSTR(pr_mansione.codMansione,1,5) in '  ||
           '(select SUBSTR(codGruppo,1,5) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
           rec.codMansione || ''' and flgTipo=2)';
      end if;
      if(length(inTurni)>0) then
          strPesaMansione := strPesaMansione ||
            ' and ((PR_DIS_TURNO.CODTURNO in (' || inTurni || ')) ';
       if(numRelMansioni>0) then
         strPesaMansione := strPesaMansione || ' or ' ||
           ' (not exists(select * from PR_DIS_TURNO ' ||
           'inner join PR_MANSIONE pm on (PR_DIS_TURNO.PRGMANSIONE=pm.prgMansione) ' ||
           'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5)  in ' ||
              '(select SUBSTR(codGruppo,1,5) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
              rec.codMansione || ''' and flgTipo=2)' || '))';
        end if;
        strPesaMansione := strPesaMansione || ')';
      end if;
      if(length(inOrari)>0) then
          strPesaMansione := strPesaMansione ||
            ' and ((PR_DIS_ORARIO.CODORARIO in (' || inOrari || ')) ';
       if(numRelMansioni>0) then
         strPesaMansione := strPesaMansione || ' or ' ||
           ' (not exists(select * from PR_DIS_ORARIO ' ||
           'inner join PR_MANSIONE pm on (PR_DIS_ORARIO.PRGMANSIONE=pm.prgMansione) ' ||
           'where pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,4) in ' ||
              '(select SUBSTR(codGruppo,1,4) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
              rec.codMansione || ''' and flgTipo=2)' || '))';
        end if;
        strPesaMansione := strPesaMansione || ')';
      end if;
      if(length(inContratti)>0) then
          strPesaMansione := strPesaMansione ||
            ' and ((PR_DIS_CONTRATTO.CODCONTRATTO in (' || inContratti || ')) ';
       if(numRelMansioni>0) then
         strPesaMansione := strPesaMansione || ' or ' ||
           ' (not exists(select * from PR_DIS_CONTRATTO ' ||
           'inner join PR_MANSIONE pm on (PR_DIS_CONTRATTO.PRGMANSIONE=pm.prgMansione) ' ||
           'inner join DE_CONTRATTO on (PR_DIS_CONTRATTO.CODCONTRATTO=DE_CONTRATTO.CODCONTRATTO) ' ||
           'where (de_contratto.FLGDISPONIBILITA=''S'' or de_contratto.FLGDISPONIBILITA is null) and ' ||
           'pm.cdnLavoratore=app.cdnLavoratore and substr(pm.codMansione,1,5) in ' ||
           '(select SUBSTR(codGruppo,1,5) from DE_REL_MANSIONE where de_rel_mansione.codMansione=''' ||
              rec.codMansione || ''' and flgTipo=2)' || '))';
        end if;
        strPesaMansione := strPesaMansione || ')';
      end if;
      strPesaMansione := strPesaMansione || ') ';
      execute immediate strPesaMansione;
   end if;
  end if;--if(substr(rec.codMansione,-2)<>'00' and substr(rec.codMansione,-4)<>'0000')
  END LOOP;
  end if;
  -- 2. Tutti gli altri vanno messi a zero
  update DO_NOMINATIVO_APPOGGIO set NUMPESOMANSIONE=0, NUMPESOESP=0
  where prgRosaAppoggio=P_PRGROSAAPPOGGIO and NUMPESOMANSIONE is null and NUMPESOESP is null;
  commit;

  -- Il peso sull'età è al momento sospeso
  /*update DO_NOMINATIVO_APPOGGIO
  set decIndiceVicinanza = ((numPesoEta + numPesoTitolo + numPesoMansione + numPesoEsp+ numPesoInfo + numPesoLingua) / 6.0)
  where prgRosaAppoggio=P_PRGROSAAPPOGGIO;*/

  -- Calcolo l'indice di vicinanza
  update DO_NOMINATIVO_APPOGGIO
  set decIndiceVicinanza = ((numPesoTitolo + numPesoMansione + numPesoEsp+ numPesoInfo + numPesoLingua) / 5.0)
  where prgRosaAppoggio=P_PRGROSAAPPOGGIO;
  commit;


  -- 11/01/2006 - Stefy
  -- Il calcolo relativo alla disponibilità territoriale avviene in base ad una nuova funzione
  -- che non fa più uso della vista VW_PR_DIS_TERRITORIO
  /*
  sql_query := 'update DO_NOMINATIVO_APPOGGIO set NUMT=1 ' ||
      'where prgRosaAppoggio=' || P_PRGROSAAPPOGGIO ||
      'and cdnLavoratore in ' ||
        '(select app.cdnLavoratore from DO_NOMINATIVO_APPOGGIO app ' ||
        'inner join PR_MANSIONE prm on (app.CDNLAVORATORE=prm.CDNLAVORATORE) ' ||
        'where app.prgRosaAppoggio=' || P_PRGROSAAPPOGGIO ||
        ' and app.NUMT is null and ' ||
     p_in_where_territorio ||
     ')';
  execute immediate sql_query;
  */
  select count(*) into numComuni from DO_COMUNE where DO_COMUNE.PRGRICHIESTAAZ = p_prgRichiestaAz;
  select count(*) into numProv from DO_PROVINCIA where DO_PROVINCIA.PRGRICHIESTAAZ = p_prgRichiestaAz;

  update DO_NOMINATIVO_APPOGGIO set NUMT=PG_INCROCIO.PDCALCOLONUMT(DO_NOMINATIVO_APPOGGIO.CDNLAVORATORE,p_prgRichiestaAz,p_in_where_territorio,numComuni,numProv)
  where prgRosaAppoggio = P_PRGROSAAPPOGGIO and numt is null;

  if(p_mem=1) then
   -- Memorizzo in locale
 sql_query := 'select distinct app.CDNLAVORATORE,  app.CODCPITIT, ' ||
        'app.NUMPESOETA, app.NUMPESOLINGUA, app.NUMPESOINFO, ' ||
        'app.NUMPESOTITOLO, app.NUMPESOMANSIONE, app.NUMPESOESP, ' ||
        'app.DECINDICEVICINANZA ' ||
     'from do_nominativo_appoggio app, pr_mansione prm ' ||
     'where (app.PRGROSAAPPOGGIO=' || P_PRGROSAAPPOGGIO || ') ' ||
       ' and (app.CDNLAVORATORE=prm.CDNLAVORATORE) ' ||
       'and (app.DECINDICEVICINANZA>=' || p_numPSogliaRichiesta || ') ' ||
       'and app.NUMT=1';
 execute immediate sql_query bulk collect into p_tab_ris;
 --dbms_output.put_line('Candidati selezionati ' ||p_tab_ris.COUNT);
 -- Memorizzo la rosa temporanea
 FOR i in 1..p_tab_ris.COUNT
 loop
  insert into DO_NOMINATIVO
   (prgRosa, prgNominativo, cdnLavoratore, codCpiTit,
   numPesoEta, numPesoTitolo, numPesoMansione, numPesoEsp,
   numPesoInfo, numPesoLingua, decIndiceVicinanza,
   dtmIns, cdnUtIns)
  values
     (P_IN_PRGROSA, s_do_nominativo.nextVal, p_tab_ris(i).cdnLavoratore, p_tab_ris(i).cpiTit,
     p_tab_ris(i).numPesoEta, p_tab_ris(i).numPesoTitolo, p_tab_ris(i).numPesoMansione, p_tab_ris(i).numPesoEsp,
     p_tab_ris(i).numPesoInfo, p_tab_ris(i).numPesoLingua, p_tab_ris(i).decIndiceVicinanza,
     sysdate, p_cdnUtente);
 end loop;
  --else
    -- in caso di cooperazione applicativa restituisco il recordset
 --OPEN p_cursor FOR sql_query_cur;
  end if;
  -- aggiorno lo stato dell'incrocio
  update do_incrocio set CODSTATOINCROCIO='C',NUMKLOINCROCIO=NUMKLOINCROCIO+1, CDNUTMOD=p_cdnUtente, DTMMOD=sysdate
  where PRGINCROCIO = p_in_prgIncrocio;
  commit;
  --pulisco la tabella di appoggio
  begin
      delete DO_NOMINATIVO_APPOGGIO where PRGROSAAPPOGGIO = P_PRGROSAAPPOGGIO;
    commit;
      exception when others then null;
  end;
  return 0;
  exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line(substr(sqlcode || ' ' || sqlerrm,1,255));
       rollback;
       return -1;
end eseguiIncrocioPesato_CM;

function updateRosaParamCM(p_CODMONOTIPOAZIENDA varchar2,
                            MR5 number,
                      IN2 number,
                            PO1 number,
                            PO2 number,
                      PO6 number,
                            PO7 number,
                            LO2 number,
                            LO3 number,
                      MV1 number,
                            MV2 number,
                            MV3 number,
                      MV4 number,
                            AC1 number,
                            FA2 number,
                      FA3 number,
                            SL1 number,
                            SL2 number,
                            p_flgescfisica varchar2,
                            p_flgescpsichica varchar2,
                            p_flgescsensoriale varchar2,
                            p_flgescintellettiva varchar2,
                            p_flgescnondeterminato varchar2,
                            p_prgrosa do_rosa.prgrosa%TYPE,
                            encrypterKey varchar2,
                            p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                            p_configDiagnFunz varchar2,
                            p_ErrCode OUT number,
                            p_query OUT varchar2
                           )
                         RETURN NUMBER IS

checkcontrollo number;
checkcontrolloDiagnosi number;
query varchar2(6000);
queryWhereCapacita varchar2(6000);
queryWhereEsclusioni varchar2(6000);
queryWhere varchar2(6000);
queryUpdate varchar2(6000);

begin

      queryWhere := '';
      queryWhereCapacita := '';

      update do_parametri_incrocio
      set
      CODMONOTIPOAZIENDA = p_CODMONOTIPOAZIENDA,
      CODMONOCAP_MR5 = MR5,
      CODMONOCAP_IN2 = IN2,
      CODMONOCAP_PO1 = PO1,
      CODMONOCAP_PO2 = PO2,
      CODMONOCAP_PO6 = PO6,
      CODMONOCAP_PO7 = PO7,
      CODMONOCAP_LO2 = LO2,
      CODMONOCAP_LO3 = LO3,
      CODMONOCAP_MV1 = MV1,
      CODMONOCAP_MV2 = MV2,
      CODMONOCAP_MV3 = MV3,
      CODMONOCAP_MV4 = MV4,
      CODMONOCAP_AC1 = AC1,
      CODMONOCAP_FA2 = FA2,
      CODMONOCAP_FA3 = FA3,
      CODMONOCAP_SL1 = SL1,
      CODMONOCAP_SL2 = SL2,
      FLGESCFISICA = p_flgescfisica,
      FLGESCPSICHICA = p_flgescpsichica,
      FLGESCSENSORIALE = p_flgescsensoriale,
      FLGESCINTELLETTIVA = p_flgescintellettiva,
      FLGESCNONDETERMINATO = p_flgescnondeterminato
      where prgrosa = p_prgrosa;


      query := 'select l.cdnlavoratore '||
              ' from an_lavoratore l '||
              ' inner join do_nominativo n on n.cdnlavoratore = l.cdnlavoratore '||
              ' left outer join cm_diagnosi_funzionale d on decrypt(d.cdnlavoratore,'''|| encrypterKey ||''') = l.cdnlavoratore '||
              ' left outer join cm_capacita c on c.prgdiagnosifunzionale = d.prgdiagnosifunzionale '||
              ' inner join pr_dispo_l68 pd on pd.cdnlavoratore = l.cdnlavoratore '||
     ' inner join am_cm_iscr i on decrypt(i.cdnlavoratore,'''|| encrypterKey ||''')  = n.cdnlavoratore ' ||
       ' inner join DE_CM_TIPO_ISCR ti on (i.codcmtipoiscr=ti.codcmtipoiscr) ' ||
     ' inner join am_documento_coll coll on (i.prgcmiscr = coll.strchiavetabella) ' ||
     ' inner join am_documento doc on (coll.prgdocumento = doc.prgdocumento and doc.codtipodocumento = ''L68'') ' ||
              ' where n.prgrosa = ' || p_prgrosa || ' '||
              ' and pd.codmonodispol8 = ''S'' '||
              ' and d.datfine is null ' ||
     ' and doc.codstatoatto = ''PR'' and doc.cdnlavoratore = n.cdnlavoratore and i.datdatafine is null';

      if (p_CODMONOTIPOAZIENDA = 'A') then
         queryWhere := queryWhere || ' and pd.flgdispoazi = ''S'' ';
      elsif (p_CODMONOTIPOAZIENDA = 'E') then
         queryWhere := queryWhere || ' and pd.flgdispoEP = ''S'' ';
      end if;

      checkcontrollo := 0;

      if (MR5 != 0) then
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''MR5'' and c.codgradocapacita >= '|| MR5 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (IN2 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''IN2'' and c.codgradocapacita >= '|| IN2 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (PO1 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''PO1'' and c.codgradocapacita >= '|| PO1 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (PO2 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''PO2'' and c.codgradocapacita >= '|| PO2 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (PO6 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''PO6'' and c.codgradocapacita >= '|| PO6 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (PO7 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''PO7'' and c.codgradocapacita >= '|| PO7 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (LO2 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''LO2'' and c.codgradocapacita >= '|| LO2 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (LO3 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''LO3'' and c.codgradocapacita >= '|| LO3 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (MV1 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''MV1'' and c.codgradocapacita >= '|| MV1 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (MV2 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''MV2'' and c.codgradocapacita >= '|| MV2 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (MV3 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''MV3'' and c.codgradocapacita >= '|| MV3 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (MV4 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''MV4'' and c.codgradocapacita >= '|| MV4 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (AC1 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''AC1'' and c.codgradocapacita >= '|| AC1 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (FA2 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''FA2'' and c.codgradocapacita >= '|| FA2 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (FA3 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''FA3'' and c.codgradocapacita >= '|| FA3 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (SL1 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''SL1'' and c.codgradocapacita >= '|| SL1 ||' ) ';
         checkcontrollo := 1;
      end if;
      if (SL2 != 0) then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''SL2'' and c.codgradocapacita >= '|| SL2 ||' ) ';
         checkcontrollo := 1;
      end if;

      queryWhereEsclusioni := '';
      checkcontrolloDiagnosi := 0;

      if (p_flgescfisica != 'N') then
         checkcontrolloDiagnosi := 1;
         queryWhereEsclusioni := queryWhereEsclusioni || ' and (d.flginvalidfisica != ''S'' or d.flginvalidfisica is null) ';
      end if;
      if (p_flgescpsichica != 'N') then
         checkcontrolloDiagnosi := 1;
         queryWhereEsclusioni := queryWhereEsclusioni || ' and (d.flginvalidpsichica != ''S'' or d.flginvalidpsichica is null) ';
      end if;

      if (p_configDiagnFunz = '0') then
          if (p_flgescsensoriale != 'N') then
             checkcontrolloDiagnosi := 1;
             queryWhereEsclusioni := queryWhereEsclusioni || ' and (d.flginvalidsensoriale != ''S'' or d.flginvalidsensoriale is null) ';
          end if;
          if (p_flgescintellettiva != 'N') then
             checkcontrolloDiagnosi := 1;
             queryWhereEsclusioni := queryWhereEsclusioni || ' and (d.flginvalidintellettiva != ''S'' or d.flginvalidintellettiva is null) ';
          end if;
      else
          if (p_flgescnondeterminato != 'N') then
             checkcontrolloDiagnosi := 1;
             queryWhereEsclusioni := queryWhereEsclusioni || ' and (d.flginvalidnondeterminata != ''S'' or d.flginvalidnondeterminata is null) ';
          end if;
      end if;

      query := query || querywhere;
      if (checkcontrollo = 1) then
      -- seleziono quelli con le capacità richieste se disabili o quelli che non sono disabili
         query := query || ' and ( ' ||
               '(ti.codmonotiporagg=''D'' and (' || queryWhereCapacita || ')) OR ' ||
         '(ti.codmonotiporagg=''A'')' ||
         ' ) ';
      end if;

      if (checkcontrolloDiagnosi = 1) then
      -- seleziono quelli con le esclusioni richieste se disabili o quelli che non sono disabili
   queryWhereEsclusioni := substr(queryWhereEsclusioni,5);
         queryWhereEsclusioni := ' and (' ||
            '(' || queryWhereEsclusioni || ' and d.prgdiagnosifunzionale is not null )' ||
         'OR (ti.codmonotiporagg=''A'') ' ||
         ')';
      end if;
      query := query || queryWhereEsclusioni;




      -- aggiornamento dei nominativi della rosa
      queryUpdate := ' update do_nominativo '||
                   ' set codTipoCanc = ''D'', '||
                   ' cdnUtCanc = '|| p_cdnUtente ||', '||
                   ' dtmCanc = SYSDATE, '||
                   ' NUMKLONOMINATIVO = NUMKLONOMINATIVO+1  '||
                   ' where do_nominativo.cdnlavoratore NOT IN (' || query || ' ) '||
                   ' and do_nominativo.PRGROSA = ' || p_prgrosa || ' '||
                   ' and codTipoCanc is null ';

      p_query := queryUpdate;

      execute immediate queryUpdate;

      return 0;
      exception
               when others then
                    p_errCode := sqlcode;
                    dbms_output.put_line(substr(sqlcode || ' ' || sqlerrm,1,255));
                    rollback;
                    return -1;

end updateRosaParamCM;


/*********************************************************************
  Matching mobilità
  restituisce le 4 stringhe che compongono lo statement da utilizzare per
  eseguire il matching esatto date una richiesta e ad una determinata alternativa.
*********************************************************************/
function Matching_mobilita(
    p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
    p_prgAlternativa DO_ALTERNATIVA.PRGALTERNATIVA%TYPE,   -- progressivo dell'Alternativa
    p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
    p_db int,                -- base dati da utilizzare
    p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_flgXcpi varchar2,
    p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
    p_out_query OUT long,
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE       -- progressivo della rosa
    ) return number IS

  checkExecIncrocio number;
  p_sql_query long;
  query_select_1 varchar2(1000);
  query_select_2 varchar2(1000);
  query_select_2_close varchar2(10);
  query_union varchar2(100);
  query_where_1 long;
  query_where_2 long;
  p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
  p_Originale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;

  -- MASTER
  where_cpi_master_1 varchar2(500) := ' and (PG_INCROCIO.PDMASTERLAVO(mo1.cdnLavoratore)=1) ';
  where_cpi_master_2 varchar2(500) := ' and (PG_INCROCIO.PDMASTERLAVO(mo2.cdnLavoratore)=1) ';
  -- CPI DI APPARTENENZA -----------------------------------------------------------------------------------------------------------------------------------------------
  -- per ora escluso, rifare come cpi_master se da inserire
  where_cpi varchar2(500) := '';
  ------------------------------------------------------------------------------------------------------------------------------------------------------
  where_dataPubb_1 varchar2(4000) := '';
  where_dataPubb_2 varchar2(4000) := '';
  --where_mansione varchar2(4000) := '';
  where_mansione long := '';
  --where_mansione_lav varchar2(4000) := '';
  where_mansione_lav long := '';
  like_mansione varchar2(20);
  recRichiesta DO_RICHIESTA_AZ%ROWTYPE;
  numComuni number;
  numProv number;
  codComAz AN_UNITA_AZIENDA.CODCOM%TYPE;
  strMansione varchar2(1000);
  strMansioneLav varchar2(1000);
  recAlternativa DO_ALTERNATIVA%ROWTYPE;
  numAnniEsp DO_ALTERNATIVA.NUMANNIESPERIENZA%TYPE;
  numMansioni number;
  -- Parametri
  parPrgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;
  parAutomunito DO_RICHIESTA_AZ.FLGAUTOMUNITO%TYPE;
  parMotomunito DO_RICHIESTA_AZ.FLGMOTOMUNITO%TYPE;
  parTrasferta DO_RICHIESTA_AZ.CODTRASFERTA%TYPE;
  parMilitare DO_RICHIESTA_AZ.FLGMILITE%TYPE;
  parFuoriSede DO_RICHIESTA_AZ.FLGFUORISEDE%TYPE;
  parMezziPub AN_UNITA_AZIENDA.FLGMEZZIPUB%TYPE;
  parEsperienza DO_ALTERNATIVA.FLGESPERIENZA%TYPE;
  parFormProf DO_ALTERNATIVA.FLGFORMAZIONEPROF%TYPE;
  parDatPubblicazione varchar2(10);
  parCpi do_richiesta_az.codcpi%type;
  p_prgTipoIncrocio de_tipo_incrocio.prgTipoIncrocio%type;

  -- Cursori
  /*
  CURSOR curMansioni IS
     select DO_MANSIONE.codMansione
   from DO_MANSIONE
   where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_MANSIONE.PRGALTERNATIVA = p_prgAlternativa;
  */
 CURSOR curMansioni IS
     select DO_MANSIONE.codMansione
     from DO_MANSIONE
     where DO_MANSIONE.PRGALTERNATIVA = p_prgAlternativa
     and DO_MANSIONE.PRGRICHIESTAAZ = (SELECT RICH2.PRGRICHIESTAAZ
                                       FROM DO_RICHIESTA_AZ RICH1
                                       INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
                                       WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz);

BEGIN

  if p_flgXcpi = '1' then
    p_prgTipoIncrocio := 13;
  else
      p_prgTipoIncrocio := 8;
  end if;

  -- Controllo che ci sia almeno una MANSIONE
  select count(*) into numMansioni
  from DO_MANSIONE
  where DO_MANSIONE.PRGRICHIESTAAZ = p_prgRichiestaAz and DO_MANSIONE.PRGALTERNATIVA = p_prgAlternativa;
  if(numMansioni=0) then
   -- ERRORE MANSIONE NON PRESENTE SUL PROFILO
   return 1;
  --dbms_output.put_line('Non è possibile effettuare l''incrocio in quanto non è stata specificata nessuna mansione!');
  end if;
  -- Controllo che la richiesta non sia stata CHIUSA mentre si accedeva all'incrocio
  SELECT RICH2.PRGRICHIESTAAZ INTO p_Originale
  FROM DO_RICHIESTA_AZ RICH1
         INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
     WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;

  SELECT do_evasione.CDNSTATORICH into p_cdnStatoRich
  FROM DO_RICHIESTA_AZ, DO_EVASIONE
  WHERE (DO_RICHIESTA_AZ.PRGRICHIESTAAZ=DO_EVASIONE.PRGRICHIESTAAZ)
  AND DO_RICHIESTA_AZ.PRGRICHIESTAAZ=p_Originale;
  if(p_cdnStatoRich=4 OR p_cdnStatoRich=5) then
   -- ERRORE RICHIESTA CHIUSA
   return 2;
  end if;

  -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;
  dbms_output.put_line('Prg Incrocio=' || p_out_prgIncrocio || ' - Prg Rosa=' || p_out_prgRosa);
  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgIncrocio, p_Originale, p_prgAlternativa, p_prgTipoIncrocio, 'E',
  p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgRosa, null, p_out_prgIncrocio, 1, p_cdnUtente, sysdate, p_cdnUtente, sysdate);

 select * into recRichiesta from DO_RICHIESTA_AZ where DO_RICHIESTA_AZ.PRGRICHIESTAAZ = p_Originale;
 parAutomunito := recRichiesta.flgAutomunito;
 parMotomunito := recRichiesta.flgMotomunito;
 parTrasferta := recRichiesta.codTrasferta;
 parMilitare := recRichiesta.flgMilite;
 parFuoriSede := recRichiesta.flgFuoriSede;
 parPrgAzienda := recRichiesta.prgAzienda;
 parDatPubblicazione := to_char(recRichiesta.Datpubblicazione, 'dd/mm/yyyy');

 --dona
 --per graduatoria mobilita x cpi
 parCpi := recRichiesta.Codcpi;

 if (parDatPubblicazione is null) then
    return 4;
 end if;

 if(p_prgAlternativa is not null) then
    select * into recAlternativa from DO_ALTERNATIVA
    where DO_ALTERNATIVA.PRGRICHIESTAAZ = p_prgRichiestaAz
    and DO_ALTERNATIVA.PRGALTERNATIVA = p_prgAlternativa;
    parEsperienza := recAlternativa.flgEsperienza;
    numAnniEsp := recAlternativa.numAnniEsperienza;
    parFormProf := recAlternativa.flgFormazioneProf;
 end if;

 if p_flgXcpi = '1' then
   -- query di select per estrarre i nominativi
   query_select_1 := ' select distinct mo1.CDNLAVORATORE from AM_MOBILITA_ISCR mo1 '||
                     ' inner join AM_MOBILITA_ISCR_MANS momans1 on momans1.prgmobilitaiscr = mo1.prgmobilitaiscr '||
                     ' inner join DE_MB_TIPO mbtipo1 on mbtipo1.codmbtipo = mo1.codtipomob and mbtipo1.codmonoattiva = ''A'' '||
                     ' inner join an_lav_storia_inf ls on ls.cdnlavoratore = mo1.cdnlavoratore and ls.CODMONOTIPOCPI = ''C'' and ls.datfine is null '||
                     ' where ls.codcpitit = '''|| PARCPI ||''' and '||
                     ' (mo1.FLGNONIMPRENDITORE is null or mo1.FLGNONIMPRENDITORE = ''N'') and ';

   query_select_2 := ' select distinct mo2.CDNLAVORATORE ' ||
                     ' from AM_MOBILITA_ISCR mo2 '||
                     ' inner join DE_MB_TIPO mbtipo2 on mbtipo2.codmbtipo = mo2.codtipomob and mbtipo2.codmonoattiva = ''A'' '||
                     ' inner join an_lav_storia_inf ls2 on ls2.cdnlavoratore = mo2.cdnlavoratore and ls2.CODMONOTIPOCPI = ''C'' and ls2.datfine is null '||
                     ' where ls2.codcpitit = '''|| PARCPI ||''' and mo2.prgmobilitaiscr not in (select momans2.prgmobilitaiscr from AM_MOBILITA_ISCR_MANS momans2) '||
                     ' and (mo2.FLGNONIMPRENDITORE is null or mo2.FLGNONIMPRENDITORE = ''N'') ';

 else
   -- query di select per estrarre i nominativi
   query_select_1 := ' select distinct mo1.CDNLAVORATORE from AM_MOBILITA_ISCR mo1 '||
                     ' inner join AM_MOBILITA_ISCR_MANS momans1 on momans1.prgmobilitaiscr = mo1.prgmobilitaiscr '||
                     ' inner join DE_MB_TIPO mbtipo1 on mbtipo1.codmbtipo = mo1.codtipomob and mbtipo1.codmonoattiva = ''A'' '||
                     ' where '||
                     ' (mo1.FLGNONIMPRENDITORE is null or mo1.FLGNONIMPRENDITORE = ''N'') and ';

   query_select_2 := ' select distinct mo2.CDNLAVORATORE ' ||
                     ' from AM_MOBILITA_ISCR mo2 '||
                     ' inner join DE_MB_TIPO mbtipo2 on mbtipo2.codmbtipo = mo2.codtipomob and mbtipo2.codmonoattiva = ''A'' '||
                     ' where mo2.prgmobilitaiscr not in (select momans2.prgmobilitaiscr from AM_MOBILITA_ISCR_MANS momans2) '||
                     ' and (mo2.FLGNONIMPRENDITORE is null or mo2.FLGNONIMPRENDITORE = ''N'') ';
 end if;

 query_union := 'union ';
 query_where_1 := '';
 query_where_1 := where_cpi_master_1;
 query_where_2 := '';
 query_where_2 := where_cpi_master_2;

 /* clausola where per la data pubblicazione                        */

 where_dataPubb_1 := ' and (mo1.datinizio <= to_date('''|| parDatPubblicazione ||''', ''dd/mm/yyyy'') and (mo1.datfine >= to_date('''|| parDatPubblicazione ||''', ''dd/mm/yyyy'') or mo1.datfine is null))';
 where_dataPubb_2 := ' and (mo2.datinizio <= to_date('''|| parDatPubblicazione ||''', ''dd/mm/yyyy'') and (mo2.datfine >= to_date('''|| parDatPubblicazione ||''', ''dd/mm/yyyy'') or mo2.datfine is null))';

 /********************************************************************
 * Mansione (dipende dall'Alternativa e parametri collegati          *
 ********************************************************************/
 /* Va gestito il raggruppamento xy0000, xyab00, xyabcd */

 FOR rec IN curMansioni LOOP
  if(where_mansione='' or (where_mansione is null)) then
    dbms_output.put_line('');
  else
     where_mansione := where_mansione || ' or ';
  end if;
  if(where_mansione_lav='' or (where_mansione_lav is null)) then
    dbms_output.put_line('');
  else
     where_mansione_lav := where_mansione_lav || ' or ';
  end if;
 -- if(SUBSTR(rec.codMansione,-4)='0000') then
   --strMansione := '(SUBSTR(momans1.codMansione,1,2)=''' || SUBSTR(rec.codMansione,1,2) || ''')  ';
  -- strMansioneLav := '(SUBSTR(mo2.codMansione,1,2)=''' || SUBSTR(rec.codMansione,1,2) || ''')  ';
  --else
    if(SUBSTR(rec.codMansione,-2)='00') then
     strMansione := '(SUBSTR(momans1.codMansione,1,5)=''' || SUBSTR(rec.codMansione,1,5) || ''')  ';
     strMansioneLav := '(SUBSTR(mo2.codMansione,1,5)=''' || SUBSTR(rec.codMansione,1,5) || ''')  ';
    else
       strMansione := '(momans1.codMansione=''' || rec.codMansione || ''') ';
       strMansioneLav := '(mo2.codMansione=''' || rec.codMansione || ''') ';
    end if;
  --end if;

  where_mansione := where_mansione || '(' || strMansione || ' ) ';
  where_mansione_lav := where_mansione_lav || '(' || strMansioneLav || ' ) ';

  like_mansione :=
   case
    --when substr(rec.codMansione,-4)='0000' then substr(rec.codMansione,1,2) || '%'
    when substr(rec.codMansione,-2)='00' then substr(rec.codMansione,1,5) || '%'
    else rec.codMansione
   end;
  -- Fine where_mansione
  --where_mansione := where_mansione || ') ';
 END LOOP;
 query_where_1 := query_where_1 || where_dataPubb_1 || ' and (' || where_mansione || ') ';
 query_where_2 := query_where_2 || where_dataPubb_2 || ' and (' || where_mansione_lav || ') ';

 query_where_1:= ltrim(query_where_1, 'and ');
 --query_where_2:= ltrim(query_where_2, 'and ');


 p_sql_query := query_select_1 || query_where_1 || query_union || query_select_2 || query_where_2;

 p_out_query := p_sql_query;

 /********************************
 Check dei parametri di Ritorno
 ********************************/
 if(p_out_prgIncrocio is null or p_out_prgRosa is null) then
    rollback;
    return -1;
 end if;

 if(length(query_select_1)=0 or length(query_select_2)=0 or length(query_where_1)=0 or length(query_where_2)=0) then
    rollback;
    return -1;
 end if;

 /**********************************************
 * esecuzione dell'incrocio                    *
 * inserimento dei candidati in do_namonativo  *
 **********************************************/

 checkExecIncrocio := Pg_Incrocio.eseguiIncrocioMobilita(p_sql_query, p_out_prgIncrocio, p_out_prgRosa, p_cdnutente, 1, p_errCode);
 if (checkExecIncrocio = -1) then
    return -1;
 end if;

 return 0;
 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       return -1;

END Matching_mobilita;


/*********************************************************************
  Matching mobilità senza prendere in considerazione le mansioni
  restituisce le 4 stringhe che compongono lo statement da utilizzare per
  eseguire il matching esatto date una richiesta e ad una determinata alternativa.
*********************************************************************/
function Matching_mobilita_no_mansione(
    p_prgRichiestaAz  DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,     -- progressivo della Richiesta
    p_prgRosa DO_ROSA.PRGROSA%TYPE,         -- progressivo della rosa sulla quale eseguire il matching
    p_db int,                -- base dati da utilizzare
    p_codCpi DE_CPI.CODCPI%TYPE,           -- codice del cpi
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
    p_flgXcpi varchar2,
    p_errCode OUT number,           -- Codice di Errore - vale null se è tutto ok
    p_out_query OUT long,
    p_out_prgIncrocio OUT DO_INCROCIO.PRGINCROCIO%TYPE,    -- progressivo dell'incrocio
    p_out_prgRosa OUT DO_ROSA.PRGROSA%TYPE       -- progressivo della rosa
    ) return number IS

 checkExecIncrocio number;
  p_sql_query long;
  query_select_1 varchar2(1000);
  query_where_1 long;
  p_cdnStatoRich DO_EVASIONE.CDNSTATORICH%TYPE;
  p_Originale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;

  -- CPI DI APPARTENENZA -----------------------------------------------------------------------------------------------------------------------------------------------
  -- per ora escluso, rifare come cpi_master se da inserire
  where_cpi varchar2(500) := '';
  ------------------------------------------------------------------------------------------------------------------------------------------------------
  where_dataPubb_1 varchar2(4000) := '';
  recRichiesta DO_RICHIESTA_AZ%ROWTYPE;
  numComuni number;
  numProv number;
  codComAz AN_UNITA_AZIENDA.CODCOM%TYPE;
  -- Parametri
  parPrgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;
  parDatPubblicazione varchar2(10);
  parCpi do_richiesta_az.codcpi%type;
  p_prgTipoIncrocio de_tipo_incrocio.prgTipoIncrocio%TYPE;

BEGIN

  if p_flgXcpi = '1' then
    p_prgTipoIncrocio := 14;
  else
      p_prgTipoIncrocio := 9;
  end if;



  -- Controllo che la richiesta non sia stata CHIUSA mentre si accedeva all'incrocio
  SELECT RICH2.PRGRICHIESTAAZ INTO p_Originale
  FROM DO_RICHIESTA_AZ RICH1
         INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
     WHERE RICH1.PRGRICHIESTAAZ =  p_prgRichiestaAz;

  SELECT do_evasione.CDNSTATORICH into p_cdnStatoRich
  FROM DO_RICHIESTA_AZ, DO_EVASIONE
  WHERE (DO_RICHIESTA_AZ.PRGRICHIESTAAZ=DO_EVASIONE.PRGRICHIESTAAZ)
  AND DO_RICHIESTA_AZ.PRGRICHIESTAAZ=p_Originale;
  if(p_cdnStatoRich=4 OR p_cdnStatoRich=5) then
   -- ERRORE RICHIESTA CHIUSA
   return 2;
  end if;

  -- Calcolo il progressivo per la rosa e per l'incrocio
  select S_DO_INCROCIO.nextVal into p_out_prgIncrocio from dual;
  select S_DO_ROSA.nextVal into p_out_prgRosa from dual;
  dbms_output.put_line('Prg Incrocio=' || p_out_prgIncrocio || ' - Prg Rosa=' || p_out_prgRosa);
  -- passo 1. inserisco il nuovo incrocio nella tabella do_incrocio
  insert into do_incrocio
  (prgIncrocio, prgRichiestaAz, prgAlternativa, prgTipoIncrocio, codStatoIncrocio,
  cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgIncrocio, p_Originale, null, p_prgTipoIncrocio, 'E',
  p_cdnUtente, sysdate, p_cdnUtente, sysdate);
  -- passo 2. inserisco il record per il riferimento alla rosa in do_rosa
  insert into do_rosa
  (prgRosa, prgRosaFiglia, prgIncrocio, prgTipoRosa, cdnUtIns, dtmIns, cdnUtMod, dtmMod)
  values
  (p_out_prgRosa, null, p_out_prgIncrocio, 1, p_cdnUtente, sysdate, p_cdnUtente, sysdate);

 select * into recRichiesta from DO_RICHIESTA_AZ where DO_RICHIESTA_AZ.PRGRICHIESTAAZ = p_Originale;
 parPrgAzienda := recRichiesta.prgAzienda;
 parDatPubblicazione := to_char(recRichiesta.Datpubblicazione, 'dd/mm/yyyy');
 parCpi := recRichiesta.Codcpi;

 if (parDatPubblicazione is null) then
   -- data pubblicazione
   return 4;
 end if;

 if p_flgXcpi = '1' then
   query_select_1 := ' select distinct mo.CDNLAVORATORE from AM_MOBILITA_ISCR mo '||
                     ' left join AM_MOBILITA_ISCR_MANS momans1 on momans1.prgmobilitaiscr = mo.prgmobilitaiscr '||
                     ' inner join DE_MB_TIPO mbtipo1 on mbtipo1.codmbtipo = mo.codtipomob and mbtipo1.codmonoattiva = ''A'' '||
                     ' inner join an_lav_storia_inf ls on ls.cdnlavoratore = mo.cdnlavoratore and ls.CODMONOTIPOCPI = ''C'' and ls.datfine is null '||
                     ' where (PG_INCROCIO.PDMASTERLAVO(mo.cdnLavoratore)=1) '||
                     ' and (mo.FLGNONIMPRENDITORE is null or mo.FLGNONIMPRENDITORE = ''N'') '||
                     ' and (mo.datinizio <= to_date('''|| parDatPubblicazione ||''', ''dd/mm/yyyy'') and (mo.datfine >= to_date('''|| parDatPubblicazione ||''', ''dd/mm/yyyy'') or mo.datfine is null)) '||
                     ' and ls.codcpitit = '''|| parCpi ||'''';

 else
   -- query di select per estrarre i nominativi
   query_select_1 := ' select distinct mo.CDNLAVORATORE from AM_MOBILITA_ISCR mo '||
                     ' left join AM_MOBILITA_ISCR_MANS momans1 on momans1.prgmobilitaiscr = mo.prgmobilitaiscr '||
                     ' inner join DE_MB_TIPO mbtipo1 on mbtipo1.codmbtipo = mo.codtipomob and mbtipo1.codmonoattiva = ''A'' '||
                     ' where (PG_INCROCIO.PDMASTERLAVO(mo.cdnLavoratore)=1) '||
                     ' and (mo.FLGNONIMPRENDITORE is null or mo.FLGNONIMPRENDITORE = ''N'') '||
                     ' and (mo.datinizio <= to_date('''|| parDatPubblicazione ||''', ''dd/mm/yyyy'') and (mo.datfine >= to_date('''|| parDatPubblicazione ||''', ''dd/mm/yyyy'') or mo.datfine is null)) ';

 end if;
 p_out_query := query_select_1;

 /********************************
 Check dei parametri di Ritorno
 ********************************/

 if(p_out_prgIncrocio is null or p_out_prgRosa is null) then
    rollback;
    return -1;
 end if;

 if(length(query_select_1)=0 or length(query_where_1)=0 ) then
    rollback;
    return -1;
 end if;

 /**********************************************
 * esecuzione dell'incrocio                    *
 * inserimento dei candidati in do_namonativo  *
 **********************************************/

 checkExecIncrocio := Pg_Incrocio.eseguiIncrocioMobilita(p_out_query, p_out_prgIncrocio, p_out_prgRosa, p_cdnutente, 1, p_errCode);
 if (checkExecIncrocio = -1) then
    return -1;
 end if;

 return 0;
 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       return -1;

END Matching_mobilita_no_mansione;

function eseguiIncrocioMobilita(
   p_query long,
   p_prgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE,  -- progressivo dell'incrocio
   p_prgRosa DO_ROSA.PRGROSA%TYPE,     -- progressivo della rosa
   p_cdnUtente TS_UTENTE.CDNUT%TYPE,        -- utente che effettua l'incrocio
   p_mem char,
   p_ErrCode OUT number
   ) return number  IS

  -- Tipo del record per la tabella di appoggio
  type p_rec_ris is record (cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type);
  type tab_ris is table of p_rec_ris;
  p_tab_ris tab_ris;
  sql_query long;
  rCpiTit DE_CPI.CODCPI%type;
  rDid DO_NOMINATIVO.DATDICHIARAZIONE%type;
  nro number;
begin

 sql_query := p_query;
 execute immediate sql_query bulk collect into p_tab_ris;
 dbms_output.put_line('');
 dbms_output.put_line('Elenco Candidati');
 if(p_mem=1) then
   FOR i in 1..p_tab_ris.COUNT
    loop
     --dbms_output.put_line(p_tab_ris(i).cdnLavoratore ||';' || p_tab_ris(i).strCognome || ';' || p_tab_ris(i).strNome);
     -- Inserimento del candidato in do_nominativo
     rCpiTit := PG_INCROCIO.PDCPITIT(p_tab_ris(i).cdnLavoratore);

     insert into DO_NOMINATIVO
     (prgNominativo, cdnLavoratore, numOrdine, codCpiTit, dtmIns, cdnUtIns, prgRosa)
     values
     (S_DO_NOMINATIVO.nextVal, p_tab_ris(i).cdnLavoratore, null,
     rCpiTit, sysdate, p_cdnUtente, p_prgRosa);
    end loop;
  end if;
  -- aggiorno lo stato dell'incrocio
  update do_incrocio set CODSTATOINCROCIO='C',NUMKLOINCROCIO=NUMKLOINCROCIO+1, CDNUTMOD=p_cdnUtente,
          DTMMOD=sysdate
  where PRGINCROCIO =  p_prgIncrocio;

  commit;
  return 0;
  exception
      when others then
         p_errCode := sqlcode;
       --dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       rollback;
       return -1;
end eseguiIncrocioMobilita;

function checkFlagCM(p_cdnLavoratore An_Lavoratore.CDNLAVORATORE%type,
                     encrypterKey varchar2
                     ) return number  IS
nro number;
checkCM number;
cdnLavCrypt varchar2(255);
begin

  cdnLavCrypt := encrypt(p_cdnLavoratore,encrypterKey);

  SELECT count(I.PRGCMISCR) into nro
  FROM AM_CM_ISCR I
  INNER JOIN AM_DOCUMENTO_COLL COLL ON (I.PRGCMISCR = COLL.STRCHIAVETABELLA)
  INNER JOIN AM_DOCUMENTO DOC ON (COLL.PRGDOCUMENTO = DOC.PRGDOCUMENTO AND DOC.CODTIPODOCUMENTO = 'L68')
  WHERE DOC.CODSTATOATTO = 'PR' AND DOC.CDNLAVORATORE = p_cdnLavoratore
  and i.datdatafine is null
  and I.Cdnlavoratore = cdnLavCrypt;

  if (nro > 0) then
    checkCM := 1;
  else
    checkCM := 0;
  end if;

  return checkCM;

  exception
      when others then
       return 0;

end checkFlagCM;

function updateRosaParamCMVDA(p_CODMONOTIPOAZIENDA varchar2,
                                                IN4 varchar2,
                                                IN5 varchar2,
                                                IN6 varchar2,
                                                PO8 varchar2,
                                                PO9 varchar2,
                                                PO10 varchar2,
                                                PO11 varchar2,
                                                PO12 varchar2,
                                                PO13 varchar2,
                                                PO14 varchar2,
                                                LO4 varchar2,
                                                LO5 varchar2,
                                                LO6 varchar2,
                                                MV5 varchar2,
                                                MV6 number,
                                                MV7 varchar2,
                                                AC5 varchar2,
                                                AC6 varchar2,
                                                FA7 varchar2,
                                                FA8 varchar2,
                                                SL5 varchar2,
                                                SL6 varchar2,
                                                SL7 varchar2,
                                                SL8 varchar2,
                                                SL9 varchar2,
                                                CA1 varchar2,
                                                CA2 varchar2,
                                                CA3 varchar2,
                                                CA4 varchar2,
                                                p_flgescfisica varchar2,
                                                p_flgescpsichica varchar2,
                                                p_flgescsensoriale varchar2,
                                                p_flgescintellettiva varchar2,
                                                p_flgescnondeterminato varchar2,
                                                p_prgrosa do_rosa.prgrosa%TYPE,
                                                encrypterKey varchar2,
                                                p_cdnUtente TS_UTENTE.CDNUT%TYPE,
                                                p_configDiagnFunz varchar2,
                                                p_ErrCode OUT number,
                                                p_query OUT varchar2
                           )
                         RETURN NUMBER IS

checkcontrollo number;
checkcontrolloDiagnosi number;
query varchar2(6000);
queryWhereCapacita varchar2(6000);
queryWhereEsclusioni varchar2(6000);
queryWhere varchar2(6000);
queryUpdate varchar2(6000);
capacita varchar2(50);

begin

      queryWhere := '';
      queryWhereCapacita := '';

      update do_parametri_incrocio
      set
          CODMONOTIPOAZIENDA = p_CODMONOTIPOAZIENDA,
          CODMONOCAP_IN4 = IN4,
          CODMONOCAP_IN5 = IN5,
          CODMONOCAP_IN6 = IN6,
          CODMONOCAP_PO8 = PO8,
          CODMONOCAP_PO9 = PO9,
          CODMONOCAP_PO10 = PO10,
          CODMONOCAP_PO11 = PO11,
          CODMONOCAP_PO12 = PO12,
          CODMONOCAP_PO13 = PO13,
          CODMONOCAP_PO14 = PO14,
          CODMONOCAP_LO4 = LO4,
          CODMONOCAP_LO5 = LO5,
          CODMONOCAP_LO6 = LO6,
          CODMONOCAP_MV5 = MV5,
          CODMONOCAP_MV6 = MV6,
          CODMONOCAP_MV7 = MV7,
          CODMONOCAP_AC5 = AC5,
          CODMONOCAP_AC6 = AC6,
          CODMONOCAP_FA7 = FA7,
          CODMONOCAP_FA8 = FA8,
          CODMONOCAP_SL5 = SL5,
          CODMONOCAP_SL6 = SL6,
          CODMONOCAP_SL7 = SL7,
          CODMONOCAP_SL8 = SL8,
          CODMONOCAP_SL9 = SL9,
          CODMONOCAP_CA1 = CA1,
          CODMONOCAP_CA2 = CA2,
          CODMONOCAP_CA3 = CA3,
          CODMONOCAP_CA4 = CA4,
          FLGESCFISICA = p_flgescfisica,
          FLGESCPSICHICA = p_flgescpsichica,
          FLGESCSENSORIALE = p_flgescsensoriale,
          FLGESCINTELLETTIVA = p_flgescintellettiva,
          FLGESCNONDETERMINATO = p_flgescnondeterminato
      where prgrosa = p_prgrosa;


      query := 'select l.cdnlavoratore '||
              ' from an_lavoratore l '||
              ' inner join do_nominativo n on n.cdnlavoratore = l.cdnlavoratore '||
              ' left outer join cm_diagnosi_funzionale d on decrypt(d.cdnlavoratore,'''|| encrypterKey ||''') = l.cdnlavoratore '||
              ' left outer join cm_capacita c on c.prgdiagnosifunzionale = d.prgdiagnosifunzionale '||
              ' inner join pr_dispo_l68 pd on pd.cdnlavoratore = l.cdnlavoratore '||
     ' inner join am_cm_iscr i on decrypt(i.cdnlavoratore,'''|| encrypterKey ||''')  = n.cdnlavoratore ' ||
       ' inner join DE_CM_TIPO_ISCR ti on (i.codcmtipoiscr=ti.codcmtipoiscr) ' ||
     ' inner join am_documento_coll coll on (i.prgcmiscr = coll.strchiavetabella) ' ||
     ' inner join am_documento doc on (coll.prgdocumento = doc.prgdocumento and doc.codtipodocumento = ''L68'') ' ||
              ' where n.prgrosa = ' || p_prgrosa || ' '||
              ' and pd.codmonodispol8 = ''S'' '||
              ' and d.datfine is null ' ||
     ' and doc.codstatoatto = ''PR'' and doc.cdnlavoratore = n.cdnlavoratore and i.datdatafine is null';

      if (p_CODMONOTIPOAZIENDA = 'A') then
         queryWhere := queryWhere || ' and pd.flgdispoazi = ''S'' ';
      elsif (p_CODMONOTIPOAZIENDA = 'E') then
         queryWhere := queryWhere || ' and pd.flgdispoEP = ''S'' ';
      end if;

      checkcontrollo := 0;

      if (IN4 != '0') then
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''IN4'' and c.codgradocapacita = '''|| IN4 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (IN5  != '0') then
        if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
        end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''IN5'' and c.codgradocapacita = '''|| IN5 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (IN6  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''IN6'' and c.codgradocapacita = '''|| IN6 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (PO8  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''PO8'' and c.codgradocapacita = '''|| PO8 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (PO9  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''PO9'' and c.codgradocapacita = '''|| PO9 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (PO10  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''PO10'' and c.codgradocapacita = '''|| PO10 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (PO11 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''PO11'' and c.codgradocapacita = '''|| PO11 ||''') ';
         checkcontrollo := 1;
      end if;
      if (PO12 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''PO12'' and c.codgradocapacita = '''|| PO12 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (PO13 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''PO13'' and c.codgradocapacita = '''|| PO13 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (PO14 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''PO14'' and c.codgradocapacita = '''|| PO14 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (LO4  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''LO4'' and c.codgradocapacita = '''|| LO4 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (LO5 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''LO5'' and c.codgradocapacita = '''|| LO5 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (LO6  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''LO6'' and c.codgradocapacita = '''|| LO6 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (MV5  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''MV5'' and c.codgradocapacita = '''|| MV5 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (MV6  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         if (MV6 = 6 OR MV6 = 7)  then
              queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''MV6'' and c.codgradocapacita = '|| MV6 ||' ) ';
              checkcontrollo := 1;
         else
            queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''MV6'' and c.codgradocapacita <= '|| MV6 ||' ) ';
            checkcontrollo := 1;
         end if;
      end if;
      if (MV7  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''MV7'' and c.codgradocapacita = '''|| MV7 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (AC5 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''AC5'' and c.codgradocapacita = '''|| AC5 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (AC6 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''AC6'' and c.codgradocapacita = '''|| AC6 ||''') ';
         checkcontrollo := 1;
      end if;
      if (FA7 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''FA7'' and c.codgradocapacita = '''|| FA7 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (FA8 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''FA8'' and c.codgradocapacita = '''|| FA8 ||''' ) ';
         checkcontrollo := 1;
      end if;
      if (SL5 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''SL5'' and c.codgradocapacita = '''|| SL5 ||''' ) ';
         checkcontrollo := 1;
      end if;
       if (SL6  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''SL6'' and c.codgradocapacita = '''|| SL6 ||''' ) ';
         checkcontrollo := 1;
      end if;
       if (SL7 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''SL7'' and c.codgradocapacita = '''|| SL7 ||''' ) ';
         checkcontrollo := 1;
      end if;
       if (SL8 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''SL8'' and c.codgradocapacita = '''|| SL8 ||''' ) ';
         checkcontrollo := 1;
      end if;
       if (SL9  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''SL9'' and c.codgradocapacita = '''|| SL9 ||''' ) ';
         checkcontrollo := 1;
      end if;
       if (CA1  != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''CA1'' and c.codgradocapacita = '''|| CA1 ||''' ) ';
         checkcontrollo := 1;
      end if;
       if (CA2 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''CA2'' and c.codgradocapacita = '''|| CA2 ||''' ) ';
         checkcontrollo := 1;
      end if;
       if (CA3 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''CA3'' and c.codgradocapacita = '''|| CA3 ||''' ) ';
         checkcontrollo := 1;
      end if;
       if (CA4 != '0') then
         if (checkcontrollo = 1) then
            queryWhereCapacita := queryWhereCapacita || ' OR ';
         end if;
         queryWhereCapacita := queryWhereCapacita || ' ( c.codcapacita = ''CA4'' and c.codgradocapacita = '''|| CA4 ||''' ) ';
         checkcontrollo := 1;
      end if;

      queryWhereEsclusioni := '';
      checkcontrolloDiagnosi := 0;

      if (p_flgescfisica != 'N') then
         checkcontrolloDiagnosi := 1;
         queryWhereEsclusioni := queryWhereEsclusioni || ' and (d.flginvalidfisica != ''S'' or d.flginvalidfisica is null) ';
      end if;
      if (p_flgescpsichica != 'N') then
         checkcontrolloDiagnosi := 1;
         queryWhereEsclusioni := queryWhereEsclusioni || ' and (d.flginvalidpsichica != ''S'' or d.flginvalidpsichica is null) ';
      end if;

      if (p_configDiagnFunz = '0') then
          if (p_flgescsensoriale != 'N') then
             checkcontrolloDiagnosi := 1;
             queryWhereEsclusioni := queryWhereEsclusioni || ' and (d.flginvalidsensoriale != ''S'' or d.flginvalidsensoriale is null) ';
          end if;
          if (p_flgescintellettiva != 'N') then
             checkcontrolloDiagnosi := 1;
             queryWhereEsclusioni := queryWhereEsclusioni || ' and (d.flginvalidintellettiva != ''S'' or d.flginvalidintellettiva is null) ';
          end if;
      else
          if (p_flgescnondeterminato != 'N') then
             checkcontrolloDiagnosi := 1;
             queryWhereEsclusioni := queryWhereEsclusioni || ' and (d.flginvalidnondeterminata != ''S'' or d.flginvalidnondeterminata is null) ';
          end if;
      end if;

      query := query || querywhere;
      if (checkcontrollo = 1) then
      -- seleziono quelli con le capacità richieste se disabili o quelli che non sono disabili
         query := query || ' and ( ' ||
               '(ti.codmonotiporagg=''D'' and (' || queryWhereCapacita || ')) OR ' ||
         '(ti.codmonotiporagg=''A'')' ||
         ' ) ';
      end if;

      if (checkcontrolloDiagnosi = 1) then
      -- seleziono quelli con le esclusioni richieste se disabili o quelli che non sono disabili
   queryWhereEsclusioni := substr(queryWhereEsclusioni,5);
         queryWhereEsclusioni := ' and (' ||
            '(' || queryWhereEsclusioni || ' and d.prgdiagnosifunzionale is not null )' ||
         'OR (ti.codmonotiporagg=''A'') ' ||
         ')';
      end if;
      query := query || queryWhereEsclusioni;

      -- aggiornamento dei nominativi della rosa
      queryUpdate := ' update do_nominativo '||
                   ' set codTipoCanc = ''D'', '||
                   ' cdnUtCanc = '|| p_cdnUtente ||', '||
                   ' dtmCanc = SYSDATE, '||
                   ' NUMKLONOMINATIVO = NUMKLONOMINATIVO+1  '||
                   ' where do_nominativo.cdnlavoratore NOT IN (' || query || ' ) '||
                   ' and do_nominativo.PRGROSA = ' || p_prgrosa || ' '||
                   ' and codTipoCanc is null ';

      p_query := queryUpdate;

      execute immediate queryUpdate;

      return 0;
      exception
               when others then
                    p_errCode := sqlcode;
                    dbms_output.put_line(substr(sqlcode || ' ' || sqlerrm,1,255));
                    rollback;
                    return -1;

end updateRosaParamCMVDA;


/*********************************************************************
    * aggiornaDtFineRecordPrecedente
    *                         *
    *                    *
    *********************************************************************/
procedure aggiornaDtFineRecordPrecedente(
        p_datafineval varchar2,
        p_cdnutmod varchar2,
        p_prgValIsee number) IS

queryWhere VARCHAR2(255);
v_numKloValoreIsee number;
begin
  select NUMKLOVALOREISEE
    into v_numKloValoreIsee
   from AS_VALORE_ISEE
   WHERE PRGVALOREISEE = p_prgValIsee;
    -- storicizzazione nella tabella di LOG
  queryWhere :=  ' WHERE PRGVALOREISEE = ' || p_prgValIsee;

  PG_LOG.doLog('U', 'AS_VALORE_ISEE', p_cdnutmod, queryWhere);

  UPDATE AS_VALORE_ISEE SET
  DATFINEVAL        = (case when to_date(p_datafineval, 'dd/mm/yyyy')<trunc(DATINIZIOVAL)
                      then  trunc(DATINIZIOVAL)
                      else  to_date(p_datafineval, 'dd/mm/yyyy')
                      end),
  CDNUTMOD          = p_cdnutmod,
  DTMMOD            = SYSDATE,
  NUMKLOVALOREISEE  = v_numKloValoreIsee + 1
  WHERE PRGVALOREISEE = p_prgValIsee;

end aggiornaDtFineRecordPrecedente;

/***********************************************************************************************
* Funzione per l'inserimento di una adesione ONLINE per il lavoratore specifico alla richiesta *
************************************************************************************************/

function ASInsAdesioneOnlineLav(
    p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
      p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
      p_cdnGruppo Ts_Gruppo.Cdngruppo%TYPE,                       -- gruppo a cui fa parte l'utente
	  p_numvaloreisee  do_nominativo.NUMVALOREISEE%type,
      p_codmonoisee        do_nominativo.codmonoisee%type, -- Calcolo Isee (Da Sil o escludi)
	  p_NUMANNOPROTISTANZA       do_nominativo.NUMANNOPROTISTANZA%type,  
	  p_STRPROTISTANZA       do_nominativo.STRPROTISTANZA%type,  
	  p_STRIDISTANZA       do_nominativo.STRIDISTANZA%type  ,
	  p_errCode OUT number           -- Codice di Errore
	 )
 RETURN NUMBER IS

p_out_prgNominativo DO_NOMINATIVO.Prgnominativo%TYPE;
p_valoreIsee do_nominativo.NUMVALOREISEE%type;
p_prgRichiestaAz DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE;
p_prgincrocio DO_INCROCIO.Prgincrocio%TYPE;
p_prgAlternativa DO_INCROCIO.Prgalternativa%TYPE;
p_prgTipoIncrocio DO_INCROCIO.Prgtipoincrocio%TYPE;
datChiamata do_richiesta_az.datchiamata%type;
p_countisee number;
statorich do_evasione.cdnstatorich%TYPE;
checkRosaLSU number;
checkPunteggio number;
checkStoricizzazione number;
checkAdesione number;

begin

  select i.prgtipoincrocio, i.prgincrocio, i.prgrichiestaaz, i.prgalternativa, i.prgtipoincrocio
         into checkRosaLSU, p_prgincrocio, p_prgRichiestaAz, p_prgAlternativa, p_prgTipoIncrocio
  from do_rosa d
  inner join do_incrocio i on i.prgincrocio = d.prgincrocio
  WHERE d.PRGROSA = p_prgRosa;

  -- verifico che si è già inserito l'adesione per quella graduatoria in un proflo diverso
  select count(nom.prgnominativo) into checkAdesione
  from do_nominativo nom
  inner join do_rosa ros on ros.prgrosa = nom.prgrosa
  inner join do_incrocio inc on inc.prgincrocio = ros.prgincrocio
  inner join do_richiesta_az rich on rich.prgrichiestaaz = inc.prgrichiestaaz
  where nom.cdnlavoratore = p_cdnLavoratore
  and inc.prgtipoincrocio = p_prgTipoIncrocio
  and rich.prgrichiestaaz = p_prgRichiestaAz
  and ros.prgrosafiglia is null;

  -- errore non è possibile inserire due adesioni per la stesso tipo di graduatoria e profili diversi
  if (checkAdesione >= 1) then
     rollback;
     return 3;
  end if;

  -- Calcolo il progressivo per il nominativo
  select s_Do_Nominativo.nextVal into p_out_prgNominativo from dual;


  -- 24/04/2020 passo 0
   -- Memorizza il valore ISEE riferito a data chiamata.
    -- Se il dato ISEE riferito a data chiamata non è presente si memorizza il valore -1
	p_valoreIsee := p_numvaloreisee;
 
   -- passo 1. inserisco la nuova adesione in do_nominativo per la rosa specifica
  insert into do_nominativo
  (PRGNOMINATIVO, CDNLAVORATORE, DTMINS, CDNUTINS, PRGROSA,CODMONOISEE,NUMVALOREISEE, NUMANNOPROTISTANZA, STRPROTISTANZA, STRIDISTANZA )
  values
  (p_out_prgNominativo, p_cdnLavoratore, sysdate, p_cdnUtente, p_prgRosa, p_codmonoisee, p_valoreIsee, p_NUMANNOPROTISTANZA, p_STRPROTISTANZA, p_STRIDISTANZA);

  
   -- passo 3. storicizzo stato occupazionale del lavoratore
  checkStoricizzazione := ASStoricizzaStatoOcc(p_prgRichiestaAz,p_cdnLavoratore,p_prgincrocio,p_cdnUtente);

  if (checkStoricizzazione != 0) then
     -- se non esiste mando in errore la procedura
     rollback;
     return checkStoricizzazione;
  end if;


  if (checkrosalsu != 7) then
     -- passo 3. calcolo il punteggio del lavoratore
     checkPunteggio := calcolopunteggiolavoratore(p_out_prgNominativo, 'AS','S',p_valoreIsee, p_cdnUtente, p_errCode);

     if (checkPunteggio < 0) then
      return checkPunteggio;
     end if;

  end if;
 
   -- cambio lo stato della richiesta ad ELABORAZIONE MATCH solamente se lo stato precedente è "inserita"
   select DO_EVASIONE.CDNSTATORICH into statorich from DO_EVASIONE where DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;

   if (statorich = 1) then
     UPDATE DO_EVASIONE
         SET DO_EVASIONE.CDNSTATORICH = 2,
             DO_EVASIONE.DTMMOD = SYSDATE
         WHERE DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;
   end if;

  
      --commit;
      return 0;
    

 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
       --rollback;
       return -1;

end ASInsAdesioneOnlineLav;

/***********************************************************************************************
* Funzione per l'aggiornamento di una adesione ONLINE per il lavoratore specifico alla richiesta *
************************************************************************************************/
function ASUpdateAdesioneOnlineLav(
	p_prgRosa Do_Rosa.Prgrosa%TYPE,                                   -- progressivo della rosa
    p_cdnLavoratore Do_Nominativo.Cdnlavoratore%TYPE,           -- progressivo del profilo
    p_prgNominativo Do_nominativo.Prgnominativo%TYPE,           -- progressivo della rosa
    p_cdnUtente TS_UTENTE.CDNUT%TYPE,                           -- utente che effettua l'inserimento
    p_codmonoisee  do_nominativo.codmonoisee%type, -- Calcolo Isee (Da Sil o escludi)
	   p_numvaloreisee do_nominativo.NUMVALOREISEE%type,
	  p_NUMANNOPROTISTANZA do_nominativo.NUMANNOPROTISTANZA%type,  
	  p_STRPROTISTANZA do_nominativo.STRPROTISTANZA%type,  
	  p_STRIDISTANZA do_nominativo.STRIDISTANZA%type,
    p_errCode OUT number         -- Codice di Errore
) RETURN NUMBER IS
p_numklodonomi do_nominativo.numklonominativo%type;
p_prgDoNominativo  Do_nominativo.Prgnominativo%TYPE;
queryWhere varchar2(250);
checkPunteggio number;
checktipoincrocio do_incrocio.prgtipoincrocio%type;

p_out_prgNominativo DO_NOMINATIVO.Prgnominativo%TYPE;
p_valoreIsee do_nominativo.NUMVALOREISEE%type;
p_prgRichiestaAz DO_RICHIESTA_AZ.Prgrichiestaaz%TYPE;
p_prgTipoIncrocio DO_INCROCIO.Prgtipoincrocio%TYPE;
 

begin

if(p_prgNominativo is not null) then
	p_prgDoNominativo := p_prgNominativo;
else
  select   i.prgrichiestaaz,   i.prgtipoincrocio
         into   p_prgRichiestaAz,  p_prgTipoIncrocio
  from do_rosa d
  inner join do_incrocio i on i.prgincrocio = d.prgincrocio
  WHERE d.PRGROSA = p_prgRosa;

  select  nom.prgnominativo  into p_prgDoNominativo
  from do_nominativo nom
  inner join do_rosa ros on ros.prgrosa = nom.prgrosa
  inner join do_incrocio inc on inc.prgincrocio = ros.prgincrocio
  inner join do_richiesta_az rich on rich.prgrichiestaaz = inc.prgrichiestaaz
  where nom.cdnlavoratore = p_cdnLavoratore
  and inc.prgtipoincrocio = p_prgTipoIncrocio
  and rich.prgrichiestaaz = p_prgRichiestaAz
  and ros.prgrosafiglia is null;
end if;
select inc.prgtipoincrocio
 into checktipoincrocio
 from do_nominativo nom
  inner join do_rosa r on nom.prgrosa = r.prgrosa 
   inner join do_incrocio inc on r.prgincrocio = inc.prgincrocio
   where nom.prgnominativo = p_prgDoNominativo;

select t.numklonominativo into p_numklodonomi  from do_nominativo t where t.prgnominativo = p_prgDoNominativo;

    queryWhere :=  ' WHERE prgnominativo = ' || p_prgDoNominativo;

     PG_LOG.doLog('U', 'DO_NOMINATIVO', p_cdnUtente, queryWhere);

 

UPDATE DO_NOMINATIVO t
set t.NUMVALOREISEE = p_numvaloreisee,
	t.codmonoisee = p_codmonoisee,
	t.NUMANNOPROTISTANZA = p_NUMANNOPROTISTANZA,
	t.STRPROTISTANZA = p_STRPROTISTANZA,
	t.STRIDISTANZA   = p_STRIDISTANZA,
    t.numklonominativo = p_numklodonomi +1,
    t.cdnutmodcm   = p_cdnUtente,
    t.dtmmodcm     = sysdate
  where t.prgnominativo = p_prgDoNominativo;
 
if checktipoincrocio != 7 then
     checkPunteggio := calcolopunteggiolavoratore(p_prgNominativo, 'AS','S',p_numvaloreisee,  p_cdnUtente, p_errCode);
end if;

 return 0;

 exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
 --        rollback;
       return -1;

end ASUpdateAdesioneOnlineLav;

function updateAsOnlineRosa (prgParDoRichiestaAz DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE,
 flagParAsOnline DO_RICHIESTA_AZ.FLGASONLINE%TYPE,
            cdnParUtMod  TS_UTENTE.CDNUTMOD%TYPE,
p_errCode OUT number         -- Codice di Errore			
) return number is

 
  numkLoVar DO_RICHIESTA_AZ.NUMKLORICHIESTAAZ%TYPE;
  numKLoRosaVar DO_ROSA.NUMKLOROSA%TYPE;
  configNumASONLINE number;
  countRosa number;
  prgRosaVar DO_ROSA.PRGROSA%TYPE;
  flgAsOnineRosa DO_ROSA.FLGASONLINE%TYPE;
  countCandidati number;
  countEvasione number;
  queryWhere VARCHAR2(255);
  canContinue number;
  retValue number;
  dataAsOnline DO_RICHIESTA_AZ.DTMASONLINE%TYPE;
   
begin
	 
	 
	configNumASONLINE := getNumConfig('ASONLINE');
	canContinue :=1;
	retValue :=0;
  
   
		select NUMKLORICHIESTAAZ, DTMASONLINE
		into numkLoVar, dataAsOnline
		from do_richiesta_az
		WHERE PRGRICHIESTAAZ = prgParDoRichiestaAz;
  
  --caso in cui ho configurazione Art16online e flagasOnline di do_richiesta_az a S
 if (configNumASONLINE = 1 and dataAsOnline is null) then

 
		SELECT COUNT(PRGRICHIESTAAZ)
		into countEvasione
		FROM do_evasione 
		WHERE PRGRICHIESTAAZ = prgParDoRichiestaAz
		AND nvl(codevasione, 'AS') = 'AS';
		
		
 		if(countEvasione > 0  and dataAsOnline is null) then 
			canContinue :=1; --si aggiornano i dati art 16 solo se codevasione è null o è AS
		else 
			retValue := 1;
			canContinue :=0;
		end if; -- countEvasione
	 
		if(canContinue = 1) then
			select count(rosa.PRGROSA) 
			into countRosa 
			from do_rosa rosa
			INNER JOIN do_incrocio inc on (rosa.PRGINCROCIO = inc.PRGINCROCIO and inc.PRGTIPOINCROCIO = 5)
			INNER JOIN do_richiesta_az az ON (az.PRGRICHIESTAAZ  = inc.PRGRICHIESTAAZ AND az.PRGRICHIESTAAZ = prgParDoRichiestaAz )
			INNER JOIN do_evasione ev on (az.PRGRICHIESTAAZ = ev.PRGRICHIESTAAZ and ev.CODEVASIONE ='AS'  )
			WHERE rosa.PRGTIPOROSA !=3 ;
			
			if(countRosa >0) then
           
		
			begin 
              select rosa.PRGROSA, rosa.FLGASONLINE, rosa.NUMKLOROSA
              into prgRosaVar , flgAsOnineRosa, numKLoRosaVar
              from do_rosa rosa
              INNER JOIN do_incrocio inc on (rosa.PRGINCROCIO = inc.PRGINCROCIO and inc.PRGTIPOINCROCIO = 5)
			  INNER JOIN do_richiesta_az az ON (az.PRGRICHIESTAAZ  = inc.PRGRICHIESTAAZ AND az.PRGRICHIESTAAZ = prgParDoRichiestaAz )
			  INNER JOIN do_evasione ev on (az.PRGRICHIESTAAZ = ev.PRGRICHIESTAAZ and ev.CODEVASIONE ='AS'  )
              WHERE rosa.PRGTIPOROSA  = 1 ;
             exception when NO_DATA_FOUND then DBMS_OUTPUT.PUT_LINE ('no data found');
			end;
        	begin
                  select rosa.PRGROSA, rosa.FLGASONLINE, rosa.NUMKLOROSA
                  into prgRosaVar , flgAsOnineRosa, numKLoRosaVar
                  from do_rosa rosa
					INNER JOIN do_incrocio inc on (rosa.PRGINCROCIO = inc.PRGINCROCIO and inc.PRGTIPOINCROCIO = 5)
			     INNER JOIN do_richiesta_az az ON (az.PRGRICHIESTAAZ  = inc.PRGRICHIESTAAZ AND az.PRGRICHIESTAAZ = prgParDoRichiestaAz )
			        INNER JOIN do_evasione ev on (az.PRGRICHIESTAAZ = ev.PRGRICHIESTAAZ and ev.CODEVASIONE ='AS'  ) 
                  WHERE rosa.PRGTIPOROSA  = 2 ;
            exception when NO_DATA_FOUND then DBMS_OUTPUT.PUT_LINE ('no data found');
			end;
			    	         
              SELECT COUNT(prgnominativo) 
              into countCandidati
              FROM do_nominativo WHERE PRGROSA =  prgRosaVar;
                --se non ci sono candidati aggiorno
				if (countCandidati = 0 ) then
				
				queryWhere :=  ' WHERE PRGRICHIESTAAZ = ' || prgParDoRichiestaAz;
				PG_LOG.doLog('U', 'do_richiesta_az', cdnParUtMod, queryWhere);
				
				update do_richiesta_az set FLGASONLINE =flagParAsOnline, NUMKLORICHIESTAAZ =numkLoVar+1 , CDNUTMOD = cdnParUtMod, DTMMOD = sysdate 
				where PRGRICHIESTAAZ = prgParDoRichiestaAz;	
                  
                  queryWhere :=  ' WHERE prgrosa = ' || prgRosaVar;
    
                  PG_LOG.doLog('U', 'DO_ROSA', cdnParUtMod, queryWhere);
				  
				  -- se flgAsOnine = 'S' allora la rosa diventa grezza se non lo è ancora
				  if(nvl(flagParAsOnline, 'N') ='S') then
					 update do_rosa set FLGASONLINE =flagParAsOnline, DTMMOD = sysdate, CDNUTMOD = cdnParUtMod, PRGTIPOROSA = 2, NUMKLOROSA = numKLoRosaVar+1
					 where prgrosa = prgRosaVar;
				  else --flgAsOnine null o N e quindi propgago il valore del flag sulla rosa ma non ne modifico il tipo
					 update do_rosa set FLGASONLINE =flagParAsOnline, DTMMOD = sysdate, CDNUTMOD = cdnParUtMod,  NUMKLOROSA = numKLoRosaVar+1
					 where prgrosa = prgRosaVar;			  
				  end if;
 
                else --ci sono candidati non posso modificare nulla
					retValue :=2;
                end if; --countCandidati
		   else
				--se non ci sono rose posso aggiornare do_richiesta_Az
				queryWhere :=  ' WHERE PRGRICHIESTAAZ = ' || prgParDoRichiestaAz;
				PG_LOG.doLog('U', 'do_richiesta_az', cdnParUtMod, queryWhere);
				
				update do_richiesta_az set FLGASONLINE =flagParAsOnline, NUMKLORICHIESTAAZ =numkLoVar+1 , CDNUTMOD = cdnParUtMod, DTMMOD = sysdate 
				where PRGRICHIESTAAZ = prgParDoRichiestaAz;	
 
           end if; --countRosa
        end if; --canContinue
  
  end if; -- configNumASONLINE
 return retValue;
 
exception
      when others then
         p_errCode := sqlcode;
       dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
 --        rollback;
       return -1;
end updateAsOnlineRosa;

/***************************************************************************************************
* rende definitive tutte le graduatorie di quel tipo e ricalcola la posizione di ciascun lavoratore*
***************************************************************************************************/
function ASSetGraduatoriaDefOnline(p_prgRichiestaAz do_richiesta_az.prgrichiestaaz%TYPE,
                                    p_prgTipoIncrocio do_incrocio.prgtipoincrocio%TYPE)
                                   RETURN NUMBER IS

retNumber number;
p_cdnStatoRich number;

CURSOR roseCursor IS
    select r.prgrosa, r.FLGASONLINE 
    from do_richiesta_az rich
    inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
    inner join do_rosa r on r.prgincrocio = inc.prgincrocio
    inner join do_alternativa a on a.prgrichiestaaz = inc.prgrichiestaaz
    where rich.prgrichiestaaz = p_prgRichiestaAz
    and inc.prgtipoincrocio = p_prgTipoIncrocio
    and r.prgrosafiglia is null
    and r.prgtiporosa = 2
    and a.prgalternativa = inc.prgalternativa;

CURSOR roseNoAlternativeCursor IS
    select r.prgrosa, r.FLGASONLINE 
    from do_richiesta_az rich
    inner join do_incrocio inc on inc.prgrichiestaaz = rich.prgrichiestaaz
    inner join do_rosa r on r.prgincrocio = inc.prgincrocio
    where rich.prgrichiestaaz = p_prgRichiestaAz
    and inc.prgtipoincrocio = p_prgTipoIncrocio
    and r.prgrosafiglia is null
    and r.prgtiporosa = 2;

begin

   retNumber := ASCalcolaPosizione(p_prgRichiestaAz, p_prgTipoIncrocio);

   if (retnumber = 0) then

     if (p_prgTipoIncrocio = 9 or p_prgTipoIncrocio = 14) then
          FOR rose IN roseNoAlternativeCursor
          LOOP
               update do_rosa
               set do_rosa.prgTipoRosa = 3,
			   do_rosa.FLGASONLINE = rose.FLGASONLINE, 
               do_rosa.NUMKLOROSA = NUMKLOROSA+1
                   where do_rosa.prgRosa = rose.prgrosa;

          END LOOP;
     else
          FOR rose IN roseCursor
          LOOP
               update do_rosa
               set do_rosa.prgTipoRosa = 3,
			   do_rosa.FLGASONLINE = rose.FLGASONLINE, 
               do_rosa.NUMKLOROSA = NUMKLOROSA+1
                   where do_rosa.prgRosa = rose.prgrosa;

          END LOOP;
     end if;



     SELECT DO_EVASIONE.CDNSTATORICH into p_cdnStatoRich
     FROM DO_EVASIONE, DO_RICHIESTA_AZ
     WHERE DO_EVASIONE.PRGRICHIESTAAZ = DO_RICHIESTA_AZ.PRGRICHIESTAAZ
     AND DO_RICHIESTA_AZ.Prgrichiestaaz = p_prgRichiestaAz
     AND DO_RICHIESTA_AZ.NUMSTORICO = 0;

     if (p_cdnStatoRich = 2) then
       -- setto lo stato di evasione ad elaborata
       UPDATE DO_EVASIONE
       SET DO_EVASIONE.CDNSTATORICH = 3,
           DO_EVASIONE.DTMMOD = SYSDATE
       WHERE DO_EVASIONE.PRGRICHIESTAAZ = p_prgRichiestaAz;
     end if;
   end if;

   commit;

   return retNumber;

   exception
    when others then
    dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
     rollback;
         return -1;

end ASSetGraduatoriaDefOnline;

END PG_INCROCIO;
/



/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_INFO_RIASS.sql
************************************************************************************** */


CREATE OR REPLACE package PG_INFO_RIASS is
 -- Author  : Vuoto
  -- Created : 09/04/2004
  -- Purpose : Informazioni riassuntive del lavoratore o DI atro genere

 retXML  long;
  -- Public function and procedure declarations
FUNCTION infoTestataLav (pCdnLavoratore IN VARCHAR2, encrypterKey varchar2, pCdnProfilo IN VARCHAR2) return CLOB;

FUNCTION trova_motivo_ces(inputPrgMovimento IN am_movimento.prgmovimento%TYPE) RETURN varchar2;

FUNCTION trova_data_ces(inputPrgMovimento IN am_movimento.prgmovimento%TYPE) RETURN varchar2;

FUNCTION stato_occ_mobil(inputCdnLavoratore IN an_lavoratore.cdnlavoratore%TYPE) RETURN varchar2;

end PG_INFO_RIASS;
/


create or replace
package body PG_INFO_RIASS is

  -- Function and procedure implementations
  FUNCTION infoTestataLav (pCdnLavoratore IN VARCHAR2, encrypterKey varchar2, pCdnProfilo IN VARCHAR2) return CLOB is

   retXml CLOB;

   lavoratore AN_LAVORATORE%rowtype;

   attr ts_attributo%rowtype;
   abi_attr ts_abi_attributo%rowtype;

   strsezione varchar2(400);
   STRDENOMINAZIONE varchar2(400);
   contenuto_campo varchar2(400);
   prgCMIscrAperta AM_CM_ISCR.PRGCMISCR%TYPE;
   conta_cm integer := 0;
   numconfigPt ts_config_loc.num%TYPE;
  --  posiz int;

   -- Cursore degli attributi
   CURSOR cur_attr is
         select A.prgattributo,
             A.strazione,
             A.codlsttab,
             A.STRDENOMINAZIONE,
             A.Strsezione,
             AA.flgmostraelencostessariga,
             AA.prgposizione,
             a.strazione nome_campo,
             nvl(aa.FLGMOSTRAELENCOSTESSARIGA, 'N') NUOVALINEA
         from ts_abi_attributo AA,
             ts_attributo A
         where A.prgattributo = AA.prgattributo
             and aa.cdnprofilo=pCdnProfilo
             and aa.cdncomponente=105
             and A.codlsttab <> 'AM_CM_IS'
             order by aa.prgposizione, a.codlsttab, a.prgattributo;


    CURSOR cur_attr_cm is
         select A.prgattributo,
             A.strazione,
             A.codlsttab,
             A.STRDENOMINAZIONE,
             A.Strsezione,
             AA.flgmostraelencostessariga,
             AA.prgposizione,
             a.strazione nome_campo,
             nvl(aa.FLGMOSTRAELENCOSTESSARIGA, 'N') NUOVALINEA
         from ts_abi_attributo AA,
             ts_attributo A
         where A.prgattributo = AA.prgattributo
             and aa.cdnprofilo=pCdnProfilo
             and aa.cdncomponente=105
             and A.codlsttab = 'AM_CM_IS'
             order by aa.prgposizione;

    -- Cursore per il collocamento mirato
    CURSOR cur_CM is
   SELECT i.prgcmiscr
        FROM am_cm_iscr i
  INNER JOIN de_cm_tipo_iscr tis ON (i.codcmtipoiscr = tis.codcmtipoiscr)
   LEFT JOIN de_cm_tipo_invalidita tin ON (i.codtipoinvalidita = tin.codtipoinvalidita)
   LEFT JOIN de_motivo_fine_atto mot ON (i.codmotivofineatto = mot.codmotivofineatto)
  INNER JOIN am_documento_coll coll ON (i.prgcmiscr = coll.strchiavetabella)
  INNER JOIN am_documento doc ON (coll.prgdocumento = doc.prgdocumento AND doc.codtipodocumento = 'L68')
       WHERE i.cdnlavoratore = encrypt(pCdnLavoratore, encrypterKey)
		 AND doc.cdnlavoratore = pCdnLavoratore
         AND doc.codstatoatto = 'PR'
 AND NOT EXISTS (SELECT 1
                   FROM am_cm_iscr i1 INNER JOIN de_cm_tipo_iscr tis1 ON (i1.codcmtipoiscr = tis1.codcmtipoiscr)
             INNER JOIN am_documento_coll coll1 ON (i1.prgcmiscr = coll1.strchiavetabella)
             INNER JOIN am_documento doc1 ON (coll1.prgdocumento = doc1.prgdocumento)
                  WHERE i1.cdnlavoratore = encrypt(pCdnLavoratore, encrypterKey)
				 AND doc1.cdnlavoratore = pCdnLavoratore
                 AND doc1.codtipodocumento = 'L68'
                 AND doc1.codstatoatto = 'PR'
                 AND i1.datdatainizio >= i.datdatainizio
                 AND i1.prgcmiscr > i.prgcmiscr
                 AND tis1.codmonotiporagg = tis.codmonotiporagg)
    ORDER BY i.datdatainizio DESC, i.datdatafine DESC;

  begin

  ---------------------------------
  -- SELEZIONE DEL LAVORATORE
  ---------------------------------

   SELECT *
       into lavoratore
    FROM AN_LAVORATORE
        WHERE AN_LAVORATORE.CDNLAVORATORE = pCdnLavoratore;


  retXml :='<rows>';
  retXml :=retXml || '<row ';
--  retXml :=retXml || ' prgposizione="-3"';
  retXml :=retXml || ' strsezione="' || lavoratore.strcognome || '"';
  retXml :=retXml || ' strdenominazione="' || lavoratore.strnome || '"';
  retXml :=retXml || ' contenuto_campo="' || lavoratore.strcodicefiscale|| '"';
  retXml :=retXml || ' contenuto_campo1="' || to_char(lavoratore.datNasc, 'dd/mm/yyyy')|| '"';  -- 15/06/2004 aggiunta anche questa informazione
  retXml :=retXml || ' />';

  ---------------------------------
  -- SELEZIONE DEGLI ATTRIBUTI
  ---------------------------------
 -- posiz:=0;
  for cur_rec in cur_attr loop

   --   posiz:=posiz+1;

      strdenominazione:=cur_rec.strdenominazione;
      strsezione:=cur_rec.strsezione;

   ---------------------------------
      -- DICHIARAZIONE IMMEDIATA DISPONIBILITA' (DID)
      ---------------------------------

      if cur_rec.codlsttab='AM_DIC_D' then

          begin
		  
		  if (cur_rec.nome_campo = 'FLGDIDL68') then
			strdenominazione := '';
		  end if;
		  
      select CONTENUTO_CAMPO
       into contenuto_campo
       from
      (select DECODE(cur_rec.nome_campo,
                             'DATDICHIARAZIONE',decode(nvl(tab.datFine, ''),
              '', to_char(tab.datDichiarazione, 'dd/mm/yyyy'),
              tab.datFine, ''),
        'CODMOTIVOFINEATTO', decode(nvl(tab.datFine, ''),
        '', 'Did valida',
        tab.datFine, substr(demfa.STRDESCRIZIONE, 1, 15) || '...'),
		'FLGDIDL68', decode(nvl(tab.flgDidL68, 'N'),
		'N', '', 'DID fittizia finalizzata all''iscrizione L.68/99')
                             ) CONTENUTO_CAMPO, tab.PRGDICHDISPONIBILITA
               from am_dich_disponibilita tab,
        am_elenco_anagrafico tab1,
     de_motivo_fine_atto demfa
              WHERE tab1.CDNLAVORATORE = pCdnLavoratore
    AND tab.prgElencoAnagrafico = tab1.prgElencoAnagrafico
    AND tab.CODMOTIVOFINEATTO   = demfa.CODMOTIVOFINEATTO (+)
                AND tab.codStatoAtto = 'PR'
    AND tab.datDichiarazione    = (select max(tab2.datDichiarazione)
                                  from am_dich_disponibilita tab2, am_elenco_anagrafico tab3
            where tab1.CDNLAVORATORE      = tab3.cdnLavoratore
                                   AND tab2.prgElencoAnagrafico = tab3.prgElencoAnagrafico
              AND tab2.codStatoAtto = 'PR')
    AND ((trunc(nvl(tab.datfine,to_date('31/12/9999','dd/mm/yyyy'))) =
            (select max (trunc(nvl(tab4.datfine,to_date('31/12/9999','dd/mm/yyyy'))))
                  from am_dich_disponibilita tab4, am_elenco_anagrafico tab5
            where tab1.CDNLAVORATORE      = tab5.cdnLavoratore
              and tab4.prgElencoAnagrafico = tab5.prgElencoAnagrafico
              and tab4.codStatoAtto = 'PR')
     ))
      order by prgDichDisponibilita desc) tabAppoggio
      where rownum = 1
      ;
   Exception
                when NO_DATA_FOUND then
                     contenuto_campo:='';
                when OTHERS then
      raise_application_error(-20100, 'Problema nella DID del lavoratore');
             end;

		  if (cur_rec.nome_campo <> 'FLGDIDL68' or contenuto_campo = 'DID fittizia finalizzata all''iscrizione L.68/99') then
		  
			  retXml :=retXml || '<row ';
	  --        retXml :=retXml || ' prgposizione="' || posiz ||  '"';
			  retXml :=retXml || ' strsezione="' || strsezione || '"';
			  retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
			  retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
			  retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
			  retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
			  retXml :=retXml || ' />';
		  end if;


       end if;

      ---------------------------------
      -- STATO OCCUPAZIONALE
      ---------------------------------

      if cur_rec.codlsttab='AM_S_OCC' then

          begin
                       select
                               DECODE(cur_rec.nome_campo,
                                                'DATINIZIO',to_char(tab.datInizio, 'dd/mm/yyyy') ,
                                                'CODSTATOOCCUPAZ',
                                                pg_utils.trunc_desc( deso.STRDESCRIZIONE,
                                                                   45, '...')||decode(deso.CODSTATOOCCUPAZRAGG,'D',stato_occ_mobil(pCdnLavoratore),'I',stato_occ_mobil(pCdnLavoratore),'') ,
                                                'FLGPENSIONATO', tab.FLGPENSIONATO,
                                                'DATANZIANITADISOC', to_char(tab.DATANZIANITADISOC,'dd/mm/yyyy'),
                                                'FLGINDENNIZZATO', tab.FLGINDENNIZZATO,
                                                'NUMMESISOSP', tab.NUMMESISOSP
                                                ) CONTENUTO_CAMPO
                      into
                           contenuto_campo
                      from
                                 am_stato_occupaz tab,
                                 DE_STATO_OCCUPAZ deso, DE_STATO_OCCUPAZ_RAGG desorag
                     WHERE tab.CDNLAVORATORE = pCdnLavoratore
                       AND tab.datFine is null
                       AND tab.codStatoOccupaz = deso.CODSTATOOCCUPAZ
                       AND deso.CODSTATOOCCUPAZRAGG = desorag.CODSTATOOCCUPAZRAGG;
             Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20101, 'Problema nello stato occupazionale del lavoratore');
             end;


          retXml :=retXml || '<row ';
  --        retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';



       end if;


      ---------------------------------
      -- AM_PAT_L
      ---------------------------------


      if cur_rec.codlsttab='AM_PAT_L' then

          begin
		  
				select ts_config_loc.num
				into numconfigPt
				from ts_config_loc
				where ts_config_loc.codtipoconfig = 'PT_INFOR'
				and ts_config_loc.strcodrif = (select codprovinciasil from ts_generale);
				
				select
				  DECODE(cur_rec.nome_campo,
						  'FLGPATTO297', nvl(de_codifica_patto.strdescrizione, decode(upper(tab.FLGPATTO297),'S','Patto150','N','Accordo generico')),
						  'DATSTIPULA', to_char(tab.datStipula,'dd/mm/yyyy'), -- aggiunti la data di stipula e lo stato dell'atto
						  'CODSTATOATTO', desa.strDescrizione,
						  'DATSCADCONFERMA', to_char(tab.datScadConferma,'dd/mm/yyyy')
				  )
				   CONTENUTO_CAMPO
				  into
					   contenuto_campo
				  from
							 AM_PATTO_LAVORATORE tab,
							  de_stato_atto desa, de_codifica_patto
				 WHERE tab.CDNLAVORATORE = pCdnLavoratore
				   AND tab.datfine is null
				   AND tab.codStatoAtto = desa.codStatoAtto
				   AND tab.codcodificapatto = de_codifica_patto.codcodificapatto(+);

             Exception
                     when NO_DATA_FOUND then
					 if (numconfigPt = 1) then
						-- si prende ultimo patto del lavoratore e si aggiungono la data fine e il motivo chiusura
						begin
							select
									  DECODE(cur_rec.nome_campo,
											  'FLGPATTO297', nvl(de_codifica_patto.strdescrizione, decode(upper(tabPT.FLGPATTO297),'S','Patto150','N','Accordo generico')),
											  'DATSTIPULA', to_char(tabPT.datStipula,'dd/mm/yyyy'),
											  'CODSTATOATTO', desa.strDescrizione,
											  'DATSCADCONFERMA', to_char(tabPT.datScadConferma,'dd/mm/yyyy'),
											  'DATFINE', nvl(to_char(tabPT.datFine,'dd/mm/yyyy'), ''),
											  'CODMOTIVOFINE', nvl(de_motivo_fine_atto.strdescrizione, '')
									  )
									   CONTENUTO_CAMPO
							into
							   contenuto_campo
							  from (select tab.cdnlavoratore, tab.codStatoAtto, tab.codcodificapatto, tab.codmotivofineatto,
										   tab.datStipula, tab.datfine, tab.datScadConferma, tab.FLGPATTO297
									from am_patto_lavoratore tab
									where tab.CDNLAVORATORE = pCdnLavoratore
									order by tab.datstipula desc, tab.dtmins desc
							  ) tabPT, de_stato_atto desa, de_codifica_patto, de_motivo_fine_atto
							 WHERE tabPT.codStatoAtto = desa.codStatoAtto
							   AND tabPT.codcodificapatto = de_codifica_patto.codcodificapatto(+)
							   AND tabPT.codmotivofineatto = de_motivo_fine_atto.codmotivofineatto(+)
							   AND ROWNUM = 1;
					 
						Exception
							when NO_DATA_FOUND then contenuto_campo:='';
							when OTHERS then raise_application_error(-20103, 'Problema nel patto del lavoratore');
						end;
					 
					 else
						contenuto_campo:='';
					 end if;
                     
					 when OTHERS then raise_application_error(-20103, 'Problema nel patto del lavoratore');

             end;

          retXml :=retXml || '<row ';
  --        retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';



      end if;
      
      ---------------------------------
      -- SP_LAV
      ---------------------------------


      if cur_rec.codlsttab='SP_LAV' then

			begin
                      select
                          DECODE(cur_rec.nome_campo,
                                  'DATAINVIOMINSAP', to_char(dataInvioMin,'dd/mm/yyyy hh24:mi'),
                                  'STATOSAP', strDescrizione
                          )
                           CONTENUTO_CAMPO
                      into
                           contenuto_campo
                      from
                           (select tab.dataInvioMin, desa.strDescrizione, rank() over (ORDER BY tab.prgSpLav desc) prgRank
                            from SP_LAVORATORE tab, de_stato_sap desa
                            WHERE tab.CDNLAVORATORE = pCdnLavoratore
                            AND tab.codStato = desa.codStato) 
                      where prgRank = 1;

			Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20103, 'Problema nella SAP del Lavoratore');

            end;

          retXml :=retXml || '<row ';
  --        retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';



      end if;      


     ---------------------------------
      -- AM_OBBFO
      ---------------------------------


      if cur_rec.codlsttab='AM_OBBFO' then

          begin
                              select
                                      decode(cur_rec.NOME_CAMPO,
                                             'FLGOBBLIGOFORMATIVO', decode(tab.FLGOBBLIGOFORMATIVO, 'S','Sì', 'N','No', null),
                                             'FLGOBBLIGOSCOLASTICO', decode(tab.FLGOBBLIGOSCOLASTICO, 'S','Sì', 'N','No', null),
                                             'CODMODALITAASSOLV', de.STRDESCRIZIONE
                                ) CONTENUTO_CAMPO
                      into
                           contenuto_campo
                      from
                                 AM_OBBLIGO_FORMATIVO tab,
                                  DE_FO_MODALITA_ASSOLV de
                     WHERE
                       tab.CDNLAVORATORE = pCdnLavoratore
                      AND tab.CODMODALITAASSOLV = de.CODMODALITAASSOLV;

             Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20104, 'Problema nell''obbligo formativo del lavoratore');
             end;

          retXml :=retXml || '<row ';
    --      retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';



      end if;


      ---------------------------------
      -- AM_MB_IS
      ---------------------------------


      if cur_rec.codlsttab='AM_MB_IS' then
        begin
                       select
                            decode(cur_rec.NOME_CAMPO,
                             'CODTIPOMOB',DE_MB_TIPO.STRDESCRIZIONE,
                             'DATINIZIOMOV',to_char(TAB.DATINIZIOMOV,'dd/mm/yyyy'),
                             'DATFINEMOV',  to_char(TAB.DATFINEMOV,  'dd/mm/yyyy'),
                             'DATINIZIO',   to_char(tab.DATINIZIO,'dd/mm/yyyy'),
                             'DATFINE',     to_char(tab.DATFINE,  'dd/mm/yyyy'),
                             'FLGINDENNITA',tab.FLGINDENNITA,
                             'MANSIONE', DE_MANSIONE.STRDESCRIZIONE,
                             'STRRAGIONESOCIALE',pg_utils.quote(AZIENDA.STRRAGIONESOCIALE),
                             'STRDENOMINAZIONE',DE_COMUNE.STRDENOMINAZIONE
                             ) CONTENUTO_CAMPO

                      into
                           contenuto_campo
                      from
                                 AM_MOBILITA_ISCR tab, DE_MB_TIPO, AN_AZIENDA AZIENDA, AN_UNITA_AZIENDA, DE_COMUNE, DE_MANSIONE
                      WHERE tab.CDNLAVORATORE = pCdnLavoratore
                     
                      AND nvl(trunc(tab.datfine),trunc(SYSDATE)) >= trunc(SYSDATE)
                      
                      AND tab.CODTIPOMOB = DE_MB_TIPO.CODMBTIPO(+)
                      AND TAB.PRGAZIENDA = AZIENDA.PRGAZIENDA(+)
                      AND TAB.PRGAZIENDA = AN_UNITA_AZIENDA.PRGAZIENDA(+)
                      AND TAB.PRGUNITA = AN_UNITA_AZIENDA.PRGUNITA(+)
                      AND TAB.CODMANSIONE = DE_MANSIONE.CODMANSIONE(+)
                      AND AN_UNITA_AZIENDA.CODCOM = DE_COMUNE.CODCOM(+);

             Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20105, 'Problema nella mobilita del lavoratore');
             end;

          retXml :=retXml || '<row ';
   --       retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';



      end if;



      ---------------------------------
      -- AM_EX_PS
      ---------------------------------


      if cur_rec.codlsttab='AM_EX_PS' then
            begin
                      select
                            decode(cur_rec.NOME_CAMPO,
                                       'DATRICHIESTA', to_char(datRichiesta,'dd/mm/yyyy'),
                                       'CODSTATUS',decode(tab.CODSTATUS, '2', 'Carta sogg.', '5', 'Carta sogg.', '1', 'No', '3','No',null),
                                       'CODSTATORICHIESTA',DE_STATO_ATTO.STRDESCRIZIONE,
                                       'CODMOTIVORIL', DE_EX_MOTIVO_RIL.STRDESCRIZIONE
                          ) CONTENUTO_CAMPO
                      into
                           contenuto_campo
                      from
                                 AM_EX_PERM_SOGG tab, DE_EX_MOTIVO_RIL, DE_STATO_ATTO
                     WHERE tab.CDNLAVORATORE = pCdnLavoratore
        AND tab.DATFINE is not null
                       AND tab.CODMOTIVORIL = DE_EX_MOTIVO_RIL.CODMOTIVORIL
                       AND tab.CODSTATORICHIESTA = DE_STATO_ATTO.CODSTATOATTO;

             Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20106, 'Problema nel permesso di soggiorno del lavoratore');
             end;

          retXml :=retXml || '<row ';
   --       retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';



      end if;


      ---------------------------------
      -- AM_IND_T
      ---------------------------------


      if cur_rec.codlsttab='AM_IND_T' then

          begin
                   select
                             DECODE(cur_rec.nome_campo,
                                              'DATINIZIO',to_char(DATINIZIO,'dd/mm/yyyy'),
                                              'DATFINE',  to_char(DATFINE,'dd/mm/yyyy'),
                                              'CODINDISPTEMP', DE_INDISP_TEMP.STRDESCRIZIONE
                                   ) CONTENUTO_CAMPO
                         into
                                 CONTENUTO_CAMPO
                       from
                                 AM_INDISP_TEMP tab, DE_INDISP_TEMP
                     WHERE tab.CDNLAVORATORE = pCdnLavoratore
                       AND NVL (TAB.datfine, SYSDATE) >= SYSDATE
                       AND TAB.datFine     = (select  max(tab1.datFine)
                                                from am_indisp_temp tab1
                                               where tab1.cdnLavoratore = tab.cdnLavoratore)
                       and rownum = 1
                       AND (TAB.codindisptemp = DE_INDISP_TEMP.codindisptemp);

             Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20107, 'Problema nell''indisponibilita temporanea del lavoratore');
             end;

          retXml :=retXml || '<row ';
   --       retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';



      end if;


      ---------------------------------
      -- AM_MOV
      ---------------------------------


      if cur_rec.codlsttab='AM_MOV' then

          begin
                       select
                             DECODE(cur_rec.NOME_CAMPO,
                        'CODCONTRATTO',-- 29/07/2004 corrispondenza
                        -- con tipo di assunzione in alcuni casi non può
                                 substr(case    -- essere univoca (esempio per AD6)
                when DE_CONTRATTO.codContratto = 'LT' -- tempo determinato
           then decode (tab.codMonoTempo,
                        'D', DE_CONTRATTO.STRDESCRIZIONE,
               'I', 'Lavoro dipendente TI')
                when DE_CONTRATTO.codContratto = 'LP' -- tempo indeterminato
           then decode (tab.codMonoTempo,
                        'D', 'Lavoro dipendente TD',
               'I', DE_CONTRATTO.STRDESCRIZIONE)
                when DE_CONTRATTO.codContratto not in ('LT', 'LP')
           then DE_CONTRATTO.STRDESCRIZIONE
             end, 1, 30) || ' ...' ,
                        'CODMANSIONE', SUBSTR(DE_MANSIONE.STRDESCRIZIONE, 1, 50) || ' ...',
                        'DATINIZIOAVV', case
                         when nvl(tab.DATINIZIOAVV, sysdate) = sysdate
              then tab.codTipoMov || ' ' || to_char(DATINIZIOMOV,'dd/mm/yyyy')
             when nvl(tab.DATINIZIOAVV, sysdate) <> sysdate
              then 'AVV'          ||  ' ' || to_Char(DATINIZIOAVV,'dd/mm/yyyy')
                end ,
                                    'DATFINEMOVEFFETTIVA', trova_data_ces(tab.prgmovimento)||trova_motivo_ces(tab.prgmovimento),
         'STRRAGIONESOCIALE', pg_utils.quote(SUBSTR(AN_AZIENDA.STRRAGIONESOCIALE, 1, 50)) || ' ...',
         'CODORARIO',         pg_utils.quote(SUBSTR(DE_ORARIO.STRDESCRIZIONE, 1, 25)) || ' ...'
                       ) CONTENUTO_CAMPO
                         into
                                 CONTENUTO_CAMPO
                       from
                                AM_MOVIMENTO tab,
        DE_CONTRATTO,
        DE_MANSIONE,
        AN_AZIENDA,
        DE_TIPO_CONTRATTO TIPOASS,
        DE_ORARIO
                     WHERE tab.CDNLAVORATORE = pCdnLavoratore
        AND tab.codtipocontratto = TIPOASS.codtipocontratto(+)
        AND codStatoAtto = 'PR' -- ESCLUDO ANNULLATI
                       AND
         ( (   (tab.DATFINEMOVEFFETTIVA IS NULL
                              AND tab.datInizioMov = (SELECT MAX(tab1.datInizioMov)
                                                    FROM AM_MOVIMENTO tab1,
               DE_TIPO_CONTRATTO dta
                                                   WHERE tab1.CODTIPOCONTRATTO = dta.CODTIPOCONTRATTO(+)
                 AND tab1.DATFINEMOVEFFETTIVA IS NULL
                                                     AND tab1.CDNLAVORATORE = tab.CDNLAVORATORE
              AND codStatoAtto = 'PR' -- ESCLUDO ANNULLATI
              AND tab1.CODTIPOMOV  <> 'CES'
              AND nvl(dta.codmonotipo,' ') <> 'T')
                                                 )
                           OR (NOT exists (SELECT tab1.datInizioMov
                                                    FROM AM_MOVIMENTO tab1,
               DE_TIPO_CONTRATTO dta
                                                   WHERE tab1.CODTIPOCONTRATTO = dta.CODTIPOCONTRATTO(+)
                 AND tab1.DATFINEMOVEFFETTIVA IS NULL
                                                     AND tab1.CDNLAVORATORE = tab.CDNLAVORATORE
              AND codStatoAtto = 'PR' -- ESCLUDO ANNULLATI
              AND tab1.CODTIPOMOV  <> 'CES'
              AND nvl(dta.codmonotipo,' ') <> 'T')
                              AND tab.datFineMovEFFETTIVA = (SELECT MAX(tab1.datFineMovEFFETTIVA)
                                                                          FROM AM_MOVIMENTO tab1,
                         DE_TIPO_CONTRATTO dta
                                                                         WHERE tab1.CODTIPOCONTRATTO = dta.CODTIPOCONTRATTO(+)
                     AND NOT tab1.DATFINEMOVEFFETTIVA IS NULL
                                                                           AND tab1.CDNLAVORATORE = tab.CDNLAVORATORE
                     AND codStatoAtto = 'PR' -- ESCLUDO ANNULLATI
                     AND tab1.CODTIPOMOV  <> 'CES'
                     AND nvl(dta.codmonotipo,' ') <> 'T')
                                                 )
                            ) AND tab.CODTIPOMOV  <> 'CES'

                      OR ( NOT exists (SELECT tab1.datInizioMov
                                         FROM AM_MOVIMENTO tab1,
             DE_TIPO_CONTRATTO dta
                                        WHERE tab1.CODTIPOCONTRATTO = dta.CODTIPOCONTRATTO(+)
            AND tab1.CDNLAVORATORE = tab.CDNLAVORATORE
            AND codStatoAtto = 'PR' -- ESCLUDO ANNULLATI
            AND tab1.CODTIPOMOV  <> 'CES'
            AND nvl(dta.codmonotipo,' ') <> 'T')
            AND tab.datInizioMov = (SELECT MAX(tab1.datInizioMov)
                                                     FROM AM_MOVIMENTO tab1,
                  DE_TIPO_CONTRATTO dta
                                                    WHERE tab1.CODTIPOCONTRATTO = dta.CODTIPOCONTRATTO(+)
                  AND tab1.CDNLAVORATORE = tab.CDNLAVORATORE
                  AND codStatoAtto = 'PR' -- ESCLUDO ANNULLATI
                  AND tab1.CODTIPOMOV  = 'CES'
                  AND nvl(dta.codmonotipo,' ') <> 'T')
       AND tab.CODTIPOMOV  = 'CES')
      )
                            and rownum = 1
                            AND tab.CODCONTRATTO= DE_CONTRATTO.CODCONTRATTO(+)
                            AND tab.CODMANSIONE = DE_MANSIONE.CODMANSIONE (+)
       AND tab.PRGAZIENDA  = AN_AZIENDA.PRGAZIENDA
       AND nvl(TIPOASS.codmonotipo,' ') <> 'T'
       AND tab.CODORARIO   = DE_ORARIO.CODORARIO (+)
     ;

             Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20108, 'Problema nei movimenti del lavoratore');
             end;

          retXml :=retXml || '<row ';
   --       retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';


      ---------------------------------
      -- PR_STU
      ---------------------------------


      elsif cur_rec.codlsttab='PR_STU' then

          begin
                      select
                           DECODE(cur_rec.NOME_CAMPO,
                      'CODTIPOTITOLO',tit2.STRDESCRIZIONE,
                      'CODTITOLO',    tit.STRDESCRIZIONE,
                      'NUMANNO', NUMANNO
                       ) CONTENUTO_CAMPO
                        into
                                 CONTENUTO_CAMPO
                       from
                                pr_studio tab,
                                de_titolo tit,
                                de_titolo tit2
                     WHERE tab.CDNLAVORATORE = pCdnLavoratore
                            AND  tab.codtitolo=tit.codtitolo
                            AND  tab.codtipotitolo=tit2.codtitolo
                            and  nvl(tab.flgprincipale,'N')='S';


             Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20109, 'Problema nei titoli di studio del lavoratore');

             end;

          retXml :=retXml || '<row ';
   --       retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';


      ---------------------------------
      -- PR_COR
      ---------------------------------


      elsif cur_rec.codlsttab='PR_COR' then

          begin
                       select
                           DECODE(cur_rec.NOME_CAMPO,
                        'CODCORSO', DE_CORSO.STRDESCRIZIONE,
                        'NUMANNO', tab.NUMANNO,
                        'FLGCOMPLETATO', DECODE(tab.FLGCOMPLETATO, 'S','Sì',  'N','No')
                          ) CONTENUTO_CAMPO
                       into
                                 CONTENUTO_CAMPO
                       from
                                PR_CORSO tab, DE_CORSO
                     WHERE tab.CDNLAVORATORE = pCdnLavoratore
                      AND (  ( NVL(tab.FLGCOMPLETATO, 'N') = 'N'
                               AND tab.numAnno = (select max(tab1.numAnno)
                                                 from pr_corso tab1
                                           WHERE tab1.CDNLAVORATORE = tab.CDNLAVORATORE
                                           and NVL(tab.FLGCOMPLETATO, 'N') = 'N')
                         )

                           OR   (NVL(tab.FLGCOMPLETATO, 'N') = 'S'
                             AND tab.numAnno = (select max(tab1.numAnno)
                                                  from pr_corso tab1
                                              WHERE tab1.CDNLAVORATORE = tab.CDNLAVORATORE
                                             and NVL(tab.FLGCOMPLETATO, 'N') = 'S')
                                   )
                                 )
                     and rownum = 1
                        AND tab.CODCORSO      = DE_CORSO.CODCORSO
                     AND  NVL(tab.FLGCOMPLETATO, 'N') = 'N';


             Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20110, 'Problema nei corsi di formazione professionale del lavoratore');
             end;

          retXml :=retXml || '<row ';
    --      retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';


      ---------------------------------
      -- EA
      ---------------------------------


      elsif cur_rec.codlsttab='EA' then

          begin
             select
                           DECODE(cur_rec.NOME_CAMPO,
                                          'DATINIZIO',to_char(tab.datInizio, 'dd/mm/yyyy')
                       ) CONTENUTO_CAMPO
                       into
                                 CONTENUTO_CAMPO
                       from
                                am_elenco_anagrafico tab
                     WHERE tab.CDNLAVORATORE = pCdnLavoratore
                       AND tab.datCan is null;


             Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20111, 'Problema nell''elenco anagrafico del lavoratore');
             end;

          retXml :=retXml || '<row ';
    --      retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';


      ---------------------------------
      -- AN_LAV_S
      ---------------------------------


      elsif cur_rec.codlsttab='AN_LAV_S' then

          begin

                       select
                             DECODE(cur_rec.nome_campo,
                                   'CODCPITIT', decode(tab.codMonoTipoCpi,
                                'C', tab1.strDescrizione,
                          'T', tab1.strDescrizione,
              'E', '')
            || '   ' || decode(tab.codMonoTipoCpi,
                                                              'C', '(Comp)',
                       'T', '(Tit)',
                       'E', '(Est)')
                                           ) || ' ' ||
              -- cpi competente se titolarità su codCpiTit
           decode(tab.codMonoTipoCpi,
                                'C', null,
                          'T', tab2.strDescrizione || '(Comp)',
              'E', '')
             CONTENUTO_CAMPO
                       into
                                           CONTENUTO_CAMPO
                       from
                                an_lav_storia_inf tab, de_cpi tab1, de_cpi tab2
                     WHERE tab.CDNLAVORATORE = pCdnLavoratore
                    AND tab.codCpiTit  = tab1.codCpi
        AND tab.CodCpiOrig = tab2.codCpi(+)
                       AND tab.datFine is null;
               Exception
                       when NO_DATA_FOUND then
                       contenuto_campo:='';
                     when OTHERS then raise_application_error(-20112, 'Problema nelle informazioni storiche del lavoratore');
             end;



          retXml :=retXml || '<row ';
       --   retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';



   ---------------------------------
      -- AM_DOC
      ---------------------------------


      elsif cur_rec.codlsttab='AM_DOC' then

          begin
                   select
                       DECODE(cur_rec.nome_campo,
                                              'DATFINE',to_char(DATFINE,'dd/mm/yyyy'),
                                              'STRNUMDOC',  STRNUMDOC,
                                              'CODTIPODOCUMENTO', DE_DOC_TIPO.STRDESCRIZIONE
                                   ) CONTENUTO_CAMPO
                         into
                                 CONTENUTO_CAMPO
                       from
                                 AM_DOCUMENTO tab, DE_DOC_TIPO
                     WHERE tab.CDNLAVORATORE = pCdnLavoratore
                       AND NVL (TAB.datfine, SYSDATE) >= SYSDATE
        AND flgDocIdentifP        = 'S'
                       AND (TAB.codTipoDocumento = DE_DOC_TIPO.codTipoDocumento)
                       and TAB.codStatoAtto <> 'AU'
        AND ROWNUM = 1; -- CONTROLLI DA FARE IN MODO CHE ESISTA UN SOLO DOCUMENTO DI IDENTIFICAZIONE PRINCIPALE

             Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20113, 'Problema nel documento di identificazione del lavoratore');
             end;

          retXml :=retXml || '<row ';
          --       retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';



      elsif cur_rec.codlsttab='AM_ISCR' then
           begin
               select CONTENUTO_CAMPO
       		   	into contenuto_campo
       			from
              (select
                           DECODE(cur_rec.NOME_CAMPO,
                                 'CODTIPOISCR', tab1.strdescrizione,
                                 'DATINIZIO', to_char(tab.datinizio, 'dd/mm/yyyy'),
                                 'DATFINE', to_char(tab.datfine, 'dd/mm/yyyy'),
                                 'CODMOTCHIUSURAISCR', tab2.strdescrizione,
                                 'RAGSOC', pg_utils.quote(SUBSTR(tab3.STRRAGIONESOCIALE, 1, 50)) || ' ...'
                       ) CONTENUTO_CAMPO
                       from am_altra_iscr tab, de_tipo_iscr tab1,
                       de_motivo_chiusuraiscr tab2, an_azienda tab3
                     WHERE tab.codtipoiscr = tab1.codtipoiscr
                       AND tab.codmotchiusuraiscr = tab2.codmotchiusuraiscr (+)
                       AND tab.prgazienda = tab3.prgazienda (+)
                       AND tab.CDNLAVORATORE = pCdnLavoratore
                       AND tab.codstato is null
                       order by tab.datinizio desc) tabAppoggio
               where rownum = 1;

                Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20111, 'Problema nell''elenco altre iscrizioni del lavoratore');
           end;

          	retXml :=retXml || '<row ';
          	retXml :=retXml || ' strsezione="' || strsezione || '"';
          	retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          	retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          	retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          	retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          	retXml :=retXml || ' />';

      end if;
	  
	  
	  if cur_rec.codlsttab='AM_CONS' then

          begin
					  select
							  decode(cur_rec.NOME_CAMPO,
									 'CODSTATOCONSENSO', de.STRDESCRIZIONE,
									 'DATREGISTRAZIONE', to_char(tab.datregistrazione, 'dd/mm/yyyy'),
									 'DATREVOCA', to_char(tab.DATREVOCA, 'dd/mm/yyyy')
						) CONTENUTO_CAMPO
                      into
                           contenuto_campo
                      from
                                 AM_CONSENSO_FIRMA tab,
                                 DE_STATO_CONSENSO de
                     WHERE
                       tab.CDNLAVORATORE = pCdnLavoratore
                      AND tab.CODSTATOCONSENSO = de.CODSTATOCONSENSO;

             Exception
                     when NO_DATA_FOUND then
                     contenuto_campo:='';
                     when OTHERS then raise_application_error(-20114, 'Problema nel consenso');
             end;

          retXml :=retXml || '<row ';
    --      retXml :=retXml || ' prgposizione="' || posiz ||  '"';
          retXml :=retXml || ' strsezione="' || strsezione || '"';
          retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
          retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo|| '"';
          retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
          retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
          retXml :=retXml || ' />';



      end if;
	  
	  


   end loop;


   ------------------------------------------
   --   AM_CM_IS
   ------------------------------------------

   for cur_recCM in cur_CM loop
      conta_cm := conta_cm + 1;
      prgCMIscrAperta := cur_recCM.prgcmiscr;
      for cur_rec in cur_attr_cm loop
       begin
         strdenominazione:=cur_rec.strdenominazione;
         strsezione:=cur_rec.strsezione;
        select
            decode(cur_rec.nome_campo,
           'DATDATAINIZIO',to_char(tab.datDataInizio, 'dd/mm/yyyy'),
           'CODCMTIPOISCR',deso.strdescrizione,
           'CODTIPOINVALIDITA', substr(deti.STRDESCRIZIONE, 1, 28) || ' ...',
           'NUMPERCINVALIDITA', tab.NUMPERCINVALIDITA || '%',
     'CODACCERTSANITARIO', deac.strDescrizione,
        -- 03/09/2007 nuovi campi da visualizzare nelle INFO
        'DATANZIANITA68', to_char(tab.datanzianita68, 'dd/mm/yyyy'),
        'DATVERBALEDAREVISIONARE', to_char(acc.datverbaledarevisionare, 'dd/mm/yyyy'),
        'CODMOTIVOFINEATTO', motFA.Strdescrizione
          ) CONTENUTO_CAMPO
         into
          contenuto_campo
         from
             am_cm_iscr tab,
             DE_CM_TIPO_ISCR deso,
    de_cm_accert_sanitario deac,
    de_cm_tipo_invalidita  deti,
       cm_verbale_accert acc,
       DE_MOTIVO_FINE_ATTO motFA
         WHERE tab.codCMTipoIscr = deso.CODCMTIPOISCR AND
       tab.codAccertSanitario = deac.CODACCERTSANITARIO(+) AND
         tab.CODTIPOINVALIDITA  = deti.CODTIPOINVALIDITA(+) AND
           tab.CODMOTIVOFINEATTO  = motFA.Codmotivofineatto(+) AND
           tab.prgverbaleacc  = acc.prgverbaleacc(+) AND
         tab.prgcmiscr = prgCMIscrAperta;

   Exception
       when NO_DATA_FOUND then contenuto_campo:='';
       when OTHERS then raise_application_error(-20102, 'Problema nel collocamento mirato del lavoratore');

  end;

  retXml :=retXml || '<row ';
       retXml :=retXml || ' strsezione="' || strsezione || '"';
     retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
     retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo || '"';
     retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
     retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
     retXml :=retXml || ' />';

   end loop;
   end loop;

   if (conta_cm = 0) then
     for cur_rec in cur_attr_cm loop
        strdenominazione:=cur_rec.strdenominazione;
        strsezione:=cur_rec.strsezione;
        contenuto_campo := '';
      retXml :=retXml || '<row ';
       retXml :=retXml || ' strsezione="' || strsezione || '"';
     retXml :=retXml || ' strdenominazione="' || strdenominazione || '"';
     retXml :=retXml || ' nome_campo="' || cur_rec.nome_campo || '"';
     retXml :=retXml || ' contenuto_campo="' || contenuto_campo|| '"';
     retXml :=retXml || ' nuovalinea="' || cur_rec.NUOVALINEA || '"';
     retXml :=retXml || ' />';
     end loop;
   end if;


   retXml :=retXml || '</rows>';
   return retXml;

 end infoTestataLav;

--Trova il motivo di Cessazione finale a partire da un movimento protocollato qualsiasi
FUNCTION trova_motivo_ces(inputPrgMovimento IN am_movimento.prgmovimento%TYPE) RETURN varchar2
IS
VarTipo varchar(3);
VarMovi am_movimento.prgmovimento%TYPE;
VarSucc am_movimento.prgmovimento%TYPE;
VarCodMvCessazione am_movimento.codmvcessazione%TYPE;
VarDescCes de_mv_cessazione.STRDESCRIZIONE%TYPE;

BEGIN
  varMovi := inputPrgMovimento;
  select codtipomov, nvl(prgmovimentosucc,-1), nvl(codmvcessazione, ' ')
    into VarTipo, VarSucc, VarCodMvCessazione
    from am_movimento
      where prgmovimento = varMovi;

   WHILE ( ((VarTipo <> 'CES') or (VarTipo = 'CES' and VarCodMvCessazione = 'SC')) and VarSucc <> -1) loop
     VarMovi := VarSucc;
     select codtipomov, nvl(prgmovimentosucc,-1), nvl(codmvcessazione, ' ')
     into VarTipo, VarSucc, VarCodMvCessazione
     from am_movimento
    where prgmovimento = varMovi;
   END LOOP;

   select de_mv_cessazione.STRDESCRIZIONE
     into VarDescCes
     from am_movimento, de_mv_cessazione
    where  am_movimento.CODMVCESSAZIONE = de_mv_cessazione.CODMVCESSAZIONE
      and prgmovimento=VarMovi;

   return ' ('||VarDescCes||')';

EXCEPTION
  WHEN OTHERS THEN
   RETURN '';
END;

--Trova la data di cessazione finale a partire da un movimento protocollato qualsiasi
FUNCTION trova_data_ces(inputPrgMovimento IN am_movimento.prgmovimento%TYPE) RETURN varchar2
IS
VarTipo varchar(3);
VarMovi am_movimento.prgmovimento%TYPE;
VarSucc am_movimento.prgmovimento%TYPE;
VarCodMvCessazione am_movimento.codmvcessazione%TYPE;
VarDataFine varchar2(10);

BEGIN
  varMovi := inputPrgMovimento;
  select codtipomov, nvl(prgmovimentosucc,-1), nvl(codmvcessazione, ' '), decode(codtipomov,'CES',to_char(datiniziomov,'dd/mm/yyyy'),to_char(datfinemov,'dd/mm/yyyy'))
    into VarTipo, VarSucc, VarCodMvCessazione, VarDataFine
    from am_movimento
      where prgmovimento = varMovi;

   WHILE ( ((VarTipo <> 'CES') or (VarTipo = 'CES' and VarCodMvCessazione = 'SC')) and VarSucc <> -1) loop
     VarMovi := VarSucc;
     select codtipomov, nvl(prgmovimentosucc,-1), nvl(codmvcessazione, ' '), decode(codtipomov,'CES',to_char(datiniziomov,'dd/mm/yyyy'),to_char(datfinemov,'dd/mm/yyyy'))
     into VarTipo, VarSucc, VarCodMvCessazione, VarDataFine
     from am_movimento
    where prgmovimento = varMovi;

	dbms_output.put_line(''||VarTipo||VarSucc||VarCodMvCessazione||VarDataFine);

   END LOOP;

   return VarDataFine;

EXCEPTION
  WHEN OTHERS THEN
   RETURN '';
END;

-- Verifica se lo stato occupazionale deriva da Mobilità
FUNCTION stato_occ_mobil(inputCdnLavoratore IN an_lavoratore.cdnlavoratore%TYPE) RETURN varchar2
IS
VarcontaDID number;
VarcontaMob number;
BEGIN

  VarcontaDID :=0;
  VarcontaMob :=0;
  select count(1)
    into VarcontaDID
    from am_dich_disponibilita, am_elenco_anagrafico
   where am_dich_disponibilita.PRGELENCOANAGRAFICO= am_elenco_anagrafico.PRGELENCOANAGRAFICO
     and am_elenco_anagrafico.CDNLAVORATORE = inputCdnLavoratore
     and am_dich_disponibilita.CODSTATOATTO = 'PR'
  ;

  if VarcontaDID = 0 then
    select count(1)
      into VarcontaMob
      from am_mobilita_iscr
     where cdnlavoratore = inputCdnLavoratore
    ;
  end if;

  IF VarcontaMob > 0 THEN
   return ' (da MOB)';
  ELSE
   return '';
  END IF;


EXCEPTION
  WHEN OTHERS THEN
   RETURN '';
END;

end PG_INFO_RIASS;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_JOB.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_JOB AS

/**********************************
* Versione 1.0                    *
*                                 *
* Autori: Tiziana Valentini       *
*         Franco Vuoto            *
*								  *
* In questo package vanno poste   *
* le procedure richiamate da JOB  *
*                                 *
***********************************/

Procedure chiudi_pubblicazioni_scadute;

END PG_JOB;
/

CREATE OR REPLACE PACKAGE BODY PG_JOB AS

Procedure chiudi_pubblicazioni_scadute
IS
BEGIN
	
	update do_evasione
	set cdnstatorich = 5, codmotivochiusurarich = 'C3'
	where codevasione in ('DFA','DFD')
	and  cdnstatorich <> 5
	and prgrichiestaaz in 
	(select prgrichiestaaz
	from do_richiesta_az
	where flgpubblicata = 'S'
	and datscadenzapubblicazione < sysdate);
	
	commit;

END chiudi_pubblicazioni_scadute;

END PG_JOB;
/





/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_LOG.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_LOG IS

    /*
     * Author  : ROLFINI / ANTENUCCI.
     * Created : 12/08/2004 / 16/09/2004
     * Purpose : Package per la gestione dei log.
     * Version : 1.1  .
     */


  TYPE campiTabellaCursorType is ref cursor;


--*******************************************************
--* PRIVATE                                             *
--*******************************************************
 procedure getCampiTabella(curCampiTabella in out campiTabellaCursorType,
                          strNomeTabella in DE_LST_TAB.strNomeTabella%type);


 procedure getTab2Log(listaTab2Log in out campiTabellaCursorType);


--*******************************************************
--* PUBLIC                                              *
--*******************************************************
 function registraLog (strNomeTabella in DE_LST_TAB.strNomeTabella%type,
                       tipoOp varchar)
                       return varchar2;

 function createScriptLgTable(strNomeTabella in DE_LST_TAB.strNomeTabella%type) return varchar2;

 function createScriptLgSequence(strNomeTabella in DE_LST_TAB.strNomeTabella%type) return varchar2;

 function createScriptLgTrigger(strNomeTabella in DE_LST_TAB.strNomeTabella%type) return varchar2;


 procedure generateLogScript;

 function mustLog(pNomeTabella in varchar2) return number;

    /*
     * Esegue il LOG per Update/Delete ('U'/'D') sulla tabella nomeTabella
	 * (tabella reale, non quella di LOG, per es ''AN_AZIENDA') per
     * l'utente passato. Nel campo strClausolaWhere occorre passare
	 * sottoforma di STRINGA l'intera clausola di WHERE che verrà usata
	 * nella successiva query di update/delete.
	 *
	 * ATTENZIONE: se la parte di WHERE SQL originale contiene delle
	 * stringhe delimitate da apice, occorre eseguirne l'ESCAPE prima
	 * di invocare questa procedura.
	 * Per es: una WHERE FLAG = 'S' diventa la stringa 'WHERE FLAG = ''S''' 
	 *   
     * by Luigi Antenucci.
     */
  PROCEDURE doLog(charUD IN VARCHAR2,
                  nomeTabella IN VARCHAR2,
                  utente IN TS_UTENTE.CDNUT%TYPE,
                  strClausolaWhere IN VARCHAR2);

end PG_LOG;
/

CREATE OR REPLACE PACKAGE BODY PG_LOG IS


--*******************************************************
--* PRIVATE                                             *
--*******************************************************

procedure getCampiTabella(curCampiTabella in out campiTabellaCursorType,
                          strNomeTabella in DE_LST_TAB.strNomeTabella%type) is

begin
  open  curCampiTabella for
    Select atc.column_name,
           atc.data_type, atc.data_length,
           atc.data_precision, atc.data_scale
      from all_tab_cols atc
      where atc.owner = user
       and atc.table_name = upper(strNomeTabella)
--       and column_name not in ('CDNUTINS', 'DTMINS', 'DTMMOD')
--       and column_name not like 'NUMKLO%'
  	   and column_name not like 'SYS_%';


end getCampiTabella;



procedure getTab2Log(listaTab2Log in out campiTabellaCursorType) is

begin
  open  listaTab2Log for
  select strNomeTabella as tab2Log
  from TS_TABLOG
  where flgLog='S';

end getTab2Log;

    /*
     * Rende una stringa con l'elenco delle colonne della
     * tabella data separate da virgola.
     * by Luigi Antenucci.
     */
    FUNCTION getTableCols(nomeTabella IN VARCHAR2)
                           RETURN VARCHAR2
    IS
        CURSOR colCursor (nomeTabella IN VARCHAR2)
        IS
            SELECT COLUMN_NAME
            FROM COLS C
               WHERE C.TABLE_NAME = nomeTabella;
        strRet VARCHAR2(4096);
        colName COLS.COLUMN_NAME%TYPE;
    BEGIN
        strRet := '';
        OPEN colCursor(nomeTabella);
        LOOP
            FETCH colCursor INTO colName;
            EXIT WHEN colCursor%NOTFOUND;
            strRet := strRet || colName || ', ';
        END LOOP;
        CLOSE colCursor;
        RETURN strRet;
    END getTableCols;



--*******************************************************
--* PUBLIC                                              *
--*******************************************************

--NON è PIù COMPATIBILE
function registraLog (strNomeTabella in DE_LST_TAB.strNomeTabella%type,
                       tipoOp varchar)return varchar2 is

    -- LA PROCEDURA SERVE PER REGISTRARE LE MODIFICHE AVVENUTE SUI CAMPI DELLE TABELLE

      nomeTabellaLog varchar2(30);
      stringaInsert1 varchar2(4000):='';
      stringaInsert2 varchar2(4000):='';
      stringaInsertTot varchar2(4000):='';

      nomeCampo all_tab_cols.column_name%type;
      tipoDato all_tab_cols.data_type%type;
      lunghezza all_tab_cols.data_length%type;
      precisione all_tab_cols.data_precision%type;
      decimali all_tab_cols.data_scale%type;

      i integer;

      -- variabili di gestione del cursore
      VarCid INTEGER; -- id cursore sql dinamico
      VarIgnore Integer;
      VarContatore binary_integer := 0;

      curCampiTabella campiTabellaCursorType;

   begin

      --imposto la tabella target e la query di insert
      nomeTabellaLog := 'LG_' || strNomeTabella;
      stringaInsert1 := 'INSERT INTO ' || nomeTabellaLog || '(prgLog, strTipoOp, dtmMod ';

      -- cursore contenente la lista (varContenutoCampoOld, varContenutoCampoNew)
      -- dei campi di una determinata tabella
      getCampiTabella(curCampiTabella, strNomeTabella);

      i:=0;
      LOOP
         fetch curCampiTabella into nomeCampo, tipoDato, lunghezza, precisione, decimali;
         EXIT WHEN curCampiTabella%NOTFOUND;
         i:=i+1;
         stringaInsert1 := stringaInsert1 || ', ' || nomeCampo;
         stringaInsert2:=stringaInsert2||', '||':'||i;
      END LOOP;
      CLOSE curCampiTabella;

      stringaInsert1:=stringaInsert1||') values ( S_'||nometabellalog||'.NextVal'||', '|| CHR(39) || tipoOp || CHR(39)|| ', sysdate ';
      stringaInsert2:=stringaInsert2||')';

    stringaInsertTot:=stringaInsert1||stringaInsert2;

    return stringaInsertTot;

end registraLog;


function createScriptLgTable(strNomeTabella in DE_LST_TAB.strNomeTabella%type) return varchar2
 IS

       curCampiLgTab campiTabellaCursorType;

       nomeColonna all_tab_cols.column_name%type;
       tipoDato all_tab_cols.data_type%type;
       lunghezza all_tab_cols.data_length%type;
       precisione all_tab_cols.data_precision%type;
       decimali all_tab_cols.data_scale%type;

       query clob;


 begin

      getCampiTabella(curCampiLgTab, strNomeTabella);

       --imposto la query di creazione della tabella
       query:='CREATE TABLE LG_' || strNomeTabella || ' (PRGLOG NUMBER(38) NOT NULL, STRTIPOOP CHAR(1), CDNUTLOG NUMBER(38), DTMMODLOG DATE';

       -- inserisco i campi che mi interessano
       loop
           fetch curCampiLgTab into nomeColonna, tipoDato, lunghezza, precisione, decimali;
           exit when curCampiLgTab%NOTFOUND;
          -- Dbms_Output.Put_Line(nomeColonna || ' ' || tipoDato || ' ' || lunghezza);     

           query:=query||', '||   CHR(10)||nomeColonna||' '||tipoDato;
           -- se il tipo di dato è un number prendo la precisione (e i decimali)
           -- altrimenti la lunghezza - a meno che non si tratti di una data
           if (tipoDato='NUMBER') then
              if (precisione is not null) then
                        query:=query||'('||precisione;
                        if (decimali>0) then
                           query:=query||','||decimali;
                        end if;
                        query:=query||')';
               end if;
           elsif(tipoDato<>'DATE') then
                query:=query||'(' || lunghezza || ')';
           end if;
           query:=query||' ';
       end loop;
       close curCampiLgTab;

       query:=query||'); ' ||   CHR(10); -- chiudiamo la dichiarazione della table

       return query;

 end createScriptLgTable;






function createScriptLgTrigger(strNomeTabella in DE_LST_TAB.strNomeTabella%type)
          return varchar2
          IS

       campiLgTab campiTabellaCursorType;

       nomeColonna all_tab_cols.column_name%type;
       tipoDato all_tab_cols.data_type%type;
       lunghezza all_tab_cols.data_length%type;
       precisione all_tab_cols.data_precision%type;
       decimali all_tab_cols.data_scale%type;

       query varchar2(4000);

        i integer;

  begin
      getCampiTabella(campiLgTab, strNomeTabella);
     --imposto la query di creazione del trigghéro
     query:='CREATE OR REPLACE TRIGGER TG_LG_' || strNomeTabella || ' ' ||   CHR(10) ||
            'AFTER INSERT OR UPDATE OR DELETE' ||   CHR(10) ||
            'ON '|| strNomeTabella ||   CHR(10) ||
            'REFERENCING OLD AS OLD NEW AS NEW ' ||   CHR(10) ||
            'FOR EACH ROW ' ||   CHR(10) ||
            'DECLARE ' ||   CHR(10) ||
            '     VarCid integer;  ' ||   CHR(10) ||
            '     VarIgnore  integer; ' ||   CHR(10) ||
            '     comando varchar2(4000); ' ||   CHR(10) ||
            'begin ' ||   CHR(10) ||
            'IF INSERTING then ' ||   CHR(10) ||
            '	 	 comando:=PG_LOG.REGISTRALOG( '||CHR(39) ||strNomeTabella || chr(39) || ',  ' ||chr(39)||'I' ||chr(39) || ' ); ' ||   CHR(10) ||
            'ELSIF UPDATING then ' ||
            '	 	 comando:=PG_LOG.REGISTRALOG( '||CHR(39) ||strNomeTabella || chr(39) || ',  ' ||chr(39)||'U' ||chr(39) || ' ); ' ||   CHR(10) ||
            'ELSIF DELETING then ' ||
            '    comando:=PG_LOG.REGISTRALOG(' || chr(39) || strNomeTabella || chr(39) ||', ' || chr(39)||'D' || chr(39) || '); ' ||   CHR(10) ||
            'END IF; ' ||   CHR(10) ||
            'Varcid := DBMS_SQL.OPEN_CURSOR; ' ||   CHR(10) ||
            'DBMS_SQL.PARSE( Varcid, comando, DBMS_SQL.NATIVE); ' ||   CHR(10);

     --ora la parte dinamica delle BIND VARIABLES
      i:=0;
      loop
         fetch campiLgTab into nomeColonna, tipoDato, lunghezza, precisione, decimali;
         exit when campiLgTab%NOTFOUND;
         i:=i+1;
         query:=query || 'DBMS_SQL.BIND_VARIABLE(VarCid, '||chr(39) || ':' || i || chr(39) || ', :new.' || nomeColonna || '); '||   CHR(10);
      end loop;
      close campiLgTab;

      --ora la parte finale per l'esecuzione
      query:=query || 'VarIgnore := DBMS_SQL.EXECUTE(VarCid); ' ||   CHR(10) ||
                      'DBMS_SQL.CLOSE_CURSOR(Varcid); ' ||   CHR(10) ||
                      'EXCEPTION ' ||   CHR(10) ||
                      'WHEN OTHERS THEN ' ||   CHR(10) ||
                      'IF VarCid IS NOT NULL THEN ' ||   CHR(10) ||
                      '   DBMS_SQL.CLOSE_CURSOR(VarCid); '||   CHR(10) ||
                      'END IF; ' ||   CHR(10) ||
                      'RAISE; ' ||   CHR(10) ||
                      'end;' || CHR(10) ||
                      '/' || CHR(10);


      return query;
  end createScriptLgTrigger;


  function createScriptLgSequence(strNomeTabella in DE_LST_TAB.strNomeTabella%type)
            return varchar2 is


  query varchar2(4000);


  begin
       query:='CREATE SEQUENCE S_LG_' || strNomeTabella ||   CHR(10) ||
               'INCREMENT BY 1 ' ||   CHR(10) ||
               'START WITH 1 ' ||   CHR(10) ||
               'MINVALUE 1; ';

       return query;
  end createScriptLgSequence;




procedure generateLogScript
is
listaTab2Log campiTabellaCursorType;
tab2Log ts_TabLog.Strnometabella%type;
queryTabella clob;
querySequence clob;
queryTrigger clob;
VarCid INTEGER; -- id cursore sql dinamico
VarIgnore Integer;
VarContatore binary_integer := 0;

  begin
      -- pulisco la tabella temporanea
     DELETE FROM LG_TEMP;

      getTab2Log(listaTab2Log); --elenco delle tabelle da loggare
      loop
           fetch listaTab2Log into tab2Log;
           exit when listaTab2Log%NOTFOUND;
           queryTabella:=createScriptLgTable(tab2log);
           querySequence:=CreateScriptLgSequence(tab2log);
--           queryTrigger:=createScriptLgTrigger(tab2Log); -- restituisce lo script di creazione di ogni trigghéro
           INSERT INTO LG_TEMP (strNomeTabella, strQueryTab, strQuerySeq, strQueryTrig) values (tab2Log, queryTabella, querySequence, queryTrigger);

      end loop;
      close listaTab2Log;
end generateLogScript;


 function mustLog(pNomeTabella in varchar2) return number
 is
   n_count number;
 begin
		select count(l.STRNOMETABELLA) into n_count from tabs t, ts_tablog l
		where
			  t.table_name = l.STRNOMETABELLA
			  and l.STRNOMETABELLA=UPPER(pNomeTabella)
        and l.flglog='S';

 	  return n_count;
 end mustLog;


/*
 * Esegue il LOG per Update/Delete ('U'/'D') sulla tabella nomeTabella
 * (tabella reale, non quella di LOG, per es ''AN_AZIENDA') per
 * l'utente passato. Nel campo strClausolaWhere occorre passare
 * sottoforma di STRINGA l'intera clausola di WHERE che verrà usata
 * nella successiva query di update/delete.
 *
 * ATTENZIONE: se la parte di WHERE SQL originale contiene delle
 * stringhe delimitate da apice, occorre eseguirne l'ESCAPE prima
 * di invocare questa procedura.
 * Per es: una WHERE FLAG = 'S' diventa la stringa 'WHERE FLAG = ''S''' 
 *   
 * by Luigi Antenucci.
 */
PROCEDURE doLog(charUD IN VARCHAR2,
                nomeTabella IN VARCHAR2,
                utente IN TS_UTENTE.CDNUT%TYPE,
                strClausolaWhere IN VARCHAR2)
IS
    queryLog     VARCHAR2(8192);
    queryLogCols VARCHAR2(4096);
BEGIN

    -- Eventuale LOG.
    IF PG_LOG.mustlog(nomeTabella) = 1 THEN

        queryLogCols := getTableCols(nomeTabella);

        queryLog := 'INSERT INTO LG_'||nomeTabella||
                     ' (' ||
                        queryLogCols ||
                        'PRGLOG, STRTIPOOP, CDNUTLOG, DTMMODLOG' ||
                    ' )  SELECT ' ||
                            queryLogCols ||
                            'S_LG_'||nomeTabella||'.NEXTVAL , '''||charUD||''',' ||
                            utente || ', SYSDATE ' ||
                        ' FROM '|| nomeTabella || ' ' ||
                        strClausolaWhere;

        EXECUTE IMMEDIATE queryLog;
    END IF;
END doLog;



end PG_LOG;
/






/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_MADREPERLA.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_MADREPERLA AS

  --Author : Antonio Esposito
  --Date : 30/11/2007
  
  type vettore_stringhe is table of varchar2(50) index by binary_integer;
  
  --Dato un codice fiscale, questa funzione recupera dal db il cdnlavoratore
  --corrispondente, se esiste, altrimenti ritorna -1
  FUNCTION recupera_cdn(Parcf varchar2) RETURN number;
  
  --Data una stringa xml e il nome di un elemento. restituisce un vettore 
  --contenente i valori corrispondenti a tutte le occorrenze dell'elemento
  --nella stringa xml
  FUNCTION carica_elem(xml_buffer IN varchar2, elem_name IN varchar2) RETURN vettore_stringhe;
  
  --Inserisce un elemento nella tabella DO_NOMINATIVO
  PROCEDURE ins_nominativo(Parcdn IN number, 
						   ParprgRosa IN number, 
						   ParcodTipoCanc IN varchar2,
						   ParstrMotivoCanc IN varchar2);
  
  --Inserisce un elemento nella tabella DO_LAV_STORIA_ROSA
  PROCEDURE ins_nominativo_storia_rosa(Parcdn IN number, 
                                       ParprgRosa IN number, 
						   			   ParcodTipoCanc IN varchar2,
									   ParcodProvincia IN varchar2,
									   ParprgRichiesta IN varchar2,
									   ParprgUnita IN varchar2,
									   ParprgTipoRosa IN varchar2);
  
  --Crea l'xml di risposta da inviare a Madreperla
  FUNCTION create_xml_response(lista_elem IN vettore_stringhe, prgRichiesta IN varchar2) return varchar2;
  
  --Inserisce una nuova richiesta di personale facendo i vari collegamenti tra le
  --tabelle interessate. Se ParnumStorico è >= 2, inserisce anche l'incrocio e la
  --rosa.
  FUNCTION InsertRichiesta(ParnumStorico IN number,
    	   				   ParnumeroRichiesta IN varchar2,
  					       PardataRichiesta IN varchar2, 
						   PardataScadenza IN varchar2, 
						   ParfigureProfessionali IN number,
						   ParsessoMotivazione IN varchar2,
						   ParsessoSelezionato IN char,
						   ParcodiceFiscaleCareGiver IN varchar2,
						   Parmansione IN varchar2,
						   Parterritorio IN varchar2,
						   ParlistaLavoratori IN varchar2,
						   ParetaMin IN number,
						   ParetaMax IN number,
						   ParetaMotivazione IN varchar2,
						   ParnumAnno IN varchar2) return varchar2;
  --Dato l'anno e il numero della richiesta, calcola il prossimo numero storico
  --della richiesta 					   
  FUNCTION storico_successivo(ParnumAnno IN varchar2, ParnumRichiesta IN varchar2) RETURN NUMBER;
  
  --Inserisce una nuova richiesta di personale se non sono valorizzati i parametri
  --ParnumAnno e ParnumRichiesta, altrimenti recupera l'ultima copia inserita e
  --ne aggiunge un'altra con numstorico successivo facendo le opportune modifiche					   
  FUNCTION Richiesta(PardataRichiesta IN varchar2, 
					  PardataScadenza IN varchar2, 
					  ParfigureProfessionali IN number,
					  ParsessoMotivazione IN varchar2,
					  ParsessoSelezionato IN char,
					  ParcodiceFiscaleCareGiver IN varchar2,
					  Parmansione IN varchar2,
					  Parterritorio IN varchar2,
					  ParlistaLavoratori IN varchar2,
					  ParetaMin IN number,
					  ParetaMax IN number,
					  ParetaMotivazione IN varchar2,
					  ParnumAnno IN varchar2,
					  ParnumRichiesta IN varchar2,
					  ParcodRitorno OUT number) return varchar2;
			
END PG_MADREPERLA;
/


CREATE OR REPLACE PACKAGE BODY PG_MADREPERLA AS

--Dato un codice fiscale, questa funzione recupera dal db il cdnlavoratore
--corrispondente, se esiste, altrimenti ritorna -1
FUNCTION recupera_cdn(Parcf varchar2) RETURN number IS

  cdnLav AN_LAVORATORE.CDNLAVORATORE%TYPE;
  existLav number;
  
BEGIN

  SELECT COUNT(1) INTO existLav FROM AN_LAVORATORE lav WHERE lav.STRCODICEFISCALE = Parcf;
  
  --se non esiste nessun lavoratore con il codicefiscale specificato, 
  --restituisco -1, altrimenti il cdnlavoratore corrispondente
  if existLav = 0 then return -1;
  end if;
  
  SELECT lav.CDNLAVORATORE INTO cdnLav 
    FROM AN_LAVORATORE lav
   WHERE lav.STRCODICEFISCALE = Parcf;

  RETURN cdnLav;
  
END;

--Data una stringa xml e il nome di un elemento. restituisce un vettore 
--contenente i valori corrispondenti a tutte le occorrenze dell'elemento
--nella stringa xml
FUNCTION carica_elem(xml_buffer IN varchar2, elem_name IN varchar2) return vettore_stringhe IS
  p xmlparser.parser;
  doc xmldom.DOMDocument;
  nl xmldom.DOMNodeList;
  n xmldom.DOMNode;
  len number;
  elem varchar2(100);
  j number := 0;
  
  lista_elem vettore_stringhe;
BEGIN
  p := xmlparser.newParser;
	
  xmlparser.setValidationMode(p, FALSE);
  
  xmlparser.parseBuffer(p, xml_buffer); 

  doc := xmlparser.getDocument(p);
   
  nl := xmldom.getElementsByTagName(doc, elem_name);  
	  
  len := xmldom.getLength(nl); 
  
  for i in 0..len-1 loop      
  	 n := xmldom.item(nl, i);
     n := xmldom.getFirstChild(n); 
     if xmldom.getNodeType(n) = xmldom.TEXT_NODE then
	     lista_elem(i) := xmldom.getNodeValue(n);
	 end if;
  end loop;
  
  return lista_elem;
END;

--Inserisce un elemento nella tabella DO_NOMINATIVO
PROCEDURE ins_nominativo(Parcdn IN number, 
		  				 ParprgRosa IN number, 
						 ParcodTipoCanc IN varchar2,
						 ParstrMotivoCanc IN varchar2) IS
						 
BEGIN

	 INSERT INTO DO_NOMINATIVO
	 			 (prgnominativo,
				  cdnlavoratore,
				  cdnutins,
				  dtmins,
				  prgrosa,
				  codtipocanc,
				  strmotivocanc,
				  dtmcanc)
 		  VALUES 
		  		 (S_DO_NOMINATIVO.nextval,
				  Parcdn,
				  50,
				  SYSDATE,
				  ParprgRosa,
				  ParcodTipoCanc,
				  ParstrMotivoCanc,
				  decode(ParstrMotivoCanc,'','',SYSDATE));
		    	  
END;

--Inserisce un elemento nella tabella DO_LAV_STORIA_ROSA
PROCEDURE ins_nominativo_storia_rosa(Parcdn IN number, 
                                     ParprgRosa IN number, 
								     ParcodTipoCanc IN varchar2,
									 ParcodProvincia IN varchar2,
									 ParprgRichiesta IN varchar2,
									 ParprgUnita IN varchar2,
									 ParprgTipoRosa IN varchar2) IS

BEGIN

	 INSERT INTO DO_LAV_STORIA_ROSA
	 			 (prgdolavstoriarosa,
				  cdnlavoratore,
				  prgrosa,
				  codtipocanc,
				  codprovincia,
				  prgazienda,
				  prgunita,
				  prgtiporosa,
				  prgrichiesta,
				  datinvio,
				  dtmcanc)
 		   SELECT 
		  		  S_DO_LAV_STORIA_ROSA.nextval,
				  Parcdn,
				  ParprgRosa,
				  ParcodTipoCanc,
				  ParcodProvincia,
				  doRaz.PRGAZIENDA,
				  ParprgUnita,
				  ParprgTipoRosa,
				  ParprgRichiesta,
				  decode(ParprgTipoRosa,'3',SYSDATE,''),
				  decode(ParcodTipoCanc,'','',SYSDATE)
			 FROM DO_RICHIESTA_AZ doRaz
			WHERE doRaz.PRGRICHIESTAAZ = ParprgRichiesta;
			
	return;
END;

--Crea l'xml di risposta da inviare a Madreperla
FUNCTION create_xml_response(lista_elem IN vettore_stringhe, prgRichiesta IN varchar2) return varchar2 IS
  
  doc xmldom.DOMDocument;
  main_node xmldom.DOMNode;
  root_node xmldom.DOMNode;
  sendDO_node xmldom.DOMNode;
  esito_node xmldom.DOMNode;
  codRic_node xmldom.DOMNode;
  listaLav_node xmldom.DOMNode;
  cf_node xmldom.DOMNode;
  item_node xmldom.DOMNode;
  
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;
  item_text xmldom.DOMText;

  xml_response varchar2(5000);
BEGIN

  doc := xmldom.newDOMDocument;
  
  main_node := xmldom.makeNode(doc);
  root_elmt := xmldom.createElement(doc, 'tns:sendIncontroDO_output');
  
  xmldom.setAttribute(root_elmt, 'xmlns:tns', 'http://www.satanet.it/Madreperla-SIL');
  xmldom.setAttribute(root_elmt, 'xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
  xmldom.setAttribute(root_elmt, 'xsi:schemaLocation', 'http://www.satanet.it/Madreperla-SIL sendIncontroDO_output.xsd');
  
  root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));

  item_elmt := xmldom.createElement(doc, 'esito');
  xmldom.setAttribute(item_elmt, 'ok', 'True');
  xmldom.setAttribute(item_elmt, 'dettaglio', '');
  esito_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));
  
  item_elmt := xmldom.createElement(doc, 'incontroDO');
  
  sendDO_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));
  
  item_elmt := xmldom.createElement(doc, 'codiceRichiesta');
  
  codRic_node := xmldom.appendChild(sendDO_node, xmldom.makeNode(item_elmt));
  
  item_text := xmldom.createTextNode(doc, prgRichiesta);
      
  item_node := xmldom.appendChild(codRic_node, xmldom.makeNode(item_text));
  
  item_elmt := xmldom.createElement(doc, 'listaLavoratori');
  
  listaLav_node := xmldom.appendChild(sendDO_node, xmldom.makeNode(item_elmt));
  
  FOR i in 0..lista_elem.count-1 LOOP
   
   	  item_elmt := xmldom.createElement(doc, 'codiceFiscale');
  
  	  item_node := xmldom.appendChild(listaLav_node, xmldom.makeNode(item_elmt));
	  
	  item_text := xmldom.createTextNode(doc, lista_elem(i));
      
	  item_node := xmldom.appendChild(item_node, xmldom.makeNode(item_text));
	
  END LOOP;
  
  xmldom.writeToBuffer(doc, xml_response);
  
  xmldom.freeDocument(doc);

  return xml_response;

END;

--Inserisce una nuova richiesta di personale facendo i vari collegamenti tra le
--tabelle interessate. Se ParnumStorico è >= 2, inserisce anche l'incrocio e la
--rosa.
FUNCTION InsertRichiesta(ParnumStorico IN number,
		 				 ParnumeroRichiesta IN varchar2,
		  				 PardataRichiesta IN varchar2, 
						 PardataScadenza IN varchar2, 
						 ParfigureProfessionali IN number,
					     ParsessoMotivazione IN varchar2,
						 ParsessoSelezionato IN char,
						 ParcodiceFiscaleCareGiver IN varchar2,
						 Parmansione IN varchar2,
						 Parterritorio IN varchar2,
						 ParlistaLavoratori IN varchar2,
						 ParetaMin IN number,
						 ParetaMax IN number,
						 ParetaMotivazione IN varchar2,
						 ParnumAnno IN varchar2) return varchar2 IS
						 
						  
	VarnumAnno DO_RICHIESTA_AZ.NUMANNO%TYPE;
	VarnumeroRichiesta DO_RICHIESTA_AZ.NUMRICHIESTA%TYPE;
	VarNewPrgRich DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;
	VarnewPrgIncrocio DO_INCROCIO.PRGINCROCIO%TYPE;
	VarnewPrgRosa DO_ROSA.PRGROSA%TYPE;
	VarnewPrgParametriIncrocio DO_PARAMETRI_INCROCIO.PRGPARAMETRIINCROCIO%TYPE;
	VarcodCpiCapoluogo DO_RICHIESTA_AZ.CODCPI%TYPE;
	VardataRichiesta varchar2(10);
	VardataScadenza varchar2(10); 
	VarfigureProfessionali number;
    VarsessoMotivazione varchar2(5000); --verificare nell'xsd la lunghezza
	VarsessoSelezionato char;
	VarcodiceFiscaleCareGiver varchar2(50);
	Varmansione varchar2(50); --verificare nell'xsd la lunghezza
	VaretaMin number;
	VaretaMax number;
	VaretaMotivazione varchar2(5000);--verificare nell'xsd la lunghezza
	VarcodProvinciaSil varchar2(10);
	lista_cf vettore_stringhe;
	lista_cdn vettore_stringhe;
	lista_def vettore_stringhe;
	lista_cf_np vettore_stringhe;
	cdn varchar2(100);
	response varchar2(5000);
	j number := 0;
  BEGIN
	
	--Se il numStoricoo è <= 2, utilizzo i dati passati come parametri, 
	--altrimenti li recupero dal db utilizzando il numRichiesta specificato
	--e il numStorico precedente (numStorico corrente - 1)
	IF ParnumStorico <= 2 THEN	
	    --recupero il numAnno dalla data della richiesta
		VarnumAnno := TO_NUMBER(TO_CHAR(TO_DATE(PardataRichiesta,'YYYY-MM-DD'),'YYYY'));
		
		--se numStorico è 0, vuol dire che stiamo creando la prima copia della richiesta,
		--quindi devo calcolare il numeroRichiesta, come il max+1 tra i numeri delle
		--richieste per l'anno corrispondente
	    IF ParnumStorico = 0 THEN 
		   SELECT NVL(MAX(NUMRICHIESTA),0)+1 INTO VarnumeroRichiesta 
	         FROM do_richiesta_az
	    	WHERE NUMANNO = VarnumAnno;
		ELSE
		   --se mumStorico > 0, ho già generato il precedentemente numeroRichiesta
		   --quindi è stato passato come parametro.
		   VarnumeroRichiesta := ParnumeroRichiesta;
		END IF;
	
		--prelevo le altre info dai parametri
		VardataRichiesta := PardataRichiesta;
		VardataScadenza := PardataScadenza; 
		VarfigureProfessionali := ParfigureProfessionali;
		VarsessoMotivazione := ParsessoMotivazione;
		VarsessoSelezionato := ParsessoSelezionato;  
		VarcodiceFiscaleCareGiver := ParcodiceFiscaleCareGiver;
		Varmansione := Parmansione; 
		VaretaMin := ParetaMin; 
		VaretaMax := ParetaMax;
		VaretaMotivazione := ParetaMotivazione; 
		/*dbms_output.put_line('Anno : '||VarNumAnno||' Numero Richiesta : '||VarnumeroRichiesta||' Numero Storico : '||ParnumStorico);
		dbms_output.put_line('VardataRichiesta : '||VardataRichiesta);
		dbms_output.put_line('VardataScadenza : '||VardataScadenza); 
		dbms_output.put_line('VarfigureProfessionali : '||VarfigureProfessionali);
		dbms_output.put_line('VarsessoMotivazione : '||VarsessoMotivazione);
		dbms_output.put_line('VarsessoSelezionato : '||VarsessoSelezionato);
		dbms_output.put_line('VarcodiceFiscaleCareGiver : '||VarcodiceFiscaleCareGiver);
		dbms_output.put_line('Varmansione : '||Varmansione);
		dbms_output.put_line('VaretaMin : '||VaretaMin);
		dbms_output.put_line('VaretaMax : '||VaretaMax);
		dbms_output.put_line('VaretaMotivazione : '||VaretaMotivazione);*/
	ELSE
	
		--se numStorico > 2, recupero i dati della richiesta precedente dal db
		--ignorando i parametri passati esclusi ParnumAnno e ParnumeroRichiesta.
		VarnumAnno := ParnumAnno;
		VarnumeroRichiesta := ParnumeroRichiesta;
		
		--dbms_output.put_line('Anno : '||VarNumAnno||' Numero Richiesta : '||VarnumeroRichiesta||' Numero Storico : '||ParnumStorico);
		
		SELECT to_char(ric.DATRICHIESTA,'YYYY-MM-DD'), to_char(ric.DATSCADENZA,'YYYY-MM-DD'),
			   ric.NUMPROFRICHIESTI, ric.STRMOTIVSESSO,
			   ric.STRSESSO, az.STRCODICEFISCALE, 
			   man.CODMANSIONE, alt.NUMDA, alt.NUMA, alt.STRMOTIVETA  
		  INTO VardataRichiesta,VardataScadenza, 
			   VarfigureProfessionali,VarsessoMotivazione,
			   VarsessoSelezionato, VarcodiceFiscaleCareGiver,
			   Varmansione,VaretaMin,VaretaMax,VaretaMotivazione
		  FROM do_richiesta_az ric, an_azienda az, 
		  	   do_mansione man, do_alternativa alt
		 WHERE ric.NUMANNO = VarNumAnno
		   AND ric.NUMRICHIESTA = VarnumeroRichiesta
		   AND ric.NUMSTORICO = (ParnumStorico - 1)
		   AND az.PRGAZIENDA = ric.PRGAZIENDA
		   AND man.PRGRICHIESTAAZ = ric.PRGRICHIESTAAZ
		   AND alt.PRGRICHIESTAAZ = ric.PRGRICHIESTAAZ;
		   
		   /*dbms_output.put_line('VardataRichiesta : '||VardataRichiesta);
		   dbms_output.put_line('VardataScadenza : '||VardataScadenza); 
		   dbms_output.put_line('VarfigureProfessionali : '||VarfigureProfessionali);
		   dbms_output.put_line('VarsessoMotivazione : '||VarsessoMotivazione);
		   dbms_output.put_line('VarsessoSelezionato : '||VarsessoSelezionato);
		   dbms_output.put_line('VarcodiceFiscaleCareGiver : '||VarcodiceFiscaleCareGiver);
		   dbms_output.put_line('Varmansione : '||Varmansione);
		   dbms_output.put_line('VaretaMin : '||VaretaMin);
		   dbms_output.put_line('VaretaMax : '||VaretaMax);
		   dbms_output.put_line('VaretaMotivazione : '||VaretaMotivazione);*/
	END IF;
	
	SELECT dePr.codcpicapoluogo, tsg.CODPROVINCIASIL INTO VarcodCpiCapoluogo, VarcodProvinciaSil
	  FROM TS_GENERALE tsG, DE_PROVINCIA dePr 
	 WHERE dePr.CODPROVINCIA = tsG.CODPROVINCIASIL;
	
	SELECT S_do_richiesta_az.nextval INTO VarNewPrgRich FROM DUAL;
	
	--dbms_output.put_line('- '||VarnumAnno||' - '||VarNewPrgRich||' - '||VarnumeroRichiesta);
	
	--inserisco la richiesta
	INSERT INTO DO_RICHIESTA_AZ 
		   		(prgrichiestaaz,
				 numanno, 
				 prgazienda , 
				 numrichiesta,  
				 prgunita, 
				 numstorico, 
				 codcpi, 
				 datrichiesta, 
				 datscadenza, 
				 numprofrichiesti, 
	   			 cdnutins, 
				 dtmins, 
				 cdnutmod, 
				 dtmmod,
				 strmotivsesso,
				 strsesso,
				 flgfuorisede,
				 codmotgenere)
		 SELECT 
		 		VarNewPrgRich, 
				VarnumAnno, 
				az.PRGAZIENDA, 
				VarnumeroRichiesta, 
				1, 
				ParnumStorico, 
				VarcodCpiCapoluogo, 
				TO_DATE(VardataRichiesta,'YYYY-MM-DD'), 
				TO_DATE(VardataScadenza,'YYYY-MM-DD'), 
				VarfigureProfessionali, 
				50,
				SYSDATE, 
				50,
				SYSDATE,
				VarsessoMotivazione,
				VarsessoSelezionato,
				'S',
				'ALT'  
		   FROM AN_AZIENDA az 
	      WHERE UPPER(az.STRCODICEFISCALE) = UPPER(VarcodiceFiscaleCareGiver);
			
		INSERT INTO DO_COMUNE c 
			   		(PRGCOMUNE,
               		 PRGRICHIESTAAZ,
               		 CODCOM, 
               		 CDNUTINS,
               		 DTMINS,
               		 CDNUTMOD,
               		 DTMMOD)
			 SELECT
				   	 S_DO_COMUNE.NEXTVAL,
		 			 VarNewPrgRich,
					 c.CODCOM,
		 			 50,
					 sysdate,
		 			 50,
					 sysdate
			   FROM  
		       		 TS_GENERALE g, DE_PROVINCIA p, DE_CPI c 
			  WHERE  g.CODPROVINCIASIL = p.CODPROVINCIA 
			    AND  p.CODCPICAPOLUOGO = c.CODCPI;
	  	 
		 UPDATE DO_EVASIONE e SET
      	 		e.CODEVASIONE = 'PRE', 
          		e.CDNSTATORICH = 3 
 		  WHERE e.PRGRICHIESTAAZ = VarNewPrgRich; 
	
	INSERT INTO DO_MANSIONE m 
		   		(PRGMANSIONE,
		         PRGRICHIESTAAZ,
		         PRGALTERNATIVA,
		         CODMANSIONE,
		         CDNUTINS,
		         DTMINS,
		         CDNUTMOD,
		         DTMMOD)
		 VALUES 
		 		(S_DO_MANSIONE.nextval,
		         VarNewPrgRich,
		         1, 
		         Varmansione,
		 		 50,sysdate,
		 		 50,sysdate);
				 
	UPDATE DO_ALTERNATIVA 
	   SET numda = VaretaMin,
	   	   numa = VaretaMax,
           strMotiveta = VaretaMotivazione,
		   codmoteta = 'ALT'
     WHERE DO_ALTERNATIVA.prgalternativa = 1
	   AND DO_ALTERNATIVA.prgrichiestaaz = varNewPrgRich;
	  
	  --dbms_output.put_line('NumStorico prima : '||ParnumStorico);
	  --se il numStorico è < 2 non creo l'incrocio ed esco, ritornando
	  --VarnumeroRichiesta in modo che possa essere poi passato alle chiamate
	  --successive
	  if ParnumStorico < 2 then return VarnumeroRichiesta;
	  end if;
	  
	  --dbms_output.put_line('NumStorico dopo : '||ParnumStorico);
	  --inserisco l'incrocio
	  SELECT S_DO_INCROCIO.nextval INTO VarnewPrgIncrocio FROM DUAL;
	  
	  INSERT INTO DO_INCROCIO
	  		 	  (prgincrocio,
				   prgrichiestaaz,
				   prgalternativa,
				   prgtipoincrocio,
				   codstatoincrocio,
				   cdnutins,
				   dtmins,
				   cdnutmod,
				   dtmmod)
  		   VALUES
	  	   		  (VarnewPrgIncrocio,
				   VarNewPrgRich,
				   1,
				   1,
				   'C',
				   50,
				   SYSDATE,
				   50,
				   SYSDATE);
		   
		   SELECT S_DO_ROSA.nextval INTO VarnewPrgRosa FROM DUAL;
		   --inserisco la rosa
		   INSERT INTO DO_ROSA
		   		  (prgrosa,
				   prgincrocio,
				   prgtiporosa,
				   cdnutins,
				   dtmins,
				   cdnutmod,
				   dtmmod,
				   datinvio)
		   VALUES 
		   		  (VarnewPrgRosa,
				   VarnewPrgIncrocio,
				   3,
				   50,
				   SYSDATE,
				   50,
				   SYSDATE,
				   SYSDATE);
		   
		   SELECT S_DO_PARAMETRI_INCROCIO.nextval INTO VarnewPrgParametriIncrocio FROM DUAL;
		   
  	       INSERT INTO DO_PARAMETRI_INCROCIO
		   		  (prgparametriincrocio,
				   prgincrocio,
				   prgrosa)
				   --codstatolav,
 				   --datstatolav,
  				   --flgpreferibile,
  				   --flgnonindispensabile,
  				   --flgsolodisoccupato)
		   VALUES
		   		  (VarnewPrgParametriIncrocio,
				   VarnewPrgIncrocio,
				   VarnewPrgRosa);
		   
		   --prelevo la lista dei cf dei lavoratori che fanno parte della rosa
		   --e la lista dei flag che indicano se il lavoratore è stato cancellato
		   --o meno dalla rosa
		   lista_cf := carica_elem(ParlistaLavoratori, 'codiceFiscale');
		   lista_def := carica_elem(ParlistaLavoratori, 'definitivo');
		   
		   for i in 0..lista_cf.count-1 loop
		   	   --inserisco sia in DO_NOMINATIVO che in DO_LAV_STORIA_ROSA tutti i lavoratori
			   --corrispondenti ai cf presenti nella lista
			   --tranne quelli che non sono presenti nel db del sil. Questi ultimi vengono
			   --inseriti in lista_cf_np, la quale verrà restituita a madreperla, in modo
			   --che i lavoratori non presenti nel db, possano essere inseriti dall'operatore.
			   --Per ogni lavoratore, se il flag "definitivo" corrispondente è true, vuol dire che il
			   --lavoratore è stato cancellato dalla rosa, quindi settiamo di conseguenza i campi relativi
			   --alla cancellazione in entrambe le tabelle interessate 
		   	   cdn := recupera_cdn(lista_cf(i));
		   	   --dbms_output.put_line(' cdn : ' || cdn);
			   
			   if cdn = -1 then 
			   	  lista_cf_np(j) := lista_cf(i);
				  j := j + 1;
			   else
			   	  
				  if lista_def(i) = 'true' then
			   	  	 ins_nominativo(cdn, VarnewPrgRosa,'','');
					 ins_nominativo_storia_rosa(cdn, VarnewPrgRosa,'',VarcodProvinciaSil,VarNewPrgRich,'1','2');
					 ins_nominativo_storia_rosa(cdn, VarnewPrgRosa,'',VarcodProvinciaSil,VarNewPrgRich,'1','3');	   
			   	  else
				  	 ins_nominativo(cdn, VarnewPrgRosa,'M','Cancellato a seguito di selezione eseguita con MADREPERLA');
					 ins_nominativo_storia_rosa(cdn, VarnewPrgRosa,'M',VarcodProvinciaSil,VarNewPrgRich,'1','2'); 
				  end if;
				  
			   end if;
			   
		   end loop;
		   
		   --creo l'xml da restituire a madreperla, includendo la lista dei
		   --lavoratori non presenti nel db
		   response := create_xml_response(lista_cf_np, VarnumAnno||'#'||VarnumeroRichiesta);
		   
		   --dbms_output.put_line('Response : ');
		   --dbms_output.put(response);
		   
		   --restituisco l'xml di output creato.
		   return response;
  END;
  
  --Dato l'anno e il numero della richiesta, calcola il prossimo numero storico
  --della richiesta
  FUNCTION storico_successivo(ParnumAnno IN varchar2, ParnumRichiesta IN varchar2) RETURN NUMBER IS
    VarnumStorico number;
  
  BEGIN
  
    SELECT NVL(MAX(NUMSTORICO),0)+1 INTO VarnumStorico 
      FROM do_richiesta_az
     WHERE NUMANNO = ParnumAnno
	   AND NUMRICHIESTA = ParnumRichiesta; 
  
    return VarnumStorico;
	
  END;
  
  --Inserisce una nuova richiesta di personale se non sono valorizzati i parametri
  --ParnumAnno e ParnumRichiesta, altrimenti recupera l'ultima copia inserita e
  --ne aggiunge un'altra con numstorico successivo facendo le opportune modifiche
  FUNCTION Richiesta(PardataRichiesta IN varchar2, 
					  PardataScadenza IN varchar2, 
					  ParfigureProfessionali IN number,
					  ParsessoMotivazione IN varchar2,
					  ParsessoSelezionato IN char,
					  ParcodiceFiscaleCareGiver IN varchar2,
					  Parmansione IN varchar2,
					  Parterritorio IN varchar2,
					  ParlistaLavoratori IN varchar2,
					  ParetaMin IN number,
					  ParetaMax IN number,
					  ParetaMotivazione IN varchar2,
					  ParnumAnno IN varchar2,
					  ParnumRichiesta IN varchar2,
					  ParcodRitorno OUT number) return varchar2 IS
  	  
	   Varresponse varchar2(5000);
	   VarnumeroRichiesta varchar2(30);
	   VarnumStorico number;
	   errore_storico exception;
  BEGIN
  	 --se non sono valorizzati ParnumAnno e ParnumRichiesta, si tratta di una nuova
	 --richiesta, quindi inseriamo in sequenza, le copie con storico = 0, 1, 2
  	 
  	 IF (ParnumAnno IS NULL) OR (ParnumRichiesta IS NULL) THEN
	   --dbms_output.put_line('numRichiesta e numAnno nulli');
	 
  	   VarnumeroRichiesta := InsertRichiesta(0,'',PardataRichiesta,PardataScadenza, 
					   ParfigureProfessionali,ParsessoMotivazione,ParsessoSelezionato,
					   ParcodiceFiscaleCareGiver,Parmansione,Parterritorio,ParlistaLavoratori,
					   ParetaMin,ParetaMax,ParetaMotivazione,'');
  	   Varresponse := InsertRichiesta(1,VarnumeroRichiesta,PardataRichiesta,PardataScadenza, 
					   ParfigureProfessionali,ParsessoMotivazione,ParsessoSelezionato,
					   ParcodiceFiscaleCareGiver,Parmansione,Parterritorio,ParlistaLavoratori,
					   ParetaMin,ParetaMax,ParetaMotivazione,'');
	   return InsertRichiesta(2,VarnumeroRichiesta,PardataRichiesta,PardataScadenza, 
					   ParfigureProfessionali,ParsessoMotivazione,ParsessoSelezionato,
					   ParcodiceFiscaleCareGiver,Parmansione,Parterritorio,ParlistaLavoratori,
					   ParetaMin,ParetaMax,ParetaMotivazione,'');
  	 ELSE
	 	 --dbms_output.put_line('numRichiesta e numAnno valorizzati : <'||ParnumAnno||'><'||ParnumRichiesta||'>');
	 	 --se sono valorizzati ParnumAnno e ParnumRichiesta si tratta di una modifica
		 --alla rosa, quindi, calcolo lo storico successivo e proseguo con la modifica,
		 --chiamando InsertRichiesta con alcuni parametri vuoti, in modo che vada a 
		 --recuperare i dati della richiesta inserita precedentemente.
		 
		 VarnumStorico := storico_successivo(ParnumAnno, ParnumRichiesta);
		 
		 --se lo storico calcolato è <= 2, vuol dire che numAnno o numeroRichiesta sono errati
		 --perchè per ogni richiesta vengono inserite sempre 3 copie con storico = 0,1,2
		 --quindi la funzione storico_successivo dovrebbe restituire uno storico pari 
		 --almeno a 3. Generiamo un'eccezione e facciamo la rollback di tutte le operazioni
		 --effettuate.
		 IF VarnumStorico <= 2 THEN
		 	raise errore_storico;
		 END IF;
		 
		 --se è andato tutto ok, facciamo la COMMIT e restituiamo l'xml di output
		 Varresponse := InsertRichiesta(VarnumStorico,ParnumRichiesta,'','','','','','','','',
		 					    ParlistaLavoratori,'','','',ParnumAnno);
								
		 COMMIT;
		 ParcodRitorno := 0;
		 return Varresponse;
	 END IF;
	 
	 EXCEPTION
	    WHEN errore_storico THEN
			 ROLLBACK;
			 ParcodRitorno := -2;
			 return '';
		WHEN others THEN
			 ROLLBACK;
			 ParcodRitorno := -1;
			 return '';
  END;
  			
END PG_MADREPERLA;
/



/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_MB.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_MB AS
/******************************************************************************
   NAME:       PG_MB
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        03/09/2007             		1. Created this package.
   			  24/09/2007	Pegoraro			Added procedure FILL_GLOBAL_MB
   			  22/10/2007	Pegoraro		SELECT optimization
******************************************************************************/

  PROCEDURE PROC_MB;
  
  PROCEDURE FILL_GLOBAL_MB;

END PG_MB;
/

CREATE OR REPLACE PACKAGE BODY PG_MB AS
  PROCEDURE PROC_MB IS
--CREATE OR REPLACE PROCEDURE PROC_MB IS
   datafine   am_mobilita_iscr.datfine%TYPE;
   note       am_mobilita_iscr.strnote%TYPE;
   prgmob     am_mobilita_iscr.prgmobilitaiscr%TYPE;
   NUMKLO     am_mobilita_iscr.NUMKLOMOBISCR%TYPE;

   CURSOR mob IS
      SELECT datfine, strnote, prgmobilitaiscr,NUMKLOMOBISCR
        FROM am_mobilita_iscr
       WHERE datfineorig IS NULL;
BEGIN
   OPEN mob;

   LOOP
      FETCH mob INTO datafine, note, prgmob,NUMKLO;
      UPDATE am_mobilita_iscr
         SET datfineorig = datafine,
             strnote = 'MB - ' || note,
			 NUMKLOMOBISCR = NUMKLO + 1,
			 DTMMOD = sysdate
       WHERE prgmobilitaiscr = prgmob;
	   
	  EXIT WHEN mob%NOTFOUND;
   END LOOP;

   CLOSE mob;
END PROC_MB;

	/* Procedura per riempire la tabella temporanea GLOBAL_MB
	   Alessandro Pegoraro
	  */
   PROCEDURE fill_global_mb
   IS
      prov       CHAR (4);
      silprov    CHAR (4);
      tmpcount   NUMBER;
   BEGIN
      /* Estraggo provincia DB*/
      SELECT ts_generale.codprovinciasil
        INTO silprov
        FROM ts_generale;

      /* Ciclo sulle unita e riempio la GLOBAL_MB */
      FOR azienda IN (
	  	  		  	 /* Filtraggio delle unita coinvolte nella mobilita */
	  	  		  	 SELECT az.prgazienda, uni.prgunita, az.strcodicefiscale,
                             uni.codcom
                        FROM an_azienda az,
                             an_unita_azienda uni,
                             am_mobilita_iscr mob
                       WHERE az.prgazienda = uni.prgazienda
                         AND uni.prgazienda = mob.prgazienda
                         AND uni.prgunita = mob.prgunita
						 
                      UNION
					  
                      SELECT az.prgazienda, uni.prgunita, az.strcodicefiscale,
                             uni.codcom
                        FROM an_azienda az,
                             an_unita_azienda uni,
                             am_movimento mov,
                             am_mobilita_iscr mob
                       WHERE 
					    	 az.prgazienda = uni.prgazienda
                            AND mov.codstatoatto = 'PR'
                        	AND mov.codtipomov <> 'CES' 
						 	AND mov.cdnlavoratore = mob.cdnlavoratore 
						 AND
						 (
						  	(mov.prgazienda = uni.prgazienda
                         	AND mov.prgunita = uni.prgunita)
							/*Ridondanze apposite x prestazioni */
							OR
							    (az.prgazienda = uni.prgazienda
                         	 	AND mov.prgaziendautiliz = uni.prgazienda
                        	 	AND mov.prgunitautiliz = uni.prgunita
								AND mov.cdnlavoratore = mob.cdnlavoratore)
						)
						)
      LOOP
	  /* tmpcount indica quante collisioni ci sono con lo stesso CF E stesso Comune */
         SELECT COUNT (1)
           INTO tmpcount
           FROM global_mb gb
          WHERE gb.prgazienda = azienda.prgazienda
            AND gb.codcom = azienda.codcom;

         /* Inserimento azienda con prg corretto (prolabor) */
         INSERT INTO global_mb
                     (prgazienda, prgunita,
                      strcodicefiscale, codcom, prg,
                      strcf
                     )
              VALUES (azienda.prgazienda, azienda.prgunita,
                      azienda.strcodicefiscale, azienda.codcom, tmpcount + 1,
                      NULL
                     );

         /* Calcolo nuova chiave prolabor */
         SELECT de_comune.codprovincia
           INTO prov
           FROM de_comune
          WHERE azienda.codcom = de_comune.codcom;
         -- AND an_unita_azienda.prgunita = azienda.prgunita
         -- AND an_unita_azienda.prgazienda = azienda.prgazienda;
		 
         IF (prov = silprov)
         THEN
            UPDATE global_mb gl
               SET strcf = rpad(azienda.strcodicefiscale,16,' ') || azienda.codcom || decode(gl.prg,
			   '0','0',
			   '1','1',
			   '2','2',
			   '3','3',
			   '4','4',
			   '5','5',
			   '6','6',
			   '7','7',
			   '8','8',
			   '9','9',
			   '10','A',
			   '11','B',
			   '12','C',
			   '13','D',
			   '14','E',
			   '15','F',
			   '16','G',
			   '17','H',
			   '18','I',
			   '19','J',
			   '20','K',
			   '21','L',
			   '22','M',
			   '23','N',
			   '24','O',
			   '25','P',
			   '26','Q',
			   '27','R',
			   '28','S',
			   '29','T',
			   '30','U')	      		
             WHERE gl.prgazienda = azienda.prgazienda
               AND gl.prgunita = azienda.prgunita;
         ELSE
            UPDATE global_mb gl
                SET strcf = rpad(azienda.strcodicefiscale,16,' ') || azienda.codcom 
             WHERE gl.prgazienda = azienda.prgazienda
               AND gl.prgunita = azienda.prgunita;
         END IF;
      END LOOP;
   END fill_global_mb;

END PG_MB;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_MIGRAZIONI.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_MIGRAZIONI IS

 /*
     * Autore:   Luigi Antenucci.
  * Data:     novembre 2004.
  * Ultima    modifica: 12 gennaio 2004.
  * Versione: 1.6.
  */

TYPE typRefCurs IS REF CURSOR;    
   
/*
 * Procedura usata dalla classe "EsportaMigrazioni" per esportare tutte le
 * migrazioni relativamente a un certo CPI di competenza e il cui record
 * di "movimento" è stato modificato in un certo intervallo temporale.
 * Vengono aggiunti dei record (uno per ogni movimento interessato) nella
 * tabella di appoggio AM_MIGRAZIONI_APPOGGIO.
 * Rende il numero dei record che ha inserito in tale tabella.
 */
FUNCTION ESPORTA_MIGRAZIONI_CPI_IN_APP(inputCodCpi IN DE_CPI.CODCPI%TYPE,
          dataUltimaMigrazioneStr IN VARCHAR2,
          dataQuestaMigrazioneStr IN VARCHAR2)
          RETURN NUMBER;

/*
 * Dato un prgMovimento rende il suo primo movimento precedente con 'AVV'.
 * Parte dal movimento passato e segue la catena dei precedenti fino a che
 * non ne trova uno con codice 'AVV' e lo rende (se non lo trova rende NULL).
 */
FUNCTION RECUPERA_MIGRAZIONE_AVV_PREC(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
            RETURN AM_MOVIMENTO%ROWTYPE;



--Dato un prgMovimento rende il suo movimento precedente .

FUNCTION RECUPERA_MIGRAZIONE_MOV_PREC(prgMovi IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
            RETURN AM_MOVIMENTO%ROWTYPE;

/* RECUPERO IL SESSO E LA DATA DI NASCITA ELABORANDO IL CODICE FISCALE */
FUNCTION GET_SES_DA_CODFIS(inputCF IN VARCHAR2) RETURN VARCHAR2;
FUNCTION GET_DATNAS_DA_CODFIS(inputCF IN VARCHAR2) RETURN DATE;

FUNCTION ESPORTA_MOVIMENTO(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
          RETURN typRefCurs;

END PG_MIGRAZIONI;
/


CREATE OR REPLACE PACKAGE BODY PG_MIGRAZIONI IS


FUNCTION RECUPERA_MIGRAZIONE_AVV_PREC(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
            RETURN AM_MOVIMENTO%ROWTYPE
IS
 rowMov AM_MOVIMENTO%ROWTYPE;
 prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
BEGIN

 -- Continuo a recuperare il record del movimento precedente finche' non trovo quello con 'AVV' (o non ce l'ho).
 prgMovCiclo := prgMov;
 LOOP

  IF prgMovCiclo IS NULL THEN
     EXIT;
  END IF;

  -- Recupero il record relativo al prgMovimento in ingresso
  SELECT MOV.*
  INTO rowMov
  FROM AM_MOVIMENTO MOV
  WHERE MOV.PRGMOVIMENTO = prgMovCiclo;

  -- Se non trovato, esco dal ciclo
  EXIT WHEN SQL%NOTFOUND;

  -- Se ho trovato il movimento con 'AVV', rendo il record
  IF rowMov.CODTIPOMOV = 'AVV' THEN
   RETURN rowMov;
  END IF;

  -- Continuo a ciclare (passo al movimento precedente)
  prgMovCiclo := rowMov.PRGMOVIMENTOPREC;

 END LOOP;

 RETURN NULL;

END RECUPERA_MIGRAZIONE_AVV_PREC;




FUNCTION RECUPERA_MIGRAZIONE_MOV_PREC(prgMovi IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
            RETURN AM_movimento%rowtype
IS
 rowMov  AM_MOVIMENTO%ROWTYPE;
 prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
BEGIN


  prgMovCiclo := prgMovi;
  IF prgMovCiclo IS NOT NULL THEN
    SELECT M.*
  INTO rowMov
  FROM AM_MOVIMENTO M
  WHERE M.PRGMOVIMENTO = prgMovCiclo;

  IF rowMov.PRGMOVIMENTO is not null then
     return rowMov;
  end if;
 END IF;

 RETURN NULL;

END RECUPERA_MIGRAZIONE_MOV_PREC;







/* PRIVATA */
PROCEDURE AGGIORNA_MIGR_IN_APP_NON_AVV(inputCodCpi IN DE_CPI.CODCPI%TYPE)
IS
    CURSOR migrInAppNonAvvCursor IS
        SELECT X.PRGMOVIMENTO, X.PRGMOVIMENTOPREC
        FROM AM_MIGRAZIONI_APPOGGIO X
        WHERE X.CODCPI = inputCodCpi
  AND   X.CODTIPOMOV <> 'AVV';

 prgMov     AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
 prgMovPrec AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
 rowMovAvv  AM_MOVIMENTO%ROWTYPE;


 flgPrecedente DE_CPI.FLGMOVORIGMIGR%TYPE;

BEGIN

  --Giovanni D'Auria 13/09/2005 inizio

  SELECT FLGMOVORIGMIGR INTO flgPrecedente
  FROM DE_CPI
  WHERE DE_CPI.CODCPI = inputCodCpi;

   --Giovanni D'Auria 13/09/2005 fine



 FOR migrInAppNonAvv IN migrInAppNonAvvCursor LOOP

  -- a) ottengo il progressivo del movimento precedente (dal record nella tabella di appoggio).
  prgMov     := migrInAppNonAvv.PRGMOVIMENTO;
  prgMovPrec := migrInAppNonAvv.PRGMOVIMENTOPREC;


  -- CONTROLLO IL FLGMOVORIGMIGR
  IF flgPrecedente = 'S' THEN
   -- b) ottengo l'intero record del movimento di 'AVV' precedente (se esiste).
   rowMovAvv := RECUPERA_MIGRAZIONE_AVV_PREC(prgMovPrec);
  ELSE
   -- b) ottengo l'intero record del movimento precedente (se esiste).
   rowMovAvv := RECUPERA_MIGRAZIONE_MOV_PREC(prgMovPrec);
  END IF;





  -- b) ottengo l'intero record del movimento di 'AVV' precedente (se esiste).
--  rowMovAvv := RECUPERA_MIGRAZIONE_AVV_PREC(prgMovPrec);







  -- c) aggiorno i campi della tab. di appoggio relativi della parte di "avviamento" del record in esame.
  --    nota: se non ho trovato il record di avviamento (che è possibile), i campi verranno "sbiancati".
  --    per questo motivo faccio due 'update': quella condizionata permette di non sbiancare i campi
  --    che so essere INVARIANTI tra movimenti successivi.

  /*IF flgPrecedente = 'S' THEN
        UPDATE AM_MIGRAZIONI_APPOGGIO X
  SET
    PRGMOVIMENTOAVV = rowMovAvv.PRGMOVIMENTO,
   /* avviamento *//*
       AVVTEM = rowMovAvv.CODMONOTEMPO,
    AVVTIPORA = rowMovAvv.CODORARIO,
    AVVTIPORA_FP = DECODE(SUBSTR(rowMovAvv.CODORARIO,1,2), NULL,NULL, 'TP','F', 'P'),
    AVVTEMINDETDATAVV = DECODE(rowMovAvv.CODMONOTEMPO, 'I', rowMovAvv.DATINIZIOAVV, NULL),
    AVVTEMDETDATAVV   = DECODE(rowMovAvv.CODMONOTEMPO, 'D', rowMovAvv.DATINIZIOAVV, NULL),
    AVVLUO = rowMovAvv.STRLUOGODILAVORO,
    AVVNOR = rowMovAvv.CODNORMATIVA,
    AVVCOM = DECODE(rowMovAvv.FLGLEGGE68, 'S', 'X',NULL),
    AVVFT = DECODE(SUBSTR(rowMovAvv.CODORARIO,1,2), 'TP', 'X',NULL),
    AVVPT = DECODE(SUBSTR(rowMovAvv.CODORARIO,1,2), 'PT', 'X','M','X',NULL),
    AVVTEMDETDATCES = rowMovAvv.DATFINEMOV,
    AVVGIOAGRPRE = rowMovAvv.NUMGGPREVISTIAGR,
    AVVGIOAGREFF = rowMovAvv.NUMGGEFFETTUATIAGR,
    AVVPTORAMEDSET = rowMovAvv.NUMORESETT,
    AVVQUA = rowMovAvv.CODMANSIONE,
    AVVGRA = rowMovAvv.CODGRADO,
    AVVLIV = rowMovAvv.NUMLIVELLO,
    AVVRETLORMEN = rowMovAvv.DECRETRIBUZIONEMEN,
    AVVAILCFLDAT = rowMovAvv.DATCFL,
    AVVAILCFLNUM = rowMovAvv.STRNUMCFL,
    AVVTIPCFLDURAPP = rowMovAvv.STRTIPOCFL,
    AVVBEN = rowMovAvv.CODAGEVOLAZIONE
  WHERE X.PRGMOVIMENTO = prgMov
  AND   X.CODCPI = inputCodCpi;    /* questo AND lo aggiungo solo per sicurezza */
/*
  IF rowMovAvv.PRGMOVIMENTO IS NOT NULL THEN
   UPDATE AM_MIGRAZIONI_APPOGGIO X
   SET
    AVVNUMMAT = rowMovAvv.STRMATRICOLA,
    AVVDATAVV = rowMovAvv.DATINIZIOAVV,
    AVVTIPASS = rowMovAvv.CODTIPOCONTRATTO,
    AVVCCNL   = rowMovAvv.CODCCNL
   WHERE X.PRGMOVIMENTO = prgMov
   AND   X.CODCPI = inputCodCpi;
  END IF;


  /*ELSif flgPrecedente = 'N' or flgPrecedente is null then*/
     UPDATE AM_MIGRAZIONI_APPOGGIO X
  SET
    PRGMOVIMENTOAVV = rowMovAvv.PRGMOVIMENTO,
   /* avviamento */
       AVVTEM = rowMovAvv.CODMONOTEMPO,
    AVVTIPORA = rowMovAvv.CODORARIO,
    AVVTIPORA_FP = DECODE(SUBSTR(rowMovAvv.CODORARIO,1,2), NULL,NULL, 'TP','F', 'P'),
    AVVTEMINDETDATAVV = DECODE(rowMovAvv.CODMONOTEMPO, 'I', rowMovAvv.DATINIZIOAVV, NULL),
    AVVTEMDETDATAVV   = DECODE(rowMovAvv.CODMONOTEMPO, 'D', rowMovAvv.DATINIZIOAVV, NULL),
    AVVLUO = rowMovAvv.STRLUOGODILAVORO,
    --AVVNOR = rowMovAvv.CODNORMATIVA,
    AVVCOM = DECODE(rowMovAvv.FLGLEGGE68, 'S', 'X',NULL),
    AVVFT = DECODE(SUBSTR(rowMovAvv.CODORARIO,1,2), 'TP', 'X',NULL),
    AVVPT = DECODE(SUBSTR(rowMovAvv.CODORARIO,1,2), 'PT', 'X','M','X',NULL),
    AVVTEMDETDATCES = rowMovAvv.DATFINEMOV,
    AVVGIOAGRPRE = rowMovAvv.NUMGGPREVISTIAGR,
    --AVVGIOAGREFF = rowMovAvv.NUMGGEFFETTUATIAGR,
    AVVPTORAMEDSET = rowMovAvv.NUMORESETT,
    AVVQUA = rowMovAvv.CODMANSIONE,
    --AVVGRA = rowMovAvv.CODGRADO,
    AVVLIV = rowMovAvv.NUMLIVELLO,
    AVVRETLORMEN = rowMovAvv.DECRETRIBUZIONEMEN,
    --AVVAILCFLDAT = rowMovAvv.DATCFL,
    --AVVAILCFLNUM = rowMovAvv.STRNUMCFL,
    --AVVTIPCFLDURAPP = rowMovAvv.STRTIPOCFL,
    AVVBEN = rowMovAvv.CODAGEVOLAZIONE
  WHERE X.PRGMOVIMENTO = prgMov
  AND   X.CODCPI = inputCodCpi;    /* questo AND lo aggiungo solo per sicurezza */

  IF flgPrecedente = 'S' THEN
   IF rowMovAvv.PRGMOVIMENTO IS NOT NULL THEN
    UPDATE AM_MIGRAZIONI_APPOGGIO X
    SET
     AVVNUMMAT = rowMovAvv.STRMATRICOLA,
     AVVDATAVV = rowMovAvv.DATINIZIOAVV,
     AVVTIPASS = rowMovAvv.CODTIPOCONTRATTO,
     AVVCCNL   = rowMovAvv.CODCCNL
    WHERE X.PRGMOVIMENTO = prgMov
    AND   X.CODCPI = inputCodCpi;
   END IF;

  END IF;
  --end if;







  /*
  UPDATE AM_MIGRAZIONI_APPOGGIO X
  SET
    PRGMOVIMENTOAVV = rowMovAvv.PRGMOVIMENTO,
   /* avviamento *//*
       AVVTEM = rowMovAvv.CODMONOTEMPO,
    AVVTIPORA = rowMovAvv.CODORARIO,
    AVVTIPORA_FP = DECODE(SUBSTR(rowMovAvv.CODORARIO,1,2), NULL,NULL, 'TP','F', 'P'),
    AVVTEMINDETDATAVV = DECODE(rowMovAvv.CODMONOTEMPO, 'I', rowMovAvv.DATINIZIOAVV, NULL),
    AVVTEMDETDATAVV   = DECODE(rowMovAvv.CODMONOTEMPO, 'D', rowMovAvv.DATINIZIOAVV, NULL),
    AVVLUO = rowMovAvv.STRLUOGODILAVORO,
    AVVNOR = rowMovAvv.CODNORMATIVA,
    AVVCOM = DECODE(rowMovAvv.FLGLEGGE68, 'S', 'X',NULL),
    AVVFT = DECODE(SUBSTR(rowMovAvv.CODORARIO,1,2), 'TP', 'X',NULL),
    AVVPT = DECODE(SUBSTR(rowMovAvv.CODORARIO,1,2), 'PT', 'X','M','X',NULL),
    AVVTEMDETDATCES = rowMovAvv.DATFINEMOV,
    AVVGIOAGRPRE = rowMovAvv.NUMGGPREVISTIAGR,
    AVVGIOAGREFF = rowMovAvv.NUMGGEFFETTUATIAGR,
    AVVPTORAMEDSET = rowMovAvv.NUMORESETT,
    AVVQUA = rowMovAvv.CODMANSIONE,
    AVVGRA = rowMovAvv.CODGRADO,
    AVVLIV = rowMovAvv.NUMLIVELLO,
    AVVRETLORMEN = rowMovAvv.DECRETRIBUZIONEMEN,
    AVVAILCFLDAT = rowMovAvv.DATCFL,
    AVVAILCFLNUM = rowMovAvv.STRNUMCFL,
    AVVTIPCFLDURAPP = rowMovAvv.STRTIPOCFL,
    AVVBEN = rowMovAvv.CODAGEVOLAZIONE
  WHERE X.PRGMOVIMENTO = prgMov
  AND   X.CODCPI = inputCodCpi;    /* questo AND lo aggiungo solo per sicurezza */
/*
  IF rowMovAvv.PRGMOVIMENTO IS NOT NULL THEN
   UPDATE AM_MIGRAZIONI_APPOGGIO X
   SET
    AVVNUMMAT = rowMovAvv.STRMATRICOLA,
    AVVDATAVV = rowMovAvv.DATINIZIOAVV,
    AVVTIPASS = rowMovAvv.CODTIPOCONTRATTO,
    AVVCCNL   = rowMovAvv.CODCCNL
   WHERE X.PRGMOVIMENTO = prgMov
   AND   X.CODCPI = inputCodCpi;
  END IF;
  */





 END LOOP;

END AGGIORNA_MIGR_IN_APP_NON_AVV;


FUNCTION GET_SES_DA_CODFIS(inputCF IN VARCHAR2) RETURN VARCHAR2
IS
BEGIN
 IF inputCF IS NULL THEN
    RETURN NULL;
 ELSIF GREATEST( TO_NUMBER(SUBSTR(inputCF,10,1)) ,3) = 3 THEN
    RETURN 'M';
 ELSE
    RETURN 'F';
 END IF;

 EXCEPTION
  WHEN OTHERS THEN
   RETURN NULL;
END GET_SES_DA_CODFIS;


FUNCTION GET_DATNAS_DA_CODFIS(inputCF IN VARCHAR2) RETURN DATE
IS
    dataStr VARCHAR2(20) := '';
    data    DATE;
    tmpGio  NUMBER;
    tmpMese VARCHAR2(2);
 tmpAnno VARCHAR2(4);
BEGIN
 IF inputCF IS NULL THEN
    RETURN NULL;
 ELSE
  -- A) recupero il giorno (con controllo sul sesso)
  tmpGio := TO_NUMBER(SUBSTR(inputCF,10,2));
  IF tmpGio >= 40 THEN
     tmpGio := tmpGio - 40;
  END IF;
  dataStr := dataStr || TO_CHAR(tmpGio, '09') || '/';

  -- B) recupero il mese
  tmpMese := SUBSTR(inputCF,9,1);
  IF    tmpMese = 'A' THEN tmpMese := '01';
  ELSIF tmpMese = 'B' THEN tmpMese := '02';
  ELSIF tmpMese = 'C' THEN tmpMese := '03';
  ELSIF tmpMese = 'D' THEN tmpMese := '04';
  ELSIF tmpMese = 'E' THEN tmpMese := '05';
  ELSIF tmpMese = 'H' THEN tmpMese := '06';
  ELSIF tmpMese = 'L' THEN tmpMese := '07';
  ELSIF tmpMese = 'M' THEN tmpMese := '08';
  ELSIF tmpMese = 'P' THEN tmpMese := '09';
  ELSIF tmpMese = 'R' THEN tmpMese := '10';
  ELSIF tmpMese = 'S' THEN tmpMese := '11';
  ELSIF tmpMese = 'T' THEN tmpMese := '12';
  ELSE                     tmpMese := '01';
  END IF;
  dataStr := dataStr || tmpMese || '/';

  -- C) recupero l'anno
  tmpAnno := SUBSTR(inputCF,7,2);
  /* FORSE DEVO DISTINGUERE, MA ORA NO:
  IF TO_NUMBER(tmpAnno) < 20 THEN
   tmpAnno := '20' || tmpAnno;
  ELSE
   tmpAnno := '19' || tmpAnno;
  END IF;
  */
  tmpAnno := '19' || tmpAnno;
  dataStr := dataStr || tmpAnno;

  -- D) converto la stringa in una data e la rendo.
  data := TO_DATE(dataStr, 'DD/MM/YYYY');
  RETURN data;
 END IF;

 EXCEPTION
  WHEN OTHERS THEN
   RETURN NULL;
END GET_DATNAS_DA_CODFIS;


/* PRIVATA */
PROCEDURE DECODIFICA_CODICI_IN_APP(inputCodCpi IN DE_CPI.CODCPI%TYPE)
IS
BEGIN
 UPDATE AM_MIGRAZIONI_APPOGGIO X
 SET
     /* COMUNI */
      --   AZIUNICOM_DESC    = DECODE(X.AZIUNICOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.AZIUNICOM) ),
      AZISEDCOM_DESC    = DECODE(X.AZISEDCOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.AZISEDCOM) ),
      LAVNASCOM_DESC    = DECODE(X.LAVNASCOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.LAVNASCOM) ),
         LAVRESCOM_DESC    = DECODE(X.LAVRESCOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.LAVRESCOM) ),
   LAVDOMCOM_DESC    = DECODE(X.LAVDOMCOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.LAVDOMCOM) ),
   AZIUTICOM_DESC    = DECODE(X.AZIUTICOM,   NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.AZIUTICOM) ),
   AZIUTISEDCOM_DESC = DECODE(X.AZIUTISEDCOM,NULL,NULL, (SELECT C.STRDENOMINAZIONE FROM DE_COMUNE C WHERE C.CODCOM = X.AZIUTISEDCOM) ),
     /* PROVINCE */
         AZIUNICOM_PROV    = DECODE(X.AZIUNICOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.AZIUNICOM) ),
      AZISEDCOM_PROV    = DECODE(X.AZISEDCOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.AZISEDCOM) ),
      LAVNASCOM_PROV    = DECODE(X.LAVNASCOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.LAVNASCOM) ),
         LAVRESCOM_PROV    = DECODE(X.LAVRESCOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.LAVRESCOM) ),
   LAVDOMCOM_PROV    = DECODE(X.LAVDOMCOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.LAVDOMCOM) ),
      AZIUTICOM_PROV    = DECODE(X.AZIUTICOM,   NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.AZIUTICOM) ),
   AZIUTISEDCOM_PROV = DECODE(X.AZIUTISEDCOM,NULL,NULL, (SELECT P.STRTARGA FROM DE_PROVINCIA P, DE_COMUNE C WHERE P.CODPROVINCIA = C.CODPROVINCIA AND C.CODCOM = X.AZIUTISEDCOM) ),
     /* QUALIFICHE */
   AVVQUA_DESC       = DECODE(X.AVVQUA,     NULL,NULL, (SELECT Q.STRDESCRIZIONE FROM DE_MANSIONE Q WHERE Q.CODMANSIONE = X.AVVQUA) ),
   CESQUA_DESC       = DECODE(X.CESQUA,     NULL,NULL, (SELECT Q.STRDESCRIZIONE FROM DE_MANSIONE Q WHERE Q.CODMANSIONE = X.CESQUA) ),
   PTRNUOQUA_DESC    = DECODE(X.PTRNUOQUA,  NULL,NULL, (SELECT Q.STRDESCRIZIONE FROM DE_MANSIONE Q WHERE Q.CODMANSIONE = X.PTRNUOQUA) ),
   APPTUTQUA_DESC    = DECODE(X.APPTUTQUA,  NULL,NULL, (SELECT Q.STRDESCRIZIONE FROM DE_MANSIONE Q WHERE Q.CODMANSIONE = X.APPTUTQUA) ),
     /* GRADI */
   --AVVGRA_DESC       = DECODE(X.AVVGRA,     NULL,NULL, (SELECT G.STRDESCRIZIONE FROM DE_MV_GRADO G WHERE G.CODGRADO = X.AVVGRA) ),
   --CESGRA_DESC       = DECODE(X.CESGRA,     NULL,NULL, (SELECT G.STRDESCRIZIONE FROM DE_MV_GRADO G WHERE G.CODGRADO = X.CESGRA) ),
   --PTRNUOGRA_DESC    = DECODE(X.PTRNUOGRA,  NULL,NULL, (SELECT G.STRDESCRIZIONE FROM DE_MV_GRADO G WHERE G.CODGRADO = X.PTRNUOGRA) ),
     /* TIPO DI ASSUNZIONE  */
   AVVTIPASS_DESC    = DECODE(X.AVVTIPASS,  NULL,NULL, (SELECT A.STRDESCRIZIONE FROM DE_TIPO_CONTRATTO A WHERE A.CODTIPOCONTRATTO = X.AVVTIPASS) ),
   TRATIPASS_DESC    = DECODE(X.TRATIPASS,  NULL,NULL, (SELECT A.STRDESCRIZIONE FROM DE_TIPO_CONTRATTO A WHERE A.CODTIPOCONTRATTO = X.TRATIPASS) ),
   /* TIPO TRASFORMAZIONE */
   AVVTIPOTRASF_DESC = DECODE(X.AVVTIPOTRASF,  NULL,NULL, (SELECT T.STRDESCRIZIONE FROM DE_TIPO_TRASF T WHERE T.CODTIPOTRASF = X.AVVTIPOTRASF) ),
     /* TIPO DI ORARIO DI LAVORO */
   AVVTIPORA_DESC    = DECODE(X.AVVTIPORA,  NULL,NULL, (SELECT O.STRDESCRIZIONE FROM DE_ORARIO O WHERE O.CODORARIO = X.AVVTIPORA) ),
   TRATIPORA_DESC    = DECODE(X.TRATIPORA,  NULL,NULL, (SELECT O.STRDESCRIZIONE FROM DE_ORARIO O WHERE O.CODORARIO = X.TRATIPORA) ),
     /* AGEVOLAZIONE */
   AVVBEN_DESC       = DECODE(X.AVVBEN,     NULL,NULL, (SELECT B.STRDESCRIZIONE FROM DE_AGEVOLAZIONE B WHERE B.CODAGEVOLAZIONE = X.AVVBEN) ),
   PTRNUOBEN_DESC    = DECODE(X.PTRNUOBEN,  NULL,NULL, (SELECT B.STRDESCRIZIONE FROM DE_AGEVOLAZIONE B WHERE B.CODAGEVOLAZIONE = X.PTRNUOBEN) ),
     /* CCNL */
   AZIUNICCNL_DESC   = DECODE(X.AZIUNICCNL, NULL,NULL, (SELECT C.STRDESCRIZIONE FROM DE_CONTRATTO_COLLETTIVO C WHERE C.CODCCNL = X.AZIUNICCNL) ),
   AVVCCNL_DESC      = DECODE(X.AVVCCNL,    NULL,NULL, (SELECT C.STRDESCRIZIONE FROM DE_CONTRATTO_COLLETTIVO C WHERE C.CODCCNL = X.AVVCCNL) ),
   /* non usato: AVVAREACCNL_DESC  = DECODE(X.AVVAREACCNL, NULL,NULL, (SELECT C.STRDESCRIZIONE FROM DE_CONTRATTO_COLLETTIVO C WHERE C.CODCCNL = X.AVVAREACCNL) ), */
   PTRNUOCCNL_DESC   = DECODE(X.PTRNUOCCNL, NULL,NULL, (SELECT C.STRDESCRIZIONE FROM DE_CONTRATTO_COLLETTIVO C WHERE C.CODCCNL = X.PTRNUOCCNL) ),
     /* ALTRE DECODIFICHE */
   CODTIPOMOV_DESC   = DECODE(X.CODTIPOMOV, NULL,NULL, (SELECT M.STRDESCRIZIONE FROM DE_MV_TIPO_MOV M WHERE M.CODTIPOMOV= X.CODTIPOMOV) ),
   LAVTITSTUD_DESC   = DECODE(X.LAVTITSTUD, NULL,NULL, (SELECT T.DESCRIZIONE FROM MN_TITOLO_L1 T WHERE T.CODICE = X.LAVTITSTUD) ),
   LAVCIT_DESC       = DECODE(X.LAVCIT,     NULL,NULL, (SELECT C.STRDESCRIZIONE FROM DE_CITTADINANZA C WHERE C.CODCITTADINANZA = X.LAVCIT) ),
   --AVVNOR_DESC       = DECODE(X.AVVNOR,     NULL,NULL, (SELECT N.STRDESCRIZIONE FROM DE_NORMATIVA N WHERE N.CODNORMATIVA = X.AVVNOR) ),
   CESMOT_DESC       = DECODE(X.CESMOT,     NULL,NULL, (SELECT M.STRDESCRIZIONE FROM DE_MV_CESSAZIONE M WHERE M.CODMVCESSAZIONE = X.CESMOT) ),
   -- Savino 23/01/2006: aggiunto campo descrizione motivo perm. sogg.
   LAVPSMOT_DESC     = DECODE(X.LAVPSMOT,   NULL,NULL, (SELECT E.STRDESCRIZIONE FROM DE_EX_MOTIVO_RIL E WHERE E.CODMOTIVORIL = X.LAVPSMOT) ),
  /* CODICE ATECO'02: se il codice ateco NON e' scaduto stampa la stringa 'ATE02', altrimenti mette NULL */
   AZIUNICODATT_ATE02 = (SELECT DECODE(SIGN(A.DATFINEVAL - TRUNC(SYSDATE)), -1, NULL, 'ATE02') FROM DE_ATTIVITA A WHERE A.CODATECO = X.AZIUNICODATT),
   LAVEXCODSTATUS_DESC = DECODE(X.LAVEXCODSTATUS, NULL, NULL, (SELECT S.STRDESCRIZIONE FROM DE_STATUS_STRANIERO S WHERE S.CODSTATUS = X.LAVEXCODSTATUS)),
     /* DECODIFICHE VIA SOFTWARE */
   APPTUTSES         = GET_SES_DA_CODFIS(X.APPTUTCODFIS),
   APPTUTNASDAT      = GET_DATNAS_DA_CODFIS(X.APPTUTCODFIS)
 WHERE X.CODCPI = inputCodCpi;

 EXCEPTION
 WHEN OTHERS THEN
  DBMS_OUTPUT.PUT_LINE('Error code: ' || SQLCODE);
  DBMS_OUTPUT.PUT_LINE('Error mesg: ' || SUBSTR(SQLERRM,1,100));

END DECODIFICA_CODICI_IN_APP;



FUNCTION ESPORTA_MIGRAZIONI_CPI_IN_APP(inputCodCpi IN DE_CPI.CODCPI%TYPE,
          dataUltimaMigrazioneStr IN VARCHAR2,
          dataQuestaMigrazioneStr IN VARCHAR2)
          RETURN NUMBER
IS
 dataUltimaMigrazione DATE := TO_DATE(dataUltimaMigrazioneStr,'DD/MM/YYYY HH24:MI:SS');
 dataQuestaMigrazione DATE := TO_DATE(dataQuestaMigrazioneStr,'DD/MM/YYYY HH24:MI:SS');
 numScritti NUMBER;
BEGIN

 /* PASSO 1: IMPORTO I RECORD (SENZA DECODIFICA DEI CODICI) NELLA TABELLA DI APPOGGIO */




 INSERT INTO AM_MIGRAZIONI_APPOGGIO
          (CODCPI,
      PRGMOVIMENTO,
      CODTIPOMOV,
      PRGMOVIMENTOPREC,
      PRGMOVIMENTOAVV,
      DTMINSMOD,
      CODMONOTIPOCPI,
      REFID,
      REFDATINV,
      REFMIT,
      EVECOD,
      EVEDAT,
      AZICODFISC,
      AZIUNIPARIVA,
      AZIUNIRAGSOC,
      AZIUNIIND,
      AZIUNICAP,
      AZIUNICOM,
      AZIUNITEL,
      AZIUNIFAX,
      AZIUNIMAIL,
      AZIUNICODATT,
      AZIUNICCNL,
      AZIUNINUMDIP,
      AZIUNIINPS,
      AZIUNINUMREGCODDOM,
      AZIUNINUMALBINT,
      AZIINAIL,
   AZITIPOAZIENDA,
      AZISEDRAGSOC,
      AZISEDIND,
      AZISEDCAP,
      AZISEDCOM,
      AZISEDTEL,
      AZISEDFAX,
      AZISEDMAIL,
      /* i seg. campi non sono gestiti:
      AZISEDDPLCOMPET,
      AZISEDORGANICO,
      AZISEDNUMDIPTICOMP,
      AZISEDNUMDIPTINONCOMP,
      AZISEDNUMDIPTIRIS,
      AZISEDNUMDIPTDCOMP,
      AZISEDNUMDIPTDNONCOMP,
      AZISEDNUMDIPTDRIS,
      AZISEDDATORENASCOM,
      AZISEDDATORENASDATA,
      AZISEDDATORESESSO,
      */
      LAVCODFIS,
      LAVCOGNOME,
      LAVNOME,
      LAVDATNAS,
      LAVSES,
      LAVNASCOM,
      LAVCIT,
      LAVRESCOM,
      LAVRESIND,
      LAVRESCAP,
      LAVDOMCOM,
      LAVDOMIND,
      LAVDOMCAP,
      LAVPSSCAD,
      -- Savino 23/01/2006: aggiunto campo codice motivo rilascio permesso di sogg.
      LAVPSMOT,
   LAVEXCODSTATUS,
   LAVTITSTUD,
      LAVCONIUG,
      LAVSCICA,
   AZIUTICNTDATFIN,
      AZIUTICODFISC,
      AZIUTIPARIVA,
      AZIUTIRAGSOC,
      AZIUTICODTIP,
      AZIUTIARTIGIANA,
      /* il seg. campo non viene gestito:
      AZIUTILEGRAP,
      */
      AZIUTIIND,
      AZIUTICAP,
      AZIUTICOM,
      AZIUTICODATT,
      AZIUTINUMDIP,
      --AZIUTICNTNUM,
      AZIUTICNTDATINI,
      --AZIUTICNTDATFIN,
      --AZIUTITOTSOGINT,
      AZIUTIINPS,
      AZIUTIINAIL,
      AZIUTISEDIND,
      AZIUTISEDCAP,
      AZIUTISEDCOM,
      AZIUTISEDTEL,
      AZIUTISEDFAX,
      AZIUTISEDMAIL,
      AVVNUMMAT,
      AVVDATAVV,
      AVVTEM,
      AVVTEMINDETDATAVV,
      AVVTEMDETDATAVV,
      AVVLUO,
      AVVTIPASS,
      --AVVNOR,
      AVVCOM,
   AVVNUMCONV,
   AVVDATACONV,
      AVVTIPORA,
      AVVTIPORA_FP,
      AVVFT,
      AVVPT,
      AVVTEMDETDATCES,
      AVVGIOAGRPRE,
      --AVVGIOAGREFF,
      AVVPTORAMEDSET,
      AVVQUA,
      /* i seg. campi non sono gestiti
      AVVMANS,
      AVVAREAFUN,
      */
      --AVVGRA,
      AVVLIV,
      AVVCCNL,
      AVVRETLORMEN,
      --AVVAILCFLDAT,
      --AVVAILCFLNUM,
      --AVVTIPCFLDURAPP,
      AVVBEN,
      /* i seg. campi non sono gestiti:
      AVVCON68DAT,
      AVVCON68NUM,
      AVVPRICONINT,
      AVVAREACCNL,
      AVVCAT,
      */
      AVVTIPOLOGIA,
      AVVINTASSPRO,
   AVVTIPOTRASF,
      CESDAT,
      CESMOT,
      CESQUA,
      --CESGRA,
      CESLIV,
      PTRNUOQUA,
      --PTRNUOGRA,
      PTRNUOLIV,
      PTRNUOCCNL,
      PTRNUOBEN,
      PRODATINI,
      PRODATFIN,
      TRADAT,
      TRANUOTEM,
      TRANUOTEMINDET,
      TRANUOTEMDET,
      TRANUOPTORAMEDSET,
      TRATIPASS,
      TRATIPORA,
      TRATIPORA_FP,
      APPNUMMESI,
      APPTUTCODFIS,
      APPTUTCOGNOME,
      APPTUTNOME,
      APPTUTESPLAVANNI,
      APPTUTTITIMP,
      APPTUTLIVINQ,
      APPTUTQUA,
      APPARTIG,
      AVVLAVORAGRIC--,
      --AVVCATEGAGRIC,
      --AVVQUALIFSRQ
      )
          SELECT
        /* codice cpi (lo stesso in input, vedi join) */
         LAVSTO.CODCPIORIG AS CODCPI,
     /* chiave del record in esame */
      MOV.PRGMOVIMENTO AS PRGMOVIMENTO,
      MOV.CODTIPOMOV AS CODTIPOMOV,
     /* riferimento al movimento temporalmente precedente */
      MOV.PRGMOVIMENTOPREC AS PRGMOVIMENTOPREC,
      DECODE(MOV.CODTIPOMOV,'AVV', MOV.PRGMOVIMENTO, NULL) AS PRGMOVIMENTOAVV,
      /* nota: se e' un avviamento metto il suo prog.; se non e' un avviamento lo recuperero' dopo */
     /* vari */
      NVL(MOV.DTMMOD, MOV.DTMINS) AS DTMINSMOD,
      LAVSTO.CODMONOTIPOCPI AS CODMONOTIPOCPI,
     /* referente / invio */
      MOV.CODCPI AS REFID,
      MOV.DATCOMUNICAZ AS REFDATINV,
      MOV.STRREFERENTE AS REFMIT,
     /* evento */
      MOV.CODTIPOMOV AS EVECOD,
      MOV.DATINIZIOMOV AS EVEDAT,
     /* unita produttiva */
      AZI.STRCODICEFISCALE AS AZICODFISC,
      AZI.STRPARTITAIVA AS AZIUNIPARIVA,
      AZI.STRRAGIONESOCIALE AS AZIUNIRAGSOC,
      AZIUNI.STRINDIRIZZO AS AZIUNIIND,
      AZIUNI.STRCAP AS AZIUNICAP,
      AZIUNI.CODCOM AS AZIUNICOM,
      AZIUNI.STRTEL AS AZIUNITEL,
      AZIUNI.STRFAX AS AZIUNIFAX,
      AZIUNI.STREMAIL AS AZIUNIMAIL,
      AZIUNI.CODATECO AS AZIUNICODATT,
      AZIUNI.CODCCNL AS AZIUNICCNL,
      AZI.NUMDIPENDENTI AS AZIUNINUMDIP,
      AZIUNI.STRNUMEROINPS AS AZIUNIINPS,
      AZIUNI.STRNUMREGISTROCOMMITT AS AZIUNINUMREGCODDOM,
      AZI.STRNUMALBOINTERINALI AS AZIUNINUMALBINT,
      AZI.STRPATINAIL AS AZIINAIL,
   AZI.CODTIPOAZIENDA AS AZITIPOAZIENDA,
     /* sede legale (se presente) */
      AZI.STRRAGIONESOCIALE AS AZISEDRAGSOC,
      /*
        Per i campi di indirizzo (da AZISEDIND a AZISEDMAIL) avevo in origine cose del tipo:
        DECODE(AZISED.PRGAZIENDA, NULL, AZIUNI.xxx, AZISED.xxx) AS AZISEDxxx,
        12/1/05: si lascia il campo originale, se e' vuoto non si riporta l'indirizzo dell'unita'.
       */
      AZISED.STRINDIRIZZO AS AZISEDIND,
      AZISED.STRCAP AS AZISEDCAP,
      AZISED.CODCOM AS AZISEDCOM,
      AZISED.STRTEL AS AZISEDTEL,
      AZISED.STRFAX AS AZISEDFAX,
      AZISED.STREMAIL AS AZISEDMAIL,
     /* i seg. campi non sono gestiti:
      null AS AZISEDDPLCOMPET,
      null AS AZISEDORGANICO,
      null AS AZISEDNUMDIPTICOMP,
      null AS AZISEDNUMDIPTINONCOMP,
      null AS AZISEDNUMDIPTIRIS,
      null AS AZISEDNUMDIPTDCOMP,
      null AS AZISEDNUMDIPTDNONCOMP,
      null AS AZISEDNUMDIPTDRIS,
      null AS AZISEDDATORENASCOM,
      null AS AZISEDDATORENASDATA,
      null AS AZISEDDATORESESSO,
     */
     /* lavoratore */
      LAV.STRCODICEFISCALE AS LAVCODFIS,
      LAV.STRCOGNOME AS LAVCOGNOME,
      LAV.STRNOME AS LAVNOME,
      LAV.DATNASC AS LAVDATNAS,
      LAV.STRSESSO AS LAVSES,
      LAV.CODCOMNAS AS LAVNASCOM,
      LAV.CODCITTADINANZA AS LAVCIT,
      LAV.CODCOMRES AS LAVRESCOM,
      LAV.STRINDIRIZZORES AS LAVRESIND,
      LAV.STRCAPRES AS LAVRESCAP,
            DECODE(CPI.FLGMOVORIGMIGR,'N',
                   DECODE(trim(LAV.CODCOMDOM),'NT','',LAV.CODCOMDOM),
                   LAV.CODCOMDOM
            ) AS LAVDOMCOM,
      LAV.STRINDIRIZZODOM AS LAVDOMIND,
      LAV.STRCAPDOM AS LAVDOMCAP,
      /*
         LAVPSSCAD := NULL se lavoratore non extracomunitario o le e ma CODSTATUS=2 oppure 5;
                      DATSCADENZA (a 31/12/2040 se e nulla) altrimenti.
      */
      DECODE(LAVEXC.PRGPERMSOGG,NULL, NULL,
       DECODE(LAVEXC.CODSTATUS,'2', NULL,'5',NULL,
        NVL(LAVEXC.DATSCADENZA, TO_DATE('31/12/2040','DD/MM/YYYY') )
       )
      ) AS LAVPSSCAD,
      LAVEXC.CODMOTIVORIL AS LAVPSMOT,
   LAVEXC.CODSTATUS AS LAVEXCODSTATUS,
      MOV.CODTITOLO AS LAVTITSTUD,
      DECODE(LAV.CODSTATOCIVILE,'C', 'X',NULL) AS LAVCONIUG,
      MOV.CODCPILAV AS LAVSCICA,
     /* Se il tipo di trasformazione è 'DL' (distacco lavoratore) 
     prendiamo i dati dall'azienda distaccataria, altrimenti 
  dall' azienda utilizzatrice */
      DECODE(MOV.CODTIPOTRASF, 'DL', MOV.DATFINEDISTACCO, MOV.DATFINERAPLAV) AS AZIUTICNTDATFIN,
   DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.STRCODICEFISCALE, AZIUTI.STRCODICEFISCALE) AS AZIUTICODFISC,
   DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.STRPARTITAIVA, AZIUTI.STRPARTITAIVA) AS AZIUTIPARIVA,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.STRRAGIONESOCIALE, AZIUTI.STRRAGIONESOCIALE) AS AZIUTIRAGSOC,
   DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.CODTIPOAZIENDA, AZIUTI.CODTIPOAZIENDA) AS AZIUTICODTIP,
      DECODE(MOV.CODTIPOTRASF, 'DL', DECODE(AZIDIST.CODTIPOAZIENDA,'ART', 'X',NULL), DECODE(AZIUTI.CODTIPOAZIENDA,'ART', 'X',NULL)) AS AZIUTIARTIGIANA,
     /* il seg. campo non viene gestito:
      null AS AZIUTILEGRAP,
     */
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTUNI.STRINDIRIZZO, AZIUTIUNI.STRINDIRIZZO) AS AZIUTIIND,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTUNI.STRCAP, AZIUTIUNI.STRCAP) AS AZIUTICAP,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTUNI.CODCOM, AZIUTIUNI.CODCOM) AS AZIUTICOM,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTUNI.CODATECO, AZIUTIUNI.CODATECO) AS AZIUTICODATT,
   DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.NUMDIPENDENTI, AZIUTI.NUMDIPENDENTI) AS AZIUTINUMDIP,
      --MOV.STRAZINTNUMCONTRATTO AS AZIUTICNTNUM,
      MOV.DATINIZIORAPLAV AS AZIUTICNTDATINI,
      --MOV.DATAZINTFINECONTRATTO AS AZIUTICNTDATFIN,
      --MOV.NUMAZINTSOGGETTI AS AZIUTITOTSOGINT,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTUNI.STRNUMEROINPS, AZIUTIUNI.STRNUMEROINPS) AS AZIUTIINPS,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDIST.STRPATINAIL, AZIUTI.STRPATINAIL) AS AZIUTIINAIL,
      /*
        12/1/05: analogamente a AZISED e AZIUNI, si lascia il campo originale:
        non piu': DECODE(AZIUTISED.PRGAZIENDA, NULL, AZIUTIUNI.xxx, AZIUTISED.xxx) AS AZIUTISEDxxx,
       */
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.STRINDIRIZZO, AZIUTISED.STRINDIRIZZO) AS AZIUTISEDIND,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.STRCAP, AZIUTISED.STRCAP) AS AZIUTISEDCAP,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.CODCOM, AZIUTISED.CODCOM) AS AZIUTISEDCOM,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.STRTEL, AZIUTISED.STRTEL) AS AZIUTISEDTEL,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.STRFAX, AZIUTISED.STRFAX) AS AZIUTISEDFAX,
      DECODE(MOV.CODTIPOTRASF, 'DL', AZIDISTSED.STREMAIL, AZIUTISED.STREMAIL) AS AZIUTISEDMAIL,
     /* avviamento */
         /* NOTA: non faccio la DECODE(MOV.CODTIPOMOV,'AVV',...,NULL) perche' tanto se non e' un */
         /* avviamento, dopo andro' a ricercare il suo avviamento originale e rimpiazzero' i dati  */
      MOV.STRMATRICOLA AS AVVNUMMAT,
      MOV.DATINIZIOAVV AS AVVDATAVV,
      MOV.CODMONOTEMPO AS AVVTEM,
      DECODE(MOV.CODMONOTEMPO, 'I', MOV.DATINIZIOAVV, NULL) AS AVVTEMINDETDATAVV,
      DECODE(MOV.CODMONOTEMPO, 'D', MOV.DATINIZIOAVV, NULL) AS AVVTEMDETDATAVV,
      MOV.STRLUOGODILAVORO AS AVVLUO,
      MOV.CODTIPOCONTRATTO AS AVVTIPASS,
      --MOV.CODNORMATIVA AS AVVNOR,
      DECODE(UPPER(MOV.FLGLEGGE68), 'S', 'X',NULL) AS AVVCOM,
   MOV.NUMCONVENZIONE AS AVVNUMCONV,
   MOV.DATCONVENZIONE AS AVVDATACONV,
      MOV.CODORARIO AS AVVTIPORA,
      DECODE(SUBSTR(MOV.CODORARIO,1,2), NULL,NULL, 'TP','F', 'P')  AS AVVTIPORA_FP,
      DECODE(SUBSTR(MOV.CODORARIO,1,2), 'TP', 'X',NULL) AS AVVFT,
      DECODE(SUBSTR(MOV.CODORARIO,1,2), 'PT', 'X','M','X',NULL) AS AVVPT,
      MOV.DATFINEMOV AS AVVTEMDETDATCES,
      MOV.NUMGGPREVISTIAGR AS AVVGIOAGRPRE,
      --MOV.NUMGGEFFETTUATIAGR AS AVVGIOAGREFF,
      MOV.NUMORESETT AS AVVPTORAMEDSET,
      MOV.CODMANSIONE AS AVVQUA,
     /* i seg. campi non sono gestiti (il primo è definito BLANK):
      null AS AVVMANS,
      null AS AVVAREAFUN,
     */
      --MOV.CODGRADO AS AVVGRA,
      MOV.NUMLIVELLO AS AVVLIV,
            DECODE(CPI.FLGMOVORIGMIGR,'N',
                   DECODE(trim(MOV.CODCCNL),'NT','',MOV.CODCCNL),
                   MOV.CODCCNL
            ) AS AVVCCNL,
      MOV.DECRETRIBUZIONEMEN AS AVVRETLORMEN,
      --MOV.DATCFL AS AVVAILCFLDAT,
      --MOV.STRNUMCFL AS AVVAILCFLNUM,
      --MOV.STRTIPOCFL AS AVVTIPCFLDURAPP,
      MOV.CODAGEVOLAZIONE AS AVVBEN,
     /* i seg. campi non sono gestiti:
      null AS AVVCON68DAT,
      null AS AVVCON68NUM,
      null AS AVVPRICONINT,
      null AS AVVAREACCNL,
      null AS AVVCAT,
     */
      DECODE(MOVAPP.NUMMESIAPPRENDISTATO, NULL, NULL,
       'N. mesi apprendistato: ' || MOVAPP.NUMMESIAPPRENDISTATO) AS AVVTIPOLOGIA,
      /* 12/1/05 - aggiunto campo AVVINTASSPRO (se nullo metto N) */
      NVL(MOV.FLGINTERASSPROPRIA,'N') AS AVVINTASSPRO,
   MOV.CODTIPOTRASF AS AVVTIPOTRASF,
     /* cessazione */
      DECODE(MOV.CODTIPOMOV,'CES', MOV.DATINIZIOMOV,    NULL) AS CESDAT,
      DECODE(MOV.CODTIPOMOV,'CES', MOV.CODMVCESSAZIONE, NULL) AS CESMOT,
      DECODE(MOV.CODTIPOMOV,'CES', MOV.CODMANSIONE, NULL) AS CESQUA,
      --DECODE(MOV.CODTIPOMOV,'CES', MOV.CODGRADO, NULL) AS CESGRA,
      DECODE(MOV.CODTIPOMOV,'CES', MOV.NUMLIVELLO, NULL) AS CESLIV,
     /* proroga/trasformazione */
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.CODMANSIONE,
                            'TRA', MOV.CODMANSIONE, NULL) AS PTRNUOQUA,
      --DECODE(MOV.CODTIPOMOV,'PRO', MOV.CODGRADO,'TRA', MOV.CODGRADO, NULL) AS PTRNUOGRA,
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.NUMLIVELLO,
                            'TRA', MOV.NUMLIVELLO, NULL) AS PTRNUOLIV,
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.CODCCNL,
                            'TRA', MOV.CODCCNL, NULL) AS PTRNUOCCNL,
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.CODAGEVOLAZIONE,
                            'TRA', MOV.CODAGEVOLAZIONE, NULL) AS PTRNUOBEN,
     /* proroga */
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.DATINIZIOMOV, NULL) AS PRODATINI,
      DECODE(MOV.CODTIPOMOV,'PRO', MOV.DATFINEMOV, NULL) AS PRODATFIN,
     /* trasformazione */
      DECODE(MOV.CODTIPOMOV,'TRA', MOV.DATINIZIOMOV, NULL) AS TRADAT,
      DECODE(MOV.CODTIPOMOV,'TRA', MOV.CODMONOTEMPO, NULL) AS TRANUOTEM,
      DECODE(MOV.CODTIPOMOV,'TRA',
        DECODE(MOV.CODMONOTEMPO, 'I', 'X', NULL),
        NULL) AS TRANUOTEMINDET,
      DECODE(MOV.CODTIPOMOV,'TRA',
        DECODE(MOV.CODMONOTEMPO, 'D', 'X', NULL),
        NULL) AS TRANUOTEMDET,
      DECODE(MOV.CODTIPOMOV,'TRA', MOV.NUMORESETT, NULL) AS TRANUOPTORAMEDSET,
      DECODE(MOV.CODTIPOMOV,'TRA', MOV.CODTIPOCONTRATTO, NULL) AS TRATIPASS,
      DECODE(MOV.CODTIPOMOV,'TRA', MOV.CODORARIO,  NULL) AS TRATIPORA,
      DECODE(MOV.CODTIPOMOV,'TRA', DECODE(SUBSTR(MOV.CODORARIO,1,2), NULL,NULL, 'TP','F', 'P'), NULL) AS TRATIPORA_FP,
     /* apprendista */
         MOVAPP.NUMMESIAPPRENDISTATO AS APPNUMMESI,
      MOVAPP.STRCODICEFISCALETUTORE AS APPTUTCODFIS,
      MOVAPP.STRCOGNOMETUTORE AS APPTUTCOGNOME,
      MOVAPP.STRNOMETUTORE AS APPTUTNOME,
      MOVAPP.NUMANNIESPTUTORE AS APPTUTESPLAVANNI,
      MOVAPP.FLGTITOLARETUTORE AS APPTUTTITIMP,
      DECODE(MOVAPP.FLGTITOLARETUTORE,NULL, MOVAPP.STRLIVELLOTUTORE,  NULL) AS APPTUTLIVINQ,
      DECODE(MOVAPP.FLGTITOLARETUTORE,NULL, MOVAPP.CODMANSIONETUTORE, NULL) AS APPTUTQUA,
      MOVAPP.FLGARTIGIANA AS APPARTIG,
      MOV.CODLAVORAZIONE--,
      --MOV.CODCATEGORIA,
      --MOV.CODQUALIFICASRQ
    FROM
     AM_MOVIMENTO MOV,
     DE_TIPO_CONTRATTO TIPOASS,
     TS_GENERALE,
     AM_MOVIMENTO_APPRENDIST MOVAPP,
     AN_LAVORATORE LAV,
     AN_AZIENDA AZI,
     AN_UNITA_AZIENDA AZIUNI,
     AN_UNITA_AZIENDA AZISED,
     AN_AZIENDA AZIUTI,
     AN_UNITA_AZIENDA AZIUTIUNI,
     AN_UNITA_AZIENDA AZIUTISED,
  AN_AZIENDA AZIDIST,
     AN_UNITA_AZIENDA AZIDISTUNI,
     AN_UNITA_AZIENDA AZIDISTSED,
     --PR_STUDIO LAVSTU,
     AN_LAV_STORIA_INF LAVSTO,
     AM_EX_PERM_SOGG LAVEXC,
          DE_CPI CPI
    WHERE
       MOVAPP.PRGMOVIMENTO (+)= MOV.PRGMOVIMENTO
    /* lavoratore  */
    AND   LAV.CDNLAVORATORE      = MOV.CDNLAVORATORE
    /* storico lavoratore */
    AND   LAVSTO.CDNLAVORATORE   = MOV.CDNLAVORATORE
    AND   DECODE(LAVSTO.DATFINE, NULL, 'S','N') = 'S'    /* usa IX_AN_LAV_STORI_DATFINE_NULL */
    /* sede e unita azienda */
    AND   AZI.PRGAZIENDA         = MOV.PRGAZIENDA
    AND   AZISED.PRGAZIENDA   (+)= MOV.PRGAZIENDA
    AND   AZISED.FLGSEDE      (+)= 'S'
    AND   AZIUNI.PRGAZIENDA      = MOV.PRGAZIENDA
    AND   AZIUNI.PRGUNITA        = MOV.PRGUNITA
    /* azienda e unita utilizzatrice */
    AND   AZIUTI.PRGAZIENDA   (+)= MOV.PRGAZIENDAUTILIZ
    AND   AZIUTISED.PRGAZIENDA(+)= MOV.PRGAZIENDAUTILIZ
    AND   AZIUTISED.FLGSEDE   (+)= 'S'
    AND   AZIUTIUNI.PRGAZIENDA(+)= MOV.PRGAZIENDAUTILIZ
    AND   AZIUTIUNI.PRGUNITA  (+)= MOV.PRGUNITAUTILIZ
 /*azienda e unita distaccataria*/
 AND   AZIDIST.PRGAZIENDA   (+)= MOV.PRGAZIENDADIST
    AND   AZIDISTSED.PRGAZIENDA(+)= MOV.PRGAZIENDADIST
    AND   AZIDISTSED.FLGSEDE   (+)= 'S'
    AND   AZIDISTUNI.PRGAZIENDA(+)= MOV.PRGAZIENDADIST
    AND   AZIDISTUNI.PRGUNITA  (+)= MOV.PRGUNITADIST
    /* titolo studio lavoratore */
    --AND   LAVSTU.CDNLAVORATORE(+)= LAV.CDNLAVORATORE
    --AND   LAVSTU.FLGPRINCIPALE(+)= 'S'
    /* dati se lavoratore extracomunitario */
    AND   LAVEXC.CDNLAVORATORE(+)= LAV.CDNLAVORATORE
    AND   DECODE(LAVEXC.DATFINE, NULL, 'S','N') = 'S'    /* usa IX_AM_EX_PS_DATFINE_NULL */
    /* filtro sul CPI che viene PRESO DALLA QUERY PRECEDENTE */
    AND   LAVSTO.CODCPIORIG      = inputCodCpi
    /* Inseriti o modificati dopo datUltimaMigrazione (in input, in formato data+ora) */
    AND   MOV.DTMINS
          BETWEEN dataUltimaMigrazione
          AND     dataQuestaMigrazione - (1/86400) /* tolgo 1 secondo */
          /* usa IX_AM_MOVIMENTO_DTMMOD */
    /* solo i record con scheda lavoratore (T) */
    AND   LAVSTO.CODMONOTIPOCPI  = 'T'
 /* Esposito 16/04/2008 - Si esportano solo i movimenti inseriti manualmente */
 AND MOV.CODMONOPROV = 'M'
    /* con stato 'PROTOCOLLATO' */
    AND   MOV.CODSTATOATTO       = 'PR'
    /* che proviene da comunicazione Obbligatoria */
    AND MOV.CODMONOMOVDICH       = 'O'
        AND LAVSTO.CODCPIORIG = CPI.CODCPI
          AND MOV.CODTIPOCONTRATTO = TIPOASS.CODTIPOCONTRATTO(+)
          AND (
          (UPPER(NVL(TS_GENERALE.FLGMIGRATIROCINI,'S')) = 'N' AND NVL(TIPOASS.CODMONOTIPO, ' ') <> 'T') OR
          (UPPER(NVL(TS_GENERALE.FLGMIGRATIROCINI,'S')) <> 'N')
          )
          ORDER BY MOV.DATINIZIOMOV ASC;
    /*
     ATTENZIONE: LE ULTIME CONDIZIONI IN "AND" DELLA QUERY SONO PRESENTI ANCHE
     NEL FILE XML DI CONFIGURAZIONE "/conf/statements/esportaMigrazioni.xml".
     IN CASO DI MODIFICA, MODIFICARE ANCHE LA'.
    */

 numScritti := SQL%ROWCOUNT;


 /* PASSO 2: PER I MOVIMENTI CHE NON SONO 'AVV' SCORRO I PRECEDENTI FINO AL PRIMO 'AVV' E USO I SUOI DATI */

 AGGIORNA_MIGR_IN_APP_NON_AVV(inputCodCpi);


 /* PASSO 3: DECODIFICO I CODICI DIRETTAMENTE SULLA TABELLA DI APPOGGIO */

 DECODIFICA_CODICI_IN_APP(inputCodCpi);


 /* RITORNO */

 RETURN numScritti;

END ESPORTA_MIGRAZIONI_CPI_IN_APP;

FUNCTION ESPORTA_MOVIMENTO(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
          RETURN typRefCurs

IS
p_errCode  number;
rowMovAvv  AM_MOVIMENTO%ROWTYPE;
p_prgmovimentoprec Am_Movimento.Prgmovimentoprec%TYPE;
query_select varchar2(10000);
risultato typRefCurs;
p_strMatricola am_movimento.strmatricola%type;
p_codmonotempo am_movimento.codmonotempo%type;
p_datinizioavv am_movimento.datinizioavv%type;
p_strluogodilavoro am_movimento.strluogodilavoro%type;
p_codtipoass am_movimento.codtipocontratto%type;
--p_codnormativa am_movimento.codnormativa%type;
p_flglegge68 am_movimento.flglegge68%type;
p_codorario am_movimento.codorario%type;
p_datfinemov am_movimento.datfinemov%type;
p_numggprevistiagr am_movimento.numggprevistiagr%type;
--p_numggeffettuatiagr am_movimento.numggeffettuatiagr%type;
p_numoresett am_movimento.numoresett%type;
p_codmansione am_movimento.codmansione%type;
--p_codgrado am_movimento.codgrado%type;
p_numlivello am_movimento.numlivello%type;
p_codccnl am_movimento.codccnl%type;
--p_datcfl am_movimento.datcfl%type;
--p_strnumcfl am_movimento.strnumcfl%type;
--p_strtipocfl am_movimento.strtipocfl%type;
p_codagevolazione am_movimento.codagevolazione%type;


BEGIN

  select mov.prgmovimentoprec into p_prgmovimentoprec
  from am_movimento mov where mov.prgmovimento = prgMov;

  -- CONTROLLO se esiste il prgmovimentoprecendente per recuperare l'avviamento
  IF p_prgmovimentoprec is not null THEN
   rowMovAvv := RECUPERA_MIGRAZIONE_AVV_PREC(prgMov);
 ELSE
   rowMovAvv := RECUPERA_MIGRAZIONE_MOV_PREC(prgMov);
 END IF;

  p_strMatricola := rowmovavv.strmatricola;
  p_codmonotempo := rowmovavv.codmonotempo;
  p_datinizioavv := rowmovavv.datinizioavv;
  p_strluogodilavoro := Pg_Utils.Quote(rowmovavv.strluogodilavoro);
  p_codtipoass := rowmovavv.codtipocontratto;
  --p_codnormativa := rowmovavv.codnormativa;
  p_flglegge68 := rowmovavv.flglegge68;
  p_codorario := rowmovavv.codorario;
  p_datfinemov := rowmovavv.datfinemov;
  p_numggprevistiagr := rowmovavv.numggprevistiagr;
  --p_numggeffettuatiagr := rowmovavv.numggeffettuatiagr;
  p_numoresett := rowmovavv.numoresett;
  p_codmansione := rowmovavv.codmansione;
  --p_codgrado := rowmovavv.codgrado;
  p_numlivello := rowmovavv.numlivello;
  p_codccnl := rowmovavv.codccnl;
  --p_datcfl := rowmovavv.datcfl;
  --p_strnumcfl := rowmovavv.strnumcfl;
  --p_strtipocfl := rowmovavv.strtipocfl;
  p_codagevolazione := rowmovavv.codagevolazione;


  query_select := 'select l.STRCOGNOME || '' '' || l.STRNOME as nome,



       mov.CODTIPOMOV       as MOV_CODTIPOMOV,



       mov.CODTIPOMOV       as evento,



       /* Datore di lavoro */



       az.STRCODICEFISCALE  as CodFiscAz,



       az.STRPARTITAIVA     as PartIvaAz,



       az.STRRAGIONESOCIALE as RagSocAz,



       uaz.STRINDIRIZZO     as IndirAz,



       cuaz.STRCAP          as CapAz,



       cuaz.CODCOM          as CodComAz,



       uaz.STRTEL           as TelAz,



       uaz.STRFAX           as FaxAz,



       uaz.STREMAIL         as EmailAz,



       uaz.CODATECO         as CodAtecoAz,



       uaz.CODCCNL          as CcnlAz,



       -- Numero dipendenti ????



       -- Numero INPS ????



       azsed.STRNUMREGISTROCOMMITT as NumRegistroCommittDom,



       az.STRNUMALBOINTERINALI as NumAlboInterinaliAz,



       azsed.STRINDIRIZZO      as IndirSede,



       azsed.CODCOM            as CodComSede,



       /* i seg. campi non sono gestiti:



        null AS AZSED_DPLCOMPET,



        null AS AZSED_ORGANICO,



        null AS AZSED_NUMDIPTICOMP,



        null AS AZSED_NUMDIPTINONCOMP,



        null AS AZSED_NUMDIPTIRIS,



        null AS AZSED_NUMDIPTDCOMP,



        null AS AZSED_NUMDIPTDNONCOMP,



        null AS AZSED_NUMDIPTDRIS,



        null AS AZSED_DATORENASCOM,



        null AS AZSED_DATORENASDATA,



        null AS AZSED_DATORESESSO,



       */



       /* Ditta individuale */



       /* Lavoratore */



       l.STRCODICEFISCALE as CodFiscLav,



       l.STRCOGNOME       as CognomeLav,



       l.STRNOME          as NomeLav,



       to_char(l.DATNASC, ''ddmmyyyy'')          as DataNascitaLav,



       l.CODCOMNAS        as CodComNascitaLav,



       l.STRSESSO         as SessoLav,



       l.CODCOMDOM        as CodComDomicilioLav,



       l.CODCITTADINANZA  as CodCittadinanzaLav,



       l.CODCOMRES        as CodComResidenzaLav,



       -- MANCA SCADENZA PERMESSO DI SOGGIORNO



       l.STRINDIRIZZORES   as IndirizzoLav,



       l.STRCAPRES         as CapLav,



       -- Titolo di studio



       -- Lavoratore coniugato



       LAVSTO.CODCPIORIG      as CPILav,



       /* Gestione interinale */



       AZIUTI.STRCODICEFISCALE AS CodFiscAzUtil,



       AZIUTI.STRPARTITAIVA AS PartIvaAzUtil,



       AZIUTI.STRRAGIONESOCIALE AS RagSocAzUtil,



       DECODE(AZIUTI.CODTIPOAZIENDA,''ART'', ''X'',NULL) AS AzUtilArtigiana,



       NULL AS LegRapprAzUtil,



       AZIUTIUNI.STRINDIRIZZO AS IndirAzUtil,



    AZIUTIUNI.STRCAP AS CapAzUtil,



    AZIUTIUNI.CODCOM AS CodComAzUtil,



    AZIUTIUNI.CODATECO AS CodAtecoAzUtil,



    AZIUTI.NUMDIPENDENTI AS NumeroDipAzUtil,



    to_char(MOV.DATCOMUNICAZ,''ddmmyyyy'') AS dataEvento,



    --MOV.STRAZINTNUMCONTRATTO AS NumContrattoAzUtil,



    --to_char(MOV.DATAZINTINIZIOCONTRATTO, ''ddmmyyyy'')  AS DataInizioContrAzUtil,



    --to_char(MOV.DATAZINTFINECONTRATTO, ''ddmmyyyy'')  AS DataFineContrAzUtil,



    --MOV.NUMAZINTSOGGETTI AS SoggInteressAzUtil,



    MOV.STRREFERENTE AS Referente,



       /* Avviamento */



       '''|| p_strMatricola ||''' as MatricolaAvv,



       DECODE('''|| p_codmonotempo ||''', ''I'', to_char(TO_DATE('''|| p_datinizioavv ||'''),''ddmmyyyy''), NULL) AS DataAvvTempoInd,



       DECODE('''|| p_codmonotempo ||''', ''D'', to_char(TO_DATE('''|| p_datinizioavv ||'''),''ddmmyyyy''), NULL) AS DataAvvTempoDet,



       '''|| p_strluogodilavoro ||''' AS LuogoSvolgAvv,



       '''|| p_codtipoass ||''' AS CodTipoAvv,



       DECODE('''|| p_flglegge68 ||''', ''S'', ''X'',NULL) AS MOV_AVVCOM_AVV,



       DECODE(SUBSTR('''|| p_codorario ||''',1,2), ''TP'', ''X'',NULL) AS FullTimeAvv,



       DECODE(SUBSTR('''|| p_codorario ||''',1,2), ''PT'', ''X'', ''M'', ''X'', NULL) AS PartTimeAvv,



       to_char(TO_DATE('''|| p_datfinemov ||'''),''ddmmyyyy'') AS DataCessazTempoDetAvv,



       '''|| p_numggprevistiagr ||''' AS GgPrevistiAgric,



       '''|| p_numoresett ||''' AS OrarioMedioSettAvv,



       '''|| p_codmansione ||''' AS QualificaAvv,



       null AS MansioneAvv,



       null AS AreaFunzAvv,



       '''|| p_numlivello ||''' AS LivelloAvv,



       DECODE(CPI.FLGMOVORIGMIGR,''N'',



       DECODE(trim('''|| p_codccnl ||'''),''NT'','''','''|| p_codccnl ||'''),



                      '''|| p_codccnl ||'''



             ) AS CcnlAvv,



      '''|| p_codagevolazione ||''' AS BeneficiAvv,



       /* i seg. campi non sono gestiti:



       null AS AVVCON68DAT,



    null AS AVVCON68NUM,



    null AS AVVPRICONINT,



    null AS AVVAREACCNL,



     null AS AVVCAT,



       */



       /* Cessazione */



       DECODE(MOV.CODTIPOMOV,''CES'', to_char(MOV.DATINIZIOMOV, ''ddmmyyyy'') ,    NULL) AS DataCess,



    DECODE(MOV.CODTIPOMOV,''CES'', MOV.CODMVCESSAZIONE, NULL) AS MotivoCess,



       /* Pror/trasf */



       DECODE(MOV.CODTIPOMOV,''PRO'', MOV.CODMANSIONE,



                            ''TRA'', MOV.CODMANSIONE, NULL) AS NuovaQualProTrasf,



     --DECODE(MOV.CODTIPOMOV,''PRO'', MOV.CODGRADO, ''TRA'', MOV.CODGRADO, NULL) AS NuovoGradoProTrasf,



     DECODE(MOV.CODTIPOMOV,''PRO'', MOV.NUMLIVELLO,



                                ''TRA'', MOV.NUMLIVELLO, NULL) AS NuovoLivProTrasf,



     DECODE(MOV.CODTIPOMOV,''PRO'', MOV.CODCCNL,



                                ''TRA'', MOV.CODCCNL, NULL) AS NuovoCcnlProTrasf,



     DECODE(MOV.CODTIPOMOV,''PRO'', MOV.CODAGEVOLAZIONE,



                                ''TRA'', MOV.CODAGEVOLAZIONE, NULL) AS NuoviBeneficiProTrasf,



       /* proroga */



       DECODE(MOV.CODTIPOMOV,''PRO'', to_char(MOV.DATINIZIOMOV, ''ddmmyyyy'') , NULL) AS DataInizioPro,



    DECODE(MOV.CODTIPOMOV,''PRO'', to_char(MOV.DATFINEMOV, ''ddmmyyyy'') , NULL) AS DataFinePro,



       /* trasformazione */



       DECODE(MOV.CODTIPOMOV,''TRA'', to_char(MOV.DATINIZIOMOV, ''ddmmyyyy'') , NULL) AS DataTrasf,



       DECODE(MOV.CODTIPOMOV,''TRA'',



        DECODE(MOV.CODMONOTEMPO, ''I'', ''X'', NULL),



                          NULL) AS NuovoTempoIndTrasf,



    DECODE(MOV.CODTIPOMOV,''TRA'',



        DECODE(MOV.CODMONOTEMPO, ''D'', ''X'', NULL),



                          NULL) AS NuovoTempoDetTrasf,



       DECODE(MOV.CODTIPOMOV,''TRA'', MOV.NUMORESETT, NULL) AS NuovoOrarioMedioSettTrasf,



       /*  apprendista */



       MOVAPP.STRCODICEFISCALETUTORE AS CodFiscTutoreAppr,



       MOVAPP.STRCOGNOMETUTORE AS CognomeTutoreAppr,



    MOVAPP.STRNOMETUTORE AS NomeTutoreAppr,



    MOVAPP.NUMANNIESPTUTORE AS EspLavTutoreAppr,



    MOVAPP.FLGTITOLARETUTORE AS TitImpresaTutoreAppr,



       DECODE(MOVAPP.FLGTITOLARETUTORE,NULL, MOVAPP.STRLIVELLOTUTORE,  NULL) AS LivInqTutoreAppr,



    DECODE(MOVAPP.FLGTITOLARETUTORE,NULL, MOVAPP.CODMANSIONETUTORE, NULL) AS QualificaTutoreAppr,



       /* campi relativi al agricoltura */



       MOV.CODLAVORAZIONE AS CodLavorazione,



       MOV.NUMLIVELLO AS CodLivelloAgr,



       --MOV.CODCATEGORIA AS CodCategoria,



       /* campi matricola e qualifica */



    /* Se la matricola non è valorizzata, prendo quella del avviamento */



       NVL(DECODE(MOV.STRMATRICOLA,NULL,'''|| p_strMatricola ||''',MOV.STRMATRICOLA),''ND'') AS NewMatricolaAvv,



       --MOV.CODQUALIFICASRQ AS QualificaSRQ,



       MOV.decretribuzionemen AS DECRETRIBUZIONEMEN,



      /* Nuovi campi aggiunti con le comunicazioni UNICHE. DAVIDE:04/06/2007*/    



   MOV.CODCOMUNICAZIONE,



   MOV.CODENTE,



   MOV.STRCODICEENTEPREV,



   MOV.CODTIPOCONTRATTO,



   MOV.CODTIPOTRASF,



   TO_CHAR(MOV.DATINIZIORAPLAV, ''DD/MM/YYYY'') DATINIZIORAPLAV,



   TO_CHAR(MOV.DATFINERAPLAV, ''DD/MM/YYYY'') DATFINERAPLAV,



   MOV.CODSOGGETTO,



   AZ.STRNUMAGSOMMINISTRAZIONE,



   MOV.DATFINEPRORAPLAV,



            MOV.DATCESSRAPLAV,



            CODTIPOSOMM



   from am_movimento mov,



   an_lavoratore l,



   an_lav_storia_inf LAVSTO,



   an_azienda az,



   an_unita_azienda uaz,



   an_unita_azienda azsed,



   de_comune cuaz,



   AM_MOVIMENTO_APPRENDIST MOVAPP,



   AN_AZIENDA AZIUTI,



  AN_UNITA_AZIENDA AZIUTIUNI,



   AN_UNITA_AZIENDA AZIUTISED,



   DE_CPI CPI



   where mov.CDNLAVORATORE = l.CDNLAVORATORE



   and l.cdnlavoratore = LAVSTO.cdnlavoratore



   and decode(LAVSTO.DATFINE, null, ''S'', ''N'') = ''S''



   and mov.PRGAZIENDA    = az.PRGAZIENDA



   and mov.PRGUNITA      = uaz.PRGUNITA



   and az.PRGAZIENDA     = uaz.PRGAZIENDA



   and uaz.CODCOM        = cuaz.CODCOM



   and mov.PRGAZIENDA    = azsed.PRGAZIENDA (+)



   and azsed.FLGSEDE  (+)= ''S''



   AND   MOVAPP.PRGMOVIMENTO (+)= MOV.PRGMOVIMENTO



   AND   AZIUTI.PRGAZIENDA   (+)= MOV.PRGAZIENDAUTILIZ



   AND   AZIUTISED.PRGAZIENDA(+)= MOV.PRGAZIENDAUTILIZ



   AND   AZIUTISED.FLGSEDE   (+)= ''S''



   AND   AZIUTIUNI.PRGAZIENDA(+)= MOV.PRGAZIENDAUTILIZ



   AND   AZIUTIUNI.PRGUNITA  (+)= MOV.PRGUNITAUTILIZ



   AND   cuaz.codcpi = CPI.CODCPI



   and mov.PRGMOVIMENTO  ='|| prgMov;

  open risultato for query_select;

  return risultato;

  EXCEPTION
       when others then
            DBMS_OUTPUT.PUT_LINE('Error code: ' || SQLCODE);
          DBMS_OUTPUT.PUT_LINE('Error mesg: ' || SUBSTR(SQLERRM,1,100));

       return risultato;

END ESPORTA_MOVIMENTO;

END PG_MIGRAZIONI;
/



/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_MOV_CATENE_ERRATE.sql
************************************************************************************** */


create or replace PACKAGE PG_MOV_CATENE_ERRATE IS

TYPE typRefCurs IS REF CURSOR;

FUNCTION CHECK_MOVIMENTI_RIPETUTI(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type
                                  )
                             RETURN NUMBER;  
FUNCTION CHECK_MOVIMENTI_SUCCESSIVI(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type )
          RETURN NUMBER;  
FUNCTION CHECK_MOVIMENTI_PRECEDENTI(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type )
          RETURN NUMBER;  
FUNCTION CHECK_MOVIMENTI_SUCC_APPR(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type )
          RETURN NUMBER;  
FUNCTION CHECK_MOVIMENTI_PREC_APPR(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type )
          RETURN NUMBER;  
FUNCTION CHECK_MOVIMENTI_SUCC_PREC(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type )
          RETURN NUMBER;  
FUNCTION CHECK_MOVIMENTI_PREC_SUCC(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type )
          RETURN NUMBER;  
FUNCTION CHECK_MOVIMENTI_PREC_AR_AN(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type )
          RETURN NUMBER;  
FUNCTION CHECK_MOVIMENTI_SUCC_AR_AN(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type)
                             RETURN NUMBER;
FUNCTION CHECK_MOV_RIPETUTI_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER;
FUNCTION CHECK_MOV_SUCCESSIVI_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER;
FUNCTION CHECK_MOV_PRECEDENTI_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER;
FUNCTION CHECK_MOV_SUCC_APPR_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER;
FUNCTION CHECK_MOV_PREC_APPR_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER;
FUNCTION CHECK_MOV_SUCC_PREC_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER;
FUNCTION CHECK_MOV_PREC_SUCC_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER;
FUNCTION CHECK_MOV_PREC_AR_AN_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER;
FUNCTION CHECK_MOV_SUCC_AR_AN_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER;                                                                                                                                                                                                                                                                    

END PG_MOV_CATENE_ERRATE;
/

create or replace PACKAGE BODY PG_MOV_CATENE_ERRATE IS

-- controllo 1 
-- All'interno dello stesso movimento (se valorizzati) prgmovimento, prgmovimentosucc e prgmovimentoprec devono essere tutti diversi tra loro  
-- ovvero non devono esserci riferimenti circolari all'interno dello stesso movimento (protocollato).
FUNCTION CHECK_MOVIMENTI_RIPETUTI(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type
                                  )
                             RETURN NUMBER IS

numMovimentiRipetuti number;


BEGIN

select count(*) ripetizioni into numMovimentiRipetuti
		from am_movimento mov 
 		where mov.cdnlavoratore = p_cdnLavoratore and mov.codstatoatto = 'PR'
 		and (mov.prgmovimento = mov.prgmovimentoprec 
    		or  mov.prgmovimento = mov.prgmovimentosucc 
    		or mov.prgmovimentoprec = mov.prgmovimentosucc
    	);



RETURN numMovimentiRipetuti;


EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_RIPETUTI= ' || sqlcode || ' ' || sqlerrm || ' p_cdnLavoratore=' || p_cdnLavoratore);
       --rollback;
        return 1;

END CHECK_MOVIMENTI_RIPETUTI;

-- controllo 2 
-- Un movimento protocollato non può essere successivo a più di un movimento protocollato
FUNCTION CHECK_MOVIMENTI_SUCCESSIVI(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type)
                             RETURN NUMBER IS

numMovimentiSuccessivi number;

BEGIN

select count(*) into numMovimentiSuccessivi
		from am_movimento mov
 		where mov.cdnlavoratore = p_cdnLavoratore and mov.codstatoatto = 'PR'
 		and exists (
			select mov1.prgmovimento, count(*)
			from am_movimento mov1 
			where mov1.prgmovimentosucc = mov.prgmovimento 
			and mov1.codstatoatto = 'PR'
			group by mov1.prgmovimento
			having count(*) > 1);

RETURN numMovimentiSuccessivi;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_SUCCESSIVI= ' || sqlcode || ' ' || sqlerrm || ' p_cdnLavoratore=' || p_cdnLavoratore);
       --rollback;
       return 1;

END CHECK_MOVIMENTI_SUCCESSIVI;

-- controllo 3
-- Un movimento protocollato non può essere il precedente di più di un movimento protocollato
FUNCTION CHECK_MOVIMENTI_PRECEDENTI(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type)
                             RETURN NUMBER IS

numMovimentiPrecedenti number;

BEGIN

select count(*) into numMovimentiPrecedenti
		from am_movimento mov
 		where mov.cdnlavoratore = p_cdnLavoratore and mov.codstatoatto = 'PR'
 		and exists (
			select mov1.prgmovimento, count(*)
			from am_movimento mov1 
			where mov1.prgmovimentoprec = mov.prgmovimento 
			and mov1.codstatoatto = 'PR'
			group by mov1.prgmovimento
			having count(*) > 1
			);

RETURN numMovimentiPrecedenti;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_PRECEDENTI= ' || sqlcode || ' ' || sqlerrm || ' p_cdnLavoratore=' || p_cdnLavoratore);
       --rollback;
       return 1;

END CHECK_MOVIMENTI_PRECEDENTI;


-- controllo 4
-- Non deve esistere un movimento protocollato che abbia un successivo valorizzato tale per cui 
-- il movimento successivo protocollato non sia correttamente collegato, 
-- ovvero:  1) ha un precedente diverso  2) il precedente è nullo
FUNCTION CHECK_MOVIMENTI_SUCC_APPR(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type)
                             RETURN NUMBER IS

numMovimentiSuccAppr number;

BEGIN

select count(*) into numMovimentiSuccAppr
		from am_movimento mov
 		where mov.cdnlavoratore = p_cdnLavoratore and mov.codstatoatto = 'PR'
 		and mov.prgmovimentosucc is not null
 		and exists 
		  (select mov1.prgmovimento
    		from am_movimento mov1 
    		where mov1.prgmovimento = mov.prgmovimentosucc 
    		and mov1.codstatoatto = 'PR' 
   			 AND 
		    ( MOV1.PRGMOVIMENTOsucc = MOV.PRGMOVIMENTO OR 
		      MOV1.PRGMOVIMENTOsucc = MOV.PRGMOVIMENTOprec OR
		      NVL(MOV1.PRGMOVIMENTOPREC, MOV.PRGMOVIMENTO) <> MOV.PRGMOVIMENTO)
		  );

RETURN numMovimentiSuccAppr;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_SUCC_APPR= ' || sqlcode || ' ' || sqlerrm || ' p_cdnLavoratore=' || p_cdnLavoratore);
       --rollback;
       return 1;

END CHECK_MOVIMENTI_SUCC_APPR;

-- controllo 5
-- Non deve esistere un movimento protocollato che abbia un precedente valorizzato tale per cui 
-- il movimento precedente protocollato non sia correttamente collegato, 
-- ovvero:  1) ha un successivo diverso  2) il successivo è nullo
FUNCTION CHECK_MOVIMENTI_PREC_APPR(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type)
                             RETURN NUMBER IS

numMovimentiPrecAppr number;

BEGIN

select count(*) into numMovimentiPrecAppr
		from am_movimento mov
 		where mov.cdnlavoratore = p_cdnLavoratore and mov.codstatoatto = 'PR'
 		and mov.prgmovimentoprec is not null
 		and exists 
		  (select mov1.prgmovimento
    		from am_movimento mov1 
    		where mov1.prgmovimento = mov.prgmovimentoprec   
    		and mov1.codstatoatto = 'PR' 
    		AND 
		    ( MOV1.PRGMOVIMENTOPREC = MOV.PRGMOVIMENTO OR 
		      NVL(MOV1.PRGMOVIMENTOSUCC, MOV.PRGMOVIMENTO) <> MOV.PRGMOVIMENTO)
		  );

RETURN numMovimentiPrecAppr;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_PREC_APPR= ' || sqlcode || ' ' || sqlerrm || ' p_cdnLavoratore=' || p_cdnLavoratore);
       --rollback;
       return 1;

END CHECK_MOVIMENTI_PREC_APPR;

-- controllo 6
-- Non deve esistere un movimento protocollato che abbia un successivo nullo ma esiste un movimento protocollato il cui precedente punta a questo.
FUNCTION CHECK_MOVIMENTI_SUCC_PREC(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type)
                             RETURN NUMBER IS

numMovimentiSuccPrec number;

BEGIN

select count(*) into numMovimentiSuccPrec
		from am_movimento mov
 		where mov.cdnlavoratore = p_cdnLavoratore and mov.codstatoatto = 'PR'
 		and mov.prgmovimentosucc is null
 		and exists 
		  (select mov1.prgmovimento
	      from am_movimento mov1
	      where mov1.prgmovimentoprec = mov.prgmovimento
	      and mov1.codstatoatto = 'PR'
	       );

RETURN numMovimentiSuccPrec;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_SUCC_PREC= ' || sqlcode || ' ' || sqlerrm || ' p_cdnLavoratore=' || p_cdnLavoratore);
       --rollback;
       return 1;

END CHECK_MOVIMENTI_SUCC_PREC;

-- controllo 7  
-- Non deve esistere un movimento protocollato che abbia un precedente nullo ma esiste un movimento protocollato il cui successivo punta a questo.
FUNCTION CHECK_MOVIMENTI_PREC_SUCC(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type)
                             RETURN NUMBER IS

numMovimentiPrecSucc number;

BEGIN

select count(*) into numMovimentiPrecSucc
		from am_movimento mov
 		where mov.cdnlavoratore = p_cdnLavoratore and mov.codstatoatto = 'PR'
 		and mov.prgmovimentoprec is null
 		and exists 
		  (select mov1.prgmovimento
	      from am_movimento mov1
	      where mov1.prgmovimentosucc = mov.prgmovimento
	      and mov1.codstatoatto = 'PR'
	       );

RETURN numMovimentiPrecSucc;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_PREC_SUCC= ' || sqlcode || ' ' || sqlerrm || ' p_cdnLavoratore=' || p_cdnLavoratore);
       --rollback;
       return 1;

END CHECK_MOVIMENTI_PREC_SUCC;

-- controllo 8
-- Non deve esistere un movimento protocollato che abbia come precedente un movimento in stato annullato (AN) o annullato rettificato (AR)  
FUNCTION CHECK_MOVIMENTI_PREC_AR_AN(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type)
                             RETURN NUMBER IS

numMovimentiPrecArAn number;

BEGIN

select count(*) into numMovimentiPrecArAn
        from am_movimento mov
        inner join am_movimento movprec on (mov.prgmovimentoprec = movprec.prgmovimento)
        where mov.cdnlavoratore = p_cdnLavoratore 
		and mov.codstatoatto = 'PR' and movprec.codstatoatto <> 'PR';

RETURN numMovimentiPrecArAn;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_PREC_AR_AN= ' || sqlcode || ' ' || sqlerrm || ' p_cdnLavoratore=' || p_cdnLavoratore);
       --rollback;
       return 1;

END CHECK_MOVIMENTI_PREC_AR_AN;

-- controllo 9
-- Non deve esistere un movimento protocollato che abbia come precedente un movimento in stato annullato (AN) o annullato rettificato (AR)  
FUNCTION CHECK_MOVIMENTI_SUCC_AR_AN(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type)
                             RETURN NUMBER IS

numMovimentiSuccArAn number;

BEGIN

select count(*) into numMovimentiSuccArAn
        from am_movimento mov
        inner join am_movimento movsucc on (mov.prgmovimentosucc = movsucc.prgmovimento)
        where mov.cdnlavoratore = p_cdnLavoratore 
		and mov.codstatoatto = 'PR' and movsucc.codstatoatto <> 'PR';

RETURN numMovimentiSuccArAn;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_SUCC_AR_AN= ' || sqlcode || ' ' || sqlerrm || ' p_cdnLavoratore=' || p_cdnLavoratore);
       --rollback;
       return 1;

END CHECK_MOVIMENTI_SUCC_AR_AN;

-- controllo 1 
-- All'interno dello stesso movimento (se valorizzati) prgmovimento, prgmovimentosucc e prgmovimentoprec devono essere tutti diversi tra loro  
-- ovvero non devono esserci riferimenti circolari all'interno dello stesso movimento (protocollato).
FUNCTION CHECK_MOV_RIPETUTI_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER IS

numMovimentiRipetuti number;

cursor recMovRipetuti is 
select mov.prgmovimento into numMovimentiRipetuti
    from am_movimento mov 
    where mov.prgmovimento in (select fmov.prgmovimento 
     from am_forza_mov fmov where fmov.prgforzatura = p_prgFozaMov) and mov.codstatoatto = 'PR'
    and (mov.prgmovimento = mov.prgmovimentoprec 
        or  mov.prgmovimento = mov.prgmovimentosucc 
        or mov.prgmovimentoprec = mov.prgmovimentosucc
      );
CodeOut number;
CodeOutRicDett number:=0;
p_prgdettaglio AM_FORZA_MOV.PRGFORZAMOV%TYPE;

BEGIN

/*select count(*) ripetizioni into numMovimentiRipetuti
    from am_movimento mov 
    where mov.cdnlavoratore = p_cdnLavoratore and mov.codstatoatto = 'PR'
    and (mov.prgmovimento = mov.prgmovimentoprec 
        or  mov.prgmovimento = mov.prgmovimentosucc 
        or mov.prgmovimentoprec = mov.prgmovimentosucc
      );*/

CodeOut := 0;
for cur in recMovRipetuti loop
   
 p_prgdettaglio:=  PG_MOVIMENTI.ricercaPrgDettaglio(p_prgFozaMov, cur.prgmovimento);
 
 CodeOutRicDett := PG_MOVIMENTI.InserisciErrore(p_prgdettaglio, 1);
 CodeOut := 1;
 
end loop;

Return CodeOut;

/*select mov.prgmovimento into numMovimentiRipetuti
    from am_movimento mov 
    where mov.prgmovimento in (select fmov.prgmovimento 
     from am_forza_mov fmov where fmov.prgforzatura = p_prgFozaMov) and mov.codstatoatto = 'PR'
    and (mov.prgmovimento = mov.prgmovimentoprec 
        or  mov.prgmovimento = mov.prgmovimentosucc 
        or mov.prgmovimentoprec = mov.prgmovimentosucc
      );*/

--RETURN numMovimentiRipetuti;


EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_RIPETUTI= ' || sqlcode );
       --rollback;
       CodeOut := 1;
       return CodeOut;

END CHECK_MOV_RIPETUTI_FORZ;
-- controllo 2 
-- Un movimento protocollato non può essere successivo a più di un movimento protocollato
FUNCTION CHECK_MOV_SUCCESSIVI_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER IS

numMovimentiSuccessivi number;

cursor recMovSuccForz is 
 select mov.prgmovimento
    from am_movimento mov
    where mov.cdnlavoratore in (select fmov.prgmovimento 
     from am_forza_mov fmov where fmov.prgforzatura = p_prgFozaMov) 
     and mov.codstatoatto = 'PR'
    and exists (
      select mov1.prgmovimento, count(*)
      from am_movimento mov1 
      where mov1.prgmovimentosucc = mov.prgmovimento 
      and mov1.codstatoatto = 'PR'
      group by mov1.prgmovimento
      having count(*) > 1);

CodeOut number;
CodeOutRicDett number:=0;
p_prgdettaglio AM_FORZA_MOV.PRGFORZAMOV%TYPE;

BEGIN

CodeOut := 0;
for cur in recMovSuccForz loop
   
 p_prgdettaglio:=  PG_MOVIMENTI.ricercaPrgDettaglio(p_prgFozaMov, cur.prgmovimento);
 
 CodeOutRicDett := PG_MOVIMENTI.InserisciErrore(p_prgdettaglio, 2);
 CodeOut := 1;
 
end loop;

RETURN CodeOut;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_SUCCESSIVI= ' || sqlcode || ' ' || sqlerrm);
       --rollback;
       return 1;

END CHECK_MOV_SUCCESSIVI_FORZ;

-- controllo 3
-- Un movimento protocollato non può essere il precedente di più di un movimento protocollato
FUNCTION CHECK_MOV_PRECEDENTI_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER IS

numMovimentiPrecedenti number;

cursor recMovPrecForz is 
select mov.prgmovimento
    from am_movimento mov
    where mov.cdnlavoratore in (select fmov.prgmovimento 
     from am_forza_mov fmov where fmov.prgforzatura = p_prgFozaMov) and mov.codstatoatto = 'PR'
    and exists (
      select mov1.prgmovimento, count(*)
      from am_movimento mov1 
      where mov1.prgmovimentoprec = mov.prgmovimento 
      and mov1.codstatoatto = 'PR'
      group by mov1.prgmovimento
      having count(*) > 1
      );


CodeOut number;
CodeOutRicDett number:=0;
p_prgdettaglio AM_FORZA_MOV.PRGFORZAMOV%TYPE;

BEGIN

CodeOut := 0;
for cur in recMovPrecForz loop
   
 p_prgdettaglio:=  PG_MOVIMENTI.ricercaPrgDettaglio(p_prgFozaMov, cur.prgmovimento);
 
 CodeOutRicDett := PG_MOVIMENTI.InserisciErrore(p_prgdettaglio, 3);
 CodeOut := 1;
 
end loop;

RETURN CodeOut;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_SUCCESSIVI= ' || sqlcode || ' ' || sqlerrm );
       --rollback;
       return 1;

END CHECK_MOV_PRECEDENTI_FORZ;

-- controllo 4
-- Non deve esistere un movimento protocollato che abbia un successivo valorizzato tale per cui 
-- il movimento successivo protocollato non sia correttamente collegato, 
-- ovvero:  1) ha un precedente diverso  2) il precedente è nullo

FUNCTION CHECK_MOV_SUCC_APPR_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER IS

numMovimentiPrecedenti number;

cursor recMovSuccAPPR is 
select mov.prgmovimento
    from am_movimento mov
    where mov.cdnlavoratore in (select fmov.prgmovimento 
     from am_forza_mov fmov where fmov.prgforzatura = p_prgFozaMov) and mov.codstatoatto = 'PR'
    and mov.prgmovimentosucc is not null
    and exists 
      (select mov1.prgmovimento
        from am_movimento mov1 
        where mov1.prgmovimento = mov.prgmovimentosucc 
        and mov1.codstatoatto = 'PR' 
         AND 
        ( MOV1.PRGMOVIMENTOsucc = MOV.PRGMOVIMENTO OR 
          MOV1.PRGMOVIMENTOsucc = MOV.PRGMOVIMENTOprec OR
          NVL(MOV1.PRGMOVIMENTOPREC, MOV.PRGMOVIMENTO) <> MOV.PRGMOVIMENTO)
      );

CodeOut number;
CodeOutRicDett number:=0;
p_prgdettaglio AM_FORZA_MOV.PRGFORZAMOV%TYPE;

BEGIN

CodeOut := 0;
for cur in recMovSuccAPPR loop
   
 p_prgdettaglio:=  PG_MOVIMENTI.ricercaPrgDettaglio(p_prgFozaMov, cur.prgmovimento);
 
 CodeOutRicDett := PG_MOVIMENTI.InserisciErrore(p_prgdettaglio, 4);
 CodeOut := 1;
 
end loop;

RETURN CodeOut;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOV_SUCC_APPR_FORZ= ' || sqlcode || ' ' || sqlerrm );
       --rollback;
       return 1;

END CHECK_MOV_SUCC_APPR_FORZ;

-- controllo 5
-- Non deve esistere un movimento protocollato che abbia un precedente valorizzato tale per cui 
-- il movimento precedente protocollato non sia correttamente collegato, 
-- ovvero:  1) ha un successivo diverso  2) il successivo è nullo

FUNCTION CHECK_MOV_PREC_APPR_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER IS

numMovimentiPrecedenti number;

cursor recMovPrecAPPR is 
select mov.prgmovimento
    from am_movimento mov
    where mov.cdnlavoratore in (select fmov.prgmovimento 
     from am_forza_mov fmov where fmov.prgforzatura = p_prgFozaMov) and mov.codstatoatto = 'PR'
    and mov.prgmovimentoprec is not null
    and exists 
      (select mov1.prgmovimento
        from am_movimento mov1 
        where mov1.prgmovimento = mov.prgmovimentoprec   
        and mov1.codstatoatto = 'PR' 
        AND 
        ( MOV1.PRGMOVIMENTOPREC = MOV.PRGMOVIMENTO OR 
          NVL(MOV1.PRGMOVIMENTOSUCC, MOV.PRGMOVIMENTO) <> MOV.PRGMOVIMENTO)
      );

CodeOut number;
CodeOutRicDett number:=0;
p_prgdettaglio AM_FORZA_MOV.PRGFORZAMOV%TYPE;

BEGIN

CodeOut := 0;
for cur in recMovPrecAPPR loop
   
 p_prgdettaglio:=  PG_MOVIMENTI.ricercaPrgDettaglio(p_prgFozaMov, cur.prgmovimento);
 
 CodeOutRicDett := PG_MOVIMENTI.InserisciErrore(p_prgdettaglio, 5);
 CodeOut := 1;
 
end loop;

RETURN CodeOut;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOV_SUCC_APPR_FORZ= ' || sqlcode || ' ' || sqlerrm );
       --rollback;
       return 1;

END CHECK_MOV_PREC_APPR_FORZ;

-- controllo 6
-- Non deve esistere un movimento protocollato che abbia un successivo nullo ma esiste un movimento protocollato il cui precedente punta a questo.

FUNCTION CHECK_MOV_SUCC_PREC_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER IS

numMovimentiPrecedenti number;

cursor recMovSuccPrec is 
select mov.prgmovimento
    from am_movimento mov
    where mov.prgmovimento in  (select fmov.prgmovimento 
     from am_forza_mov fmov where fmov.prgforzatura = p_prgFozaMov) and mov.codstatoatto = 'PR'
    and mov.prgmovimentosucc is null
    and exists 
      (select mov1.prgmovimento
        from am_movimento mov1
        where mov1.prgmovimentoprec = mov.prgmovimento
        and mov1.codstatoatto = 'PR'
         );

CodeOut number;
CodeOutRicDett number:=0;
p_prgdettaglio AM_FORZA_MOV.PRGFORZAMOV%TYPE;

BEGIN

CodeOut := 0;
for cur in recMovSuccPrec loop
   
 p_prgdettaglio:=  PG_MOVIMENTI.ricercaPrgDettaglio(p_prgFozaMov, cur.prgmovimento);
 
 CodeOutRicDett := PG_MOVIMENTI.InserisciErrore(p_prgdettaglio, 6);
 CodeOut := 1;
 
end loop;

RETURN CodeOut;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOV_SUCC_PREC_FORZ= ' || sqlcode || ' ' || sqlerrm);
       --rollback;
       return 1;

END CHECK_MOV_SUCC_PREC_FORZ;

-- controllo 7  
-- Non deve esistere un movimento protocollato che abbia un precedente nullo ma esiste un movimento protocollato il cui successivo punta a questo.

FUNCTION CHECK_MOV_PREC_SUCC_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER IS

numMovimentiPrecedenti number;

cursor recMovPrecSucc is 
select mov.prgmovimento
    from am_movimento mov
    where mov.prgmovimento in (select fmov.prgmovimento 
     from am_forza_mov fmov where fmov.prgforzatura = p_prgFozaMov) and mov.codstatoatto = 'PR'
    and mov.prgmovimentoprec is null
    and exists 
      (select mov1.prgmovimento
        from am_movimento mov1
        where mov1.prgmovimentosucc = mov.prgmovimento
        and mov1.codstatoatto = 'PR'
         );

CodeOut number;
CodeOutRicDett number:=0;
p_prgdettaglio AM_FORZA_MOV.PRGFORZAMOV%TYPE;

BEGIN

CodeOut := 0;
for cur in recMovPrecSucc loop
   
 p_prgdettaglio:=  PG_MOVIMENTI.ricercaPrgDettaglio(p_prgFozaMov, cur.prgmovimento);
 
 CodeOutRicDett := PG_MOVIMENTI.InserisciErrore(p_prgdettaglio, 7);
 CodeOut := 1;
 
end loop;

RETURN CodeOut;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOV_PREC_SUCC_FORZ= ' || sqlcode || ' ' || sqlerrm );
       --rollback;
       return 1;

END CHECK_MOV_PREC_SUCC_FORZ;

-- controllo 8
-- Non deve esistere un movimento protocollato che abbia come precedente un movimento in stato annullato (AN) o annullato rettificato (AR)  
FUNCTION CHECK_MOV_PREC_AR_AN_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER IS

numMovimentiPrecedenti number;

cursor recMovPrecArAn is 
select mov.prgmovimento
        from am_movimento mov
        inner join am_movimento movprec on (mov.prgmovimentoprec = movprec.prgmovimento)
        where mov.prgmovimento in (select fmov.prgmovimento 
     from am_forza_mov fmov where fmov.prgforzatura = p_prgFozaMov) 
		and mov.codstatoatto = 'PR' and movprec.codstatoatto <> 'PR';

CodeOut number;
CodeOutRicDett number:=0;
p_prgdettaglio AM_FORZA_MOV.PRGFORZAMOV%TYPE;

BEGIN

CodeOut := 0;
for cur in recMovPrecArAn loop
   
 p_prgdettaglio:=  PG_MOVIMENTI.ricercaPrgDettaglio(p_prgFozaMov, cur.prgmovimento);
 
 CodeOutRicDett := PG_MOVIMENTI.InserisciErrore(p_prgdettaglio, 8);
 CodeOut := 1;
 
end loop;

RETURN CodeOut;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOV_PREC_AR_AN_FORZ= ' || sqlcode || ' ' || sqlerrm);
       --rollback;
       return 1;

END CHECK_MOV_PREC_AR_AN_FORZ;

-- controllo 9
-- Non deve esistere un movimento protocollato che abbia come precedente un movimento in stato annullato (AN) o annullato rettificato (AR)  
FUNCTION CHECK_MOV_SUCC_AR_AN_FORZ(p_prgFozaMov AM_FORZA_MOV.PRGFORZATURA%TYPE)
                             RETURN NUMBER IS

numMovimentiPrecedenti number;

cursor recMovSuccArAn is 
select mov.prgmovimento
        from am_movimento mov
        inner join am_movimento movsucc on (mov.prgmovimentosucc = movsucc.prgmovimento)
        where mov.cdnlavoratore in (select fmov.prgmovimento 
     from am_forza_mov fmov where fmov.prgforzatura = p_prgFozaMov)  
		and mov.codstatoatto = 'PR' and movsucc.codstatoatto <> 'PR';


CodeOut number;
CodeOutRicDett number:=0;
p_prgdettaglio AM_FORZA_MOV.PRGFORZAMOV%TYPE;

BEGIN

CodeOut := 0;
for cur in recMovSuccArAn loop
   
 p_prgdettaglio:=  PG_MOVIMENTI.ricercaPrgDettaglio(p_prgFozaMov, cur.prgmovimento);
 
 CodeOutRicDett := PG_MOVIMENTI.InserisciErrore(p_prgdettaglio, 21);
 CodeOut := 1;
 
end loop;

RETURN CodeOut;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOV_SUCC_AR_AN_FORZ= ' || sqlcode || ' ' || sqlerrm );
       --rollback;
       return 1;

END CHECK_MOV_SUCC_AR_AN_FORZ;


END PG_MOV_CATENE_ERRATE;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_MOVIMENTI_DOPPI.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_MOVIMENTI_DOPPI IS

TYPE typRefCurs IS REF CURSOR;

FUNCTION CHECK_MOVIMENTI_DOPPI(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type,
                             p_codTipoMov Am_Movimento.Codtipomov%type,
                             p_datInizioMov varchar2)
          RETURN NUMBER;      

FUNCTION CONTROLLO_ULTERIORE(p_codTipoMovApp Am_Movimento_Appoggio.Codtipomov%type,
                             p_codMonoTempoApp Am_Movimento_Appoggio.codmonotempo%type,
                             p_datFineMovApp varchar2,
                             p_codMvCessazioneApp Am_Movimento_Appoggio.codmvcessazione%type,
                             p_datFineMov varchar2,
                             p_codMvCessazione Am_Movimento.codmvcessazione%type)
          RETURN NUMBER;  
          
FUNCTION CONTROLLO_MOV(p_datInizioDaMov varchar2,
                       p_datInizioAMov varchar2,
                       p_datComunicazDaMov varchar2,
                       p_datComunicazAMov varchar2) 
          RETURN NUMBER;  

FUNCTION INS_MOVIMENTI_DOPPI(p_prgmov am_movimento_Appoggio.Prgmovimentoapp%type,
                             p_codTipoMovApp Am_Movimento_Appoggio.Codtipomov%type,
                             p_prgmovimentoappcve am_movimento_appoggio.prgmovimentoappcve%type)
          RETURN NUMBER;           

FUNCTION DEL_MOVIMENTI_APPOGGIO(p_prgMov Am_Movimento_Appoggio.Prgmovimentoapp%type )
          RETURN NUMBER;

FUNCTION COUNT_CONTROLLO_MOV(p_datInizioDaMov varchar2,
                       p_datInizioAMov varchar2,
                       p_datComunicazDaMov varchar2,
                       p_datComunicazAMov varchar2) 
                       RETURN NUMBER;
          
END PG_MOVIMENTI_DOPPI;
/
CREATE OR REPLACE PACKAGE BODY PG_MOVIMENTI_DOPPI IS


FUNCTION CHECK_MOVIMENTI_DOPPI(p_cdnLavoratore AM_MOVIMENTO.Cdnlavoratore%type,
                             p_codTipoMov Am_Movimento.Codtipomov%type,
                             p_datInizioMov varchar2)
                             RETURN NUMBER IS

numMovimentiSimili number;
                             
BEGIN

SELECT count(mov.prgMovimento) into numMovimentiSimili  	    
	FROM am_movimento mov,  an_lavoratore lav, an_azienda az, an_unita_azienda azu, de_comune com, 
	     de_provincia pr , ( select doc.numProtocollo, coll.strChiaveTabella 
							    from am_documento doc , am_documento_coll coll 
						      where doc.cdnLavoratore = p_cdnLavoratore
                  and doc.prgDocumento = coll.prgDocumento  
							    and coll.cdnComponente = 
                  (select cdncomponente from ts_componente 
                  where upper(strpage) = upper('MovDettaglioGeneraleConsultaPage') )
				          ) tab
	WHERE mov.CODSTATOATTO = 'PR' 		 
    and mov.prgMovimento = tab.STRCHIAVETABELLA(+)
	  and mov.cdnlavoratore = lav.cdnlavoratore 
	  and mov.prgAzienda = az.prgAzienda 
	  and az.prgAzienda = azu.prgAzienda 
	  and azu.prgUnita = mov.prgUnita  
	  and azu.codCom = com.codCom and com.codProvincia = pr.codProvincia
	  and UPPER(CODTIPOMOV) = UPPER(p_codTipoMov) 
	  and mov.DATINIZIOMOV = TO_DATE(p_datInizioMov, 'DD/MM/YYYY')
	  and mov.CDNLAVORATORE = p_cdnLavoratore;


RETURN numMovimentiSimili;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CHECK_MOVIMENTI_DOPPI= ' || sqlcode || ' ' || sqlerrm || ' p_cdnLavoratore=' || p_cdnLavoratore || ', p_codTipoMov='|| p_codTipoMov|| ',p_datInizioMov= '||p_datInizioMov);
       --rollback;
       return -1;

END CHECK_MOVIMENTI_DOPPI;

/********************************************
WARNING: controllo non bloccante
*********************************************/
FUNCTION CONTROLLO_ULTERIORE(p_codTipoMovApp Am_Movimento_Appoggio.Codtipomov%type,
                             p_codMonoTempoApp Am_Movimento_Appoggio.codmonotempo%type,
                             p_datFineMovApp varchar2,
                             p_codMvCessazioneApp Am_Movimento_Appoggio.codmvcessazione%type,
                             p_datFineMov varchar2,
                             p_codMvCessazione Am_Movimento.codmvcessazione%type)
                             RETURN NUMBER IS

checkMovimentoDoppio number;
                             
BEGIN
     
     -- ulteriori controlli:  
     -- Il movimento viene considerato "doppio" solo se non si tratta di un avviamento
     -- fittizio dovuto a una cessazione
     if ((p_codTipoMovApp = 'AVV' and p_codMonoTempoApp = 'D')) then
        if (p_datFineMovApp = p_datFineMov) then
           checkMovimentoDoppio := 1;
        end if;
     elsif (p_codTipoMovApp = 'PRO') then
        if (p_datFineMovApp = p_datFineMov) then
           checkMovimentoDoppio := 1;
        end if;
     elsif (p_codTipoMovApp = 'CES') then
        if (p_codMvCessazioneApp = p_codMvCessazione) then
           checkMovimentoDoppio := 1;
        end if; 
     elsif ((p_codTipoMovApp = 'AVV' and p_codMonoTempoApp = 'I')) then       
        checkMovimentoDoppio := 1;
     elsif (p_codTipoMovApp = 'TRA') then
        checkMovimentoDoppio := 1;        
     else
        checkMovimentoDoppio := 0;
     end if;        
     

RETURN checkMovimentoDoppio;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CONTROLLO_ULTERIORE= ' || sqlcode || ' ' || sqlerrm );
       --rollback;
       return -1;

END CONTROLLO_ULTERIORE;
                             
FUNCTION CONTROLLO_MOV(p_datInizioDaMov varchar2,
                       p_datInizioAMov varchar2,
                       p_datComunicazDaMov varchar2,
                       p_datComunicazAMov varchar2) 
                       RETURN NUMBER IS

CURSOR curMovimentiApp IS 
        select prgmovimentoapp, strazcodicefiscale, strazpartitaiva, strazragionesociale, codazateco, codazccnl, 
        numazdipendenti, strpatinail, struaindirizzo, coduacom, struacap, struatel, struafax, struaemail, strualindirizzo, 
        codualcom, strcodicefiscale, strcognome, strnome, strsesso, datnasc, codcomnasc, codcittadinanza, codcomdom, 
        strindirizzodom, strcapdom, datscadenza, codtipotitolo, codcpi, datcomunicaz, to_char(datiniziomov, 'dd/mm/yyyy') as datiniziomov, codtipomov, codmansione, 
        strdesattivita, codcontratto, codmonotempo, flgsocio, codccnl, decretribuzionemen, numlivello, flglegge68, 
        flglavdomicilio, codagevolazione, codorario, codmvcessazione, to_char(datfinemov, 'dd/mm/yyyy') as datfinemov, strnote, 
        cdnutins, dtmins, cdnutmod, dtmmod, numklomovapp, strmatricola, codtipoass, codtipocontratto, codnormativa, codgrado, flgartigiana, 
        datcfl, strnumcfl, strtipocfl, nummesiapprendistato, codmonoprov, strposinps, codstatoatto, 
        flgasspropria, strazintcodicefiscale, strazintpartitaiva, strazintragionesociale, codazintateco, numazintdipendenti, 
        codazinttipoazienda, struaintindirizzo, coduaintcom, struaintcap, straznumalbointerinali, strnumregistrocommitt, datregistrocommitt, 
        flgretribuzionemenccnl, strluogodilavoro, codcpilav, datvisitamedica, strappcodicefiscaletutore, strappcognometutore, strappnometutore, 
        numappanniesptutore, strapplivellotutore, codappmansionetutore, codaztipoazienda, strazintnumcontratto, 
        datazintiniziocontratto, datazintfinecontratto, strazintrap, numazintsoggetti, numggtramovcomunicazione, strreferente, strnumprtprovincia, 
        numggprevistiagr, numggeffettuatiagr, prgmovimentoappcve, flgassdacess, flgtitolaretutore, numoresett, codcomnascdi, datnascdi, 
        strsessodi, codlavorazione, codlivelloagr, codcategoria, strversionetracciato, codqualificasrq,
		codtipocomunic, codcomunicazione, codcomunicazioneprec, DATINIZIORAPLAV, DATFINERAPLAV, DATFINEPRORAPLAV, DATCESSRAPLAV,
		  CODTIPOSOMM, FLGPAGAMENTORIMPATRIO, FLGAZUTILIZESTERA, 
		  DATFINEAFFITTORAMO, STRNUMAGSOMMINISTRAZIONE, FLGSISTEMAZIONEALLOGGIATIVA, 
		  CODQUESTURA, STRCOGNOMELEGRAPP, STRNOMELEGRAPP, CODCITTADINANZALEGRAPP,
		  STRSESSOLEGRAPP, DATNASCLEGRAPP, CODCOMNASCLEGRAPP, DATSCADENZALEGRAPP, CODTIPODOCEXLEGRAPP,
		  STRNUMDOCEXLEGRAPP, CODMOTIVOPERMSOGGEXLEGRAPP, CODQUESTURALEGRAPP, 
		  FLGAZESTERA, STRCFAZESTERA, STRRAGSOCAZESTERA, CODTIPOENTEPROMOTORE, CODTIPOMIS, FLGDISTPARZIALE, FLGDISTAZESTERA, FLGPA,
		  FLGSOGGINITALIA, DATFINEPERIODOFORMATIVO, FLGLAVOROINMOBILITA, FLGLAVOROSTAGIONALE, STRCODFISCPROMOTORETIR, 
		  FLGPROSECUZIONE, CODVARIAZIONE, STRDENOMINAZIONETIR, CODCATEGORIATIR, CODTIPOLOGIATIR,
		  CODSOGGPROMOTOREMIN, FLGASSOBBL, CODCATASSOBBL, STRUALTEL, STRUALFAX, STRUALEMAIL, STREMAILREFERENTE, decretribuzioneann, strtracciato
       from am_movimento_appoggio 
       where flgassdacess != 'S'
       AND datInizioMov >= to_date(p_datInizioDaMov, 'DD/MM/YYYY') 
       AND datInizioMov <= to_date(decode(p_datInizioAMov, null , to_char(sysdate, 'dd/mm/yyyy'), p_datInizioAMov), 'DD/MM/YYYY')
       AND datComunicaz >= to_date(decode(p_datComunicazDaMov, null ,'01/01/1900', p_datComunicazDaMov), 'DD/MM/YYYY')
       AND datComunicaz <= to_date(decode(p_datComunicazAMov, null , to_char(sysdate, 'dd/mm/yyyy'), p_datComunicazAMov), 'DD/MM/YYYY');
       
checkInsert number;
checkSimileDoppio number; 
checkMovimentoDoppio number;
checkMovimentoSimile number;
checkPrgUnitaProduttiva number;      
checkPrgUnitaUtil number; 
checkUlterioreControllo number;
check_cdnLavoratore number;
check_prgAzienda number;
check_prgAziendaUtil number;
p_cdnLavoratore an_lavoratore.cdnlavoratore%type;       
p_prgAzienda an_azienda.prgazienda%type;
p_prgUnitaProduttiva an_unita_azienda.prgunita%type;
p_prgAziendaUtil an_azienda.prgazienda%type;
p_prgUnitaUtil an_unita_azienda.prgunita%type;
p_prgAziendaMov am_movimento.prgazienda%type;
p_prgUnitaMov am_movimento.prgunita%type;
p_prgAziendaUtilizMov am_movimento.prgaziendautiliz%type;
p_prgUnitaUtilizMov am_movimento.prgunitautiliz%type;
p_datFineMov varchar2(10);
p_codMvCessazione am_movimento.codMvCessazione%type;
       
BEGIN

FOR recMovimentoApp in curMovimentiApp LOOP
    
    SELECT count(cdnLavoratore) into check_cdnLavoratore
    FROM AN_LAVORATORE 
    WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strcodicefiscale);
 
    SELECT count(prgAzienda) into check_prgAzienda
    FROM AN_AZIENDA 
    WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strazcodicefiscale);
    
    SELECT count(prgAzienda) into check_prgAziendaUtil
    FROM AN_AZIENDA 
    WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strazintcodicefiscale);
    
    if ((check_cdnLavoratore > 0) and (check_prgAzienda > 0)) then
    
        -- verifico l'esistenza del lavoratore e recupero il suo cdnLavoratore    
        SELECT cdnLavoratore into p_cdnLavoratore
        FROM AN_LAVORATORE 
        WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strcodicefiscale);
        
        -- verifico l'esistenza dell'azienda e dell'unita aziendale
        SELECT prgAzienda into p_prgAzienda
        FROM AN_AZIENDA 
        WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strazcodicefiscale);
        
        if (p_prgAzienda is not null) then
           p_prgUnitaProduttiva := null;
            
           SELECT count(prgUnita) into checkPrgUnitaProduttiva
           FROM AN_UNITA_AZIENDA 
           WHERE prgAzienda = p_prgAzienda;
           
           if (checkPrgUnitaProduttiva = 1) then
             SELECT prgUnita into p_prgUnitaProduttiva
             FROM AN_UNITA_AZIENDA 
             WHERE prgAzienda = p_prgAzienda;
           end if;
        end if;
        
        -- verifico l'esistenza dell'azienda utilizzatrice e della sua unita aziendale
        if (check_prgAziendaUtil > 0) then
          SELECT prgAzienda into p_prgAziendaUtil
          FROM AN_AZIENDA 
          WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strazintcodicefiscale);
        
          if (p_prgAzienda is not null) then
             p_prgUnitaUtil:= null;
              
             SELECT count(prgUnita) into checkPrgUnitaUtil
             FROM AN_UNITA_AZIENDA 
             WHERE prgAzienda = p_prgAziendaUtil;
             
             if (checkPrgUnitaUtil = 1) then
               SELECT prgUnita into p_prgUnitaUtil
               FROM AN_UNITA_AZIENDA 
               WHERE prgAzienda = p_prgAziendaUtil;
             end if;
          end if;  
        end if; 
        -- nel caso le info azienda utilizzaztrice siano nulle si settano a -1
        if (p_prgAziendaUtil is null) then 
           p_prgAziendaUtil := -1;
        end if;
        if (p_prgUnitaUtil is null) then 
           p_prgUnitaUtil:= -1;
        end if;
        
        if ((p_cdnLavoratore is not null) and 
            (p_prgAzienda is not null) and 
            (p_prgunitaproduttiva is not null)) then    
           
           --verifico se esiste per l'i-esimo movimento appoggio un movimento simile/doppio
           checkSimileDoppio := pg_movimenti_doppi.check_movimenti_doppi(p_cdnLavoratore, recMovimentoApp.codtipomov, recMovimentoApp.datiniziomov);
           
           if (checkSimileDoppio > 0) then
              -- verifica che si tratti di un documento doppio
              checkMovimentoDoppio := 0;      
              checkMovimentoSimile := 0;    
              DECLARE
              CURSOR curMovimentiSim IS
                     SELECT mov.prgazienda, mov.prgunita, mov.prgaziendautiliz, mov.prgunitautiliz, to_char(mov.datfinemov, 'dd/mm/yyyy') as datfinemov, mov.codmvcessazione              
    	               FROM am_movimento mov,  an_lavoratore lav, an_azienda az, an_unita_azienda azu, de_comune com, 
    	                    de_provincia pr , ( select doc.numProtocollo, coll.strChiaveTabella 
    							        from am_documento doc , am_documento_coll coll 
    						          where doc.cdnLavoratore = p_cdnLavoratore
                          and doc.prgDocumento = coll.prgDocumento  
    							        and coll.cdnComponente = 
                          (select cdncomponente from ts_componente 
                          where upper(strpage) = upper('MovDettaglioGeneraleConsultaPage') )
    				              ) tab   
                      WHERE mov.CODSTATOATTO = 'PR' 		 
                      and mov.prgMovimento = tab.STRCHIAVETABELLA(+)
    	                and mov.cdnlavoratore = lav.cdnlavoratore 
    	                and mov.prgAzienda = az.prgAzienda 
    	                and az.prgAzienda = azu.prgAzienda 
    	                and azu.prgUnita = mov.prgUnita  
    	                and azu.codCom = com.codCom and com.codProvincia = pr.codProvincia
    	                and UPPER(CODTIPOMOV) = UPPER(recMovimentoApp.codtipomov) 
    	                and mov.DATINIZIOMOV = TO_DATE(recMovimentoApp.datiniziomov, 'DD/MM/YYYY')
    	                and mov.CDNLAVORATORE = p_cdnLavoratore;
              
              BEGIN
                   OPEN curMovimentiSim;
                   LOOP     
                   FETCH curMovimentiSim INTO p_prgAziendaMov, p_prgUnitaMov, p_prgAziendaUtilizMov, 
                                              p_prgUnitaUtilizMov, p_datFineMov, p_codMvCessazione;         
                   EXIT WHEN curMovimentiSim%NOTFOUND;                 
                      
                      if ((p_prgAzienda = p_prgAziendaMov) and
                         (p_prgUnitaProduttiva = p_prgUnitaMov) and
                         (p_prgAziendaUtil = p_prgAziendaUtilizMov) and
                         (p_prgUnitaUtil = p_prgUnitaUtilizMov)) then
                         
                         -- si è trovato un movimento doppio
                         checkMovimentoDoppio := 1;
                         EXIT;
                      
                      end if;
                      
                      if ((p_prgAzienda = p_prgAziendaMov) and
                         (p_prgUnitaProduttiva = p_prgUnitaMov)) then
                         
                         -- si è trovato un movimento simile
                         checkMovimentoSimile := 1;
                         EXIT;
                      end if;   
                      
                      -- controllo non bloccante
                      /*                  
                      checkUlterioreControllo := pg_movimenti_doppi.controllo_ulteriore(recMovimentoApp.codTipoMov,
                                                                                        recMovimentoApp.codMonoTempo,
                                                                                        recMovimentoApp.datFineMov,
                                                                                        recMovimentoApp.codMvCessazione,
                                                                                        p_datfinemov,
                                                                                        p_codmvcessazione);
                      if (checkUlterioreControllo = 1) then
                         checkMovimentoDoppio := 1;
                         exit;
                      end if;
                      */                                                                              
                   END LOOP;
                   CLOSE curMovimentiSim;
              END;
              
              if (checkMovimentoDoppio = 1) then
                 -- caso di movimento doppio insere il movimento in AM_MOVIMENTO_DOPPI
                 checkInsert := INS_MOVIMENTI_DOPPI(recMovimentoApp.prgmovimentoapp,
                                                    recMovimentoApp.codTipoMov,
                                                    recMovimentoApp.prgmovimentoappcve);
              end if;   
              
              if (checkMovimentoSimile = 1) then
                 -- si verifica se è un movimento simile
                 checkInsert := INS_MOVIMENTI_DOPPI(recMovimentoApp.prgmovimentoapp,
                                                    recMovimentoApp.codTipoMov,
                                                    recMovimentoApp.prgmovimentoappcve);             
              end if;              
           end if;           
        end if;
    end if;
    
END LOOP;

RETURN 0;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore CONTROLLO_MOV = ' || sqlcode || ' ' || sqlerrm || 'p_cdnLavoratore=' || p_cdnLavoratore);
       rollback;
       return -1;

END CONTROLLO_MOV;

FUNCTION INS_MOVIMENTI_DOPPI(p_prgMov Am_Movimento_Appoggio.Prgmovimentoapp%type,
                             p_codTipoMovApp Am_Movimento_Appoggio.Codtipomov%type,
                             p_prgmovimentoappcve am_movimento_appoggio.prgmovimentoappcve%type)
                             RETURN NUMBER IS
                             
new_prgmovimentoapp am_movimento_appoggio_doppi.prgmovimentoapp%type;
new_prgmovimentoappCve am_movimento_appoggio_doppi.prgmovimentoapp%type;
checkDel number;
                             
BEGIN

   if (p_prgmovimentoappcve is not null) then
      
      -- prgmovimentoapp del movimemento AVV da CES veloce 
      -- sequance
      select s_am_movimento_appoggio_doppi.nextval into new_prgmovimentoappCve from dual;
      
      insert into am_movimento_appoggio_doppi 
      (prgmovimentoapp, 
      strazcodicefiscale, 
      strazpartitaiva, 
      strazragionesociale, 
      codazateco, 
      codazccnl, 
      numazdipendenti, 
      strpatinail, 
      struaindirizzo, 
      coduacom, 
      struacap, 
      struatel, 
      struafax, 
      struaemail, 
      strualindirizzo, 
      codualcom, 
      strcodicefiscale, 
      strcognome, 
      strnome, 
      strsesso, 
      datnasc, 
      codcomnasc, 
      codcittadinanza, 
      codcomdom, 
      strindirizzodom, 
      strcapdom, 
      datscadenza, 
      codtipotitolo, 
      codcpi, 
      datcomunicaz, 
      datiniziomov, 
      codtipomov, 
      codmansione, 
      strdesattivita, 
      codcontratto, 
      codmonotempo, 
      flgsocio, 
      codccnl, 
      decretribuzionemen, 
      numlivello, 
      flglegge68, 
      flglavdomicilio, 
      codagevolazione, 
      codorario, 
      numoresett,
      codmvcessazione, 
      datfinemov, 
      strnote, 
      cdnutins, 
      dtmins, 
      cdnutmod, 
      dtmmod, 
      numklomovapp, 
      strmatricola, 
      codtipoass,
	  codtipocontratto,
      codnormativa, 
      codgrado, 
      flgartigiana, 
      datcfl, 
      strnumcfl, 
      strtipocfl, 
      nummesiapprendistato, 
      codmonoprov, 
      strposinps, 
      codstatoatto, 
      flgasspropria, 
      strazintcodicefiscale, 
      strazintpartitaiva, 
      strazintragionesociale, 
      codazintateco, 
      numazintdipendenti, 
      codazinttipoazienda, 
      struaintindirizzo, 
      coduaintcom, 
      struaintcap, 
      straznumalbointerinali, 
      strnumregistrocommitt, 
      datregistrocommitt, 
      flgretribuzionemenccnl, 
      strluogodilavoro, 
      codcpilav, 
      datvisitamedica, 
      strappcodicefiscaletutore, 
      strappcognometutore, 
      strappnometutore, 
      numappanniesptutore, 
      strapplivellotutore, 
      codappmansionetutore,
      codaztipoazienda, 
      strazintnumcontratto, 
      datazintiniziocontratto, 
      datazintfinecontratto, 
      strazintrap, 
      numazintsoggetti, 
      numggtramovcomunicazione, 
      strreferente, 
      strnumprtprovincia, 
      numggprevistiagr, 
      numggeffettuatiagr, 
      prgmovimentoappcve, 
      flgassdacess, 
      flgtitolaretutore, 
      codcomnascdi, 
      datnascdi, 
      strsessodi, 
      codlavorazione, 
      codlivelloagr, 
      codcategoria, 
      strversionetracciato, 
      codqualificasrq,
      codtipocomunic,
      codcomunicazione,
	  codcomunicazioneprec,
	  DATINIZIORAPLAV,
	  DATFINERAPLAV,
      DATFINEPRORAPLAV,
	  DATCESSRAPLAV,
	  CODTIPOSOMM, FLGPAGAMENTORIMPATRIO, FLGAZUTILIZESTERA, 
	  DATFINEAFFITTORAMO, STRNUMAGSOMMINISTRAZIONE, FLGSISTEMAZIONEALLOGGIATIVA, 
	  CODQUESTURA, STRCOGNOMELEGRAPP, STRNOMELEGRAPP, CODCITTADINANZALEGRAPP,
	  STRSESSOLEGRAPP, DATNASCLEGRAPP, CODCOMNASCLEGRAPP, DATSCADENZALEGRAPP, CODTIPODOCEXLEGRAPP,
	  STRNUMDOCEXLEGRAPP, CODMOTIVOPERMSOGGEXLEGRAPP, CODQUESTURALEGRAPP, 
	  FLGAZESTERA, STRCFAZESTERA, STRRAGSOCAZESTERA, CODTIPOENTEPROMOTORE, CODTIPOMIS, FLGDISTPARZIALE, FLGDISTAZESTERA, FLGPA,
	  FLGSOGGINITALIA, DATFINEPERIODOFORMATIVO, FLGLAVOROINMOBILITA, FLGLAVOROSTAGIONALE, STRCODFISCPROMOTORETIR, 
	  FLGPROSECUZIONE, CODVARIAZIONE,
	  STRDENOMINAZIONETIR,
	  CODCATEGORIATIR,
	  CODTIPOLOGIATIR,
	  CODSOGGPROMOTOREMIN, FLGASSOBBL, CODCATASSOBBL, STRUALTEL, STRUALFAX, STRUALEMAIL, STREMAILREFERENTE, codtipotrasf, decretribuzioneann, strtracciato)
      select 
        new_prgmovimentoappCve, 
        ma.strazcodicefiscale, 
        ma.strazpartitaiva, 
        ma.strazragionesociale, 
        ma.codazateco, 
        ma.codazccnl, 
        ma.numazdipendenti, 
        ma.strpatinail, 
        ma.struaindirizzo, 
        ma.coduacom, 
        ma.struacap, 
        ma.struatel, 
        ma.struafax, 
        ma.struaemail, 
        ma.strualindirizzo, 
        ma.codualcom, 
        ma.strcodicefiscale, 
        ma.strcognome, 
        ma.strnome, 
        ma.strsesso, 
        ma.datnasc, 
        ma.codcomnasc, 
        ma.codcittadinanza, 
        ma.codcomdom, 
        ma.strindirizzodom, 
        ma.strcapdom, 
        ma.datscadenza, 
        ma.codtipotitolo, 
        ma.codcpi, 
        ma.datcomunicaz, 
        ma.datiniziomov, 
        ma.codtipomov, 
        ma.codmansione, 
        ma.strdesattivita, 
        ma.codcontratto, 
        ma.codmonotempo, 
        ma.flgsocio, 
        ma.codccnl, 
        ma.decretribuzionemen, 
        ma.numlivello, 
        ma.flglegge68, 
        ma.flglavdomicilio, 
        ma.codagevolazione, 
        ma.codorario, 
        ma.numoresett, 
        ma.codmvcessazione, 
        ma.datfinemov, 
        ma.strnote, 
        ma.cdnutins, 
        ma.dtmins, 
        ma.cdnutmod, 
        ma.dtmmod, 
        ma.numklomovapp, 
        ma.strmatricola, 
        ma.codtipoass,
		ma.codtipocontratto, 
        ma.codnormativa, 
        ma.codgrado, 
        ma.flgartigiana, 
        ma.datcfl, 
        ma.strnumcfl, 
        ma.strtipocfl, 
        ma.nummesiapprendistato, 
        ma.codmonoprov, 
        ma.strposinps, 
        ma.codstatoatto, 
        ma.flgasspropria, 
        ma.strazintcodicefiscale, 
        ma.strazintpartitaiva, 
        ma.strazintragionesociale, 
        ma.codazintateco, 
        ma.numazintdipendenti, 
        ma.codazinttipoazienda, 
        ma.struaintindirizzo, 
        ma.coduaintcom, 
        ma.struaintcap, 
        ma.straznumalbointerinali, 
        ma.strnumregistrocommitt, 
        ma.datregistrocommitt, 
        ma.flgretribuzionemenccnl, 
        ma.strluogodilavoro, 
        ma.codcpilav, 
        ma.datvisitamedica, 
        ma.strappcodicefiscaletutore, 
        ma.strappcognometutore, 
        ma.strappnometutore, 
        ma.numappanniesptutore, 
        ma.strapplivellotutore, 
        ma.codappmansionetutore, 
        ma.codaztipoazienda, 
        ma.strazintnumcontratto, 
        ma.datazintiniziocontratto, 
        ma.datazintfinecontratto, 
        ma.strazintrap, 
        ma.numazintsoggetti, 
        ma.numggtramovcomunicazione, 
        ma.strreferente, 
        ma.strnumprtprovincia, 
        ma.numggprevistiagr, 
        ma.numggeffettuatiagr, 
        ma.prgmovimentoappcve, 
        ma.flgassdacess, 
        ma.flgtitolaretutore, 
        ma.codcomnascdi, 
        ma.datnascdi, 
        ma.strsessodi, 
        ma.codlavorazione, 
        ma.codlivelloagr, 
        ma.codcategoria, 
        ma.strversionetracciato, 
        ma.codqualificasrq,
        ma.codtipocomunic,
        ma.codcomunicazione,
		ma.codcomunicazioneprec,
		ma.DATINIZIORAPLAV,
	    ma.DATFINERAPLAV,
        ma.DATFINEPRORAPLAV,
	    ma.DATCESSRAPLAV,
	    ma.CODTIPOSOMM, ma.FLGPAGAMENTORIMPATRIO, ma.FLGAZUTILIZESTERA, 
	    ma.DATFINEAFFITTORAMO, ma.STRNUMAGSOMMINISTRAZIONE, ma.FLGSISTEMAZIONEALLOGGIATIVA,
	    ma.CODQUESTURA, ma.STRCOGNOMELEGRAPP, ma.STRNOMELEGRAPP, ma.CODCITTADINANZALEGRAPP,
	    ma.STRSESSOLEGRAPP, ma.DATNASCLEGRAPP, ma.CODCOMNASCLEGRAPP, ma.DATSCADENZALEGRAPP, ma.CODTIPODOCEXLEGRAPP,
	    ma.STRNUMDOCEXLEGRAPP, ma.CODMOTIVOPERMSOGGEXLEGRAPP, ma.CODQUESTURALEGRAPP,
	    ma.FLGAZESTERA, ma.STRCFAZESTERA, ma.STRRAGSOCAZESTERA, ma.CODTIPOENTEPROMOTORE, ma.CODTIPOMIS, ma.FLGDISTPARZIALE, ma.FLGDISTAZESTERA, ma.FLGPA,
		ma.FLGSOGGINITALIA, ma.DATFINEPERIODOFORMATIVO, ma.FLGLAVOROINMOBILITA, ma.FLGLAVOROSTAGIONALE, ma.STRCODFISCPROMOTORETIR, 
		ma.FLGPROSECUZIONE, ma.CODVARIAZIONE,
		ma.STRDENOMINAZIONETIR,
		ma.CODCATEGORIATIR,
		ma.CODTIPOLOGIATIR,
		ma.CODSOGGPROMOTOREMIN, ma.FLGASSOBBL, ma.CODCATASSOBBL, ma.STRUALTEL, ma.STRUALFAX, ma.STRUALEMAIL, ma.STREMAILREFERENTE,
		ma.codtipotrasf, ma.decretribuzioneann, ma.strtracciato
      from am_movimento_appoggio ma
      where ma.prgmovimentoapp = p_prgmovimentoappcve;
      
      insert into am_mov_agev_app_doppi
	      (prgmovagevappdoppi, 
	       prgmovimentoapp, 
	       codagevolazione, 
	       cdnutins, 
	       dtmins, 
	       cdnutmod, 
	       dtmmod)
      select 
      	  s_am_mov_agev_app_doppi.nextval, 
      	  new_prgmovimentoappCve, 
      	  agev_app.codagevolazione,
      	  agev_app.cdnutins, 
	      agev_app.dtmins, 
	      agev_app.cdnutmod, 
	      agev_app.dtmmod
      from am_mov_agev_app agev_app
      where agev_app.prgmovimentoapp = p_prgmovimentoappcve;
                  
    end if;

	-- recupero prg da sequence
	select s_am_movimento_appoggio_doppi.nextval into new_prgmovimentoapp from dual;

	insert into am_movimento_appoggio_doppi 
	(prgmovimentoapp, 
	strazcodicefiscale, 
	strazpartitaiva, 
	strazragionesociale, 
	codazateco, 
	codazccnl, 
	numazdipendenti, 
	strpatinail, 
	struaindirizzo, 
	coduacom, 
	struacap, 
	struatel, 
	struafax, 
	struaemail, 
	strualindirizzo, 
	codualcom, 
	strcodicefiscale, 
	strcognome, 
	strnome, 
	strsesso, 
	datnasc, 
	codcomnasc, 
	codcittadinanza, 
	codcomdom, 
	strindirizzodom, 
	strcapdom, 
	datscadenza, 
	codtipotitolo, 
	codcpi, 
	datcomunicaz, 
	datiniziomov, 
	codtipomov, 
	codmansione, 
	strdesattivita, 
	codcontratto, 
	codmonotempo, 
	flgsocio, 
	codccnl, 
	decretribuzionemen, 
	numlivello, 
	flglegge68, 
	flglavdomicilio, 
	codagevolazione, 
	codorario, 
	numoresett,
	codmvcessazione, 
	datfinemov, 
	strnote, 
	cdnutins, 
	dtmins, 
	cdnutmod, 
	dtmmod, 
	numklomovapp, 
	strmatricola, 
	codtipoass,
	codtipocontratto, 
	codnormativa, 
	codgrado, 
	flgartigiana, 
	datcfl, 
	strnumcfl, 
	strtipocfl, 
	nummesiapprendistato, 
	codmonoprov, 
	strposinps, 
	codstatoatto, 
	flgasspropria, 
	strazintcodicefiscale, 
	strazintpartitaiva, 
	strazintragionesociale, 
	codazintateco, 
	numazintdipendenti, 
	codazinttipoazienda, 
	struaintindirizzo, 
	coduaintcom, 
	struaintcap, 
	straznumalbointerinali, 
	strnumregistrocommitt, 
	datregistrocommitt, 
	flgretribuzionemenccnl, 
	strluogodilavoro, 
	codcpilav, 
	datvisitamedica, 
	strappcodicefiscaletutore, 
	strappcognometutore, 
	strappnometutore, 
	numappanniesptutore, 
	strapplivellotutore, 
	codappmansionetutore, 
	codaztipoazienda, 
	strazintnumcontratto, 
	datazintiniziocontratto, 
	datazintfinecontratto, 
	strazintrap, 
	numazintsoggetti, 
	numggtramovcomunicazione, 
	strreferente, 
	strnumprtprovincia,
	numggprevistiagr, 
	numggeffettuatiagr, 
	prgmovimentoappcve, 
	flgassdacess, 
	flgtitolaretutore, 
	codcomnascdi, 
	datnascdi, 
	strsessodi, 
	codlavorazione, 
	codlivelloagr, 
	codcategoria, 
	strversionetracciato, 
	codqualificasrq,
	codtipocomunic,
	codcomunicazione,
	codcomunicazioneprec,
	DATINIZIORAPLAV,
	DATFINERAPLAV,
	DATFINEPRORAPLAV,
	DATCESSRAPLAV,
	CODTIPOSOMM, FLGPAGAMENTORIMPATRIO, FLGAZUTILIZESTERA, 
	DATFINEAFFITTORAMO, STRNUMAGSOMMINISTRAZIONE, FLGSISTEMAZIONEALLOGGIATIVA,
	CODQUESTURA, STRCOGNOMELEGRAPP, STRNOMELEGRAPP, CODCITTADINANZALEGRAPP,
	STRSESSOLEGRAPP, DATNASCLEGRAPP, CODCOMNASCLEGRAPP, DATSCADENZALEGRAPP, CODTIPODOCEXLEGRAPP,
	STRNUMDOCEXLEGRAPP, CODMOTIVOPERMSOGGEXLEGRAPP, CODQUESTURALEGRAPP,
	FLGAZESTERA, STRCFAZESTERA, STRRAGSOCAZESTERA, CODTIPOENTEPROMOTORE, CODTIPOMIS, FLGDISTPARZIALE, FLGDISTAZESTERA, FLGPA, 
	FLGSOGGINITALIA, DATFINEPERIODOFORMATIVO, FLGLAVOROINMOBILITA, FLGLAVOROSTAGIONALE, STRCODFISCPROMOTORETIR, 
	FLGPROSECUZIONE, CODVARIAZIONE,
	STRDENOMINAZIONETIR,
	CODCATEGORIATIR,
	CODTIPOLOGIATIR,
	CODSOGGPROMOTOREMIN, FLGASSOBBL, CODCATASSOBBL, STRUALTEL, STRUALFAX, STRUALEMAIL, STREMAILREFERENTE, codtipotrasf, decretribuzioneann, strtracciato)
	select 
	new_prgmovimentoapp, 
	ma.strazcodicefiscale, 
	ma.strazpartitaiva, 
	ma.strazragionesociale, 
	ma.codazateco, 
	ma.codazccnl, 
	ma.numazdipendenti, 
	ma.strpatinail, 
	ma.struaindirizzo, 
	ma.coduacom, 
	ma.struacap, 
	ma.struatel, 
	ma.struafax, 
	ma.struaemail, 
	ma.strualindirizzo, 
	ma.codualcom, 
	ma.strcodicefiscale, 
	ma.strcognome, 
	ma.strnome, 
	ma.strsesso, 
	ma.datnasc, 
	ma.codcomnasc, 
	ma.codcittadinanza, 
	ma.codcomdom, 
	ma.strindirizzodom, 
	ma.strcapdom, 
	ma.datscadenza, 
	ma.codtipotitolo, 
	ma.codcpi, 
	ma.datcomunicaz, 
	ma.datiniziomov, 
	ma.codtipomov, 
	ma.codmansione, 
	ma.strdesattivita, 
	ma.codcontratto, 
	ma.codmonotempo, 
	ma.flgsocio, 
	ma.codccnl, 
	ma.decretribuzionemen, 
	ma.numlivello, 
	ma.flglegge68, 
	ma.flglavdomicilio, 
	ma.codagevolazione, 
	ma.codorario, 
	ma.numoresett,
	ma.codmvcessazione, 
	ma.datfinemov, 
	ma.strnote, 
	ma.cdnutins, 
	ma.dtmins, 
	ma.cdnutmod, 
	ma.dtmmod, 
	ma.numklomovapp, 
	ma.strmatricola, 
	ma.codtipoass,
	ma.codtipocontratto,
	ma.codnormativa, 
	ma.codgrado, 
	ma.flgartigiana, 
	ma.datcfl, 
	ma.strnumcfl, 
	ma.strtipocfl, 
	ma.nummesiapprendistato, 
	ma.codmonoprov, 
	ma.strposinps, 
	ma.codstatoatto, 
	ma.flgasspropria, 
	ma.strazintcodicefiscale, 
	ma.strazintpartitaiva, 
	ma.strazintragionesociale, 
	ma.codazintateco, 
	ma.numazintdipendenti, 
	ma.codazinttipoazienda, 
	ma.struaintindirizzo, 
	ma.coduaintcom, 
	ma.struaintcap, 
	ma.straznumalbointerinali, 
	ma.strnumregistrocommitt, 
	ma.datregistrocommitt, 
	ma.flgretribuzionemenccnl, 
	ma.strluogodilavoro, 
	ma.codcpilav, 
	ma.datvisitamedica, 
	ma.strappcodicefiscaletutore, 
	ma.strappcognometutore, 
	ma.strappnometutore, 
	ma.numappanniesptutore, 
	ma.strapplivellotutore, 
	ma.codappmansionetutore, 
	ma.codaztipoazienda, 
	ma.strazintnumcontratto, 
	ma.datazintiniziocontratto, 
	ma.datazintfinecontratto, 
	ma.strazintrap, 
	ma.numazintsoggetti, 
	ma.numggtramovcomunicazione, 
	ma.strreferente, 
	ma.strnumprtprovincia, 
	ma.numggprevistiagr, 
	ma.numggeffettuatiagr, 
	new_prgmovimentoappCve, 
	ma.flgassdacess, 
	ma.flgtitolaretutore, 
	ma.codcomnascdi, 
	ma.datnascdi, 
	ma.strsessodi, 
	ma.codlavorazione, 
	ma.codlivelloagr, 
	ma.codcategoria, 
	ma.strversionetracciato, 
	ma.codqualificasrq,
	ma.codtipocomunic,
	ma.codcomunicazione,
	ma.codcomunicazioneprec,
	ma.DATINIZIORAPLAV,
	ma.DATFINERAPLAV,
	ma.DATFINEPRORAPLAV,
	ma.DATCESSRAPLAV,
	ma.CODTIPOSOMM, ma.FLGPAGAMENTORIMPATRIO, ma.FLGAZUTILIZESTERA, 
	ma.DATFINEAFFITTORAMO, ma.STRNUMAGSOMMINISTRAZIONE, ma.FLGSISTEMAZIONEALLOGGIATIVA,
	ma.CODQUESTURA, ma.STRCOGNOMELEGRAPP, ma.STRNOMELEGRAPP, ma.CODCITTADINANZALEGRAPP,
	ma.STRSESSOLEGRAPP, ma.DATNASCLEGRAPP, ma.CODCOMNASCLEGRAPP, ma.DATSCADENZALEGRAPP, ma.CODTIPODOCEXLEGRAPP,
	ma.STRNUMDOCEXLEGRAPP, ma.CODMOTIVOPERMSOGGEXLEGRAPP, ma.CODQUESTURALEGRAPP,
	ma.FLGAZESTERA, ma.STRCFAZESTERA, ma.STRRAGSOCAZESTERA, ma.CODTIPOENTEPROMOTORE, ma.CODTIPOMIS, ma.FLGDISTPARZIALE, ma.FLGDISTAZESTERA, ma.FLGPA,
	ma.FLGSOGGINITALIA, ma.DATFINEPERIODOFORMATIVO, ma.FLGLAVOROINMOBILITA, ma.FLGLAVOROSTAGIONALE, ma.STRCODFISCPROMOTORETIR, 
	ma.FLGPROSECUZIONE, ma.CODVARIAZIONE,
	ma.STRDENOMINAZIONETIR,
	ma.CODCATEGORIATIR,
	ma.CODTIPOLOGIATIR,
	ma.CODSOGGPROMOTOREMIN, ma.FLGASSOBBL, ma.CODCATASSOBBL, ma.STRUALTEL, ma.STRUALFAX, ma.STRUALEMAIL, ma.STREMAILREFERENTE,
	ma.codtipotrasf, ma.decretribuzioneann, ma.strtracciato
	from am_movimento_appoggio ma
	where ma.prgmovimentoapp = p_prgMov;

	insert into am_mov_agev_app_doppi
	  (prgmovagevappdoppi, 
	   prgmovimentoapp, 
	   codagevolazione, 
	   cdnutins, 
	   dtmins, 
	   cdnutmod, 
	   dtmmod)
	  select 
	   s_am_mov_agev_app_doppi.nextval, 
	   new_prgmovimentoapp, 
	   agev_app.codagevolazione,
	   agev_app.cdnutins, 
	   agev_app.dtmins, 
	   agev_app.cdnutmod, 
	   agev_app.dtmmod
	  from am_mov_agev_app agev_app
	  where agev_app.prgmovimentoapp = p_prgMov;

	--ELIMINO IL movimento di appoggio
	checkDel := Pg_Movimenti_Doppi.Del_Movimenti_Appoggio(p_prgMov);
	if (checkDel = -1) then
	   dbms_output.put_line('Errore Pg_Movimenti_Doppi.Del_Movimenti_Appoggio= ' || sqlcode || ' ' || sqlerrm || ' prgMovimentoApp=' || p_prgMov);
	   return -1;
	end if;

    if (p_prgmovimentoappcve is not null) then
      --ELIMINO IL movimento di appoggio collegato
      checkDel := Pg_Movimenti_Doppi.Del_Movimenti_Appoggio(p_prgmovimentoappcve);
      if (checkDel = -1) then
         dbms_output.put_line('Errore Pg_Movimenti_Doppi.Del_Movimenti_Appoggio= ' || sqlcode || ' ' || sqlerrm || ' prgMovimentoApp=' || p_prgmovimentoappcve);
         return -1;
      end if;
    end if;

RETURN 0;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore INS_MOVIMENTI_DOPPI= ' || sqlcode || ' ' || sqlerrm || ' prgMovimentoApp=' || p_prgMov);
       return -1;

END INS_MOVIMENTI_DOPPI;

FUNCTION DEL_MOVIMENTI_APPOGGIO(p_prgMov Am_Movimento_Appoggio.Prgmovimentoapp%type )
                             RETURN NUMBER IS
                             
BEGIN

delete Am_Mov_Agev_App where Prgmovimentoapp = p_prgMov;
delete Am_Movimento_Appoggio where Prgmovimentoapp = p_prgMov;

RETURN 0;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore DEL_MOVIMENTI_APPOGGIO= ' || sqlcode || ' ' || sqlerrm || ' prgMovimentoApp' || p_prgMov);
       --rollback;
       return -1;

END DEL_MOVIMENTI_APPOGGIO;

FUNCTION COUNT_CONTROLLO_MOV(p_datInizioDaMov varchar2,
                       p_datInizioAMov varchar2,
                       p_datComunicazDaMov varchar2,
                       p_datComunicazAMov varchar2) 
                       RETURN NUMBER IS

CURSOR curMovimentiApp IS 
        select prgmovimentoapp, strazcodicefiscale, strazpartitaiva, strazragionesociale, codazateco, codazccnl, 
        numazdipendenti, strpatinail, struaindirizzo, coduacom, struacap, struatel, struafax, struaemail, strualindirizzo, 
        codualcom, strcodicefiscale, strcognome, strnome, strsesso, datnasc, codcomnasc, codcittadinanza, codcomdom, 
        strindirizzodom, strcapdom, datscadenza, codtipotitolo, codcpi, datcomunicaz, to_char(datiniziomov, 'dd/mm/yyyy') as datiniziomov, codtipomov, codmansione, 
        strdesattivita, codcontratto, codmonotempo, flgsocio, codccnl, decretribuzionemen, numlivello, flglegge68, 
        flglavdomicilio, codagevolazione, codorario, codmvcessazione, to_char(datfinemov, 'dd/mm/yyyy') as datfinemov, strnote, 
        cdnutins, dtmins, cdnutmod, dtmmod, numklomovapp, strmatricola, codtipoass, codtipocontratto, codnormativa, codgrado, flgartigiana, 
        datcfl, strnumcfl, strtipocfl, nummesiapprendistato, codmonoprov, strposinps, codstatoatto, 
        flgasspropria, strazintcodicefiscale, strazintpartitaiva, strazintragionesociale, codazintateco, numazintdipendenti, 
        codazinttipoazienda, struaintindirizzo, coduaintcom, struaintcap, straznumalbointerinali, strnumregistrocommitt, datregistrocommitt, 
        flgretribuzionemenccnl, strluogodilavoro, codcpilav, datvisitamedica, strappcodicefiscaletutore, strappcognometutore, strappnometutore, 
        numappanniesptutore, strapplivellotutore, codappmansionetutore, codaztipoazienda, strazintnumcontratto, 
        datazintiniziocontratto, datazintfinecontratto, strazintrap, numazintsoggetti, numggtramovcomunicazione, strreferente, strnumprtprovincia, 
        numggprevistiagr, numggeffettuatiagr, prgmovimentoappcve, flgassdacess, flgtitolaretutore, numoresett, codcomnascdi, datnascdi, 
        strsessodi, codlavorazione, codlivelloagr, codcategoria, strversionetracciato, codqualificasrq
       from am_movimento_appoggio 
       where flgassdacess != 'S'
       AND datInizioMov >= to_date(p_datInizioDaMov, 'DD/MM/YYYY') 
       AND datInizioMov <= to_date(decode(p_datInizioAMov, null , to_char(sysdate, 'dd/mm/yyyy'), p_datInizioAMov), 'DD/MM/YYYY')
       AND datComunicaz >= to_date(decode(p_datComunicazDaMov, null ,'01/01/1900', p_datComunicazDaMov), 'DD/MM/YYYY')
       AND datComunicaz <= to_date(decode(p_datComunicazAMov, null , to_char(sysdate, 'dd/mm/yyyy'), p_datComunicazAMov), 'DD/MM/YYYY');

i number;       
checkInsert number;
checkSimileDoppio number; 
checkMovimentoDoppio number;
checkMovimentoSimile number;
checkPrgUnitaProduttiva number;      
checkPrgUnitaUtil number; 
checkUlterioreControllo number;
check_cdnLavoratore number;
check_prgAzienda number;
check_prgAziendaUtil number;
p_cdnLavoratore an_lavoratore.cdnlavoratore%type;       
p_prgAzienda an_azienda.prgazienda%type;
p_prgUnitaProduttiva an_unita_azienda.prgunita%type;
p_prgAziendaUtil an_azienda.prgazienda%type;
p_prgUnitaUtil an_unita_azienda.prgunita%type;
p_prgAziendaMov am_movimento.prgazienda%type;
p_prgUnitaMov am_movimento.prgunita%type;
p_prgAziendaUtilizMov am_movimento.prgaziendautiliz%type;
p_prgUnitaUtilizMov am_movimento.prgunitautiliz%type;
p_datFineMov varchar2(10);
p_codMvCessazione am_movimento.codMvCessazione%type;
       
BEGIN

i := 0;
 
FOR recMovimentoApp in curMovimentiApp LOOP
    
    SELECT count(cdnLavoratore) into check_cdnLavoratore
    FROM AN_LAVORATORE 
    WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strcodicefiscale);
 
    SELECT count(prgAzienda) into check_prgAzienda
    FROM AN_AZIENDA 
    WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strazcodicefiscale);
    
    SELECT count(prgAzienda) into check_prgAziendaUtil
    FROM AN_AZIENDA 
    WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strazintcodicefiscale);
    
    if ((check_cdnLavoratore > 0) and (check_prgAzienda > 0)) then
    
        -- verifico l'esistenza del lavoratore e recupero il suo cdnLavoratore    
        SELECT cdnLavoratore into p_cdnLavoratore
        FROM AN_LAVORATORE 
        WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strcodicefiscale);
        
        -- verifico l'esistenza dell'azienda e dell'unita aziendale
        SELECT prgAzienda into p_prgAzienda
        FROM AN_AZIENDA 
        WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strazcodicefiscale);
        
        if (p_prgAzienda is not null) then
           p_prgUnitaProduttiva := null;
            
           SELECT count(prgUnita) into checkPrgUnitaProduttiva
           FROM AN_UNITA_AZIENDA 
           WHERE prgAzienda = p_prgAzienda;
           
           if (checkPrgUnitaProduttiva = 1) then
             SELECT prgUnita into p_prgUnitaProduttiva
             FROM AN_UNITA_AZIENDA 
             WHERE prgAzienda = p_prgAzienda;
           end if;
        end if;
        
        -- verifico l'esistenza dell'azienda utilizzatrice e della sua unita aziendale
        if (check_prgAziendaUtil > 0) then
          SELECT prgAzienda into p_prgAziendaUtil
          FROM AN_AZIENDA 
          WHERE UPPER(strCodiceFiscale)=UPPER(recMovimentoApp.strazintcodicefiscale);
        
          if (p_prgAzienda is not null) then
             p_prgUnitaUtil:= null;
              
             SELECT count(prgUnita) into checkPrgUnitaUtil
             FROM AN_UNITA_AZIENDA 
             WHERE prgAzienda = p_prgAziendaUtil;
             
             if (checkPrgUnitaUtil = 1) then
               SELECT prgUnita into p_prgUnitaUtil
               FROM AN_UNITA_AZIENDA 
               WHERE prgAzienda = p_prgAziendaUtil;
             end if;
          end if;  
        end if; 
        -- nel caso le info azienda utilizzaztrice siano nulle si settano a -1
        if (p_prgAziendaUtil is null) then 
           p_prgAziendaUtil := -1;
        end if;
        if (p_prgUnitaUtil is null) then 
           p_prgUnitaUtil:= -1;
        end if;
        
        if ((p_cdnLavoratore is not null) and 
            (p_prgAzienda is not null) and 
            (p_prgunitaproduttiva is not null)) then    
           
           --verifico se esiste per l'i-esimo movimento appoggio un movimento simile/doppio
           checkSimileDoppio := pg_movimenti_doppi.check_movimenti_doppi(p_cdnLavoratore, recMovimentoApp.codtipomov, recMovimentoApp.datiniziomov);
           
           if (checkSimileDoppio > 0) then
              -- verifica che si tratti di un documento doppio
              checkMovimentoDoppio := 0;      
              checkMovimentoSimile := 0;    
              DECLARE
              CURSOR curMovimentiSim IS
                     SELECT mov.prgazienda, mov.prgunita, mov.prgaziendautiliz, mov.prgunitautiliz, to_char(mov.datfinemov, 'dd/mm/yyyy') as datfinemov, mov.codmvcessazione              
    	               FROM am_movimento mov,  an_lavoratore lav, an_azienda az, an_unita_azienda azu, de_comune com, 
    	                    de_provincia pr , ( select doc.numProtocollo, coll.strChiaveTabella 
    							        from am_documento doc , am_documento_coll coll 
    						          where doc.cdnLavoratore = p_cdnLavoratore
                          and doc.prgDocumento = coll.prgDocumento  
    							        and coll.cdnComponente = 
                          (select cdncomponente from ts_componente 
                          where upper(strpage) = upper('MovDettaglioGeneraleConsultaPage') )
    				              ) tab   
                      WHERE mov.CODSTATOATTO = 'PR' 		 
                      and mov.prgMovimento = tab.STRCHIAVETABELLA(+)
    	                and mov.cdnlavoratore = lav.cdnlavoratore 
    	                and mov.prgAzienda = az.prgAzienda 
    	                and az.prgAzienda = azu.prgAzienda 
    	                and azu.prgUnita = mov.prgUnita  
    	                and azu.codCom = com.codCom and com.codProvincia = pr.codProvincia
    	                and UPPER(CODTIPOMOV) = UPPER(recMovimentoApp.codtipomov) 
    	                and mov.DATINIZIOMOV = TO_DATE(recMovimentoApp.datiniziomov, 'DD/MM/YYYY')
    	                and mov.CDNLAVORATORE = p_cdnLavoratore;
              
              BEGIN
                   OPEN curMovimentiSim;
                   LOOP     
                   FETCH curMovimentiSim INTO p_prgAziendaMov, p_prgUnitaMov, p_prgAziendaUtilizMov, 
                                              p_prgUnitaUtilizMov, p_datFineMov, p_codMvCessazione;         
                   EXIT WHEN curMovimentiSim%NOTFOUND;                 
                      
                      if ((p_prgAzienda = p_prgAziendaMov) and
                         (p_prgUnitaProduttiva = p_prgUnitaMov) and
                         (p_prgAziendaUtil = p_prgAziendaUtilizMov) and
                         (p_prgUnitaUtil = p_prgUnitaUtilizMov)) then
                         
                         -- si è trovato un movimento doppio
                         checkMovimentoDoppio := 1;
                         i := i+1;	
                         EXIT;
                      
                      end if;
                      
                      if ((p_prgAzienda = p_prgAziendaMov) and
                         (p_prgUnitaProduttiva = p_prgUnitaMov)) then
                         
                         -- si è trovato un movimento simile
                         checkMovimentoSimile := 1;
                         i := i+1;	
                         EXIT;
                      end if;   
                                                                                                                    
                   END LOOP;
                   CLOSE curMovimentiSim;
              END;
	      	                              
           end if;           
        end if;
    end if;
    
END LOOP;

RETURN i;

EXCEPTION
    when others then        
       dbms_output.put_line('Errore COUNT_CONTROLLO_MOV = ' || sqlcode || ' ' || sqlerrm || 'p_cdnLavoratore=' || p_cdnLavoratore);
       rollback;
       return -1;

END COUNT_CONTROLLO_MOV;

END PG_MOVIMENTI_DOPPI;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_MOVIMENTI.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_MOVIMENTI IS

  TYPE dati_doc is RECORD(
    doc_prg am_documento.PRGDOCUMENTO%type,
    doc_kLo am_documento.NUMKLODOCUMENTO%type);

  procedure Ins_mov_sospeso(PrgParAzienda         AM_MOVIMENTO.PRGAZIENDA%TYPE,
                            PrgParUnita           AM_MOVIMENTO.PRGUNITA%TYPE,
                            CdnParLavoratore      AM_MOVIMENTO.CDNLAVORATORE%TYPE,
                            DatParComunicazione   AM_MOVIMENTO.DATCOMUNICAZ%TYPE,
                            DatParInizioMov       AM_MOVIMENTO.DATINIZIOMOV%TYPE,
                            CodParTipoMov         AM_MOVIMENTO.CODTIPOMOV%TYPE,
                            CodParMonoTempo       AM_MOVIMENTO.CODMONOTEMPO%TYPE,
                            CodParTipoAss         AM_MOVIMENTO.CODTIPOCONTRATTO%TYPE,
                            CodParMonoProv        AM_MOVIMENTO.CODMONOPROV%TYPE,
                            CodParMonoMovDich     AM_MOVIMENTO.CODMONOMOVDICH%TYPE,
                            CdnParUtente          AM_MOVIMENTO.CDNUTINS%TYPE,
                            CodParMansione        AM_MOVIMENTO.CODMANSIONE%TYPE,
                            CodParContratto       AM_MOVIMENTO.CODCONTRATTO%TYPE,
                            CodParCcnl            AM_MOVIMENTO.CODCCNL%TYPE,
                            CodParOrario          AM_MOVIMENTO.CODORARIO%TYPE,
                            CodParAgevolazione    AM_MOVIMENTO.CODAGEVOLAZIONE%TYPE,
                            CodParNormativa       AM_MOVIMENTO.CODNORMATIVA%TYPE,
                            CodParGrado           AM_MOVIMENTO.CODGRADO%TYPE,
                            CodParTitolo          AM_MOVIMENTO.CODTITOLO%TYPE,
                            CodParCpi             AM_MOVIMENTO.CODCPI%TYPE,
                            CodParCpiLav          AM_MOVIMENTO.CODCPILAV%TYPE,
                            CodParMvCessazione    AM_MOVIMENTO.CODMVCESSAZIONE%TYPE,
                            PrgParAziendaUtiliz   AM_MOVIMENTO.PRGAZIENDAUTILIZ%TYPE,
                            PrgParUnitaUtiliz     AM_MOVIMENTO.PRGUNITAUTILIZ%TYPE,
                            StrParMatricola       AM_MOVIMENTO.STRMATRICOLA%TYPE,
                            NumParLivello         AM_MOVIMENTO.NUMLIVELLO%TYPE,
                            StrParDesAttivita     AM_MOVIMENTO.STRDESATTIVITA%TYPE,
                            StrParInps            AM_MOVIMENTO.STRPOSINPS%TYPE,
                            StrParInail           AM_MOVIMENTO.STRPATINAIL%TYPE,
                            DecParRetribuzione    AM_MOVIMENTO.DECRETRIBUZIONEMEN%TYPE,
                            NumParOreSett         AM_MOVIMENTO.NUMORESETT%TYPE,
                            DecParggPrev          AM_MOVIMENTO.NUMGGPREVISTIAGR%TYPE,
                            DecParggEff           AM_MOVIMENTO.NUMGGEFFETTUATIAGR%TYPE,
                            DatParInizioAvv       AM_MOVIMENTO.DATINIZIOAVV%TYPE,
                            DatParFineMov         AM_MOVIMENTO.DATFINEMOV%TYPE,
                            strParReferente       AM_MOVIMENTO.STRREFERENTE%TYPE,
                            StrParLuogolavoro     AM_MOVIMENTO.STRLUOGODILAVORO%TYPE,
                            StrParAzIntContratto  AM_MOVIMENTO.STRAZINTNUMCONTRATTO%TYPE,
                            StrParAzIntRap        AM_MOVIMENTO.STRAZINTRAP%TYPE,
                            DatParIntIniCont      AM_MOVIMENTO.DATAZINTINIZIOCONTRATTO%TYPE,
                            DatParIntFineCont     AM_MOVIMENTO.DATAZINTFINECONTRATTO%TYPE,
                            NumParIntSogg         AM_MOVIMENTO.NUMAZINTSOGGETTI%TYPE,
                            NumParIntDip          AM_MOVIMENTO.NUMAZINTDIPENDENTI%TYPE,
                            FlgParIntAssPro       AM_MOVIMENTO.FLGINTERASSPROPRIA%TYPE,
                            FlgParLavDomic        AM_MOVIMENTO.FLGLAVDOMICILIO%TYPE,
                            FlgParSocio           AM_MOVIMENTO.FLGSOCIO%TYPE,
                            FlgParLegge68         AM_MOVIMENTO.FLGLEGGE68%TYPE,
                            FlgParModTempo        AM_MOVIMENTO.FLGMODTEMPO%TYPE,
                            FlgParModered         AM_MOVIMENTO.FLGMODREDDITO%TYPE,
                            CodParMotAnnullamento AM_MOVIMENTO.CODMOTANNULLAMENTO%TYPE);

  procedure Update_Azienda_Mov_Collegati(P_prgMov   AM_MOVIMENTO.PRGMOVIMENTO%TYPE,
                                         P_prgAz    AM_MOVIMENTO.PRGAZIENDA%TYPE,
                                         P_prgUnita AM_MOVIMENTO.PRGUNITA%TYPE);

  FUNCTION RECUPERA_TIPOASS_AVV(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
    RETURN AM_MOVIMENTO.CODTIPOCONTRATTO%TYPE;

  FUNCTION RECUPERA_GRADO_AVV(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
    RETURN AM_MOVIMENTO.CODGRADO%TYPE;

  PROCEDURE LOGGA_RECORD(tab       IN varchar2,
                         chiave    IN varchar2,
                         valChiave IN number,
                         operation IN varchar2,
                         utLog     IN number);

  FUNCTION ULTIMACATENA(codicefiscale IN varchar2) RETURN varchar2;

  FUNCTION CALCULA_MOV_PREC(prgmovimentoq IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE) RETURN varchar2;

  PROCEDURE CANC_MOV_APP_ERR(result    OUT Varchar2,
                             codiceErr IN varchar2,
                             dataDA    IN Varchar2,
                             dataA     IN Varchar2,
                             tipoMov   IN Varchar2,
                             cfAz      IN Varchar2,
                             cfLav     IN Varchar2,
                             codCom    IN Varchar2,
                             dataInsDA IN Varchar2,
                             dataInsA  IN Varchar2,
                             utIns     IN Varchar2);

FUNCTION GetCodContrattoForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.CODTIPOCONTRATTO%TYPE;

FUNCTION MesiSospDecretoFornero2014 (cdnLav IN an_lavoratore.cdnlavoratore%type,
									 dataStatoOccRif IN am_stato_occupaz.datinizio%type,
									 prgStatoOcc IN am_stato_occupaz.prgstatooccupaz%type) return varchar2;

FUNCTION MesiSospFornero2014DallaData (cdnLav IN an_lavoratore.cdnlavoratore%type,
									   dataCalcolo IN varchar2,
									   dataRif IN varchar2) return varchar2;

FUNCTION MesiSospFornero2014AllaData (cdnLav IN an_lavoratore.cdnlavoratore%type,
									  dataCalcolo IN ts_generale.datFornero%type,
									  dataCalcoloMesiSosp IN ts_generale.datFornero%type) return varchar2;

FUNCTION DettaglioAnzianitaFornero2014 (cdnLav IN an_lavoratore.cdnlavoratore%type) return varchar2;

FUNCTION MesiRischioDisoccupazione (cdnLav IN an_lavoratore.cdnlavoratore%type,
								    dataCalcoloAnzianita IN am_stato_occupaz.datcalcoloanzianita%type) return varchar2;

FUNCTION MesiRischioDisoccupazionePar (cdnLav IN an_lavoratore.cdnlavoratore%type,
									   dataCalcoloAnzianita IN am_stato_occupaz.datcalcoloanzianita%type,
									   dataRif IN am_stato_occupaz.datinizio%type) return varchar2;

FUNCTION CalcolaAnzianita (cdnLav IN an_lavoratore.cdnlavoratore%type,
						   dataCalcolo IN varchar2) return varchar2;
               
----------------------------------------------------------------------------------
--Procedura per la gestione della modifica forzata dei movimenti di un lavoratore
----------------------------------------------------------------------------------


PROCEDURE ModificaForzataMovimenti (prgMovForz IN AM_FORZATURA.PRGFORZATURA%TYPE,
                                    utenteForz IN AM_FORZATURA.CDNUTINS%TYPE,
                                    errCodeOut out number);               

FUNCTION  CTRMODMOVSUCC (
                        prgMov IN Am_Forza_Mov.Prgmovimento%type, 
                        prgMovSucc IN Am_Forza_Mov.Prgsucc%TYPE,
                        p_UtenteForz IN AM_FORZATURA.CDNUTINS%TYPE,
                        dataInizioMov IN Am_Forza_Mov.Datinizio%TYPE,
                        fl_errElab  IN OUT NOCOPY boolean,
                        rowMov  IN OUT NOCOPY AM_MOVIMENTO%ROWTYPE,
                        dataFineMovEff IN OUT NOCOPY Am_Forza_Mov.Datfinemoveffettiva%TYPE
                        ) 
  return number;    
  

FUNCTION CTRMODMOVPREC (prgMov IN Am_Forza_Mov.prgmovimento%type, 
                        prgMovPrec IN Am_Forza_Mov.Prgprec%TYPE,
                        p_UtenteForz IN AM_FORZATURA.CDNUTINS%TYPE,
                        p_datiniziomovForz IN Am_Forza_Mov.Datinizio%TYPE,
                        rowMov  IN OUT NOCOPY AM_MOVIMENTO%ROWTYPE,
                        fl_ErrElab IN OUT NOCOPY boolean) 
  return number;  
 
FUNCTION ModCodStatoAtto (p_codstatoatto IN Am_Forza_Mov.Codstatoatto%type, 
                        utenteForz IN Am_FORZATURA.Cdnutins%TYPE,
                        p_datiniziomovForz IN Am_Forza_Mov.Datinizio%TYPE,
                        rowMov  IN OUT NOCOPY AM_MOVIMENTO%ROWTYPE,
                        p_prgprec IN OUT NOCOPY am_forza_mov.prgprec%type,
                        p_prgsucc IN OUT NOCOPY am_forza_mov.prgsucc%type,
                        p_datfinemoveffettForz IN OUT NOCOPY am_forza_mov.datfinemoveffettiva%TYPE,
                        fl_ErrElab IN OUT NOCOPY boolean) 
  return number; 
 
FUNCTION Aggiorna_DateMovSucc (prgMovSucc IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE, 
                              p_data_inizio_mov_succ IN AM_MOVIMENTO.DATINIZIOMOV%TYPE , 
                              p_data_fine_mov_succ IN AM_MOVIMENTO.DATFINEMOV%TYPE,
                              p_cdnutmod         IN AM_FORZATURA.CDNUTINS%TYPE)
  return number ;
  
FUNCTION Aggiorna_DateMovPrec (prgMovPrec IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE, 
                              p_datfinemoveffettprec IN AM_MOVIMENTO.DATFINEMOVEFFETTIVA%TYPE, 
                              p_cdnutmod         IN AM_FORZATURA.CDNUTINS%TYPE)
  return number;    
  
FUNCTION InserisciNuovoDocumento (rowMov IN AM_MOVIMENTO%ROWTYPE, 
                               utenteForz IN Am_FORZATURA.Cdnutins%TYPE,
                               p_datiniziomovForz IN Am_Forza_Mov.Datinizio%TYPE
                               ) 
  return number ;
  
FUNCTION ModificaDocumento (rowMov IN AM_MOVIMENTO%ROWTYPE, 
                               utenteForz IN Am_FORZATURA.Cdnutins%TYPE,
                               p_codstatoatto IN AM_MOVIMENTO.Codstatoatto%TYPE
                              )  
  return number;   
  
FUNCTION RicercaPrgDettaglio ( prgMovForz IN AM_FORZATURA.PRGFORZATURA%TYPE,  
                               prgMov     IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE 
                              ) 
  return number;  
  
FUNCTION InserisciErrore ( prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE, 
                               codErrore IN Number
                              ) 
  return number;            

FUNCTION AggiornaMovimento (   prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE,
                               p_cdnutmod         IN AM_FORZATURA.CDNUTINS%TYPE,
                               p_prgsucc IN AM_MOVIMENTO.PRGMOVIMENTOSUCC%TYPE,
                               p_prgprec IN AM_MOVIMENTO.PRGMOVIMENTOPREC%TYPE,
                               p_datiniziomovForz IN AM_MOVIMENTO.DATINIZIOMOV%TYPE,
                               p_datfinemoveffettForz IN AM_MOVIMENTO.DATFINEMOVEFFETTIVA%TYPE,
                               rowMov IN AM_MOVIMENTO%ROWTYPE, 
                               p_codstatoatto IN AM_MOVIMENTO.Codstatoatto%TYPE,
                               f_ErrElab      IN OUT NOCOPY boolean
                              ) 
         return number;

FUNCTION AggiornaMovimentoForzato (prgMovForzDett IN AM_FORZA_MOV.PRGFORZAMOV%TYPE,
                                   p_cdnutmod         IN AM_FORZATURA.CDNUTINS%TYPE,
                                   p_prgsucc IN AM_FORZA_MOV.PRGSUCC%TYPE,
                                   p_prgprec IN AM_FORZA_MOV.PRGPREC%TYPE,
                                   p_datiniziomovForz IN AM_FORZA_MOV.DATINIZIO%TYPE,
                                   p_datfinemoveffettForz IN AM_FORZA_MOV.DATFINEMOVEFFETTIVA%TYPE,
                                   p_codstatoatto IN AM_FORZA_MOV.CODSTATOATTO%TYPE) 
         return number;   
FUNCTION AggiornamentoEsitoTabForzatura (prgForzatura IN AM_FORZATURA.PRGFORZATURA%TYPE,
                                         esito        IN AM_FORZATURA.NUMESITO%TYPE) 
         return number;    

--------------------------------------------------------------
--Procedura di controllo di congruenza delle catene dei movimenti forzati
--------------------------------------------------------------                    
         
PROCEDURE CheckCatenaMovForzati(prgMovForz IN AM_FORZA_MOV.PRGFORZAMOV%TYPE,
                                fl_errElab IN OUT NOCOPY boolean);   

--------------------------------------------------------------
-- Procedura di controllo di congruenza di tutte le catene dei movimenti 
-- del lavoratore
--------------------------------------------------------------  
                                
PROCEDURE CheckCatenaMovLavoratore(p_CdnLavoratore IN AM_MOVIMENTO.CDNLAVORATORE%TYPE,
                                   errCodOut OUT number) ;                                      

END PG_MOVIMENTI;
/
CREATE OR REPLACE PACKAGE BODY PG_MOVIMENTI IS



procedure Ins_mov_sospeso
(PrgParAzienda AM_MOVIMENTO.PRGAZIENDA%TYPE, PrgParUnita AM_MOVIMENTO.PRGUNITA%TYPE,
 CdnParLavoratore AM_MOVIMENTO.CDNLAVORATORE%TYPE, DatParComunicazione AM_MOVIMENTO.DATCOMUNICAZ%TYPE,
 DatParInizioMov AM_MOVIMENTO.DATINIZIOMOV%TYPE, CodParTipoMov AM_MOVIMENTO.CODTIPOMOV%TYPE,
 CodParMonoTempo AM_MOVIMENTO.CODMONOTEMPO%TYPE, CodParTipoAss AM_MOVIMENTO.CODTIPOCONTRATTO%TYPE,
 CodParMonoProv AM_MOVIMENTO.CODMONOPROV%TYPE, CodParMonoMovDich AM_MOVIMENTO.CODMONOMOVDICH%TYPE,
 CdnParUtente AM_MOVIMENTO.CDNUTINS%TYPE, CodParMansione AM_MOVIMENTO.CODMANSIONE%TYPE,
 CodParContratto AM_MOVIMENTO.CODCONTRATTO%TYPE, CodParCcnl AM_MOVIMENTO.CODCCNL%TYPE,
 CodParOrario AM_MOVIMENTO.CODORARIO%TYPE, CodParAgevolazione AM_MOVIMENTO.CODAGEVOLAZIONE%TYPE,
 CodParNormativa AM_MOVIMENTO.CODNORMATIVA%TYPE, CodParGrado AM_MOVIMENTO.CODGRADO%TYPE,
 CodParTitolo AM_MOVIMENTO.CODTITOLO%TYPE, CodParCpi AM_MOVIMENTO.CODCPI%TYPE,
 CodParCpiLav AM_MOVIMENTO.CODCPILAV%TYPE, CodParMvCessazione AM_MOVIMENTO.CODMVCESSAZIONE%TYPE,
 PrgParAziendaUtiliz AM_MOVIMENTO.PRGAZIENDAUTILIZ%TYPE, PrgParUnitaUtiliz AM_MOVIMENTO.PRGUNITAUTILIZ%TYPE,
 StrParMatricola AM_MOVIMENTO.STRMATRICOLA%TYPE, NumParLivello AM_MOVIMENTO.NUMLIVELLO%TYPE,
 StrParDesAttivita AM_MOVIMENTO.STRDESATTIVITA%TYPE, StrParInps AM_MOVIMENTO.STRPOSINPS%TYPE,
 StrParInail AM_MOVIMENTO.STRPATINAIL%TYPE, DecParRetribuzione AM_MOVIMENTO.DECRETRIBUZIONEMEN%TYPE,
 NumParOreSett AM_MOVIMENTO.NUMORESETT%TYPE, DecParggPrev AM_MOVIMENTO.NUMGGPREVISTIAGR%TYPE,
 DecParggEff AM_MOVIMENTO.NUMGGEFFETTUATIAGR%TYPE, DatParInizioAvv AM_MOVIMENTO.DATINIZIOAVV%TYPE,
 DatParFineMov AM_MOVIMENTO.DATFINEMOV%TYPE, strParReferente AM_MOVIMENTO.STRREFERENTE%TYPE,
 StrParLuogolavoro AM_MOVIMENTO.STRLUOGODILAVORO%TYPE, StrParAzIntContratto AM_MOVIMENTO.STRAZINTNUMCONTRATTO%TYPE,
 StrParAzIntRap AM_MOVIMENTO.STRAZINTRAP%TYPE, DatParIntIniCont AM_MOVIMENTO.DATAZINTINIZIOCONTRATTO%TYPE,
 DatParIntFineCont AM_MOVIMENTO.DATAZINTFINECONTRATTO%TYPE, NumParIntSogg AM_MOVIMENTO.NUMAZINTSOGGETTI%TYPE,
 NumParIntDip AM_MOVIMENTO.NUMAZINTDIPENDENTI%TYPE, FlgParIntAssPro AM_MOVIMENTO.FLGINTERASSPROPRIA%TYPE,
 FlgParLavDomic AM_MOVIMENTO.FLGLAVDOMICILIO%TYPE, FlgParSocio AM_MOVIMENTO.FLGSOCIO%TYPE,
 FlgParLegge68 AM_MOVIMENTO.FLGLEGGE68%TYPE,
 FlgParModTempo AM_MOVIMENTO.FLGMODTEMPO%TYPE, FlgParModered AM_MOVIMENTO.FLGMODREDDITO%TYPE,
 CodParMotAnnullamento AM_MOVIMENTO.CODMOTANNULLAMENTO%TYPE
 )
as
  conta      INTEGER;
  prgmovi    AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
  codmans    AM_MOVIMENTO.CODMANSIONE%TYPE;
  codcontr   AM_MOVIMENTO.CODCONTRATTO%TYPE;
  codccoll   AM_MOVIMENTO.CODCCNL%TYPE;
  codora   AM_MOVIMENTO.CODORARIO%TYPE;
  codagevol   AM_MOVIMENTO.CODAGEVOLAZIONE%TYPE;
  codnorma   AM_MOVIMENTO.CODNORMATIVA%TYPE;
  codgra   AM_MOVIMENTO.CODGRADO%TYPE;
  codtit   AM_MOVIMENTO.CODTITOLO%TYPE;
  codCpiAz   AM_MOVIMENTO.CODCPI%TYPE;
  codCpiLa   AM_MOVIMENTO.CODCPILAV%TYPE;
  codCess   AM_MOVIMENTO.CODMVCESSAZIONE%TYPE;
  prgaziut   AM_MOVIMENTO.PRGAZIENDAUTILIZ%TYPE;
  prguniut   AM_MOVIMENTO.PRGUNITAUTILIZ%TYPE;
  codannull   AM_MOVIMENTO.CODMOTANNULLAMENTO%TYPE;

begin
   ------------------------------
  -- Controllo campi obbligatori
  ------------------------------
  -- Controllo azienda
  select count(*)
    into conta
    from an_unita_azienda
   where prgazienda = PrgParAzienda
     and prgunita = PrgParUnita
  ;
  if conta = 0 then
   raise_application_error (-20100, 'Manca l''azienda!');
  end if;

  -- Controllo lavoratore
  select count(*)
    into conta
    from an_lavoratore
   where cdnlavoratore = CdnParLavoratore
  ;
  if conta = 0 then
   raise_application_error (-20101, 'Manca il lavoratore!');
  end if;

  -- Controllo il tipo di Movimento
  if CodParTipoMov not in ('AVV','CES','TRA','PRO') then
   raise_application_error (-20104, 'Specificare il tipo di movimento!');
  end if;

  -- Controllo data di inizio movimento
  if DatParInizioMov is null then
    raise_application_error (-20103, 'La data di inizio del movimento non è valorizzata!');
  end if;

  -- Controllo data di comunicazione
  if DatParComunicazione is null then
    raise_application_error (-20102, 'La data di comunicazione non è valorizzata!');
  end if;

  -- Controllo il tempo det/indet
  if CodParMonoTempo not in ('D','I') then
   raise_application_error (-20105, 'La durata (TD/TI) non è specificata!');
  end if;

  -- Controllo il tipo di assunzione
  select count(*)
    into conta
    from de_tipo_contratto
   where codtipocontratto = CodParTipoAss
   ;
  if conta = 0 then
   raise_application_error (-20106, 'Il tipo di assunzione non è specificato!');
  end if;

  -- Controllo provenienza
  if CodParMonoProv not in ('F','M','P') then
   raise_application_error (-20107, 'Il tipo di provenienza del file non è specificato!');
  end if;

  -- Controllo tipo di dichiarazione
  if CodParMonoMovDich not in ('C','D','O') then
   raise_application_error (-20108, 'La provenienza del movimento non è specificato!');
  end if;

  -- Controllo utente
  select count(*)
    into conta
    from ts_utente
   where cdnut = CdnParUtente
  ;
  if conta = 0 then
   raise_application_error (-20109, 'Utente non presente in archivio!');
  end if;

  -- Controllo mansione
  if CodParMansione is not null then
   select count(*)
     into conta
     from de_mansione
     where codmansione = CodParMansione
   ;
   if conta = 0 then
    codmans := null;
   else
    codmans := CodParMansione;
   end if;
  else
    codmans := null;
  end if;

  -- Controllo contratto
  if CodParContratto is not null then
   select count(*)
     into conta
     from de_contratto
     where codcontratto = CodParContratto
     and flgmovimenti='S'
   ;
   if conta = 0 then
    select codcontratto
     into codcontr
     from de_tipo_contratto
    where codtipocontratto = CodParTipoAss
   ;
   else
     codcontr := CodParContratto;
   end if;
  else
    codcontr := null;
  end if;

  -- Controllo contratto collettivo
  if CodParCcnl is not null then
   select count(*)
     into conta
     from de_contratto_collettivo
     where codccnl = CodParCcnl
   ;
   if conta = 0 then
    select codccnl
     into codccoll
     from an_unita_azienda
    where prgazienda = PrgParAzienda
      and prgunita = PrgParUnita
   ;
   else
     codccoll := CodParCcnl;
   end if;
  else
    codccoll := null;
  end if;

  -- Controllo orario
  if CodParOrario is not null then
   select count(*)
    into conta
    from de_orario
   where codorario = CodParOrario
     and flgmovimenti = 'S'
  ;
  if conta = 0 then
     codora := null;
  else
        codora := CodParOrario;
  end if;
  else
    codora:= null;
  end if;

  -- Controllo beneficio
  if CodParAgevolazione is not null then
   select count(*)
    into conta
    from de_agevolazione
   where codagevolazione = CodParAgevolazione
  ;
  if conta = 0 then
     codagevol := null;
  else
        codagevol := CodParAgevolazione;
  end if;
  else
    codagevol := null;
  end if;

  -- Controllo normativa
  if CodParNormativa is not null then
   select count(*)
    into conta
    from de_normativa
   where codnormativa = CodParNormativa
  ;
  if conta = 0 then
     codnorma := null;
  else
        codnorma := CodParNormativa;
  end if;
  else
    codnorma := null;
  end if;

  -- Controllo grado
  if CodParGrado is not null then
   select count(*)
    into conta
    from de_mv_grado
   where codgrado = CodParGrado
  ;
  if conta = 0 then
     codgra := null;
  else
        codgra := CodParGrado;
  end if;
  else
    codgra := null;
  end if;

  -- Controllo titolo di studio
  if CodParTitolo is not null then
   select count(*)
    into conta
    from de_titolo
   where codtitolo = CodParTitolo
  ;
  if conta = 0 then
     codtit := null;
  else
        codtit := CodParTitolo;
  end if;
  else
    codtit := null;
  end if;

  -- Controllo CPI Azienda
  if CodParCpi is not null then
   select count(*)
    into conta
    from de_cpi
   where codcpi = CodParCpi
  ;
  if conta = 0 then
     select de_comune.codcpi
       into codcpiaz
       from an_unita_azienda, de_comune
      where an_unita_azienda.codcom = de_comune.codcom
        and prgazienda = PrgParAzienda
        and prgunita =  PrgParUnita
     ;
  else
        codcpiaz := CodParCpi;
  end if;
  else
    codcpiaz := null;
  end if;

  -- Controllo CPI Lavoratore
  if CodParCpiLav is not null then
   select count(*)
    into conta
    from de_cpi
   where codcpi = CodParCpiLav
  ;
   if conta = 0 then
     select de_comune.codcpi
       into codcpila
       from an_lavoratore, de_comune
      where an_lavoratore.codcomdom = de_comune.codcom
        and cdnlavoratore = CdnParLavoratore
       ;
  else
        codcpila := CodParCpiLav;
  end if;
  else
    codcpila := null;
  end if;

  -- Controllo Motivo di cessazione
  if CodParMvCessazione is not null then
   select count(*)
    into conta
    from de_mv_cessazione
   where codmvcessazione = CodParMvCessazione
  ;
  if conta = 0 then
     codcess := null;
  else
        codcess := CodParMvCessazione;
  end if;
  else
   codcess := null;
  end if;

  -- Controllo Azienda Utilizzatrice
  if PrgParAziendaUtiliz is not null then
   select count(*)
    into conta
    from an_unita_azienda
   where prgazienda = PrgParAziendaUtiliz
     and prgunita = PrgParUnitaUtiliz
   ;
   if conta = 0 then
     prgaziut := null;
     prguniut := null;
   else
      prgaziut := PrgParAziendaUtiliz;
     prguniut := PrgParUnitaUtiliz;
   end if;
  else
    prgaziut := null;
   prguniut := null;
  end if;


  -- Controllo Motivazione
  if CodParMotAnnullamento is not null then
   select count(*)
     into conta
     from de_mot_annullamento
    where codmotannullamento = CodParMotAnnullamento
   ;
   if conta = 0 then
     codannull := null;
   else
      codannull := CodParMotAnnullamento;
   end if;
  else
    codannull:= null;
  end if;



  -- Calcolo Chiave
  select S_AM_MOVIMENTO.nextval
    into prgmovi
    from dual;

  insert
    into am_movimento
          (PRGMOVIMENTO, PRGAZIENDA, PRGUNITA, CDNLAVORATORE, DATCOMUNICAZ, DATINIZIOMOV,
      CODTIPOMOV, CODMONOTEMPO, CODTIPOCONTRATTO, CODMONOPROV, CODMONOMOVDICH,
      CDNUTINS, DTMINS, CDNUTMOD, DTMMOD, -- da qui in poi nullable
      CODMANSIONE, CODCONTRATTO, CODCCNL, CODORARIO, CODAGEVOLAZIONE, CODNORMATIVA, CODGRADO, CODTITOLO,
   CODCPI, CODCPILAV, CODMVCESSAZIONE, PRGAZIENDAUTILIZ, PRGUNITAUTILIZ,
   STRMATRICOLA, NUMLIVELLO, STRDESATTIVITA, STRPOSINPS, STRPATINAIL,
   DECRETRIBUZIONEMEN, NUMORESETT, NUMGGPREVISTIAGR, NUMGGEFFETTUATIAGR, DATINIZIOAVV, DATFINEMOV,
   STRREFERENTE, STRLUOGODILAVORO, STRAZINTNUMCONTRATTO, STRAZINTRAP, DATAZINTINIZIOCONTRATTO,
   DATAZINTFINECONTRATTO, NUMAZINTSOGGETTI, NUMAZINTDIPENDENTI, FLGINTERASSPROPRIA, FLGLAVDOMICILIO,
   FLGSOCIO, FLGLEGGE68, FLGMODTEMPO, FLGMODREDDITO, CODMOTANNULLAMENTO, CODSTATOATTO
     )
 values (prgmovi, PrgParAzienda, PrgParUnita, CdnParLavoratore, DatParComunicazione, DatParInizioMov,
      CodParTipoMov, CodParMonoTempo, CodParTipoAss, CodParMonoProv, CodParMonoMovDich,
   CdnParUtente, sysdate, CdnParUtente, sysdate, -- da qui in poi nullable
   codmans, codcontr, codccoll, codora, codagevol, codnorma, codgra, codtit,
   codCpiAz, codCpiLa, codcess, prgaziut, prguniut,
   StrParMatricola, NumParLivello, StrParDesAttivita, StrParInps, StrParInail,
   DecParRetribuzione, NumParOreSett, DecParggPrev, DecParggEff, DatParInizioAvv, DatParFineMov,
   strParReferente, StrParLuogolavoro, StrParAzIntContratto, StrParAzIntRap, DatParIntIniCont,
   DatParIntFineCont, NumParIntSogg, NumParIntDip, FlgParIntAssPro, FlgParLavDomic,
   FlgParSocio, FlgParLegge68, FlgParModTempo, FlgParModered, codannull,'SS'
     )
     ;

exception
WHEN OTHERS THEN
  raise;
end;


procedure Update_Azienda_Mov_Collegati( P_prgMov AM_MOVIMENTO.PRGMOVIMENTO%TYPE  ,P_prgAz AM_MOVIMENTO.PRGAZIENDA%TYPE,
 P_prgUnita AM_MOVIMENTO.PRGUNITA%TYPE )



 as

  prgmovi    AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
  prgmoviApp   AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
  prgmovprec  AM_MOVIMENTO.PRGMOVIMENTOPREC%TYPE;
  prgdoc   AM_DOCUMENTO.PRGDOCUMENTO%TYPE;
  numKloDoc   AM_DOCUMENTO.NUMKLODOCUMENTO%TYPE;
  numKloMovi  AM_MOVIMENTO.NUMKLOMOV%TYPE;
  contaSucc   INTEGER;
  contaDoc   INTEGER;



 docu dati_doc;

 begin


  prgmovprec := P_prgmov;
  contaSucc := 0;

     select count(prgmovimento) into contaSucc
  from am_movimento
  where prgmovimentoprec = prgmovprec
  AND codstatoatto = 'PR';


  if contaSucc = 1 then
    select prgmovimento
    into prgmovi
    from am_movimento
    where prgmovimentoprec = prgmovprec
    AND codstatoatto = 'PR';
  end if;

  --prgmovi è il progressivo del movimento successivo

  while prgmovi is not null
   loop


   --seleziono i dati del documento associato al movimento successivo

   select count(*) into contaDoc
   from am_documento ,
   am_documento_coll ,
         de_doc_ambito,
         de_doc_tipo
   where am_documento_coll.prgdocumento = am_documento.prgdocumento
     AND am_documento.codTipoDocumento = de_doc_tipo.CODTIPODOCUMENTO
   AND de_doc_tipo.CODAMBITODOC = de_doc_ambito.CODAMBITODOC
   and am_documento_coll.strChiaveTabella = prgmovi;


   if contaDoc = 1 then

    select am_documento.prgdocumento,
           am_documento.NUMKLODOCUMENTO into docu
    from am_documento ,
    am_documento_coll ,
          de_doc_ambito,
          de_doc_tipo
    where am_documento_coll.prgdocumento = am_documento.prgdocumento
      AND am_documento.codTipoDocumento = de_doc_tipo.CODTIPODOCUMENTO
    AND de_doc_tipo.CODAMBITODOC = de_doc_ambito.CODAMBITODOC
    and am_documento_coll.strChiaveTabella = prgmovi;

   numKloDoc := docu.doc_kLo;
   prgDoc  := docu.doc_prg;


   if prgdoc is not null then

     UPDATE AM_DOCUMENTO
     SET PRGAZIENDA = P_prgAz,
     PRGUNITA = P_prgUnita,
     NUMKLODOCUMENTO = numKloDoc + 1
     WHERE PRGDOCUMENTO = prgdoc;

   end if ;


  end if;

  select numklomov into numKloMovi
  from am_movimento
  where prgmovimento = prgmovi;

  UPDATE AM_MOVIMENTO
  SET PRGAZIENDA = P_prgAz,
  PRGUNITA = P_prgUnita,
  NUMKLOMOV = numKloMovi + 1
  WHERE PRGMOVIMENTO = prgmovi;

  prgmoviApp := prgmovi;
  prgmovi := null;
  prgmovprec:= prgmoviApp;

     select count(prgmovimento) into contaSucc
  from am_movimento
  where prgmovimentoprec = prgmovprec
  AND codstatoatto = 'PR';


  if contaSucc = 1 then
   select prgmovimento into prgmovi
   from am_movimento
   where prgmovimentoprec = prgmovprec
   AND codstatoatto = 'PR';
  end if;


   end loop;

 exception
 WHEN OTHERS THEN
  raise_application_error (-20990, 'Fallito aggiornamento dei movimenti collegati. Il codice di errore sql mappa un messaggio in messages_it_IT.properties');
 end;

FUNCTION RECUPERA_TIPOASS_AVV(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.CODTIPOCONTRATTO%TYPE
IS
 rowMov AM_MOVIMENTO%ROWTYPE;
 prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
BEGIN
 -- Continuo a recuperare il record del movimento precedente finche' non trovo quello con 'AVV' (o non ce l'ho).
 prgMovCiclo := prgMov;
 LOOP

  IF prgMovCiclo IS NULL THEN
     EXIT;
  END IF;

  -- Recupero il record relativo al prgMovimento in ingresso
  SELECT MOV.*
  INTO rowMov
  FROM AM_MOVIMENTO MOV
  WHERE MOV.PRGMOVIMENTO = prgMovCiclo;

  -- Se non trovato, esco dal ciclo
  EXIT WHEN SQL%NOTFOUND;

  -- Se ho trovato il movimento con 'AVV', rendo il record
  IF rowMov.CODTIPOMOV = 'AVV' or rowMov.PRGMOVIMENTOPREC is null THEN
   RETURN rowMov.CODTIPOCONTRATTO;
  END IF;

  -- Continuo a ciclare (passo al movimento precedente)
  prgMovCiclo := rowMov.PRGMOVIMENTOPREC;

 END LOOP;

 RETURN NULL;

END RECUPERA_TIPOASS_AVV;


FUNCTION RECUPERA_GRADO_AVV(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.CODGRADO%TYPE
IS
 rowMov AM_MOVIMENTO%ROWTYPE;
 prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
BEGIN
 -- Continuo a recuperare il record del movimento precedente finche' non trovo quello con 'AVV' (o non ce l'ho).
 prgMovCiclo := prgMov;
 LOOP

  IF prgMovCiclo IS NULL THEN
     EXIT;
  END IF;

  -- Recupero il record relativo al prgMovimento in ingresso
  SELECT MOV.*
  INTO rowMov
  FROM AM_MOVIMENTO MOV
  WHERE MOV.PRGMOVIMENTO = prgMovCiclo;

  -- Se non trovato, esco dal ciclo
  EXIT WHEN SQL%NOTFOUND;

  -- Se ho trovato il movimento con 'AVV', rendo il record
  IF rowMov.CODTIPOMOV = 'AVV' or rowMov.PRGMOVIMENTOPREC is null THEN
   RETURN rowMov.CODGRADO;
  END IF;

  -- Continuo a ciclare (passo al movimento precedente)
  prgMovCiclo := rowMov.PRGMOVIMENTOPREC;

 END LOOP;

 RETURN NULL;

END RECUPERA_GRADO_AVV;

PROCEDURE CANC_MOV_APP_ERR(result OUT Varchar2, codiceErr IN varchar2, dataDA IN Varchar2, dataA IN Varchar2, tipoMov IN Varchar2, cfAz IN Varchar2, cfLav IN Varchar2, codCom IN Varchar2, dataInsDA IN Varchar2, dataInsA IN Varchar2, utIns IN Varchar2) IS
   risultato XMLType;
   err varchar2(20);
   num number;
   lastDeletedPrg number(38);

   CURSOR RisMov IS
        SELECT ris.PRGMOVIMENTOAPP, BLOB_TO_CLOB(ris.BLBRISULTATO) AS cl,
		to_char(app.DATINIZIOMOV,'dd/MM/yyyy') as DATINIZIO,
		app.CODTIPOMOV, app.STRAZCODICEFISCALE, app.STRCODICEFISCALE, app.CODCOMUNICAZIONE
        FROM AM_RISULTATO_MOVIMENTO ris
		JOIN AM_MOVIMENTO_APPOGGIO app ON ris.PRGMOVIMENTOAPP = app.PRGMOVIMENTOAPP
		WHERE app.DATINIZIOMOV >= to_date(nvl(dataDA,'01/01/0001'),'dd/MM/yyyy')
		AND app.DATINIZIOMOV <= to_date(nvl(dataA,'31/12/9999'),'dd/MM/yyyy')
		AND app.DTMINS >= to_date(nvl(dataInsDA,'01/01/0001'),'dd/MM/yyyy')
		AND app.DTMINS <= to_date(nvl(dataInsA,'31/12/9999'),'dd/MM/yyyy')
		AND nvl(cfAZ,app.STRAZCODICEFISCALE) = app.STRAZCODICEFISCALE
		AND nvl(codCom,app.CODCOMUNICAZIONE) = app.CODCOMUNICAZIONE
		AND nvl(cfLav,app.STRCODICEFISCALE) = app.STRCODICEFISCALE
		AND nvl(tipoMov,app.CODTIPOMOV) = app.CODTIPOMOV
		AND nvl(utIns,app.CDNUTINS) = app.CDNUTINS
		order by ris.PRGMOVIMENTOAPP;
BEGIN
   num := 0;
   lastDeletedPrg := -1;

   --dbms_output.enable(1000000);

   FOR rec IN RisMov LOOP
   	   if(rec.PRGMOVIMENTOAPP <> lastDeletedPrg) Then
   	   		risultato := XMLType(rec.cl);

	   		if(risultato.existsnode('/LOG/RECORD/PROCESSOR/ERROR')=1) Then

   	           err := risultato.extract('//ERROR/@code').getStringVal();

	           --dbms_output.put_line('error code : '||err);

	       	   if(err = codiceErr) Then
			   	  --dbms_output.put('mov canc : ');
			   	  --dbms_output.put_line(rec.PRGMOVIMENTOAPP);

			   	  logga_record('AM_MOVIMENTO_APPOGGIO','PRGMOVIMENTOAPP',rec.PRGMOVIMENTOAPP,'D',365);

			   	  delete from am_movimento_appoggio app where app.PRGMOVIMENTOAPP = rec.PRGMOVIMENTOAPP;

			   	  lastDeletedPrg := rec.PRGMOVIMENTOAPP;

		   	   	  num := num + 1;
	       	   end if;
	   	   end if;
	   end if;
   END LOOP;

   if( num=0 ) Then
   	   result := 'Non sono stati trovati movimenti compatibili con i parametri indicati.';
   else
   	   result := 'Sono stati eliminati '||num||' movimenti dalla tabella di appoggio.';
   end if;

   COMMIT;

   EXCEPTION
     WHEN OTHERS THEN
       result := 'Si è verificato un errore nella stored.';
	   ROLLBACK;
	   RAISE;
END CANC_MOV_APP_ERR;

PROCEDURE LOGGA_RECORD(tab IN varchar2, chiave IN varchar2, valChiave IN number, operation IN varchar2, utLog IN number) IS
   strQuery varchar2(32767);
   strColonne varchar2(32767);
   strColonneVal varchar2(32767);

   CURSOR COLINS IS
   		SELECT C.COLUMN_NAME FROM COLS C WHERE C.TABLE_NAME = tab;

BEGIN
   strQuery := 'INSERT INTO LG_'||tab||' (';

   for rec in COLINS loop
       strColonne := strColonne || rec.COLUMN_NAME || ', ';
	   --dbms_output.put_line('col : ' ||strColonne);
	   --dbms_output.put_line(rec.COLUMN_NAME);
	   --dbms_output.put_line('n : '||conta);
   end loop;

   strColonneVal := strColonne || 'S_LG_'||tab||'.NEXTVAL, '''||operation||''','||utLog||',SYSDATE';
   strColonne := strColonne || ' PRGLOG, STRTIPOOP, CDNUTLOG, DTMMODLOG';

   strQuery := strQuery || strColonne ||') SELECT '|| strColonneVal || ' FROM '||tab||' WHERE '||chiave||' = '||valChiave;

   execute immediate strQuery;
   --dbms_output.put_line(strQuery);
END LOGGA_RECORD;



FUNCTION ULTIMACATENA(codicefiscale IN varchar2) RETURN varchar2 IS
    numMovAperti       integer;
    ret                varchar2(2000);
    checkScartare      boolean;
	prgMovimentoVar 	am_movimento.prgmovimento%TYPE;
	prgMovimentoCurrVar am_movimento.prgmovimento%TYPE;
	prgMovimentoPrecVar am_movimento.prgmovimentoprec%TYPE;
	prgMovimentoSuccVar am_movimento.prgmovimentosucc%TYPE;
	retCurr       	   	varchar2(2000);
	nCatene				integer;
	iScarto				integer;

	CURSOR curMovimenti IS
		select mov.prgmovimentoprec prgmovimentoprec,
			 mov.prgmovimento prgmovimento,
			 mov.prgmovimentosucc prgmovimentosucc,
			 case
				when mov.codtipomov <> 'CES'
				   then mov.datfinemoveffettiva
				else mov.datiniziomov
			  end as datafinemovimento
		from am_movimento mov
		   inner join an_lavoratore lav on (mov.cdnlavoratore =  lav.cdnlavoratore)
			left join an_lav_storia_inf lav_sto2 on (mov.cdnlavoratore =  lav_sto2.cdnlavoratore)
		where lav.strcodicefiscale = codicefiscale and mov.codstatoatto = 'PR'
			and (
				(mov.codtipomov <> 'CES' and trunc(nvl(mov.datfinemoveffettiva, sysdate)) >= trunc(sysdate)) or
				(mov.codtipomov = 'CES' and trunc(mov.datiniziomov) >= trunc(sysdate))
			)
			and lav_sto2.codmonotipocpi = 'C'
			and (trunc(nvl(lav_sto2.datfine, to_date('31/12/9999','dd/mm/yyyy'))) >=  trunc(sysdate)
			and trunc(lav_sto2.datinizio) <= trunc(sysdate))
			order by datafinemovimento desc, mov.dtmins desc;

	rec curMovimenti%ROWTYPE;

    type mov_scartare is record (prgmov AM_MOVIMENTO.PRGMOVIMENTO%TYPE);
    type table_mov_scartare is table of mov_scartare index by binary_integer;
    mov_scat table_mov_scartare;

  BEGIN
    ret                := null;
    checkScartare      := false;
    numMovAperti       := 0;
    iScarto 		   := 0;

	IF (NOT curMovimenti%ISOPEN) THEN
		OPEN curMovimenti;
	END IF;
	FETCH curMovimenti INTO rec;
	numMovAperti := curMovimenti%ROWCOUNT;
	CLOSE curMovimenti;

	if (numMovAperti = 0) then
		--devo restituire l'ultima catena di movimenti che ha data fine movimento maggiore
		begin
			ret := to_char(numMovAperti);

			select tab.prgmovimentoprec,
				 tab.prgmovimento,
				 tab.prgmovimentosucc
			into prgMovimentoPrecVar, prgMovimentoVar, prgMovimentoSuccVar
			from (
			select mov.prgmovimentoprec prgmovimentoprec,
					 mov.prgmovimento prgmovimento,
					 mov.prgmovimentosucc prgmovimentosucc,
					 case
						when mov.codtipomov <> 'CES'
						   then mov.datfinemoveffettiva
						else mov.datiniziomov
					 end as datafinemovimento
				from am_movimento mov
			   inner join an_lavoratore lav on (mov.cdnlavoratore =  lav.cdnlavoratore)
				left join an_lav_storia_inf lav_sto2 on (mov.cdnlavoratore =  lav_sto2.cdnlavoratore)
			   where lav.strcodicefiscale = codicefiscale
				 and mov.codstatoatto = 'PR'
				 and lav_sto2.codmonotipocpi = 'C'
				 and (trunc(nvl(lav_sto2.datfine, to_date('31/12/9999','dd/mm/yyyy'))) >=  trunc(sysdate)
					  and trunc(lav_sto2.datinizio) <= trunc(sysdate))
				order by datafinemovimento desc, mov.dtmins desc
				) tab
				where rownum = 1;

			retCurr := null;

			WHILE prgMovimentoSuccVar is not null LOOP

				select prgmovimento, prgmovimentosucc
				into prgMovimentoCurrVar, prgMovimentoSuccVar
				from am_movimento
				where prgmovimento = prgMovimentoSuccVar;

				if (retCurr is null) then
					retCurr := to_char(numMovAperti) || '-' || prgMovimentoCurrVar;
				else
					retCurr := to_char(numMovAperti) || '-' || prgMovimentoCurrVar || '|' || retCurr;
				end if;

			END LOOP;

			if (retCurr is null) then
				retCurr := to_char(numMovAperti) || '-' || prgMovimentoVar;
			else
				retCurr := retCurr || '|' || to_char(numMovAperti) || '-' || prgMovimentoVar;
			end if;

			WHILE prgMovimentoPrecVar is not null LOOP

				select prgmovimento, prgmovimentoprec
				into prgMovimentoCurrVar, prgMovimentoPrecVar
				from am_movimento
				where prgmovimento = prgMovimentoPrecVar;

				retCurr := retCurr || '|' || to_char(numMovAperti) || '-' || prgMovimentoCurrVar;

			END LOOP;

			ret := ret || '|' || retCurr;

		exception
			when NO_DATA_FOUND then
				ret := to_char(numMovAperti);
			when others then
				return null;
		end;

	else
		--devo restituire tutte le catene aperte a partire da quella con data fine movimento maggiore
		begin
			nCatene := 0;

			FOR rec in curMovimenti LOOP
				prgMovimentoPrecVar := rec.prgmovimentoprec;
				prgMovimentoVar := rec.prgmovimento;
				prgMovimentoSuccVar := rec.prgmovimentosucc;

				retCurr := null;
				checkScartare := false;

				if (iScarto > 0) then
					for a in mov_scat.first..mov_scat.last loop
						if (prgMovimentoVar = mov_scat(a).prgmov) then
							checkScartare := true;
						end if;
				   end loop;
				end if;

				if (not checkScartare) then

					WHILE prgMovimentoSuccVar is not null LOOP

						select prgmovimento, prgmovimentosucc
						into prgMovimentoCurrVar, prgMovimentoSuccVar
						from am_movimento
						where prgmovimento = prgMovimentoSuccVar;

						if (retCurr is null) then
							retCurr := to_char(nCatene) || '-' || prgMovimentoCurrVar;
						else
							retCurr := to_char(nCatene) || '-' || prgMovimentoCurrVar || '|' || retCurr;
						end if;

						mov_scat(iScarto).prgmov:= prgMovimentoCurrVar;
						iScarto := iScarto +1;

					END LOOP;

					mov_scat(iScarto).prgmov:= prgMovimentoVar;
					iScarto := iScarto +1;

					if (retCurr is null) then
						retCurr := to_char(nCatene) || '-' || prgMovimentoVar;
					else
						retCurr := retCurr || '|' || to_char(nCatene) || '-' || prgMovimentoVar;
					end if;

					WHILE prgMovimentoPrecVar is not null LOOP

						select prgmovimento, prgmovimentoprec
						into prgMovimentoCurrVar, prgMovimentoPrecVar
						from am_movimento
						where prgmovimento = prgMovimentoPrecVar;

						retCurr := retCurr || '|' || to_char(nCatene) || '-' || prgMovimentoCurrVar;

						mov_scat(iScarto).prgmov:= prgMovimentoCurrVar;
						iScarto := iScarto +1;

					END LOOP;

					if (ret is null) then
						ret := retCurr;
					else
						ret := ret || '|' || retCurr;
					end if;

					nCatene := nCatene + 1;

				end if;

			END LOOP;

			ret := to_char(nCatene) || '|' || ret;

		exception
			when others then
				return null;
		end;

	end if;

    return ret;

END ULTIMACATENA;


FUNCTION CALCULA_MOV_PREC(prgmovimentoq IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE) RETURN varchar2 IS
  ret    varchar2(20);
  prgmov am_movimento.prgmovimentoprec%type;
BEGIN
begin
  select nvl((select mov.prgmovimentoprec
               from am_movimento mov
              where mov.prgmovimento = prgmovimentoq),
             0) into prgmov
  from dual;

  if (prgmov is not null or prgmov <> 0) then
    ret := to_char(prgmov);
  else
    ret := '0';
  end if;
  return ret;
exception
  when others then
    dbms_output.put_line('Errore= ' || sqlcode || ' ' || sqlerrm);
    return '0';


end;

END CALCULA_MOV_PREC;

FUNCTION GetCodContrattoForRp (PprgMovimento IN am_movimento.PRGMOVIMENTO%TYPE) RETURN AM_MOVIMENTO.CODTIPOCONTRATTO%TYPE IS

	VarMovi am_movimento.prgmovimento%TYPE;
	VarSucc am_movimento.PRGMOVIMENTO%TYPE;
	VarTipo varchar(3);
	VarCodTipoContratto am_movimento.CODTIPOCONTRATTO%TYPE;
	VarContrattoPrec am_movimento.CODTIPOCONTRATTO%TYPE;
	VarContrattoRet am_movimento.CODTIPOCONTRATTO%TYPE;

BEGIN

	varMovi := PprgMovimento;
	select codtipomov, nvl(PRGMOVIMENTOSUCC,-1), CODTIPOCONTRATTO
	into VarTipo, VarSucc, VarCodTipoContratto
	from am_movimento
	where prgmovimento = varMovi;

	VarContrattoPrec := VarCodTipoContratto;

	WHILE (VarTipo <> 'CES' and VarSucc <> -1) loop
		VarContrattoPrec := VarCodTipoContratto;
		VarMovi := VarSucc;
		select codtipomov, nvl(prgmovimentosucc,-1), CODTIPOCONTRATTO
		into VarTipo, VarSucc, VarCodTipoContratto
		from am_movimento
		where prgmovimento = varMovi;
	END LOOP;

	IF VarTipo <> 'CES' THEN
		VarContrattoRet := VarCodTipoContratto;
	ELSE
		VarContrattoRet := VarContrattoPrec;
	END IF;

	RETURN VarContrattoRet;

END GetCodContrattoForRp;


FUNCTION MesiSospDecretoFornero2014 (cdnLav IN an_lavoratore.cdnlavoratore%type, dataStatoOccRif IN am_stato_occupaz.datinizio%type,
	prgStatoOcc IN am_stato_occupaz.prgstatooccupaz%type) return varchar2 is

	CURSOR cursorStatoOcc IS
          select
			case
				when trunc(occ.datinizio) < (select trunc(datFornero) from ts_generale)
				then (select datFornero from ts_generale)
				else occ.datinizio
			end as datinizio,
		  nvl(occ.datfine, (select trunc(dat150)-1 from ts_generale)) datfine
		  FROM am_stato_occupaz occ
		   WHERE occ.cdnlavoratore = cdnLav
		   AND occ.codstatooccupaz = 'B1'
		   AND trunc(nvl(occ.datfine, (select trunc(dat150)-1 from ts_generale))) >= (select trunc(datFornero) from ts_generale)
		   AND (dataStatoOccRif is null or trunc(occ.datinizio) <= trunc(dataStatoOccRif))
		   AND (trunc(occ.datinizio) < (select trunc(dat150) from ts_generale))
		   order by occ.datinizio asc;

	CURSOR cursorStatoOcc150 IS
          select occ.datinizio datinizio, nvl(occ.datfine, sysdate) datfine
		  FROM am_stato_occupaz occ
		   WHERE occ.cdnlavoratore = cdnLav
		   AND occ.codstatooccupaz = 'B1'
		   AND (trunc(occ.datinizio) >= (select trunc(dat150) from ts_generale))
		   AND (dataStatoOccRif is null or trunc(occ.datinizio) <= trunc(dataStatoOccRif))
		   order by occ.datinizio asc;

	rec_StatoOcc cursorStatoOcc%ROWTYPE;
	rec_StatoOcc150 cursorStatoOcc150%ROWTYPE;

	p_datdatainizio am_stato_occupaz.datinizio%type;
	p_datdatafine am_stato_occupaz.datfine%type;

	p_datdatafineCurr am_stato_occupaz.datfine%type;
	p_datdatainizioCurr am_stato_occupaz.datfine%type;

	p_datdatacalcolososp am_stato_occupaz.datcalcolomesisosp%type;

	mesiSosp number := 0;
	mesiSosp150 number := 0;
	annoDataInizio number;
	annoDataFine number;
	meseDataInizio number;
	meseDataFine number;
	annoDataSospensione number;
	meseDataSospensione number;
	annoDataCurr number;
	meseDataCurr number;
	giornoDataCurr number;
	annoPrec number := 0;
	mesePrec number := 0;
	meseDataInizioCurr number;
	giorniSospMeseCurr number := 0;
	giorniSospReali number := 0;
	giorniSospTotali number := 0;
	giorniSospTotali150 number := 0;
	giorniSospRestanti150 number := 0;
	calcolaSospFornero boolean := true;
	dataFornero ts_generale.datFornero%type;
	data150 ts_generale.dat150%type;
	mesi_anz_fornero number := 0;
	mesePrecIsSospeso boolean := false;
	calcolaSosp150 boolean := false;
	giornoDataInizio number;
	giornoDataFine number;
	differenzaMesi number := 0;
begin

	BEGIN

		select trunc(datFornero)
		into dataFornero
		from ts_generale;

		select trunc(dat150)
		into data150
		from ts_generale;

		if (prgStatoOcc is null) then
			SELECT am_stato_occupaz.datcalcolomesisosp,
			(case
				when trunc(am_stato_occupaz.datcalcoloanzianita) < dataFornero
				then
				   (to_number(
								(to_char(sysdate,'yyyy')
								 - to_char(dataFornero,'yyyy')) * 12
								 + to_char(sysdate,'mm')
								- to_char(dataFornero,'mm') + 1
							+ (case
								   when ((to_char(sysdate,'yyyy')
										  - to_char(dataFornero,'yyyy')) * 12
										  + to_char(sysdate,'mm')
										  - to_char(dataFornero,'mm') + 1) > 1
								   then
										   -(case when
												 (30 - to_char(dataFornero,'dd') + 1) < 16
												 then 1
												 when
												 (30 - to_char(dataFornero,'dd') + 1) >= 15
												 then 0
										   end)
										   -(case when
												  to_char(sysdate,'dd') < 16
												  then 1
												  when
												  to_char(sysdate,'dd') >= 15
												  then 0
											end)

								  when
									  ((to_char(sysdate,'yyyy')
										- to_char(dataFornero,'yyyy')) * 12
										+ to_char(sysdate,'mm')
										- to_char(dataFornero,'mm') + 1) = 1
								  then
									  -(case when
											 (to_char(sysdate,'dd')
											 - to_char(dataFornero,'dd') + 1) < 16
											 then 1
											 when
											 (to_char(sysdate,'dd')
											 - to_char(dataFornero,'dd') + 1) >= 15
											 then 0
										end)
								  end))
					)
				else
					(to_number(
								(to_char(sysdate,'yyyy')
								 - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
								 + to_char(sysdate,'mm')
								- to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1
							+ (case
								   when ((to_char(sysdate,'yyyy')
										  - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
										  + to_char(sysdate,'mm')
										  - to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) > 1
								   then
										   -(case when
												 trunc(am_stato_occupaz.datcalcoloanzianita) >= data150
													then 2 - (trunc( (
														(case
														  when to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd')) =
															   to_number(to_char(sysdate, 'dd'))
														  then 30
														  else to_number(to_char(sysdate, 'dd'))
														end) + (30 -
																(case
																  when to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd')) < 31
																  then to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd'))
																  else 30
																end) + 1
															  )) /30))
												 when
												 (30 - to_char(am_stato_occupaz.datcalcoloanzianita,'dd') + 1) < 16
												 then 1
												 when
												 (30 - to_char(am_stato_occupaz.datcalcoloanzianita,'dd') + 1) >= 15
												 then 0
										   end)
										   -(case when
												  trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and to_char(sysdate,'dd') < 16
												  then 1
												  when
												  trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and to_char(sysdate,'dd') >= 15
												  then 0
												  else 0
											end)

								  when
									  ((to_char(sysdate,'yyyy')
										- to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
										+ to_char(sysdate,'mm')
										- to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) = 1
								  then
									  -(case when
											trunc(am_stato_occupaz.datcalcoloanzianita) >= data150 and
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) =
											 to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd'))
											 then 0
											 when
											 trunc(am_stato_occupaz.datcalcoloanzianita) >= data150 and
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) <>
											 to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd'))
											 then 1
									         when trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) < 16
											 then 1
											 when trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) >= 15
											 then 0
										end)
								  end))
					)
			end)
			INTO p_datdatacalcolososp, mesi_anz_fornero
			FROM am_stato_occupaz
			INNER JOIN de_stato_occupaz ON (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
			INNER JOIN de_stato_occupaz_ragg ON (de_stato_occupaz.codstatooccupazragg = de_stato_occupaz_ragg.codstatooccupazragg)
			INNER JOIN an_lav_storia_inf inf ON (am_stato_occupaz.cdnlavoratore = inf.cdnlavoratore)
			WHERE am_stato_occupaz.datfine IS NULL
			AND am_stato_occupaz.cdnlavoratore = cdnLav
			AND de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I')
			AND inf.datfine IS NULL;

		else
			SELECT am_stato_occupaz.datcalcolomesisosp,
			(case
				when trunc(am_stato_occupaz.datcalcoloanzianita) < dataFornero
				then
				   (to_number(
								(to_char(sysdate,'yyyy')
								 - to_char(dataFornero,'yyyy')) * 12
								 + to_char(sysdate,'mm')
								- to_char(dataFornero,'mm') + 1
							+ (case
								   when ((to_char(sysdate,'yyyy')
										  - to_char(dataFornero,'yyyy')) * 12
										  + to_char(sysdate,'mm')
										  - to_char(dataFornero,'mm') + 1) > 1
								   then
										   -(case when
												 (30 - to_char(dataFornero,'dd') + 1) < 16
												 then 1
												 when
												 (30 - to_char(dataFornero,'dd') + 1) >= 15
												 then 0
										   end)
										   -(case when
												  to_char(sysdate,'dd') < 16
												  then 1
												  when
												  to_char(sysdate,'dd') >= 15
												  then 0
											end)

								  when
									  ((to_char(sysdate,'yyyy')
										- to_char(dataFornero,'yyyy')) * 12
										+ to_char(sysdate,'mm')
										- to_char(dataFornero,'mm') + 1) = 1
								  then
									  -(case when
											 (to_char(sysdate,'dd')
											 - to_char(dataFornero,'dd') + 1) < 16
											 then 1
											 when
											 (to_char(sysdate,'dd')
											 - to_char(dataFornero,'dd') + 1) >= 15
											 then 0
										end)
								  end))
					)
				else
					(to_number(
								(to_char(sysdate,'yyyy')
								 - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
								 + to_char(sysdate,'mm')
								- to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1
							+ (case
								   when ((to_char(sysdate,'yyyy')
										  - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
										  + to_char(sysdate,'mm')
										  - to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) > 1
								   then
											-(case when
												 trunc(am_stato_occupaz.datcalcoloanzianita) >= data150
													then 2 - (trunc( (
														(case
														  when to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd')) =
															   to_number(to_char(sysdate, 'dd'))
														  then 30
														  else to_number(to_char(sysdate, 'dd'))
														end) + (30 -
																(case
																  when to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd')) < 31
																  then to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd'))
																  else 30
																end) + 1
															  )) /30))
												 when
												 (30 - to_char(am_stato_occupaz.datcalcoloanzianita,'dd') + 1) < 16
												 then 1
												 when
												 (30 - to_char(am_stato_occupaz.datcalcoloanzianita,'dd') + 1) >= 15
												 then 0
										   end)
										   -(case when
												  trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and to_char(sysdate,'dd') < 16
												  then 1
												  when
												  trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and to_char(sysdate,'dd') >= 15
												  then 0
												  else 0
											end)

								  when
									  ((to_char(sysdate,'yyyy')
										- to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
										+ to_char(sysdate,'mm')
										- to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) = 1
								  then
								      -(case when
											trunc(am_stato_occupaz.datcalcoloanzianita) >= data150 and
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) =
											 to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd'))
											 then 0
											 when
											 trunc(am_stato_occupaz.datcalcoloanzianita) >= data150 and
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) <>
											 to_number(to_char(LAST_DAY(to_date('01/' || to_char(sysdate, 'mm') || '/' || to_char(sysdate, 'yyyy'), 'dd/mm/yyyy')), 'dd'))
											 then 1
									         when trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) < 16
											 then 1
											 when trunc(am_stato_occupaz.datcalcoloanzianita) < data150 and
											 (to_number(to_char(sysdate,'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) >= 15
											 then 0
										end)
								  end))
					)
			end)
			INTO p_datdatacalcolososp, mesi_anz_fornero
			FROM am_stato_occupaz
			INNER JOIN de_stato_occupaz ON (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
			INNER JOIN de_stato_occupaz_ragg ON (de_stato_occupaz.codstatooccupazragg = de_stato_occupaz_ragg.codstatooccupazragg)
			WHERE am_stato_occupaz.prgstatooccupaz = prgStatoOcc
			AND de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I');

		end if;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN calcolaSospFornero := false;
		WHEN OTHERS THEN calcolaSospFornero := false;
	END;

	if (calcolaSospFornero) then

		annoDataSospensione := to_number(to_char(p_datdatacalcolososp, 'yyyy'));
		meseDataSospensione := to_number(to_char(p_datdatacalcolososp, 'mm'));

		annoDataCurr := to_number(to_char(sysdate, 'yyyy'));
		meseDataCurr := to_number(to_char(sysdate, 'mm'));
		giornoDataCurr := to_number(to_char(sysdate, 'dd'));

		for rec_StatoOcc in cursorStatoOcc loop
			p_datdatainizio := rec_StatoOcc.datinizio;
			p_datdatafine := rec_StatoOcc.datfine;

			if ( (trunc(p_datdatainizio) >= trunc(p_datdatacalcolososp)) or
			     (trunc(p_datdatacalcolososp) >= trunc(p_datdatainizio) and trunc(p_datdatacalcolososp) <= trunc(p_datdatafine))
				) then

				if (trunc(p_datdatainizio) <= trunc(p_datdatacalcolososp)) then
					p_datdatainizio := p_datdatacalcolososp;
				end if;

				if (trunc(p_datdatafine) >= trunc(sysdate)) then
					p_datdatafine := sysdate;
				end if;

				giorniSospTotali := giorniSospTotali + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);

				annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
				meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));

				annoDataFine := to_number(to_char(p_datdatafine, 'yyyy'));
				meseDataFine := to_number(to_char(p_datdatafine, 'mm'));

				if (annoDataFine = annoDataInizio and meseDataFine = meseDataInizio) then
					if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then
						if (annoDataSospensione = annoDataInizio and meseDataSospensione = meseDataInizio) then
							giorniSospReali := trunc(p_datdatafine) - trunc(p_datdatainizio) + 1;
							if (to_number(to_char(p_datdatacalcolososp, 'dd')) < 16) then
								giorniSospMeseCurr := giorniSospMeseCurr + (to_number(to_char(p_datdatacalcolososp, 'dd')) - 1) + giorniSospReali;
							end if;
						else
							giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);
						end if;
					else
						if ((30 - giorniSospMeseCurr) < 16) then
							mesiSosp := mesiSosp + 1;
						end if;
						giorniSospMeseCurr := trunc(p_datdatafine) - trunc(p_datdatainizio) + 1;
					end if;
					annoPrec := annoDataFine;
					mesePrec := meseDataFine;

				else

					if (annoDataFine = annoDataInizio and meseDataFine > meseDataInizio) then
						p_datdatafineCurr := LAST_DAY(p_datdatainizio);
						if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then
							if (annoDataSospensione = annoDataInizio and meseDataSospensione = meseDataInizio) then
								giorniSospReali := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
								if (to_number(to_char(p_datdatacalcolososp, 'dd')) < 16) then
									giorniSospMeseCurr := giorniSospMeseCurr + (to_number(to_char(p_datdatacalcolososp, 'dd')) - 1) + giorniSospReali;
								end if;
							else
								giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1);
							end if;

							if ((30 - giorniSospMeseCurr) < 16) then
								mesiSosp := mesiSosp + 1;
							end if;
						else
							--giorni sospensione calcolati per il mese precedente
							if ((30 - giorniSospMeseCurr) < 16) then
								mesiSosp := mesiSosp + 1;
							end if;
							--giorni sospensione calcolati per il mese corrente
							giorniSospMeseCurr := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
							if ((30 - giorniSospMeseCurr) < 16) then
								mesiSosp := mesiSosp + 1;
							end if;
						end if;

						mesiSosp := mesiSosp + (meseDataFine - meseDataInizio - 1);

						p_datdatainizioCurr := to_date('01/' || to_char(meseDataFine) || '/' || to_char(annoDataFine), 'dd/mm/yyyy');

						giorniSospMeseCurr := trunc(p_datdatafine) - trunc(p_datdatainizioCurr) + 1;

						annoPrec := annoDataFine;
						mesePrec := meseDataFine;

					else
						if (annoDataFine > annoDataInizio) then
							p_datdatafineCurr := LAST_DAY(p_datdatainizio);
							if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then
								if (annoDataSospensione = annoDataInizio and meseDataSospensione = meseDataInizio) then
									giorniSospReali := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
									if (to_number(to_char(p_datdatacalcolososp, 'dd')) < 16) then
										giorniSospMeseCurr := giorniSospMeseCurr + (to_number(to_char(p_datdatacalcolososp, 'dd')) - 1) + giorniSospReali;
									end if;
								else
									giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1);
								end if;

								if ((30 - giorniSospMeseCurr) < 16) then
									mesiSosp := mesiSosp + 1;
								end if;
							else
								--giorni sospensione calcolati per il mese precedente
								if ((30 - giorniSospMeseCurr) < 16) then
									mesiSosp := mesiSosp + 1;
								end if;
								--giorni sospensione calcolati per il mese corrente
								giorniSospMeseCurr := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
								if ((30 - giorniSospMeseCurr) < 16) then
									mesiSosp := mesiSosp + 1;
								end if;
							end if;

							mesiSosp := mesiSosp + (12 - meseDataInizio);

							mesiSosp := mesiSosp + ((annoDataFine - annoDataInizio - 1) * 12);

							mesiSosp := mesiSosp + meseDataFine - 1;

							p_datdatainizioCurr := to_date('01/' || to_char(meseDataFine) || '/' || to_char(annoDataFine), 'dd/mm/yyyy');

							giorniSospMeseCurr := trunc(p_datdatafine) - trunc(p_datdatainizioCurr) + 1;

							annoPrec := annoDataFine;
							mesePrec := meseDataFine;

						end if;

					end if;

				end if;

			end if;

		end loop;

		annoDataCurr := to_number(to_char(sysdate, 'yyyy'));
		meseDataCurr := to_number(to_char(sysdate, 'mm'));
		giornoDataCurr := to_number(to_char(sysdate, 'dd'));

		if (not(annoPrec = annoDataCurr and mesePrec = meseDataCurr) or (giornoDataCurr >= 16)) then
			if (giorniSospMeseCurr > 0) then
				if ((30 - giorniSospMeseCurr) < 16) then
					mesiSosp := mesiSosp + 1;
					mesePrecIsSospeso := true;
				end if;
			end if;
		end if;

		for rec_StatoOcc150 in cursorStatoOcc150 loop
			p_datdatainizio := rec_StatoOcc150.datinizio;
			p_datdatafine := rec_StatoOcc150.datfine;
			calcolaSosp150 := true;

			if ( (trunc(p_datdatainizio) >= trunc(p_datdatacalcolososp)) or
			     (trunc(p_datdatacalcolososp) >= trunc(p_datdatainizio) and trunc(p_datdatacalcolososp) <= trunc(p_datdatafine))
				) then

				if (trunc(p_datdatainizio) <= trunc(p_datdatacalcolososp)) then
					p_datdatainizio := p_datdatacalcolososp;
				end if;

				if (trunc(p_datdatafine) >= trunc(sysdate)) then
					p_datdatafine := sysdate;
				end if;

				annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
				meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));
				annoDataFine := to_number(to_char(p_datdatafine, 'yyyy'));
				meseDataFine := to_number(to_char(p_datdatafine, 'mm'));

				if (mesePrecIsSospeso) then
					-- il mese e'' stato considerato come sospeso secondo le regole prima del decreto 150 e quindi non vanno considerati i giorni
					-- di sospensione nel calcolo post decreto 150
					if (annoPrec = annoDataInizio and mesePrec = meseDataInizio) then
						if (annoPrec = annoDataFine and mesePrec = meseDataFine) then
							calcolaSosp150 := false;
						else
							if (meseDataInizio = 12) then
								p_datdatainizio := to_date('01/01/' || to_char(annoDataInizio + 1), 'dd/mm/yyyy');
								meseDataInizio := 1;
								annoDataInizio := annoDataInizio + 1;
							else
								p_datdatainizio := to_date('01/' || to_char(meseDataInizio + 1) || '/' || to_char(annoDataInizio), 'dd/mm/yyyy');
								meseDataInizio := meseDataInizio + 1;
							end if;
						end if;
					end if;
				end if;

				if (calcolaSosp150) then
					differenzaMesi := (((to_number(to_char(p_datdatafine, 'yyyy')) - to_number(to_char(p_datdatainizio, 'yyyy'))) * 12) +
						to_number(to_char(p_datdatafine, 'mm')) - to_number(to_char(p_datdatainizio, 'mm')) + 1) - 2;
					if (differenzaMesi > 0) then
						giornoDataInizio := to_number(to_char(p_datdatainizio, 'dd'));
						if (giornoDataInizio = to_number(to_char(LAST_DAY(to_date('01/' || to_char(p_datdatainizio, 'mm') || '/' || to_char(p_datdatainizio, 'yyyy'), 'dd/mm/yyyy')), 'dd'))) then
							giorniSospTotali150 := giorniSospTotali150 + 1;
						else
							giorniSospTotali150 := giorniSospTotali150 + (30 - giornoDataInizio + 1);
						end if;
						giorniSospTotali150 := giorniSospTotali150 + (30 * (differenzaMesi));
						giornoDataFine := to_number(to_char(p_datdatafine, 'dd'));
						if (giornoDataFine > 30) then
							giornoDataFine := 30;
						else
							if (meseDataFine = 2 and giornoDataFine = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))) then
								giornoDataFine := 30;
							end if;
						end if;
						giorniSospTotali150 := giorniSospTotali150 + giornoDataFine;
					else
						if (differenzaMesi < 0) then
							-- sospensione nello stesso mese
							if ( (meseDataInizio = 2) and
								 ((trunc(p_datdatafine) - trunc(p_datdatainizio) + 1) = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))
							   ) ) then
							   giorniSospTotali150 := giorniSospTotali150 + 30;
							else
								if ((trunc(p_datdatafine) - trunc(p_datdatainizio) + 1) > 30) then
									giorniSospTotali150 := giorniSospTotali150 + 30;
								else
									giorniSospTotali150 := giorniSospTotali150 + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);
								end if;
							end if;
						else
							-- sospensione a cavallo di due mesi
							giornoDataInizio := to_number(to_char(p_datdatainizio, 'dd'));
							if (giornoDataInizio = to_number(to_char(LAST_DAY(to_date('01/' || to_char(p_datdatainizio, 'mm') || '/' || to_char(p_datdatainizio, 'yyyy'), 'dd/mm/yyyy')), 'dd'))) then
								giorniSospTotali150 := giorniSospTotali150 + 1;
							else
								giorniSospTotali150 := giorniSospTotali150 + (30 - giornoDataInizio + 1);
							end if;
							giornoDataFine := to_number(to_char(p_datdatafine, 'dd'));
							if (giornoDataFine > 30) then
								giornoDataFine := 30;
							else
								if (meseDataFine = 2 and giornoDataFine = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))) then
									giornoDataFine := 30;
								end if;
							end if;
							giorniSospTotali150 := giorniSospTotali150 + giornoDataFine;
						end if;
					end if;
				end if;
			end if;

		end loop;

		if (giorniSospTotali150 > 0) then
			mesiSosp150 := trunc(giorniSospTotali150/30);
			giorniSospRestanti150 := MOD(giorniSospTotali150,30);

			mesiSosp := mesiSosp + mesiSosp150;
			giorniSospTotali := giorniSospTotali + giorniSospTotali150;
		end if;

	END IF;

	return to_char(mesiSosp) || '-' || to_char(giorniSospTotali) || '-' || to_char(mesi_anz_fornero) || '-' || to_char(giorniSospRestanti150);

end MesiSospDecretoFornero2014;


FUNCTION MesiSospFornero2014DallaData (cdnLav IN an_lavoratore.cdnlavoratore%type, dataCalcolo IN varchar2,
	dataRif IN varchar2) return varchar2 is

	CURSOR cursorStatoOcc IS
          select
			case
				when trunc(occ.datinizio) < (select trunc(datFornero) from ts_generale)
				then (select datFornero from ts_generale)
				else occ.datinizio
			end as datinizio,
		  nvl(occ.datfine, to_date(dataRif, 'dd/mm/yyyy')) datfine
		  FROM am_stato_occupaz occ
		   WHERE occ.cdnlavoratore = cdnLav
		   AND occ.codstatooccupaz = 'B1'
		   AND ( (trunc(occ.datinizio) >= to_date(dataCalcolo, 'dd/mm/yyyy')) or
                 (to_date(dataCalcolo, 'dd/mm/yyyy') >= trunc(occ.datinizio) and
                  to_date(dataCalcolo, 'dd/mm/yyyy') <= nvl(trunc(occ.datfine), to_date(dataRif, 'dd/mm/yyyy'))) )
		   AND trunc(nvl(occ.datfine, sysdate)) >= (select trunc(datFornero) from ts_generale)
		   AND (trunc(occ.datinizio) < (select trunc(dat150) from ts_generale))
		   order by occ.datinizio asc;


	CURSOR cursorStatoOcc150 IS
          select occ.datinizio datinizio,
		  nvl(occ.datfine, to_date(dataRif, 'dd/mm/yyyy')) datfine
		  FROM am_stato_occupaz occ
		   WHERE occ.cdnlavoratore = cdnLav
		   AND occ.codstatooccupaz = 'B1'
		   AND ( (trunc(occ.datinizio) >= to_date(dataCalcolo, 'dd/mm/yyyy')) or
                 (to_date(dataCalcolo, 'dd/mm/yyyy') >= trunc(occ.datinizio) and
                  to_date(dataCalcolo, 'dd/mm/yyyy') <= nvl(trunc(occ.datfine), to_date(dataRif, 'dd/mm/yyyy'))) )
		  AND (trunc(occ.datinizio) >= (select trunc(dat150) from ts_generale))
		  order by occ.datinizio asc;

	rec_StatoOcc cursorStatoOcc%ROWTYPE;
	p_datdatainizio am_stato_occupaz.datinizio%type;
	p_datdatafine am_stato_occupaz.datfine%type;

	p_datdatafineCurr am_stato_occupaz.datfine%type;
	p_datdatainizioCurr am_stato_occupaz.datfine%type;

	p_datdatacalcolososp am_stato_occupaz.datcalcolomesisosp%type;

	mesiSosp number := 0;
	mesiSosp150 number := 0;
	annoDataInizio number;
	annoDataFine number;
	meseDataInizio number;
	meseDataFine number;
	annoDataSospensione number;
	meseDataSospensione number;
	annoPrec number := 0;
	mesePrec number := 0;
	meseDataInizioCurr number;
	giorniSospMeseCurr number := 0;
	giorniSospReali number := 0;
	giorniSospTotali number := 0;
	calcolaSospFornero boolean := true;
	annoDataCurr number;
	meseDataCurr number;
	giornoDataCurr number;
	mesePrecIsSospeso boolean := false;
	calcolaSosp150 boolean := false;
	giornoDataInizio number;
	giornoDataFine number;
	giorniSospTotali150 number := 0;
	giorniSospRestanti150 number := 0;
	differenzaMesi number := 0;
begin

	BEGIN
		SELECT am_stato_occupaz.datcalcolomesisosp
		INTO p_datdatacalcolososp
		FROM am_stato_occupaz
		INNER JOIN de_stato_occupaz ON (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
		INNER JOIN de_stato_occupaz_ragg ON (de_stato_occupaz.codstatooccupazragg = de_stato_occupaz_ragg.codstatooccupazragg)
		WHERE am_stato_occupaz.datfine IS NULL
		AND am_stato_occupaz.cdnlavoratore = cdnLav
		AND de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I');

	EXCEPTION
		WHEN NO_DATA_FOUND THEN calcolaSospFornero := false;
		WHEN OTHERS THEN calcolaSospFornero := false;
	END;

	if (calcolaSospFornero) then

		annoDataSospensione := to_number(to_char(p_datdatacalcolososp, 'yyyy'));
		meseDataSospensione := to_number(to_char(p_datdatacalcolososp, 'mm'));

		for rec_StatoOcc in cursorStatoOcc loop
			p_datdatainizio := rec_StatoOcc.datinizio;
			p_datdatafine := rec_StatoOcc.datfine;

			if (trunc(p_datdatafine) <= trunc(to_date(dataCalcolo, 'dd/mm/yyyy'))) then
				p_datdatafine := to_date(dataCalcolo, 'dd/mm/yyyy');
			else
				if (trunc(p_datdatafine) >= trunc(to_date(dataRif, 'dd/mm/yyyy'))) then
					p_datdatafine := to_date(dataRif, 'dd/mm/yyyy');
				end if;
			end if;

			if (trunc(p_datdatafine) >= trunc(sysdate)) then
				p_datdatafine := sysdate;
			end if;

			if (trunc(p_datdatainizio) <= trunc(to_date(dataCalcolo, 'dd/mm/yyyy'))) then
				p_datdatainizio := to_date(dataCalcolo, 'dd/mm/yyyy');
			end if;

			giorniSospTotali := giorniSospTotali + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);

			annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
			meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));

			annoDataFine := to_number(to_char(p_datdatafine, 'yyyy'));
			meseDataFine := to_number(to_char(p_datdatafine, 'mm'));

			if (annoDataFine = annoDataInizio and meseDataFine = meseDataInizio) then
				if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then
					if (annoDataSospensione = annoDataInizio and meseDataSospensione = meseDataInizio) then
						giorniSospReali := trunc(p_datdatafine) - trunc(p_datdatainizio) + 1;
						if (to_number(to_char(p_datdatacalcolososp, 'dd')) < 16) then
							giorniSospMeseCurr := giorniSospMeseCurr + (to_number(to_char(p_datdatacalcolososp, 'dd')) - 1) + giorniSospReali;
						end if;
					else
						giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);
					end if;
				else
					if ((30 - giorniSospMeseCurr) < 16) then
						mesiSosp := mesiSosp + 1;
					end if;
					giorniSospMeseCurr := trunc(p_datdatafine) - trunc(p_datdatainizio) + 1;
				end if;
				annoPrec := annoDataFine;
				mesePrec := meseDataFine;

			else

				if (annoDataFine = annoDataInizio and meseDataFine > meseDataInizio) then
					p_datdatafineCurr := LAST_DAY(p_datdatainizio);
					if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then
						if (annoDataSospensione = annoDataInizio and meseDataSospensione = meseDataInizio) then
							giorniSospReali := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
							if (to_number(to_char(p_datdatacalcolososp, 'dd')) < 16) then
								giorniSospMeseCurr := giorniSospMeseCurr + (to_number(to_char(p_datdatacalcolososp, 'dd')) - 1) + giorniSospReali;
							end if;
						else
							giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1);
						end if;

						if ((30 - giorniSospMeseCurr) < 16) then
							mesiSosp := mesiSosp + 1;
						end if;
					else
						--giorni sospensione calcolati per il mese precedente
						if ((30 - giorniSospMeseCurr) < 16) then
							mesiSosp := mesiSosp + 1;
						end if;
						--giorni sospensione calcolati per il mese corrente
						giorniSospMeseCurr := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
						if ((30 - giorniSospMeseCurr) < 16) then
							mesiSosp := mesiSosp + 1;
						end if;
					end if;

					mesiSosp := mesiSosp + (meseDataFine - meseDataInizio - 1);

					p_datdatainizioCurr := to_date('01/' || to_char(meseDataFine) || '/' || to_char(annoDataFine), 'dd/mm/yyyy');

					giorniSospMeseCurr := trunc(p_datdatafine) - p_datdatainizioCurr + 1;

					annoPrec := annoDataFine;
					mesePrec := meseDataFine;

				else
					if (annoDataFine > annoDataInizio) then
						p_datdatafineCurr := LAST_DAY(p_datdatainizio);
						if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then
							if (annoDataSospensione = annoDataInizio and meseDataSospensione = meseDataInizio) then
								giorniSospReali := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
								if (to_number(to_char(p_datdatacalcolososp, 'dd')) < 16) then
									giorniSospMeseCurr := giorniSospMeseCurr + (to_number(to_char(p_datdatacalcolososp, 'dd')) - 1) + giorniSospReali;
								end if;
							else
								giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1);
							end if;

							if ((30 - giorniSospMeseCurr) < 16) then
								mesiSosp := mesiSosp + 1;
							end if;
						else
							--giorni sospensione calcolati per il mese precedente
							if ((30 - giorniSospMeseCurr) < 16) then
								mesiSosp := mesiSosp + 1;
							end if;
							--giorni sospensione calcolati per il mese corrente
							giorniSospMeseCurr := p_datdatafineCurr - p_datdatainizio + 1;
							if ((30 - giorniSospMeseCurr) < 16) then
								mesiSosp := mesiSosp + 1;
							end if;
						end if;

						mesiSosp := mesiSosp + (12 - meseDataInizio);

						mesiSosp := mesiSosp + ((annoDataFine - annoDataInizio - 1) * 12);

						mesiSosp := mesiSosp + meseDataFine - 1;

						p_datdatainizioCurr := to_date('01/' || to_char(meseDataFine) || '/' || to_char(annoDataFine), 'dd/mm/yyyy');

						giorniSospMeseCurr := p_datdatafine - p_datdatainizioCurr + 1;

						annoPrec := annoDataFine;
						mesePrec := meseDataFine;

					end if;

				end if;

			end if;

		end loop;

		annoDataCurr := to_number(to_char(sysdate, 'yyyy'));
		meseDataCurr := to_number(to_char(sysdate, 'mm'));
		giornoDataCurr := to_number(to_char(sysdate, 'dd'));

		if (not(annoPrec = annoDataCurr and mesePrec = meseDataCurr) or (giornoDataCurr >= 16)) then
			if (giorniSospMeseCurr > 0) then
				if ((30 - giorniSospMeseCurr) < 16) then
					mesiSosp := mesiSosp + 1;
					mesePrecIsSospeso := true;
				end if;
			end if;
		end if;

		for rec_StatoOcc150 in cursorStatoOcc150 loop
			p_datdatainizio := rec_StatoOcc150.datinizio;
			p_datdatafine := rec_StatoOcc150.datfine;
			calcolaSosp150 := true;

			if (trunc(p_datdatafine) <= trunc(to_date(dataCalcolo, 'dd/mm/yyyy'))) then
				p_datdatafine := to_date(dataCalcolo, 'dd/mm/yyyy');
			else
				if (trunc(p_datdatafine) >= trunc(to_date(dataRif, 'dd/mm/yyyy'))) then
					p_datdatafine := to_date(dataRif, 'dd/mm/yyyy');
				end if;
			end if;

			if (trunc(p_datdatafine) >= trunc(sysdate)) then
				p_datdatafine := sysdate;
			end if;


			if (trunc(p_datdatainizio) <= trunc(to_date(dataCalcolo, 'dd/mm/yyyy'))) then
				p_datdatainizio := to_date(dataCalcolo, 'dd/mm/yyyy');
			end if;

			annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
			meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));
			annoDataFine := to_number(to_char(p_datdatafine, 'yyyy'));
			meseDataFine := to_number(to_char(p_datdatafine, 'mm'));

			if (mesePrecIsSospeso) then
				-- il mese e'' stato considerato come sospeso secondo le regole prima del decreto 150 e quindi non vanno considerati i giorni
				-- di sospensione nel calcolo post decreto 150
				if (annoPrec = annoDataInizio and mesePrec = meseDataInizio) then
					if (annoPrec = annoDataFine and mesePrec = meseDataFine) then
						calcolaSosp150 := false;
					else
						if (meseDataInizio = 12) then
							p_datdatainizio := to_date('01/01/' || to_char(annoDataInizio + 1), 'dd/mm/yyyy');
							meseDataInizio := 1;
							annoDataInizio := annoDataInizio + 1;
						else
							p_datdatainizio := to_date('01/' || to_char(meseDataInizio + 1) || '/' || to_char(annoDataInizio), 'dd/mm/yyyy');
							meseDataInizio := meseDataInizio + 1;
						end if;
					end if;
				end if;
			end if;

			if (calcolaSosp150) then
				differenzaMesi := (((to_number(to_char(p_datdatafine, 'yyyy')) - to_number(to_char(p_datdatainizio, 'yyyy'))) * 12) +
					to_number(to_char(p_datdatafine, 'mm')) - to_number(to_char(p_datdatainizio, 'mm')) + 1) - 2;
				if (differenzaMesi > 0) then
					giornoDataInizio := to_number(to_char(p_datdatainizio, 'dd'));
					if (giornoDataInizio = to_number(to_char(LAST_DAY(to_date('01/' || to_char(p_datdatainizio, 'mm') || '/' || to_char(p_datdatainizio, 'yyyy'), 'dd/mm/yyyy')), 'dd'))) then
						giorniSospTotali150 := giorniSospTotali150 + 1;
					else
						giorniSospTotali150 := giorniSospTotali150 + (30 - giornoDataInizio + 1);
					end if;
					giorniSospTotali150 := giorniSospTotali150 + (30 * (differenzaMesi));
					giornoDataFine := to_number(to_char(p_datdatafine, 'dd'));
					if (giornoDataFine > 30) then
						giornoDataFine := 30;
					else
						if (meseDataFine = 2 and giornoDataFine = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))) then
							giornoDataFine := 30;
						end if;
					end if;
					giorniSospTotali150 := giorniSospTotali150 + giornoDataFine;
				else
					if (differenzaMesi < 0) then
						-- sospensione nello stesso mese
						if ( (meseDataInizio = 2) and
							 ((trunc(p_datdatafine) - trunc(p_datdatainizio) + 1) = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))
						   ) ) then
						   giorniSospTotali150 := giorniSospTotali150 + 30;
						else
							if ((trunc(p_datdatafine) - trunc(p_datdatainizio) + 1) > 30) then
								giorniSospTotali150 := giorniSospTotali150 + 30;
							else
								giorniSospTotali150 := giorniSospTotali150 + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);
							end if;
						end if;
					else
						-- sospensione a cavallo di due mesi
						giornoDataInizio := to_number(to_char(p_datdatainizio, 'dd'));
						if (giornoDataInizio = to_number(to_char(LAST_DAY(to_date('01/' || to_char(p_datdatainizio, 'mm') || '/' || to_char(p_datdatainizio, 'yyyy'), 'dd/mm/yyyy')), 'dd'))) then
							giorniSospTotali150 := giorniSospTotali150 + 1;
						else
							giorniSospTotali150 := giorniSospTotali150 + (30 - giornoDataInizio + 1);
						end if;
						giornoDataFine := to_number(to_char(p_datdatafine, 'dd'));
						if (giornoDataFine > 30) then
							giornoDataFine := 30;
						else
							if (meseDataFine = 2 and giornoDataFine = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))) then
								giornoDataFine := 30;
							end if;
						end if;
						giorniSospTotali150 := giorniSospTotali150 + giornoDataFine;
					end if;
				end if;
			end if;

		end loop;

		if (giorniSospTotali150 > 0) then
			mesiSosp150 := trunc(giorniSospTotali150/30);
			giorniSospRestanti150 := MOD(giorniSospTotali150,30);

			mesiSosp := mesiSosp + mesiSosp150;
			giorniSospTotali := giorniSospTotali + giorniSospTotali150;
		end if;

	END IF;

	return to_char(mesiSosp) || '-' || to_char(giorniSospTotali) || '-' || to_char(giorniSospRestanti150);

end MesiSospFornero2014DallaData;


FUNCTION MesiSospFornero2014AllaData (cdnLav IN an_lavoratore.cdnlavoratore%type,
									  dataCalcolo IN ts_generale.datFornero%type,
									  dataCalcoloMesiSosp IN ts_generale.datFornero%type) return varchar2 is

	CURSOR cursorStatoOcc IS
          select
			case
				when trunc(occ.datinizio) < (select trunc(datFornero) from ts_generale)
				then (select datFornero from ts_generale)
				else occ.datinizio
			end as datinizio,
		  nvl(occ.datfine, dataCalcolo) datfine
		  FROM am_stato_occupaz occ
		   WHERE occ.cdnlavoratore = cdnLav
		   AND occ.codstatooccupaz = 'B1'
		   AND (occ.datinizio >= dataCalcoloMesiSosp or
		   (dataCalcoloMesiSosp >= occ.datinizio and
			dataCalcoloMesiSosp <= nvl(occ.datfine, dataCalcolo)))
		   AND (trunc(occ.datinizio) < (select trunc(dat150) from ts_generale))
		   AND trunc(nvl(occ.datfine, dataCalcolo)) >= (select trunc(datFornero) from ts_generale)
		   order by occ.datinizio asc;

	CURSOR cursorStatoOcc150 IS
          select occ.datinizio datinizio,
		  nvl(occ.datfine, dataCalcolo) datfine
		  FROM am_stato_occupaz occ
		   WHERE occ.cdnlavoratore = cdnLav
		   AND occ.codstatooccupaz = 'B1'
		   AND (occ.datinizio >= dataCalcoloMesiSosp or
		   (dataCalcoloMesiSosp >= occ.datinizio and
			dataCalcoloMesiSosp <= nvl(occ.datfine, dataCalcolo)))
		   AND trunc(occ.datinizio) >= (select trunc(dat150) from ts_generale)
		   AND trunc(nvl(occ.datfine, dataCalcolo)) >= (select trunc(dat150) from ts_generale)
		   order by occ.datinizio asc;

	rec_StatoOcc cursorStatoOcc%ROWTYPE;
	rec_StatoOcc150 cursorStatoOcc150%ROWTYPE;
	p_datdatainizio am_stato_occupaz.datinizio%type;
	p_datdatafine am_stato_occupaz.datfine%type;

	p_datdatafineCurr am_stato_occupaz.datfine%type;
	p_datdatainizioCurr am_stato_occupaz.datfine%type;

	p_datdatacalcolososp am_stato_occupaz.datcalcolomesisosp%type;

	mesiSosp number := 0;
	mesiSosp150 number := 0;
	annoDataInizio number;
	annoDataFine number;
	meseDataInizio number;
	meseDataFine number;
	annoDataSospensione number;
	meseDataSospensione number;
	annoPrec number := 0;
	mesePrec number := 0;
	meseDataInizioCurr number;
	giorniSospMeseCurr number := 0;
	giorniSospReali number := 0;
	giorniSospTotali number := 0;
	calcolaSospFornero boolean := true;
	annoDataCurr number;
	meseDataCurr number;
	giornoDataCurr number;
	mesePrecIsSospeso boolean := false;
	calcolaSosp150 boolean := false;
	giornoDataInizio number;
	giornoDataFine number;
	giorniSospTotali150 number := 0;
	giorniSospRestanti150 number := 0;
	differenzaMesi number := 0;
begin

	BEGIN
		SELECT am_stato_occupaz.datcalcolomesisosp
		INTO p_datdatacalcolososp
		FROM am_stato_occupaz
		INNER JOIN de_stato_occupaz ON (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
		INNER JOIN de_stato_occupaz_ragg ON (de_stato_occupaz.codstatooccupazragg = de_stato_occupaz_ragg.codstatooccupazragg)
		INNER JOIN an_lav_storia_inf inf ON (am_stato_occupaz.cdnlavoratore = inf.cdnlavoratore)
		WHERE am_stato_occupaz.cdnlavoratore = cdnLav and
		inf.datfine IS NULL and
		trunc(am_stato_occupaz.DATINIZIO) <= trunc(dataCalcolo) and
		(am_stato_occupaz.datfine IS NULL or trunc(am_stato_occupaz.datfine) >= trunc(dataCalcolo)) and
		de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I');

	EXCEPTION
		WHEN NO_DATA_FOUND THEN calcolaSospFornero := false;
		WHEN OTHERS THEN calcolaSospFornero := false;
	END;

	if (calcolaSospFornero) then

		annoDataSospensione := to_number(to_char(p_datdatacalcolososp, 'yyyy'));
		meseDataSospensione := to_number(to_char(p_datdatacalcolososp, 'mm'));

		for rec_StatoOcc in cursorStatoOcc loop
			p_datdatainizio := rec_StatoOcc.datinizio;
			p_datdatafine := rec_StatoOcc.datfine;

			if (trunc(p_datdatainizio) <= trunc(p_datdatacalcolososp)) then
				p_datdatainizio := p_datdatacalcolososp;
			end if;

			--inizio commento: se non ci sono dati errati sul DB, questo caso non si verifica mai
			if (trunc(p_datdatafine) <= trunc(p_datdatacalcolososp)) then
				p_datdatafine := p_datdatacalcolososp;
			end if;
			--fine commento: se non ci sono dati errati sul DB, questo caso non si verifica mai

			if (trunc(p_datdatafine) >= trunc(dataCalcolo)) then
				p_datdatafine := dataCalcolo;
			end if;

			giorniSospTotali := giorniSospTotali + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);

			annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
			meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));

			annoDataFine := to_number(to_char(p_datdatafine, 'yyyy'));
			meseDataFine := to_number(to_char(p_datdatafine, 'mm'));

			if (annoDataFine = annoDataInizio and meseDataFine = meseDataInizio) then
				if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then
					if (annoDataSospensione = annoDataInizio and meseDataSospensione = meseDataInizio) then
						giorniSospReali := trunc(p_datdatafine) - trunc(p_datdatainizio) + 1;
						if (to_number(to_char(p_datdatacalcolososp, 'dd')) < 16) then
							giorniSospMeseCurr := giorniSospMeseCurr + (to_number(to_char(p_datdatacalcolososp, 'dd')) - 1) + giorniSospReali;
						end if;
					else
						giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);
					end if;
				else
					if ((30 - giorniSospMeseCurr) < 16) then
						mesiSosp := mesiSosp + 1;
					end if;
					giorniSospMeseCurr := trunc(p_datdatafine) - trunc(p_datdatainizio) + 1;
				end if;
				annoPrec := annoDataFine;
				mesePrec := meseDataFine;

			else

				if (annoDataFine = annoDataInizio and meseDataFine > meseDataInizio) then
					p_datdatafineCurr := LAST_DAY(p_datdatainizio);
					if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then
						if (annoDataSospensione = annoDataInizio and meseDataSospensione = meseDataInizio) then
							giorniSospReali := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
							if (to_number(to_char(p_datdatacalcolososp, 'dd')) < 16) then
								giorniSospMeseCurr := giorniSospMeseCurr + (to_number(to_char(p_datdatacalcolososp, 'dd')) - 1) + giorniSospReali;
							end if;
						else
							giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1);
						end if;

						if ((30 - giorniSospMeseCurr) < 16) then
							mesiSosp := mesiSosp + 1;
						end if;
					else
						--giorni sospensione calcolati per il mese precedente
						if ((30 - giorniSospMeseCurr) < 16) then
							mesiSosp := mesiSosp + 1;
						end if;
						--giorni sospensione calcolati per il mese corrente
						giorniSospMeseCurr := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
						if ((30 - giorniSospMeseCurr) < 16) then
							mesiSosp := mesiSosp + 1;
						end if;
					end if;

					mesiSosp := mesiSosp + (meseDataFine - meseDataInizio - 1);

					p_datdatainizioCurr := to_date('01/' || to_char(meseDataFine) || '/' || to_char(annoDataFine), 'dd/mm/yyyy');

					giorniSospMeseCurr := trunc(p_datdatafine) - p_datdatainizioCurr + 1;

					annoPrec := annoDataFine;
					mesePrec := meseDataFine;

				else
					if (annoDataFine > annoDataInizio) then
						p_datdatafineCurr := LAST_DAY(p_datdatainizio);
						if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then
							if (annoDataSospensione = annoDataInizio and meseDataSospensione = meseDataInizio) then
								giorniSospReali := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
								if (to_number(to_char(p_datdatacalcolososp, 'dd')) < 16) then
									giorniSospMeseCurr := giorniSospMeseCurr + (to_number(to_char(p_datdatacalcolososp, 'dd')) - 1) + giorniSospReali;
								end if;
							else
								giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1);
							end if;

							if ((30 - giorniSospMeseCurr) < 16) then
								mesiSosp := mesiSosp + 1;
							end if;
						else
							--giorni sospensione calcolati per il mese precedente
							if ((30 - giorniSospMeseCurr) < 16) then
								mesiSosp := mesiSosp + 1;
							end if;
							--giorni sospensione calcolati per il mese corrente
							giorniSospMeseCurr := p_datdatafineCurr - p_datdatainizio + 1;
							if ((30 - giorniSospMeseCurr) < 16) then
								mesiSosp := mesiSosp + 1;
							end if;
						end if;

						mesiSosp := mesiSosp + (12 - meseDataInizio);

						mesiSosp := mesiSosp + ((annoDataFine - annoDataInizio - 1) * 12);

						mesiSosp := mesiSosp + meseDataFine - 1;

						p_datdatainizioCurr := to_date('01/' || to_char(meseDataFine) || '/' || to_char(annoDataFine), 'dd/mm/yyyy');

						giorniSospMeseCurr := p_datdatafine - p_datdatainizioCurr + 1;

						annoPrec := annoDataFine;
						mesePrec := meseDataFine;

					end if;

				end if;

			end if;

		end loop;

		annoDataCurr := to_number(to_char(sysdate, 'yyyy'));
		meseDataCurr := to_number(to_char(sysdate, 'mm'));
		giornoDataCurr := to_number(to_char(sysdate, 'dd'));

		if (not(annoPrec = annoDataCurr and mesePrec = meseDataCurr) or (giornoDataCurr >= 16)) then
			if (giorniSospMeseCurr > 0) then
				if ((30 - giorniSospMeseCurr) < 16) then
					mesiSosp := mesiSosp + 1;
					mesePrecIsSospeso := true;
				end if;
			end if;
		end if;

		for rec_StatoOcc150 in cursorStatoOcc150 loop
			p_datdatainizio := rec_StatoOcc150.datinizio;
			p_datdatafine := rec_StatoOcc150.datfine;
			calcolaSosp150 := true;

			if (trunc(p_datdatainizio) <= trunc(p_datdatacalcolososp)) then
				p_datdatainizio := p_datdatacalcolososp;
			end if;

			if (trunc(p_datdatafine) <= trunc(p_datdatacalcolososp)) then
				p_datdatafine := p_datdatacalcolososp;
			end if;

			if (trunc(p_datdatafine) >= trunc(dataCalcolo)) then
				p_datdatafine := dataCalcolo;
			end if;

			annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
			meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));
			annoDataFine := to_number(to_char(p_datdatafine, 'yyyy'));
			meseDataFine := to_number(to_char(p_datdatafine, 'mm'));

			if (mesePrecIsSospeso) then
				-- il mese e'' stato considerato come sospeso secondo le regole prima del decreto 150 e quindi non vanno considerati i giorni
				-- di sospensione nel calcolo post decreto 150
				if (annoPrec = annoDataInizio and mesePrec = meseDataInizio) then
					if (annoPrec = annoDataFine and mesePrec = meseDataFine) then
						calcolaSosp150 := false;
					else
						if (meseDataInizio = 12) then
							p_datdatainizio := to_date('01/01/' || to_char(annoDataInizio + 1), 'dd/mm/yyyy');
							meseDataInizio := 1;
							annoDataInizio := annoDataInizio + 1;
						else
							p_datdatainizio := to_date('01/' || to_char(meseDataInizio + 1) || '/' || to_char(annoDataInizio), 'dd/mm/yyyy');
							meseDataInizio := meseDataInizio + 1;
						end if;
					end if;
				end if;
			end if;

			if (calcolaSosp150) then
				differenzaMesi := (((to_number(to_char(p_datdatafine, 'yyyy')) - to_number(to_char(p_datdatainizio, 'yyyy'))) * 12) +
					to_number(to_char(p_datdatafine, 'mm')) - to_number(to_char(p_datdatainizio, 'mm')) + 1) - 2;
				if (differenzaMesi > 0) then
					giornoDataInizio := to_number(to_char(p_datdatainizio, 'dd'));
					if (giornoDataInizio = to_number(to_char(LAST_DAY(to_date('01/' || to_char(p_datdatainizio, 'mm') || '/' || to_char(p_datdatainizio, 'yyyy'), 'dd/mm/yyyy')), 'dd'))) then
						giorniSospTotali150 := giorniSospTotali150 + 1;
					else
						giorniSospTotali150 := giorniSospTotali150 + (30 - giornoDataInizio + 1);
					end if;
					giorniSospTotali150 := giorniSospTotali150 + (30 * (differenzaMesi));
					giornoDataFine := to_number(to_char(p_datdatafine, 'dd'));
					if (giornoDataFine > 30) then
						giornoDataFine := 30;
					else
						if (meseDataFine = 2 and giornoDataFine = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))) then
							giornoDataFine := 30;
						end if;
					end if;
					giorniSospTotali150 := giorniSospTotali150 + giornoDataFine;
				else
					if (differenzaMesi < 0) then
						-- sospensione nello stesso mese
						if ( (meseDataInizio = 2) and
							 ((trunc(p_datdatafine) - trunc(p_datdatainizio) + 1) = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))
						   ) ) then
						   giorniSospTotali150 := giorniSospTotali150 + 30;
						else
							if ((trunc(p_datdatafine) - trunc(p_datdatainizio) + 1) > 30) then
								giorniSospTotali150 := giorniSospTotali150 + 30;
							else
								giorniSospTotali150 := giorniSospTotali150 + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);
							end if;
						end if;
					else
						-- sospensione a cavallo di due mesi
						giornoDataInizio := to_number(to_char(p_datdatainizio, 'dd'));
						if (giornoDataInizio = to_number(to_char(LAST_DAY(to_date('01/' || to_char(p_datdatainizio, 'mm') || '/' || to_char(p_datdatainizio, 'yyyy'), 'dd/mm/yyyy')), 'dd'))) then
							giorniSospTotali150 := giorniSospTotali150 + 1;
						else
							giorniSospTotali150 := giorniSospTotali150 + (30 - giornoDataInizio + 1);
						end if;
						giornoDataFine := to_number(to_char(p_datdatafine, 'dd'));
						if (giornoDataFine > 30) then
							giornoDataFine := 30;
						else
							if (meseDataFine = 2 and giornoDataFine = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))) then
								giornoDataFine := 30;
							end if;
						end if;
						giorniSospTotali150 := giorniSospTotali150 + giornoDataFine;
					end if;
				end if;
			end if;

		end loop;

		if (giorniSospTotali150 > 0) then
			mesiSosp150 := trunc(giorniSospTotali150/30);
			giorniSospRestanti150 := MOD(giorniSospTotali150,30);

			mesiSosp := mesiSosp + mesiSosp150;
			giorniSospTotali := giorniSospTotali + giorniSospTotali150;
		end if;

	END IF;

	return to_char(mesiSosp) || '-' || to_char(giorniSospRestanti150);

end MesiSospFornero2014AllaData;


FUNCTION DettaglioAnzianitaFornero2014 (cdnLav IN an_lavoratore.cdnlavoratore%type) return varchar2 is

	CURSOR cursorStatoOcc IS
          select
			case
				when trunc(occ.datinizio) < (select trunc(datFornero) from ts_generale)
				then (select datFornero from ts_generale)
				else occ.datinizio
			end as datinizio,
		  nvl(occ.datfine, sysdate) datfine
		  FROM am_stato_occupaz occ
		   WHERE occ.cdnlavoratore = cdnLav
		   AND occ.codstatooccupaz in ('B1', 'B3')
		   AND trunc(nvl(occ.datfine, sysdate)) >= (select trunc(datFornero) from ts_generale)
		   order by occ.datinizio asc;

	rec_StatoOcc cursorStatoOcc%ROWTYPE;
	p_datdatainizio am_stato_occupaz.datinizio%type;
	p_datdatafine am_stato_occupaz.datfine%type;

	p_datdatafineCurr am_stato_occupaz.datfine%type;
	p_datdatainizioCurr am_stato_occupaz.datfine%type;

	p_datdatafineGGSosp am_stato_occupaz.datfine%type;
	p_datdatainizioGGSosp am_stato_occupaz.datfine%type;

	p_datdatacalcolososp am_stato_occupaz.datcalcolomesisosp%type;

	p_datdatacalcolosospIniziale am_stato_occupaz.datcalcolomesisosp%type;

	annoDataInizio number;
	annoDataFine number;
	meseDataInizio number;
	meseDataFine number;
	annoPrec number := 0;
	mesePrec number := 0;
	meseDataInizioCurr number;
	giorniSospMeseCurr number := 0;
	giorniSospReali number := 0;
	giorniSospTotali number := 0;
	calcolaSospFornero boolean := true;
	--il risultato formattato in questo modo : anno-mese-1-giornisosp#anno-mese-0-giornisosp
	risultatoAnzianita varchar2(2000) := '0';
	annoDataCurr number;
	meseDataCurr number;
	giornoDataCurr number;
	datFornero ts_generale.datFornero%type;
	dat150 ts_generale.dat150%type;
	datLastMese ts_generale.datFornero%type;
	annoDataFornero number;
	meseDataFornero number;
	annoDataSospensione number;
	meseDataSospensione number;
	meseDataSospensioneOrig number;
	numeroMovimento number := 0;
	calcolaMeseAnz boolean := true;
	giorniCommerciali number := 0;

begin

	BEGIN
		SELECT am_stato_occupaz.datcalcolomesisosp
		INTO p_datdatacalcolososp
		FROM am_stato_occupaz
		INNER JOIN de_stato_occupaz ON (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
		INNER JOIN de_stato_occupaz_ragg ON (de_stato_occupaz.codstatooccupazragg = de_stato_occupaz_ragg.codstatooccupazragg)
		INNER JOIN an_lav_storia_inf inf ON (am_stato_occupaz.cdnlavoratore = inf.cdnlavoratore)
		WHERE am_stato_occupaz.datfine IS NULL
		AND am_stato_occupaz.cdnlavoratore = cdnLav
		AND de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I')
		AND inf.datfine IS NULL;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN calcolaSospFornero := false;
		WHEN OTHERS THEN calcolaSospFornero := false;
	END;

	if (calcolaSospFornero) then

		select trunc(datFornero)
		into datFornero
		from ts_generale;

		select trunc(dat150)
		into dat150
		from ts_generale;

		annoDataFornero := to_number(to_char(datFornero, 'yyyy'));
		meseDataFornero := to_number(to_char(datFornero, 'mm'));

		for rec_StatoOcc in cursorStatoOcc loop
			calcolaMeseAnz := true;

			p_datdatainizio := rec_StatoOcc.datinizio;
			p_datdatafine := rec_StatoOcc.datfine;

			if ( (trunc(p_datdatainizio) >= trunc(p_datdatacalcolososp)) or
			     (trunc(p_datdatacalcolososp) >= trunc(p_datdatainizio) and trunc(p_datdatacalcolososp) <= trunc(p_datdatafine))
				) then

				numeroMovimento := numeroMovimento + 1;

				if (trunc(p_datdatainizio) <= trunc(p_datdatacalcolososp)) then
					p_datdatainizio := p_datdatacalcolososp;
				end if;

				if (trunc(p_datdatafine) <= trunc(p_datdatacalcolososp)) then
					p_datdatafine := p_datdatacalcolososp;
				end if;

				if (trunc(p_datdatafine) >= trunc(sysdate)) then
					p_datdatafine := sysdate;
				end if;

				giorniSospTotali := giorniSospTotali + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);

				annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
				meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));

				annoDataFine := to_number(to_char(p_datdatafine, 'yyyy'));
				meseDataFine := to_number(to_char(p_datdatafine, 'mm'));


				if (numeroMovimento = 1) then

					if (trunc(p_datdatacalcolososp) >= datFornero) then
						p_datdatacalcolosospIniziale := p_datdatacalcolososp;
					else
						p_datdatacalcolosospIniziale := datFornero;
					end if;

					annoDataSospensione := to_number(to_char(p_datdatacalcolosospIniziale, 'yyyy'));
					meseDataSospensioneOrig := to_number(to_char(p_datdatacalcolosospIniziale, 'mm'));
					meseDataSospensione := meseDataSospensioneOrig;

					--calcolo anzianità tra la data calcolo sospensione e la data inizio
					if (annoDataSospensione <= annoDataInizio and meseDataSospensione < meseDataInizio) then
						if (to_number(to_char(p_datdatacalcolosospIniziale, 'dd')) < 16) then
							if (risultatoAnzianita = '0') then
								risultatoAnzianita := annoDataSospensione || '-' || meseDataSospensione || '-' || '1' || '-' || '0';
							else
								risultatoAnzianita := risultatoAnzianita || '#' || annoDataSospensione || '-' || meseDataSospensione || '-' || '1' || '-' || '0';
							end if;
						else
							if (risultatoAnzianita = '0') then
								risultatoAnzianita := annoDataSospensione || '-' || meseDataSospensione || '-' || '0' || '-' || '0';
							else
								risultatoAnzianita := risultatoAnzianita || '#' || annoDataSospensione || '-' || meseDataSospensione || '-' || '0' || '-' || '0';
							end if;
						end if;

						while (annoDataSospensione < annoDataInizio) loop
							meseDataSospensione := meseDataSospensione + 1;
							while (meseDataSospensione <= 12) loop
								if (risultatoAnzianita = '0') then
									risultatoAnzianita := annoDataSospensione || '-' || meseDataSospensione || '-' || '1' || '-' || '0';
								else
									risultatoAnzianita := risultatoAnzianita || '#' || annoDataSospensione || '-' || meseDataSospensione || '-' || '1' || '-' || '0';
								end if;
								meseDataSospensione := meseDataSospensione + 1;
							end loop;
							meseDataSospensione := 0;
							annoDataSospensione := annoDataSospensione + 1;
						end loop;

						meseDataSospensione := meseDataSospensione + 1;
						while (meseDataSospensione < meseDataInizio) loop
							if (risultatoAnzianita = '0') then
								risultatoAnzianita := annoDataSospensione || '-' || meseDataSospensione || '-' || '1' || '-' || '0';
							else
								risultatoAnzianita := risultatoAnzianita || '#' || annoDataSospensione || '-' || meseDataSospensione || '-' || '1' || '-' || '0';
							end if;
							meseDataSospensione := meseDataSospensione + 1;
						end loop;


					else
						if (annoDataSospensione = annoDataInizio and meseDataSospensione = meseDataInizio) then

							if (annoDataFine = annoDataInizio and meseDataFine = meseDataInizio) then
								giorniSospReali := trunc(p_datdatafine) - trunc(p_datdatainizio) + 1;
								giorniSospMeseCurr := (to_number(to_char(p_datdatacalcolosospIniziale, 'dd')) - 1) + giorniSospReali;

								annoPrec := annoDataFine;
								mesePrec := meseDataFine;

								calcolaMeseAnz := false;

							else
								datLastMese := LAST_DAY(p_datdatainizio);
								giorniSospMeseCurr := trunc(datLastMese) - trunc(p_datdatainizio) + 1;
								if ((30 - to_number(to_char(p_datdatacalcolosospIniziale, 'dd')) - giorniSospMeseCurr) < 16) then
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoDataSospensione || '-' || meseDataSospensione || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoDataSospensione || '-' || meseDataSospensione || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
									end if;
								else
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoDataSospensione || '-' || meseDataSospensione || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoDataSospensione || '-' || meseDataSospensione || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
									end if;
								end if;

								p_datdatainizio := datLastMese + 1;

								giorniSospMeseCurr := 0;

								annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
								meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));

							end if;

						end if;

					end if;

				end if;

				if (calcolaMeseAnz) then

					if (annoDataFine = annoDataInizio and meseDataFine = meseDataInizio) then
						if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then
							giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);
						else
							if (annoPrec = annoDataSospensione and mesePrec = meseDataSospensioneOrig) then
								if ((30 - giorniSospMeseCurr) < 16) then
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospReali);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospReali);
									end if;
								else
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospReali);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospReali);
									end if;
								end if;

							else

								if ((30 - giorniSospMeseCurr) < 16) then
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
									end if;
								else
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
									end if;
								end if;
							end if;

							--anzianità tra la sospensione precedente e l'inizio delle nuova
							while (annoPrec < annoDataInizio) loop
								mesePrec := mesePrec + 1;
								while (mesePrec <= 12) loop
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
									end if;
									mesePrec := mesePrec + 1;
								end loop;
								mesePrec := 0;
								annoPrec := annoPrec + 1;
							end loop;

							mesePrec := mesePrec + 1;
							while (mesePrec < meseDataInizio) loop
								if (risultatoAnzianita = '0') then
									risultatoAnzianita := annoDataInizio || '-' || mesePrec || '-' || '1' || '-' || '0';
								else
									risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || mesePrec || '-' || '1' || '-' || '0';
								end if;
								mesePrec := mesePrec + 1;
							end loop;

							giorniSospMeseCurr := trunc(p_datdatafine) - trunc(p_datdatainizio) + 1;
						end if;
						annoPrec := annoDataFine;
						mesePrec := meseDataFine;

					else

						if (annoDataFine = annoDataInizio and meseDataFine > meseDataInizio) then
							p_datdatafineCurr := LAST_DAY(p_datdatainizio);
							if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then

								giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1);

								if (annoPrec = annoDataSospensione and mesePrec = meseDataSospensioneOrig) then
									giorniSospReali := giorniSospReali + (trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1);
									if ((30 - giorniSospMeseCurr) < 16) then
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospReali);
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospReali);
										end if;
									else
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospReali);
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospReali);
										end if;
									end if;
								else
									if ((30 - giorniSospMeseCurr) < 16) then
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
										end if;
									else
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
										end if;
									end if;
								end if;

							else

								if (annoPrec = annoDataSospensione and mesePrec = meseDataSospensioneOrig) then
									--giorni sospensione calcolati per il mese precedente
									if ((30 - giorniSospMeseCurr) < 16) then
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospReali);
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospReali);
										end if;
									else
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospReali);
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospReali);
										end if;
									end if;

								else
									--giorni sospensione calcolati per il mese precedente
									if ((30 - giorniSospMeseCurr) < 16) then
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
										end if;
									else
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
										end if;
									end if;
								end if;

								--anzianità tra la sospensione precedente e l'inizio delle nuova
								while (annoPrec < annoDataInizio) loop
									mesePrec := mesePrec + 1;
									while (mesePrec <= 12) loop
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
										end if;
										mesePrec := mesePrec + 1;
									end loop;
									mesePrec := 0;
									annoPrec := annoPrec + 1;
								end loop;

								mesePrec := mesePrec + 1;
								while (mesePrec < meseDataInizio) loop
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoDataInizio || '-' || mesePrec || '-' || '1' || '-' || '0';
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || mesePrec || '-' || '1' || '-' || '0';
									end if;
									mesePrec := mesePrec + 1;
								end loop;

								--giorni sospensione calcolati per il mese corrente
								giorniSospMeseCurr := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
								if ((30 - giorniSospMeseCurr) < 16) then
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
									end if;
								else
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
									end if;
								end if;
							end if;

							meseDataInizio := meseDataInizio + 1;
							while (meseDataInizio < meseDataFine) loop
								p_datdatainizioGGSosp := to_date('01/' || to_char(meseDataInizio) || '/' || to_char(annoDataInizio), 'dd/mm/yyyy');
								p_datdatafineGGSosp := LAST_DAY(p_datdatainizioGGSosp);

								if (risultatoAnzianita = '0') then
									risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char((trunc(p_datdatafineGGSosp) - trunc(p_datdatainizioGGSosp) + 1));
								else
									risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char((trunc(p_datdatafineGGSosp) - trunc(p_datdatainizioGGSosp) + 1));
								end if;
								meseDataInizio := meseDataInizio + 1;
							end loop;

							p_datdatainizioCurr := to_date('01/' || to_char(meseDataFine) || '/' || to_char(annoDataFine), 'dd/mm/yyyy');

							giorniSospMeseCurr := trunc(p_datdatafine) - trunc(p_datdatainizioCurr) + 1;

							annoPrec := annoDataFine;
							mesePrec := meseDataFine;

						else
							if (annoDataFine > annoDataInizio) then
								p_datdatafineCurr := LAST_DAY(p_datdatainizio);
								if ((annoPrec = 0 and mesePrec = 0) or (annoPrec = annoDataInizio and mesePrec = meseDataInizio)) then
									giorniSospMeseCurr := giorniSospMeseCurr + (trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1);

									if (annoPrec = annoDataSospensione and mesePrec = meseDataSospensioneOrig) then
										giorniSospReali := giorniSospReali + (trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1);
										if ((30 - giorniSospMeseCurr) < 16) then
											if (risultatoAnzianita = '0') then
												risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospReali);
											else
												risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospReali);
											end if;
										else
											if (risultatoAnzianita = '0') then
												risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospReali);
											else
												risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospReali);
											end if;
										end if;
									else
										if ((30 - giorniSospMeseCurr) < 16) then
											if (risultatoAnzianita = '0') then
												risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
											else
												risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
											end if;
										else
											if (risultatoAnzianita = '0') then
												risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
											else
												risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
											end if;
										end if;
									end if;
								else
									if (annoPrec = annoDataSospensione and mesePrec = meseDataSospensioneOrig) then
										--giorni sospensione calcolati per il mese precedente
										if ((30 - giorniSospMeseCurr) < 16) then
											if (risultatoAnzianita = '0') then
												risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospReali);
											else
												risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospReali);
											end if;
										else
											if (risultatoAnzianita = '0') then
												risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospReali);
											else
												risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospReali);
											end if;
										end if;
									else
										--giorni sospensione calcolati per il mese precedente
										if ((30 - giorniSospMeseCurr) < 16) then
											if (risultatoAnzianita = '0') then
												risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
											else
												risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
											end if;
										else
											if (risultatoAnzianita = '0') then
												risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
											else
												risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
											end if;
										end if;
									end if;

									--anzianità tra la sospensione precedente e l'inizio delle nuova
									while (annoPrec < annoDataInizio) loop
										mesePrec := mesePrec + 1;
										while (mesePrec <= 12) loop
											if (risultatoAnzianita = '0') then
												risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
											else
												risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
											end if;
											mesePrec := mesePrec + 1;
										end loop;
										mesePrec := 0;
										annoPrec := annoPrec + 1;
									end loop;

									mesePrec := mesePrec + 1;
									while (mesePrec < meseDataInizio) loop
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoDataInizio || '-' || mesePrec || '-' || '1' || '-' || '0';
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || mesePrec || '-' || '1' || '-' || '0';
										end if;
										mesePrec := mesePrec + 1;
									end loop;

									--giorni sospensione calcolati per il mese corrente
									giorniSospMeseCurr := trunc(p_datdatafineCurr) - trunc(p_datdatainizio) + 1;
									if ((30 - giorniSospMeseCurr) < 16) then
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
										end if;
									else
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
										end if;
									end if;
								end if;

								--B1 può essere al max a cavallo di 2 anni.
								--Quando si esce dal ciclo, annoDataInizio = annoDataFine e meseDataInizio = 0;
								while (annoDataInizio < annoDataFine) loop
									meseDataInizio := meseDataInizio + 1;
									while (meseDataInizio <= 12) loop
										p_datdatainizioGGSosp := to_date('01/' || to_char(meseDataInizio) || '/' || to_char(annoDataInizio), 'dd/mm/yyyy');
										p_datdatafineGGSosp := LAST_DAY(p_datdatainizioGGSosp);
										if (risultatoAnzianita = '0') then
											risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char((trunc(p_datdatafineGGSosp) - trunc(p_datdatainizioGGSosp) + 1));
										else
											risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char((trunc(p_datdatafineGGSosp) - trunc(p_datdatainizioGGSosp) + 1));
										end if;
										meseDataInizio := meseDataInizio + 1;
									end loop;
									meseDataInizio := 0;
									annoDataInizio := annoDataInizio + 1;
								end loop;

								meseDataInizio := meseDataInizio + 1;
								while (meseDataInizio < meseDataFine) loop
									p_datdatainizioGGSosp := to_date('01/' || to_char(meseDataInizio) || '/' || to_char(annoDataInizio), 'dd/mm/yyyy');
									p_datdatafineGGSosp := LAST_DAY(p_datdatainizioGGSosp);
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char((trunc(p_datdatafineGGSosp) - trunc(p_datdatainizioGGSosp) + 1));
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoDataInizio || '-' || meseDataInizio || '-' || '0' || '-' || to_char((trunc(p_datdatafineGGSosp) - trunc(p_datdatainizioGGSosp) + 1));
									end if;
									meseDataInizio := meseDataInizio + 1;
								end loop;

								p_datdatainizioCurr := to_date('01/' || to_char(meseDataFine) || '/' || to_char(annoDataFine), 'dd/mm/yyyy');

								giorniSospMeseCurr := trunc(p_datdatafine) - trunc(p_datdatainizioCurr) + 1;

								annoPrec := annoDataFine;
								mesePrec := meseDataFine;

							end if;

						end if;

					end if;

				end if;

				numeroMovimento := numeroMovimento + 1;
			end if;

		end loop;

		annoDataCurr := to_number(to_char(dat150, 'yyyy'));
		meseDataCurr := to_number(to_char(dat150, 'mm'));
		giornoDataCurr := to_number(to_char(dat150, 'dd'));

		if (giorniSospMeseCurr > 0) then
			giorniCommerciali := 30;
			if (annoPrec = annoDataSospensione and mesePrec = meseDataSospensioneOrig) then
				if (not(annoPrec = annoDataCurr and mesePrec = meseDataCurr) or (giornoDataCurr >= 16)) then
					if ((giorniCommerciali - giorniSospMeseCurr) < 16) then
						if (risultatoAnzianita = '0') then
							risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospReali);
						else
							risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospReali);
						end if;
					else
						if (risultatoAnzianita = '0') then
							risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospReali);
						else
							risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospReali);
						end if;
					end if;
				else
					if (annoPrec = annoDataCurr and mesePrec = meseDataCurr) then
						if (giornoDataCurr < 16) then
							if (risultatoAnzianita = '0') then
								risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
							else
								risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
							end if;
						else
							if ((giorniCommerciali - giorniSospMeseCurr) < 16) then
								if ((giorniCommerciali - giorniSospMeseCurr) < 16) then
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
									end if;
								else
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
									end if;
								end if;
							end if;
						end if;
					end if;
				end if;
			else
				if (not(annoPrec = annoDataCurr and mesePrec = meseDataCurr) or (giornoDataCurr >= 16)) then
					if ((giorniCommerciali - giorniSospMeseCurr) < 16) then
						if (risultatoAnzianita = '0') then
							risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
						else
							risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
						end if;
					else
						if (risultatoAnzianita = '0') then
							risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
						else
							risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
						end if;
					end if;
				else
					if (annoPrec = annoDataCurr and mesePrec = meseDataCurr) then
						if (giornoDataCurr < 16) then
							if (risultatoAnzianita = '0') then
								risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
							else
								risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
							end if;
						else
							if ((giorniCommerciali - giorniSospMeseCurr) < 16) then
								if ((giorniCommerciali - giorniSospMeseCurr) < 16) then
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || to_char(giorniSospMeseCurr);
									end if;
								else
									if (risultatoAnzianita = '0') then
										risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
									else
										risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || to_char(giorniSospMeseCurr);
									end if;
								end if;
							end if;
						end if;
					end if;
				end if;
			end if;
		end if;

		if (risultatoAnzianita = '0') then
			if (trunc(p_datdatacalcolososp) > datFornero) then
				annoPrec := to_number(to_char(p_datdatacalcolososp, 'yyyy'));
				mesePrec := to_number(to_char(p_datdatacalcolososp, 'mm'));
				if (to_number(to_char(p_datdatacalcolososp, 'dd')) < 16) then
					risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
				else
					risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || '0';
				end if;

			else
				annoPrec := annoDataFornero;
				mesePrec := 0;
			end if;

		end if;

		if (annoPrec = annoDataCurr and mesePrec < meseDataCurr) then
			mesePrec := mesePrec + 1;
			while (mesePrec < meseDataCurr) loop
				if (risultatoAnzianita = '0') then
					risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
				else
					risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
				end if;
				mesePrec := mesePrec + 1;
			end loop;
			if (to_number(to_char(dat150, 'dd')) >= 16) then
				if (risultatoAnzianita = '0') then
					risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
				else
					risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
				end if;
			else
				if (risultatoAnzianita = '0') then
					risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || '0';
				else
					risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || '0';
				end if;
			end if;
		else
			if (annoPrec < annoDataCurr) then
				while (annoPrec < annoDataCurr) loop
					mesePrec := mesePrec + 1;
					while (mesePrec <= 12) loop
						if (risultatoAnzianita = '0') then
							risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
						else
							risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
						end if;
						mesePrec := mesePrec + 1;
					end loop;
					mesePrec := 0;
					annoPrec := annoPrec + 1;
				end loop;

				mesePrec := mesePrec + 1;
				while (mesePrec < meseDataCurr) loop
					if (risultatoAnzianita = '0') then
						risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
					else
						risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
					end if;
					mesePrec := mesePrec + 1;
				end loop;
				if (to_number(to_char(dat150, 'dd')) >= 16) then
					if (risultatoAnzianita = '0') then
						risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
					else
						risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '1' || '-' || '0';
					end if;
				else
					if (risultatoAnzianita = '0') then
						risultatoAnzianita := annoPrec || '-' || mesePrec || '-' || '0' || '-' || '0';
					else
						risultatoAnzianita := risultatoAnzianita || '#' || annoPrec || '-' || mesePrec || '-' || '0' || '-' || '0';
					end if;
				end if;

			end if;

		end if;

	end if;

	return risultatoAnzianita;

end DettaglioAnzianitaFornero2014;


FUNCTION MesiRischioDisoccupazione (cdnLav IN an_lavoratore.cdnlavoratore%type, dataCalcoloAnzianita IN am_stato_occupaz.datcalcoloanzianita%type) return varchar2 is

	CURSOR cursorStatoOcc IS
          select (to_number(
							(to_char(nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)),'yyyy')
                             - to_char(am_stato_occupaz.datinizio,'yyyy')) * 12
	  						 + to_char(nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)),'mm')
		                    - to_char(am_stato_occupaz.datinizio,'mm') + 1
						+ (case
	   	 	  				   when ((to_char(nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)),'yyyy')
	                                  - to_char(am_stato_occupaz.datinizio,'yyyy')) * 12
	   		  	   			   	      + to_char(nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)),'mm')
		                              - to_char(am_stato_occupaz.datinizio,'mm') + 1) > 1
							   then
	   						   		   -(case when
				   	 	  	  		  	 	 (30 - to_char(am_stato_occupaz.datinizio,'dd') + 1) < 16
						  				   	 then 1
						  				   	 when
				   	 	  	  			   	 (30 - to_char(am_stato_occupaz.datinizio,'dd') + 1) >= 15
						  				   	 then 0
					  				   end)
					  				   -(case when
				   	 	  	  			 	  to_char(nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)),'dd') < 16
						  					  then 1
						  					  when
				   	 	  	  				  to_char(nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)),'dd') >= 15
						  					  then 0
					  					end)

			 				  when
			 	  			  	  ((to_char(nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)),'yyyy')
	                                - to_char(am_stato_occupaz.datinizio,'yyyy')) * 12
	   		  	  			  	  	+ to_char(nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)),'mm')
	                                - to_char(am_stato_occupaz.datinizio,'mm') + 1) = 1
			 				  then
			 	 			  	  -(case when
			   	 	  	  		  		 (to_char(nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)),'dd')
		                                 - to_char(am_stato_occupaz.datinizio,'dd') + 1) < 16
					  					 then 1
					    		         when
			   	 	  	  	 			 (to_char(nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)),'dd')
		                                 - to_char(am_stato_occupaz.datinizio,'dd') + 1) >= 15
					    				 then 0
				  				    end)
			 				  end))) mesi_rischio_disocc,
									 am_stato_occupaz.datinizio datinizio, nvl(am_stato_occupaz.datfine,(select trunc(dat150)-1 from ts_generale)) datfine
		  FROM am_stato_occupaz
		   WHERE am_stato_occupaz.cdnlavoratore = cdnLav
		   AND am_stato_occupaz.codstatooccupaz = 'B3'
		   AND trunc(am_stato_occupaz.datinizio) >= trunc(dataCalcoloAnzianita)
		   AND trunc(am_stato_occupaz.datinizio) < (select trunc(dat150) from ts_generale)
		   order by am_stato_occupaz.datinizio asc;


	CURSOR cursorStatoOcc150 IS
		select occ.datinizio datinizio, nvl(occ.datfine, sysdate) datfine
		  FROM am_stato_occupaz occ
		   WHERE occ.cdnlavoratore = cdnLav
		   AND occ.codstatooccupaz = 'B3'
		   AND trunc(occ.datinizio) >= trunc(dataCalcoloAnzianita)
		   AND trunc(occ.datinizio) >= (select trunc(dat150) from ts_generale)
		   order by occ.datinizio asc;

	rec_StatoOcc150 cursorStatoOcc150%ROWTYPE;
	giorniSospTotali150 number := 0;
	giorniSospRestanti150 number := 0;
	p_datdatainizio am_stato_occupaz.datinizio%type;
	p_datdatafine am_stato_occupaz.datfine%type;
	rec_StatoOcc cursorStatoOcc%ROWTYPE;
	p_mesi_rischio_disocc number := 0;
	mesePrecIsSospeso boolean := false;
	calcolaSosp150 boolean := false;
	annoPrec number := 0;
	mesePrec number := 0;
	giornoDataInizio number;
	giornoDataFine number;
	annoDataInizio number;
	annoDataFine number;
	meseDataInizio number;
	meseDataFine number;
	differenzaMesi number := 0;

begin

	for rec_StatoOcc in cursorStatoOcc loop
		p_mesi_rischio_disocc := p_mesi_rischio_disocc + nvl(rec_StatoOcc.mesi_rischio_disocc,0);
		p_datdatainizio := rec_StatoOcc.datinizio;
		p_datdatafine := rec_StatoOcc.datfine;
		annoPrec := to_number(to_char(p_datdatafine, 'yyyy'));
		mesePrec := to_number(to_char(p_datdatafine, 'mm'));
	end loop;

	annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
	meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));
	annoDataFine := to_number(to_char(p_datdatafine, 'yyyy'));
	meseDataFine := to_number(to_char(p_datdatafine, 'mm'));

	if (annoDataInizio = annoDataFine and meseDataInizio = meseDataFine) then
		if ((to_number(to_char(p_datdatafine, 'dd')) - to_number(to_char(p_datdatainizio, 'dd')) + 1) >= 15) then
			mesePrecIsSospeso := true;
		end if;
	else
		if (to_number(to_char(p_datdatafine,'dd')) >= 15) then
			mesePrecIsSospeso := true;
		end if;
	end if;

	for rec_StatoOcc150 in cursorStatoOcc150 loop
		p_datdatainizio := rec_StatoOcc150.datinizio;
		p_datdatafine := rec_StatoOcc150.datfine;

		annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
		meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));
		annoDataFine := to_number(to_char(p_datdatafine, 'yyyy'));
		meseDataFine := to_number(to_char(p_datdatafine, 'mm'));

		calcolaSosp150 := true;

		if (mesePrecIsSospeso) then
			-- il mese e'' stato considerato come sospeso secondo le regole prima del decreto 150 e quindi non vanno considerati i giorni
			-- di sospensione nel calcolo post decreto 150
			if (annoPrec = annoDataInizio and mesePrec = meseDataInizio) then
				if (annoPrec = annoDataFine and mesePrec = meseDataFine) then
					calcolaSosp150 := false;
				else
					if (meseDataInizio = 12) then
						p_datdatainizio := to_date('01/01/' || to_char(annoDataInizio + 1), 'dd/mm/yyyy');
						meseDataInizio := 1;
						annoDataInizio := annoDataInizio + 1;
					else
						p_datdatainizio := to_date('01/' || to_char(meseDataInizio + 1) || '/' || to_char(annoDataInizio), 'dd/mm/yyyy');
						meseDataInizio := meseDataInizio + 1;
					end if;
				end if;
			end if;
		end if;

		if (calcolaSosp150) then
			differenzaMesi := (((to_number(to_char(p_datdatafine, 'yyyy')) - to_number(to_char(p_datdatainizio, 'yyyy'))) * 12) +
				to_number(to_char(p_datdatafine, 'mm')) - to_number(to_char(p_datdatainizio, 'mm')) + 1) - 2;
			if (differenzaMesi > 0) then
				giornoDataInizio := to_number(to_char(p_datdatainizio, 'dd'));
				if (giornoDataInizio = to_number(to_char(LAST_DAY(to_date('01/' || to_char(p_datdatainizio, 'mm') || '/' || to_char(p_datdatainizio, 'yyyy'), 'dd/mm/yyyy')), 'dd'))) then
					giorniSospTotali150 := giorniSospTotali150 + 1;
				else
					giorniSospTotali150 := giorniSospTotali150 + (30 - giornoDataInizio + 1);
				end if;
				giorniSospTotali150 := giorniSospTotali150 + (30 * (differenzaMesi));
				giornoDataFine := to_number(to_char(p_datdatafine, 'dd'));
				if (giornoDataFine > 30) then
					giornoDataFine := 30;
				else
					if (meseDataFine = 2 and giornoDataFine = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))) then
						giornoDataFine := 30;
					end if;
				end if;
				giorniSospTotali150 := giorniSospTotali150 + giornoDataFine;
			else
				if (differenzaMesi < 0) then
					-- sospensione nello stesso mese
					if ( (meseDataInizio = 2) and
						 ((trunc(p_datdatafine) - trunc(p_datdatainizio) + 1) = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))
					   ) ) then
					   giorniSospTotali150 := giorniSospTotali150 + 30;
					else
						if ((trunc(p_datdatafine) - trunc(p_datdatainizio) + 1) > 30) then
							giorniSospTotali150 := giorniSospTotali150 + 30;
						else
							giorniSospTotali150 := giorniSospTotali150 + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);
						end if;
					end if;
				else
					-- sospensione a cavallo di due mesi
					giornoDataInizio := to_number(to_char(p_datdatainizio, 'dd'));
					if (giornoDataInizio = to_number(to_char(LAST_DAY(to_date('01/' || to_char(p_datdatainizio, 'mm') || '/' || to_char(p_datdatainizio, 'yyyy'), 'dd/mm/yyyy')), 'dd'))) then
						giorniSospTotali150 := giorniSospTotali150 + 1;
					else
						giorniSospTotali150 := giorniSospTotali150 + (30 - giornoDataInizio + 1);
					end if;
					giornoDataFine := to_number(to_char(p_datdatafine, 'dd'));
					if (giornoDataFine > 30) then
						giornoDataFine := 30;
					else
						if (meseDataFine = 2 and giornoDataFine = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))) then
							giornoDataFine := 30;
						end if;
					end if;
					giorniSospTotali150 := giorniSospTotali150 + giornoDataFine;
				end if;
			end if;
		end if;

	end loop;

	if (giorniSospTotali150 > 0) then
		giorniSospRestanti150 := MOD(giorniSospTotali150,30);
		p_mesi_rischio_disocc := p_mesi_rischio_disocc + trunc(giorniSospTotali150/30);
	end if;

	return to_char(p_mesi_rischio_disocc) || '-' || to_char(giorniSospRestanti150);

end MesiRischioDisoccupazione;


FUNCTION MesiRischioDisoccupazionePar (cdnLav IN an_lavoratore.cdnlavoratore%type, dataCalcoloAnzianita IN am_stato_occupaz.datcalcoloanzianita%type,
									   dataRif IN am_stato_occupaz.datinizio%type) return varchar2 is

	CURSOR cursorStatoOcc IS
          select (to_number(
							(to_char((case
										when nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)) > trunc(dataRif) then dataRif
										else nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale))
									 end), 'yyyy')
                             - to_char(am_stato_occupaz.datinizio,'yyyy')) * 12
	  						 + to_char((case
										when nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)) > trunc(dataRif) then dataRif
										else nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale))
									 end), 'mm')
		                    - to_char(am_stato_occupaz.datinizio,'mm') + 1
						+ (case
	   	 	  				   when ((to_char((case
												when nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)) > trunc(dataRif) then dataRif
												else nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale))
											 end), 'yyyy')
	                                  - to_char(am_stato_occupaz.datinizio,'yyyy')) * 12
	   		  	   			   	      + to_char((case
													when nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)) > trunc(dataRif) then dataRif
													else nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale))
												 end), 'mm')
		                              - to_char(am_stato_occupaz.datinizio,'mm') + 1) > 1
							   then
	   						   		   -(case when
				   	 	  	  		  	 	 (30 - to_char(am_stato_occupaz.datinizio,'dd') + 1) < 16
						  				   	 then 1
						  				   	 when
				   	 	  	  			   	 (30 - to_char(am_stato_occupaz.datinizio,'dd') + 1) >= 15
						  				   	 then 0
					  				   end)
					  				   -(case when
											 to_char((case
												when nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)) > trunc(dataRif) then dataRif
												else nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale))
											 end), 'dd') < 16
						  					  then 1
						  					  when
				   	 	  	  				  to_char((case
													when nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)) > trunc(dataRif) then dataRif
													else nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale))
												 end), 'dd') >= 15
						  					  then 0
					  					end)

			 				  when
			 	  			  	  ((to_char((case
										when nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)) > trunc(dataRif) then dataRif
										else nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale))
									 end), 'yyyy')
	                                - to_char(am_stato_occupaz.datinizio,'yyyy')) * 12
	   		  	  			  	  	+ to_char((case
											when nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)) > trunc(dataRif) then dataRif
											else nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale))
										 end), 'mm')
	                                - to_char(am_stato_occupaz.datinizio,'mm') + 1) = 1
			 				  then
			 	 			  	  -(case when
			   	 	  	  		  		 (to_char((case
												when nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)) > trunc(dataRif) then dataRif
												else nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale))
											 end), 'dd')
		                                 - to_char(am_stato_occupaz.datinizio,'dd') + 1) < 16
					  					 then 1
					    		         when
			   	 	  	  	 			 (to_char((case
												when nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale)) > trunc(dataRif) then dataRif
												else nvl(am_stato_occupaz.datfine, (select trunc(dat150)-1 from ts_generale))
											 end), 'dd')
		                                 - to_char(am_stato_occupaz.datinizio,'dd') + 1) >= 15
					    				 then 0
				  				    end)
			 				  end))) mesi_rischio_disocc,
									 am_stato_occupaz.datinizio datinizio, nvl(am_stato_occupaz.datfine,(select trunc(dat150)-1 from ts_generale)) datfine
		  FROM am_stato_occupaz
		   WHERE am_stato_occupaz.cdnlavoratore = cdnLav
		   AND am_stato_occupaz.codstatooccupaz = 'B3'
		   AND trunc(am_stato_occupaz.datinizio) >= trunc(dataCalcoloAnzianita)
		   AND trunc(am_stato_occupaz.datinizio) <= trunc(dataRif)
		   AND trunc(am_stato_occupaz.datinizio) < (select trunc(dat150) from ts_generale)
		   order by am_stato_occupaz.datinizio asc;


	CURSOR cursorStatoOcc150 IS
		select occ.datinizio datinizio, nvl(occ.datfine, sysdate) datfine
		  FROM am_stato_occupaz occ
		   WHERE occ.cdnlavoratore = cdnLav
		   AND occ.codstatooccupaz = 'B3'
		   AND trunc(occ.datinizio) >= trunc(dataCalcoloAnzianita)
		   AND trunc(occ.datinizio) <= trunc(dataRif)
		   AND trunc(occ.datinizio) >= (select trunc(dat150) from ts_generale)
		   order by occ.datinizio asc;

	rec_StatoOcc150 cursorStatoOcc150%ROWTYPE;
	giorniSospTotali150 number := 0;
	giorniSospRestanti150 number := 0;
	p_datdatainizio am_stato_occupaz.datinizio%type;
	p_datdatafine am_stato_occupaz.datfine%type;
	rec_StatoOcc cursorStatoOcc%ROWTYPE;
	p_mesi_rischio_disocc number := 0;
	mesePrecIsSospeso boolean := false;
	calcolaSosp150 boolean := false;
	annoPrec number := 0;
	mesePrec number := 0;
	giornoDataInizio number;
	giornoDataFine number;
	annoDataInizio number;
	annoDataFine number;
	meseDataInizio number;
	meseDataFine number;
	differenzaMesi number := 0;

begin

	for rec_StatoOcc in cursorStatoOcc loop
		p_mesi_rischio_disocc := p_mesi_rischio_disocc + nvl(rec_StatoOcc.mesi_rischio_disocc,0);
		p_datdatainizio := rec_StatoOcc.datinizio;
		p_datdatafine := rec_StatoOcc.datfine;
		annoPrec := to_number(to_char(p_datdatafine, 'yyyy'));
		mesePrec := to_number(to_char(p_datdatafine, 'mm'));
	end loop;

	annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
	meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));
	annoDataFine := to_number(to_char(p_datdatafine, 'yyyy'));
	meseDataFine := to_number(to_char(p_datdatafine, 'mm'));

	if (annoDataInizio = annoDataFine and meseDataInizio = meseDataFine) then
		if ((to_number(to_char(p_datdatafine, 'dd')) - to_number(to_char(p_datdatainizio, 'dd')) + 1) >= 15) then
			mesePrecIsSospeso := true;
		end if;
	else
		if (to_number(to_char(p_datdatafine,'dd')) >= 15) then
			mesePrecIsSospeso := true;
		end if;
	end if;

	for rec_StatoOcc150 in cursorStatoOcc150 loop
		p_datdatainizio := rec_StatoOcc150.datinizio;
		p_datdatafine := rec_StatoOcc150.datfine;

		if (trunc(p_datdatafine) > trunc(dataRif)) then
			p_datdatafine := dataRif;
		end if;

		annoDataInizio := to_number(to_char(p_datdatainizio, 'yyyy'));
		meseDataInizio := to_number(to_char(p_datdatainizio, 'mm'));
		annoDataFine := to_number(to_char(p_datdatafine, 'yyyy'));
		meseDataFine := to_number(to_char(p_datdatafine, 'mm'));

		calcolaSosp150 := true;

		if (mesePrecIsSospeso) then
			-- il mese e'' stato considerato come sospeso secondo le regole prima del decreto 150 e quindi non vanno considerati i giorni
			-- di sospensione nel calcolo post decreto 150
			if (annoPrec = annoDataInizio and mesePrec = meseDataInizio) then
				if (annoPrec = annoDataFine and mesePrec = meseDataFine) then
					calcolaSosp150 := false;
				else
					if (meseDataInizio = 12) then
						p_datdatainizio := to_date('01/01/' || to_char(annoDataInizio + 1), 'dd/mm/yyyy');
						meseDataInizio := 1;
						annoDataInizio := annoDataInizio + 1;
					else
						p_datdatainizio := to_date('01/' || to_char(meseDataInizio + 1) || '/' || to_char(annoDataInizio), 'dd/mm/yyyy');
						meseDataInizio := meseDataInizio + 1;
					end if;
				end if;
			end if;
		end if;

		if (calcolaSosp150) then
			differenzaMesi := (((to_number(to_char(p_datdatafine, 'yyyy')) - to_number(to_char(p_datdatainizio, 'yyyy'))) * 12) +
				to_number(to_char(p_datdatafine, 'mm')) - to_number(to_char(p_datdatainizio, 'mm')) + 1) - 2;
			if (differenzaMesi > 0) then
				giornoDataInizio := to_number(to_char(p_datdatainizio, 'dd'));
				if (giornoDataInizio = to_number(to_char(LAST_DAY(to_date('01/' || to_char(p_datdatainizio, 'mm') || '/' || to_char(p_datdatainizio, 'yyyy'), 'dd/mm/yyyy')), 'dd'))) then
					giorniSospTotali150 := giorniSospTotali150 + 1;
				else
					giorniSospTotali150 := giorniSospTotali150 + (30 - giornoDataInizio + 1);
				end if;
				giorniSospTotali150 := giorniSospTotali150 + (30 * (differenzaMesi));
				giornoDataFine := to_number(to_char(p_datdatafine, 'dd'));
				if (giornoDataFine > 30) then
					giornoDataFine := 30;
				else
					if (meseDataFine = 2 and giornoDataFine = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))) then
						giornoDataFine := 30;
					end if;
				end if;
				giorniSospTotali150 := giorniSospTotali150 + giornoDataFine;
			else
				if (differenzaMesi < 0) then
					-- sospensione nello stesso mese
					if ( (meseDataInizio = 2) and
						 ((trunc(p_datdatafine) - trunc(p_datdatainizio) + 1) = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))
					   ) ) then
					   giorniSospTotali150 := giorniSospTotali150 + 30;
					else
						if ((trunc(p_datdatafine) - trunc(p_datdatainizio) + 1) > 30) then
							giorniSospTotali150 := giorniSospTotali150 + 30;
						else
							giorniSospTotali150 := giorniSospTotali150 + (trunc(p_datdatafine) - trunc(p_datdatainizio) + 1);
						end if;
					end if;
				else
					-- sospensione a cavallo di due mesi
					giornoDataInizio := to_number(to_char(p_datdatainizio, 'dd'));
					if (giornoDataInizio = to_number(to_char(LAST_DAY(to_date('01/' || to_char(p_datdatainizio, 'mm') || '/' || to_char(p_datdatainizio, 'yyyy'), 'dd/mm/yyyy')), 'dd'))) then
						giorniSospTotali150 := giorniSospTotali150 + 1;
					else
						giorniSospTotali150 := giorniSospTotali150 + (30 - giornoDataInizio + 1);
					end if;
					giornoDataFine := to_number(to_char(p_datdatafine, 'dd'));
					if (giornoDataFine > 30) then
						giornoDataFine := 30;
					else
						if (meseDataFine = 2 and giornoDataFine = to_number(to_char(LAST_DAY(to_date('01/02/' || to_char(annoDataFine), 'dd/mm/yyyy')), 'dd'))) then
							giornoDataFine := 30;
						end if;
					end if;
					giorniSospTotali150 := giorniSospTotali150 + giornoDataFine;
				end if;
			end if;
		end if;

	end loop;

	if (giorniSospTotali150 > 0) then
		giorniSospRestanti150 := MOD(giorniSospTotali150,30);
		p_mesi_rischio_disocc := p_mesi_rischio_disocc + trunc(giorniSospTotali150/30);
	end if;

	return to_char(p_mesi_rischio_disocc) || '-' || to_char(giorniSospRestanti150);

end MesiRischioDisoccupazionePar;


FUNCTION CalcolaAnzianita (cdnLav IN an_lavoratore.cdnlavoratore%type, dataCalcolo IN varchar2) return varchar2 is
	mesiSosp number := 0;
	mesiSospFornero number := 0;
	mesiSospForneroCompleto varchar2(50);
	giorniSospRestanti number := 0;
	mesiRischioDisocc number := 0;
	giorniRischioDisocc number := 0;
	mesiAnz number := 0;
	giorniAnz number := 0;
	differenzaMesi number := 0;
	mesiRischioDisoccCompleto varchar2(50);
	mesiAnzPrec number := 0;
	mesiSospPrec number := 0;
	calcolaAnz boolean := true;
	mesiAggiuntivi number := 0;
	meseDiffAnzianitaGiorni int;
	meseResiduoAnzianita int := 0;
	numVarMesiTotAnz int;
	giorniResiduiAnz int;
begin

	BEGIN

		SELECT  to_number(substr(PG_MOVIMENTI.MesiSospFornero2014AllaData(cdnLav, to_date(dataCalcolo, 'dd/mm/yyyy'), am_stato_occupaz.datcalcolomesisosp), 1,
				instr(PG_MOVIMENTI.MesiSospFornero2014AllaData(cdnLav, to_date(dataCalcolo, 'dd/mm/yyyy'), am_stato_occupaz.datcalcolomesisosp), '-', 1)-1)),
				PG_MOVIMENTI.MesiSospFornero2014AllaData(cdnLav, to_date(dataCalcolo, 'dd/mm/yyyy'), am_stato_occupaz.datcalcolomesisosp),
		 (case
			when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I')
			then MESISOSPPRECFORNEROALLADATA(cdnLav, am_stato_occupaz.datcalcolomesisosp, to_date(dataCalcolo, 'dd/mm/yyyy'))
			when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG not in ('D','I')
			then 0
		end),
         (case
    		when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I')
        	   then
               (to_number(
							(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'yyyy')
                             - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
	  						 + to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'mm')
		                    - to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1
						+ (case
	   	 	  				   when ((to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'yyyy')
	                                  - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
	   		  	   			   	      + to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'mm')
		                              - to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) > 1
							   then
	   						   		   -(case when
										 trunc(am_stato_occupaz.datcalcoloanzianita) >= (select trunc(dat150) from ts_generale)
											then 2 - (trunc( (
												(case
												  when to_number(to_char(LAST_DAY(to_date('01/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'mm') || '/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'yyyy'), 'dd/mm/yyyy')), 'dd')) =
													   to_number(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'dd'))
												  then 30
												  else to_number(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'dd'))
												end) + (30 -
														(case
														  when to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd')) < 31
														  then to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd'))
														  else 30
														end) + 1
													  )) /30))
										 when
										 (30 - to_char(am_stato_occupaz.datcalcoloanzianita,'dd') + 1) < 16
										 then 1
										 when
										 (30 - to_char(am_stato_occupaz.datcalcoloanzianita,'dd') + 1) >= 15
										 then 0
								   	 end)
								   	 -(case when
										  trunc(am_stato_occupaz.datcalcoloanzianita) < (select trunc(dat150) from ts_generale) and to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'dd') < 16
										  then 1
										  when
										  trunc(am_stato_occupaz.datcalcoloanzianita) < (select trunc(dat150) from ts_generale) and to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'dd') >= 15
										  then 0
										  else 0
									 end)
			 				  when
			 	  			  	  ((to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'yyyy')
	                                - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
	   		  	  			  	  	+ to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'mm')
	                                - to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) = 1
			 				  then
			 				  	  -(case when
										trunc(am_stato_occupaz.datcalcoloanzianita) >= (select trunc(dat150) from ts_generale) and
										 (to_number(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) =
										 to_number(to_char(LAST_DAY(to_date('01/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'mm') || '/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'yyyy'), 'dd/mm/yyyy')), 'dd'))
										 then 0
										 when
										 trunc(am_stato_occupaz.datcalcoloanzianita) >= (select trunc(dat150) from ts_generale) and
										 (to_number(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) <>
										 to_number(to_char(LAST_DAY(to_date('01/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'mm') || '/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'yyyy'), 'dd/mm/yyyy')), 'dd'))
										 then 1
										 when trunc(am_stato_occupaz.datcalcoloanzianita) < (select trunc(dat150) from ts_generale) and
										 (to_number(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) < 16
										 then 1
										 when trunc(am_stato_occupaz.datcalcoloanzianita) < (select trunc(dat150) from ts_generale) and
										 (to_number(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) >= 15
										 then 0
							     end)
			 				  end)))
             when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG not in ('D','I')
             then
                  0
         end), --mesi_anz
         (case
			when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I')
			   then
					(case
						when ((to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'yyyy')
							  - to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
							  + to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'mm')
							  - to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) > 1
						then
							   (case when
								 trunc(am_stato_occupaz.datcalcoloanzianita) >= (select trunc(dat150) from ts_generale)
									then mod(
									((case
										  when to_number(to_char(LAST_DAY(to_date('01/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'mm') || '/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'yyyy'), 'dd/mm/yyyy')), 'dd')) =
											   to_number(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'dd'))
										  then 30
										  else to_number(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'dd'))
										end) +
										(30 -
											(case
											  when to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd')) < 31
											  then to_number(to_char(am_stato_occupaz.datcalcoloanzianita, 'dd'))
											  else 30
											end) + 1
										  )
									), 30)
								  else 0
								end)
						when
						  ((to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'yyyy')
							- to_char(am_stato_occupaz.datcalcoloanzianita,'yyyy')) * 12
							+ to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'mm')
							- to_char(am_stato_occupaz.datcalcoloanzianita,'mm') + 1) = 1
							then
								(case when
									trunc(am_stato_occupaz.datcalcoloanzianita) >= (select trunc(dat150) from ts_generale)
									  and (to_number(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) =
										   to_number(to_char(LAST_DAY(to_date('01/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'mm') || '/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'yyyy'), 'dd/mm/yyyy')), 'dd'))
									then 0
									when
									  trunc(am_stato_occupaz.datcalcoloanzianita) >= (select trunc(dat150) from ts_generale)
									  and (to_number(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1) <>
										   to_number(to_char(LAST_DAY(to_date('01/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'mm') || '/' || to_char(to_date(dataCalcolo, 'dd/mm/yyyy'), 'yyyy'), 'dd/mm/yyyy')), 'dd'))
									then (to_number(to_char(to_date(dataCalcolo, 'dd/mm/yyyy'),'dd')) - to_number(to_char(am_stato_occupaz.datcalcoloanzianita,'dd')) + 1)
									else 0
								end)
						else 0
					end)
			 when de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG not in ('D','I')
			 then 0
		end), --giorni_anz
         substr(PG_MOVIMENTI.MesiRischioDisoccupazionePar(am_stato_occupaz.cdnLavoratore, am_stato_occupaz.datcalcoloanzianita, to_date(dataCalcolo, 'dd/mm/yyyy')), 1,
			instr(PG_MOVIMENTI.MesiRischioDisoccupazionePar(am_stato_occupaz.cdnLavoratore, am_stato_occupaz.datcalcoloanzianita, to_date(dataCalcolo, 'dd/mm/yyyy')), '-', 1)-1),
         PG_MOVIMENTI.MesiRischioDisoccupazionePar(am_stato_occupaz.cdnLavoratore, am_stato_occupaz.datcalcoloanzianita, to_date(dataCalcolo, 'dd/mm/yyyy')),
         to_number(am_stato_occupaz.NUMANZIANITAPREC297),
         to_number(am_stato_occupaz.NUMMESISOSP)
	into mesiSospFornero, mesiSospForneroCompleto, mesiSosp, mesiAnz, giorniAnz, mesiRischioDisocc, mesiRischioDisoccCompleto, mesiAnzPrec, mesiSospPrec
    FROM am_stato_occupaz
         INNER JOIN de_stato_occupaz ON (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
         INNER JOIN de_stato_occupaz_ragg ON (de_stato_occupaz.codstatooccupazragg = de_stato_occupaz_ragg.codstatooccupazragg)
   WHERE am_stato_occupaz.cdnlavoratore = cdnLav and de_stato_occupaz_ragg.CODSTATOOCCUPAZRAGG in ('D','I')
		 and to_date(dataCalcolo, 'dd/mm/yyyy') between trunc(am_stato_occupaz.datinizio) and trunc(nvl(am_stato_occupaz.datfine, sysdate));

	EXCEPTION
		WHEN NO_DATA_FOUND THEN calcolaAnz := false;
		WHEN OTHERS THEN calcolaAnz := false;
	END;

	giorniSospRestanti := 0;
	mesiAggiuntivi := 0;
	meseDiffAnzianitaGiorni := 0;
	meseResiduoAnzianita := 0;
	numVarMesiTotAnz := 0;
	giorniResiduiAnz := 0;

	if (calcolaAnz) then

		if (mesiAnz is null) then
			mesiAnz := 0;
		end if;

		if (mesiSosp is null) then
			mesiSosp := 0;
		end if;

		if (mesiSospFornero is null) then
			mesiSospFornero := 0;
		end if;

		if (mesiRischioDisocc is null) then
			mesiRischioDisocc := 0;
		end if;

		if (giorniAnz is null) then
			giorniAnz := 0;
		end if;

		if (mesiAnzPrec is null) then
		   mesiAnzPrec := 0;
		end if;

		if (mesiSospPrec is null) then
		   mesiSospPrec := 0;
		end if;

		if (mesiRischioDisoccCompleto is not null) then
			giorniSospRestanti := to_number(substr(mesiRischioDisoccCompleto, instr(mesiRischioDisoccCompleto, '-', 1, 1)+1));
		end if;

		if (mesiSospForneroCompleto is not null) then
			giorniSospRestanti := giorniSospRestanti + to_number(substr(mesiSospForneroCompleto, instr(mesiSospForneroCompleto, '-', 1, 1)+1));
		end if;

		mesiAggiuntivi := trunc(giorniSospRestanti/30);

		if (giorniAnz >= mod(giorniSospRestanti,30)) then
			giorniAnz := giorniAnz - mod(giorniSospRestanti,30);
			giorniResiduiAnz := giorniAnz;
		else
			if (mod(giorniSospRestanti,30) > 0) then
				giorniAnz := giorniAnz + (30 - (mod(giorniSospRestanti,30)));
				meseDiffAnzianitaGiorni := 1;
			end if;
			if (giorniAnz > 0) then
				giorniResiduiAnz := mod(giorniAnz,30);
			end if;
		end if;

		numVarMesiTotAnz := mesiAnzPrec + mesiAnz;
		numVarMesiTotAnz := numVarMesiTotAnz - (mesiSosp + mesiSospFornero + mesiSospPrec + mesiRischioDisocc + mesiAggiuntivi);
		if (numVarMesiTotAnz > 0 and meseDiffAnzianitaGiorni > 0) then
			numVarMesiTotAnz := numVarMesiTotAnz - meseDiffAnzianitaGiorni;
		end if;

	END IF;

	return to_char(numVarMesiTotAnz) || '-' || to_char(giorniResiduiAnz);

end CalcolaAnzianita;
----------------------------------------------------------------------------------
--Procedura per la gestione della modifica forzata dei movimenti di un lavoratore
----------------------------------------------------------------------------------
PROCEDURE ModificaForzataMovimenti (prgMovForz IN AM_FORZATURA.PRGFORZATURA%TYPE,
                                    utenteForz IN AM_FORZATURA.CDNUTINS%TYPE,
                                    errCodeOut out number) is
                                    
                                    
CURSOR cursorModForzataMov IS
    select fmov.*
      FROM am_forza_mov fmov
       WHERE fmov.prgforzatura = prgMovForz
       order by fmov.prgmovimento;
      
p_numklom am_forza_mov.numkloforzamov%type;
rowMov AM_MOVIMENTO%ROWTYPE;
p_datiniziomovForz am_forza_mov.datinizio%type;
p_datfinemoveffettForz am_forza_mov.datfinemoveffettiva%type;
fl_errElab boolean := false;
p_codstatoatto am_forza_mov.codstatoatto%type;
p_prgprec am_forza_mov.prgprec%type;
p_prgsucc am_forza_mov.prgsucc%type;
p_CodeOut number;
p_CodeOutInsErrore number;
p_CdnLavoratore am_movimento.cdnlavoratore%type;
p_prgmovforzdetail am_forza_mov.prgforzamov%type;


     
begin


for rec_MovForzati in cursorModForzataMov loop
   
   select mov.* into rowMov
      from am_movimento mov
    where mov.prgmovimento = rec_MovForzati.PRGMOVIMENTO;

    p_datiniziomovForz := rec_MovForzati.Datinizio;
    p_datfinemoveffettForz := rec_MovForzati.Datfinemoveffettiva;
    p_codstatoatto := rec_MovForzati.Codstatoatto;
    p_prgsucc      := rec_MovForzati.Prgsucc;
    p_prgprec      := rec_MovForzati.Prgprec;
    p_CdnLavoratore := rowMov.Cdnlavoratore;
    p_prgmovforzdetail := rec_MovForzati.Prgforzamov;
    
 if nvl(p_datfinemoveffettForz, to_date('31/12/9999', 'dd/mm/yyyy')) >= p_datiniziomovForz then
 
 --- Funzione che va a fare controlli preliminari sul movimento successivo 
 ----agganciato al movimento il elaborazione  
 
  p_CodeOut:=  CTRMODMOVSUCC(rec_MovForzati.Prgmovimento, p_prgsucc, utenteForz, p_datiniziomovForz, fl_errElab, rowMov,  p_datfinemoveffettForz);
  
 --- Se la fuzione ritorna un errore sui controlli effettuati viene inserito un record 
 ---- nella tabella degli errori AM_FORZAMOV_ESITO
  if p_CodeOut != 0 then
    p_CodeOutInsErrore :=InserisciErrore(p_prgmovforzdetail, p_CodeOut);
    fl_errElab := true;
  end if; 
 --- Funzione che va a fare controlli preliminari sul movimento precedente 
 ----agganciato al movimento il elaborazione  

  p_CodeOut:=  CTRMODMOVPREC(rec_MovForzati.Prgmovimento, p_prgprec, utenteForz, p_datiniziomovForz, rowMov, fl_errElab);
  
  if p_CodeOut != 0 then
    p_CodeOutInsErrore :=InserisciErrore(p_prgmovforzdetail, p_CodeOut);
    fl_errElab := true;
  end if;

 ---- Funzione che in caso di modifica dello stato dell'atto va ad effettuare i relativi
 ---- aggiornamenti nella tabella AM_DOCUMENTO
 
 if p_codstatoatto != rowMov.Codstatoatto then
    p_CodeOut:= ModCodStatoAtto(p_codstatoatto, utenteForz,  p_datiniziomovForz, rowMov, p_prgprec, p_prgsucc, p_datfinemoveffettForz, fl_errElab);
    if p_CodeOut != 0 then
      p_CodeOutInsErrore :=InserisciErrore(p_prgmovforzdetail, p_CodeOut);
      fl_errElab := true;
    end if;
 end if; 


---- Se durante l'elaborazione sono stati modificati i valori della tabella di dettaglio AM_FORZ_MOV
----- li vado ad aggiornare prima di Aggiornare il movimento
 
 if (nvl(p_datiniziomovForz, to_date('31/12/9999', 'dd/mm/yyyy')) != nvl(rec_MovForzati.Datinizio, to_date('31/12/9999', 'dd/mm/yyyy'))) 
   or (nvl(p_datfinemoveffettForz, to_date('31/12/9999', 'dd/mm/yyyy')) != nvl(rec_MovForzati.Datfinemoveffettiva, to_date('31/12/9999', 'dd/mm/yyyy'))) 
   or (p_codstatoatto != rec_MovForzati.Codstatoatto) 
   or (p_prgsucc != rec_MovForzati.Prgsucc) 
   or (p_prgprec != rec_MovForzati.Prgprec) then
   p_CodeOut := AggiornaMovimentoForzato(rec_MovForzati.Prgforzamov, utenteForz, p_prgsucc,p_prgprec,p_datiniziomovForz, p_datfinemoveffettForz,p_codstatoatto);
 end if;

--- Funzione che va a fare i relativi aggiornamenti nella tabella  AM_MOVIMENTO
  p_CodeOut:= AggiornaMovimento(rec_MovForzati.Prgmovimento, utenteForz, p_prgsucc,p_prgprec,p_datiniziomovForz,p_datfinemoveffettForz, rowMov, p_codstatoatto, fl_errElab);  
     
     if p_CodeOut != 0 then
       p_CodeOutInsErrore :=InserisciErrore(p_prgmovforzdetail, p_CodeOut);
       fl_errElab := true;
     end if;
   
 else 
   fl_errElab := true;
   errCodeOut := 14;
   p_CodeOutInsErrore :=InserisciErrore(p_prgmovforzdetail, errCodeOut);
 end if; 
end loop;

--- Procedura che va a fare il check sulle catene dei movimenti forzati aggiornati
--- per verificarne la congruenza

 if fl_errElab = false then
     CheckCatenaMovForzati(prgMovForz, fl_errElab); 
     if fl_errElab = false then
       errCodeOut := 0;
      else 
        errCodeOut := -1;
     end if;
  else
      errCodeOut := -1; 
 end if;

p_CodeOut := AggiornamentoEsitoTabForzatura(prgMovForz, errCodeOut);
 

EXCEPTION
     WHEN OTHERS THEN
         errCodeOut := -1; --errore generico

END;
-----------------------------------
FUNCTION  CTRMODMOVSUCC (
                        prgMov IN Am_Forza_Mov.Prgmovimento%type, 
                        prgMovSucc IN Am_Forza_Mov.Prgsucc%TYPE,
                        p_UtenteForz IN AM_FORZATURA.CDNUTINS%TYPE,
                        dataInizioMov IN Am_Forza_Mov.Datinizio%TYPE,
                        fl_errElab  IN OUT NOCOPY boolean,
                        rowMov  IN OUT NOCOPY AM_MOVIMENTO%ROWTYPE,
                        dataFineMovEff IN OUT NOCOPY Am_Forza_Mov.Datfinemoveffettiva%TYPE
                        ) 
  return number  is


codMonoTempoSucc AM_MOVIMENTO.CODMONOTEMPO%TYPE;
CodeOut number := 0;
rowMovSucc AM_MOVIMENTO%ROWTYPE;
p_data_inizio_mov_succ AM_MOVIMENTO.DATINIZIOMOV%TYPE;
p_data_fine_mov_succ   AM_MOVIMENTO.Datfinemov%TYPE;
p_numklomovsucc AM_MOVIMENTO.NUMKLOMOV%TYPE;


BEGIN
  
  if (rowMov.Codtipomov = 'CES') and (prgMovSucc is not null) then 
              fl_errElab := false;
              CodeOut := 12; ---Movimento di Cessazione ma progressivo Movimento Successivo valorizzato;
  else
     if prgMovSucc is not null  then 
         select movsucc.* into rowMovSucc 
             from am_movimento movsucc 
            where movsucc.prgmovimento = prgMovSucc;
            
            if rowMov.Codmonotempo = 'I' and rowMovSucc.Codmonotempo = 'D' then
               CodeOut := 9; ---PrgMovSucc Modificato ma stiamo passando da Movimento Tempo 
                        ----   Ind. a Mov a tempo Det.
            else 
              if rowMovSucc.Codtipomov = 'AVV' then
                CodeOut := 18;
                fl_errElab := true;
              else
                if rowMov.Codmonotempo = 'D' and rowMovSucc.Codmonotempo = 'D' then 

                     if rowMovSucc.Codtipomov = 'TRA' then 
                       p_data_inizio_mov_succ := rowMovsucc.Datiniziomov;
                       p_data_fine_mov_succ := rowMov.Datfinemov;
                       dataFineMovEff := rowMovSucc.Datiniziomov -1;
                       CodeOut:=  Aggiorna_DateMovSucc(prgMovSucc, p_data_inizio_mov_succ, p_data_fine_mov_succ, p_UtenteForz);
                     elsif rowMovSucc.Codtipomov = 'PRO' then
                       p_data_inizio_mov_succ := rowMovsucc.Datiniziomov;
                       dataFineMovEff := rowMovSucc.Datiniziomov -1;
                       p_data_fine_mov_succ := rowMovSucc.Datfinemov;
                       CodeOut:=  Aggiorna_DateMovSucc(prgMovSucc, p_data_inizio_mov_succ, p_data_fine_mov_succ, p_UtenteForz);
                     else 
                       dataFineMovEff := rowMovSucc.Datiniziomov;
                     end if; 
                 elsif rowMovSucc.Codtipomov = 'CES' then
                     dataFineMovEff := rowMovSucc.Datiniziomov ;
                 else 
                     dataFineMovEff := rowMovSucc.Datiniziomov -1;
                     p_data_inizio_mov_succ := rowMovsucc.Datiniziomov;
                     p_data_fine_mov_succ := rowMovsucc.Datfinemov;
                     CodeOut:=  Aggiorna_DateMovSucc(prgMovSucc, p_data_inizio_mov_succ, p_data_fine_mov_succ, p_UtenteForz);                   
                 end if;
              end if;
      end if;
      end if;
   end if;
          
  

 
 if rowMovsucc.Codtipomov = 'TRA' then
    rowMov.Codmonotipofine := 'T';
  elsif
    rowMovsucc.Codtipomov = 'CES' then
    rowMov.Codmonotipofine := 'C';
  elsif
    rowMovsucc.Codtipomov = 'PRO' then
    rowMov.Codmonotipofine := 'P';
  else
    rowMov.Codmonotipofine := null;
  end if;   
   
    
  return CodeOut;

EXCEPTION
     WHEN OTHERS THEN
         CodeOut := 100; --errore generico
END; 
----------------------------------------
-----------------------------------
FUNCTION CTRMODMOVPREC (prgMov IN Am_Forza_Mov.prgmovimento%type, 
                        prgMovPrec IN Am_Forza_Mov.Prgprec%TYPE,
                        p_UtenteForz IN AM_FORZATURA.CDNUTINS%TYPE,
                        p_datiniziomovForz IN Am_Forza_Mov.Datinizio%TYPE,
                        rowMov  IN OUT NOCOPY AM_MOVIMENTO%ROWTYPE,
                        fl_ErrElab IN OUT NOCOPY boolean) 
  return number  is


codMonoTempoPrec AM_MOVIMENTO.CODMONOTEMPO%TYPE;
CodeOut number :=0;
rowMovPrec AM_MOVIMENTO%ROWTYPE;
p_datfinemoveffettprec AM_MOVIMENTO.Datfinemoveffettiva%TYPE;
p_numklomovprec AM_MOVIMENTO.NUMKLOMOV%TYPE;


BEGIN
  
   
   if (rowMov.Codtipomov = 'AVV') and (prgMovPrec is not NULL) then 
           fl_ErrElab :=true; 
           CodeOut := 13; ---Movimento di Avviamento ma progressivo Movimento Precedente valorizzato;
   else  
      if prgMovPrec is not NULL then     
          select movprec.* into rowMovPrec 
             from am_movimento movprec 
            where movprec.prgmovimento = prgMovPrec;
          if rowMov.Codmonotempo = 'D' and rowMovPrec.codMonoTempo = 'I' then
              fl_ErrElab :=true;
              CodeOut := 10; ---PrgMovPrec Valorizzato ma stiamo passando da Stato Tempo   Det a tempo InDet.;
          else 
              if rowMov.Codtipomov = 'CES' and rowMovPrec.Codtipomov= 'CES' then
                  fl_ErrElab :=true; 
                   CodeOut := 17; ---Movimento di Avviamento ma progressivo Movimento Precedente valorizzato;
              else 
                   if rowMov.Codtipomov = 'CES' then
                     p_datfinemoveffettprec := p_datiniziomovForz;
                   else 
                     p_datfinemoveffettprec := p_datiniziomovForz - 1;
                   end if; 
              CodeOut := Aggiorna_DateMovPrec(prgMovPrec, p_datfinemoveffettprec, p_UtenteForz );
             end if;
          end if;  
         end if;                
     end if;

  
  return CodeOut;

EXCEPTION
     WHEN OTHERS THEN
         CodeOut := 100; --errore generico
END; 
------------------------------------------
-----------------------------------
FUNCTION ModCodStatoAtto (p_codstatoatto IN Am_Forza_Mov.Codstatoatto%type, 
                        utenteForz IN Am_FORZATURA.Cdnutins%TYPE,
                        p_datiniziomovForz IN Am_Forza_Mov.Datinizio%TYPE,
                        rowMov  IN OUT NOCOPY AM_MOVIMENTO%ROWTYPE,
                        p_prgprec IN OUT NOCOPY am_forza_mov.prgprec%type,
                        p_prgsucc IN OUT NOCOPY am_forza_mov.prgsucc%type,
                        p_datfinemoveffettForz IN OUT NOCOPY am_forza_mov.datfinemoveffettiva%TYPE,
                        fl_ErrElab IN OUT NOCOPY boolean) 
  return number  is
  
 p_codtipomov am_movimento.codtipomov%type;
 docPres number;
 p_numkloprot    am_protocollo.numkloprotocollo%TYPE;
 CodeOut number :=0;


BEGIN

---Controllo se esiste un Documento Collegato al Movimento da Protocollare/Annullare
   select count(*)
     into docPres
    from am_documento doc
      inner join am_documento_coll doc_coll on doc.prgdocumento = doc_coll.prgdocumento
       where doc.codtipodocumento = 'MV'||rowMov.Codtipomov and to_number(doc_coll.strchiavetabella) = rowMov.Prgmovimento;
  
 ---Se non esiste lo inserisco altrimenti lo modifico
  if p_codstatoatto = 'PR' then
   if docPres = 0 then
     CodeOut := InserisciNuovoDocumento(rowMov, utenteForz, p_datiniziomovForz);
     rowMov.Codmotannullamento := null;
   else
     CodeOut := ModificaDocumento(rowMov, utenteForz, p_codstatoatto); 
   end if;  
  else
     CodeOut := ModificaDocumento(rowMov, utenteForz, p_codstatoatto);
     rowMov.Codmotannullamento := 'UFF';
     p_prgsucc := null;
     p_prgprec := null;
     rowMov.Prgstatooccupaz := null;
     p_datfinemoveffettForz := rowMov.Datfinemoveffettiva;
  end if;   
    
if CodeOut != 0 then
   fl_ErrElab := true;
end if;
  
  return CodeOut;

EXCEPTION
     WHEN OTHERS THEN
         fl_ErrElab :=true;
         Return  -1; --errore Modifica Codice Stato Atto
END; 
-------------------------------------------
FUNCTION Aggiorna_DateMovSucc (prgMovSucc IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE, 
                              p_data_inizio_mov_succ IN AM_MOVIMENTO.DATINIZIOMOV%TYPE , 
                              p_data_fine_mov_succ IN AM_MOVIMENTO.DATFINEMOV%TYPE,
                              p_cdnutmod         IN AM_FORZATURA.CDNUTINS%TYPE)
  return number  is

p_numklomovsucc  AM_MOVIMENTO.NUMKLOMOV%TYPE;
queryWhere VARCHAR2(255);

BEGIN

select t.numklomov into p_numklomovsucc from AM_MOVIMENTO t where t.prgmovimento = prgMovSucc;   

   -- storicizzazione nella tabella di LOG
    queryWhere :=  ' WHERE prgmovimento = ' || prgMovSucc;

    PG_LOG.doLog('U', 'AM_MOVIMENTO', p_cdnutmod, queryWhere);   

   UPDATE AM_MOVIMENTO
     SET datiniziomov = p_data_inizio_mov_succ,
         datfinemov   = p_data_fine_mov_succ,
         datfinemoveffettiva = p_data_fine_mov_succ,
         cdnutmod       = p_cdnutmod,
         DTMMOD          =sysdate,
         numklomov   =  p_numklomovsucc + 1
    WHERE
        prgmovimento = prgMovSucc;
    
  
  return 0;

EXCEPTION
     WHEN OTHERS THEN
         Return -1; --errore generico
END; 

-------------------------------
FUNCTION Aggiorna_DateMovPrec (prgMovPrec IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE, 
                              p_datfinemoveffettprec IN AM_MOVIMENTO.DATFINEMOVEFFETTIVA%TYPE, 
                              p_cdnutmod         IN AM_FORZATURA.CDNUTINS%TYPE)
  return number  is
  
queryWhere VARCHAR2(255); 
 p_numklomovprec AM_MOVIMENTO.NUMKLOMOV%TYPE;

BEGIN
  
select t.numklomov into p_numklomovprec from AM_MOVIMENTO t where t.prgmovimento = prgMovPrec; 

   -- storicizzazione nella tabella di LOG
    queryWhere :=  ' WHERE prgmovimento = ' || prgMovPrec;

    PG_LOG.doLog('U', 'AM_MOVIMENTO', p_cdnutmod, queryWhere);
      
   UPDATE AM_MOVIMENTO
     SET datfinemov   = p_datfinemoveffettprec,
         cdnutmod       = p_cdnutmod,
         DTMMOD          =sysdate,     
         numklomov   =  p_numklomovprec + 1
    WHERE
        prgmovimento = prgMovPrec;
    
  
  return 0;

EXCEPTION
     WHEN OTHERS THEN
       dbms_output.put_line('Errore Aggiorna_DateMovPrec = ' || sqlcode || ' ' || sqlerrm );
         Return 100; --errore generico
END; 

--------------------------------------------------

FUNCTION InserisciNuovoDocumento (rowMov IN AM_MOVIMENTO%ROWTYPE, 
                               utenteForz IN Am_FORZATURA.Cdnutins%TYPE,
                               p_datiniziomovForz IN Am_Forza_Mov.Datinizio%TYPE
                               ) 
  return number  is
  
 p_codtipomov am_movimento.codtipomov%type;
 docPres number;
 p_cdncomponente ts_componente.cdncomponente%TYPE;
 p_annoprot varchar2(4);
 p_NumProtocollo AM_PROTOCOLLO.NUMPROTOCOLLO%TYPE;
 p_numkloprot    AM_PROTOCOLLO.NUMKLOPROTOCOLLO%TYPE;
 p_prgdoc AM_DOCUMENTO.PRGDOCUMENTO%TYPE;
 p_prgblob number;
 p_prgDocColl AM_DOCUMENTO_COLL.PRGDOCUMENTOCOLL%TYPE;
 CodeOut number;

BEGIN
  select to_char(sysdate, 'YYYY') into p_annoprot from dual ;

  SELECT AM_PROTOCOLLO.NUMPROTOCOLLO +1 NUMPROTOCOLLO, 
   AM_PROTOCOLLO.NUMKLOPROTOCOLLO
    INTO p_NumProtocollo, p_numkloprot
   FROM AM_PROTOCOLLO
      WHERE AM_PROTOCOLLO.NUMANNOPROT = p_annoprot;
      
    CodeOut:= PG_GESTAMM.insertDocumento(p_prgdoc,
                                         rowMov.Codcpi,
                                         rowMov.Cdnlavoratore,
                                         rowMov.Prgazienda,
                                         rowMov.Prgunita,
                                         'MV'||rowMov.Codtipomov,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         to_char(p_datiniziomovForz, 'DD/MM/YYYY'),
                                         NULL,
                                         NULL,
                                         'I',
                                         to_char(rowMov.Datcomunicaz, 'DD/MM/YYYY'),
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         to_number(p_annoprot),
                                         p_NumProtocollo,
                                         NULL,
                                         utenteForz,
                                         utenteForz,
                                         to_char(sysdate, 'DD/MM/YYYY HH24:MI:SS'),
                                         'PR',
                                         p_prgblob,
                                         'movdettagliogeneraleconsultapage',
                                         p_prgDocColl,
                                         rowMov.Prgmovimento);

        UPDATE AM_PROTOCOLLO
          SET AM_PROTOCOLLO.NUMPROTOCOLLO = p_NumProtocollo ,
              AM_PROTOCOLLO.NUMKLOPROTOCOLLO = p_numkloprot +1
         WHERE AM_PROTOCOLLO.NUMANNOPROT = to_number(p_annoprot);
 

                                         
   return 0;

EXCEPTION
     WHEN OTHERS THEN
       dbms_output.put_line('Errore Inserimento_Nuovo_Documento= ' || sqlcode || ' ' || sqlerrm);  
        Return 14; --errore generico
END; 
-------------------------------------------       
FUNCTION ModificaDocumento (rowMov IN AM_MOVIMENTO%ROWTYPE, 
                               utenteForz IN Am_FORZATURA.Cdnutins%TYPE,
                               p_codstatoatto IN AM_MOVIMENTO.Codstatoatto%TYPE
                              ) 
  return number  is
  
 p_prgdocumento AM_DOCUMENTO.PRGDOCUMENTO%TYPE;
 p_numklodocumento AM_DOCUMENTO.NUMKLODOCUMENTO%TYPE;
 CodeOut number;
 queryWhere VARCHAR2(255);

BEGIN
  
  select doc.prgdocumento, doc.numklodocumento 
   into p_prgdocumento, p_numklodocumento
from am_documento doc
inner join am_documento_coll doc_coll on doc.prgdocumento = doc_coll.prgdocumento
    where doc.codtipodocumento = 'MV'||rowMov.Codtipomov and to_number(doc_coll.strchiavetabella) = rowMov.Prgmovimento;

   -- storicizzazione nella tabella di LOG
    queryWhere :=  ' WHERE prgdocumento = ' || p_prgdocumento;

    PG_LOG.doLog('U', 'AM_DOCUMENTO', utenteForz, queryWhere); 

  if p_codstatoatto = 'PR' then 
       UPDATE AM_DOCUMENTO t
          SET t.codstatoatto = 'PR',
              t.codmotannullamentoatto = null,
              t.dtmmod =sysdate,
              t.cdnutmod = utenteForz ,
              t.numklodocumento = p_numklodocumento +1
         WHERE t.prgdocumento  = p_prgdocumento;
   else
      UPDATE AM_DOCUMENTO t
          SET t.codstatoatto = 'AN',
              t.codmotannullamentoatto = 'UFF',
              t.dtmmod =sysdate,
              t.cdnutmod = utenteForz ,
              t.numklodocumento = p_numklodocumento +1
         WHERE t.prgdocumento  = p_prgdocumento;
     end if;
  CodeOut := 0;
   return CodeOut;

EXCEPTION
     WHEN OTHERS THEN
         dbms_output.put_line('Errore MODIFICA_DOCUMENTO = ' || sqlcode || ' ' || sqlerrm); 
         Return 15; --errore generico
END; 
----------------------------------------------------------
FUNCTION AggiornaMovimento (   prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE,
                               p_cdnutmod         IN AM_FORZATURA.CDNUTINS%TYPE,
                               p_prgsucc IN AM_MOVIMENTO.PRGMOVIMENTOSUCC%TYPE,
                               p_prgprec IN AM_MOVIMENTO.PRGMOVIMENTOPREC%TYPE,
                               p_datiniziomovForz IN AM_MOVIMENTO.DATINIZIOMOV%TYPE,
                               p_datfinemoveffettForz IN AM_MOVIMENTO.DATFINEMOVEFFETTIVA%TYPE,
                               rowMov IN AM_MOVIMENTO%ROWTYPE, 
                               p_codstatoatto IN AM_MOVIMENTO.Codstatoatto%TYPE,
                               f_ErrElab      IN OUT NOCOPY boolean
                              ) 
         return number  is
                              
p_numklomov AM_MOVIMENTO.NUMKLOMOV%TYPE;
CodeOut number :=0;
 queryWhere VARCHAR2(255);
BEGIN
  
 select numklomov into p_numklomov from am_movimento where prgmovimento = rowMov.Prgmovimento;
 
   -- storicizzazione nella tabella di LOG
    queryWhere :=  ' WHERE prgmovimento = ' || rowMov.Prgmovimento;

    PG_LOG.doLog('U', 'AM_MOVIMENTO', p_cdnutmod, queryWhere);   

 if p_datiniziomovForz <=  nvl(p_datfinemoveffettForz, to_date('31/12/9999', 'dd/mm/yyyy')) then
   if rowMov.Datfinemov is null then
       UPDATE AM_MOVIMENTO t
          SET t.prgmovimentoprec       = p_prgprec,
              t.prgmovimentosucc       = p_prgsucc,
              t.datiniziomov           = p_datiniziomovForz,
              t.datfinemoveffettiva    = p_datfinemoveffettForz,
              t.codstatoatto           = p_codstatoatto,
              t.datfinemov             = p_datfinemoveffettForz,
              t.codmonotipofine        = rowMov.Codmonotipofine,
              t.codmotannullamento     = rowMov.Codmotannullamento,
              t.prgstatooccupaz        = rowMov.Prgstatooccupaz,
              t.dtmmod                 = sysdate,
              t.cdnutmod               = p_cdnutmod,
              t.numklomov              =  p_numklomov + 1
         WHERE t.prgmovimento  = rowMov.Prgmovimento;
    else
      if nvl(p_datfinemoveffettForz, to_date('31/12/9999', 'dd/mm/yyyy')) <= rowMov.Datfinemov then
        UPDATE AM_MOVIMENTO t
          SET t.prgmovimentoprec       = p_prgprec,
              t.prgmovimentosucc       = p_prgsucc,
              t.datiniziomov           = p_datiniziomovForz,
              t.datfinemoveffettiva    = p_datfinemoveffettForz,
              t.codstatoatto           = p_codstatoatto,
              t.datfinemov             = rowMov.Datfinemov,
              t.codmonotipofine        = rowMov.Codmonotipofine,
              t.codmotannullamento     = rowMov.Codmotannullamento,
              t.prgstatooccupaz        = rowMov.Prgstatooccupaz,
              t.dtmmod                 = sysdate,
              t.cdnutmod               = p_cdnutmod,
              t.numklomov              = p_numklomov + 1
         WHERE t.prgmovimento  = rowMov.Prgmovimento;
       else
         CodeOut := 20;
         f_ErrElab :=true;
       end if;  
    end if;  
 else 
     CodeOut := 19;
     f_ErrElab :=true;
 end if;

   return CodeOut;

EXCEPTION
     WHEN OTHERS THEN
         f_ErrElab :=true;
         return  16; --errore generico
END; 
---------------------------------------------------
FUNCTION AggiornaMovimentoForzato (prgMovForzDett IN AM_FORZA_MOV.PRGFORZAMOV%TYPE,
                                   p_cdnutmod         IN AM_FORZATURA.CDNUTINS%TYPE,
                                   p_prgsucc IN AM_FORZA_MOV.PRGSUCC%TYPE,
                                   p_prgprec IN AM_FORZA_MOV.PRGPREC%TYPE,
                                   p_datiniziomovForz IN AM_FORZA_MOV.DATINIZIO%TYPE,
                                   p_datfinemoveffettForz IN AM_FORZA_MOV.DATFINEMOVEFFETTIVA%TYPE,
                                   p_codstatoatto IN AM_FORZA_MOV.CODSTATOATTO%TYPE ) 
         return number  is
PRAGMA AUTONOMOUS_TRANSACTION;
                              
p_numklomov AM_FORZA_MOV.NUMKLOFORZAMOV%TYPE;
CodeOut number :=0;
 queryWhere VARCHAR2(255);
BEGIN
  
 select numkloforzamov into p_numklomov from AM_FORZA_MOV t where t.prgforzamov = prgMovForzDett;
 
   -- storicizzazione nella tabella di LOG
    queryWhere :=  ' WHERE prgforzamov = ' || prgMovForzDett;

    PG_LOG.doLog('U', 'AM_FORZA_MOV', p_cdnutmod, queryWhere);   

 
       UPDATE AM_FORZA_MOV t
          SET t.prgprec                = p_prgprec,
              t.prgsucc                = p_prgsucc,
              t.datinizio              = p_datiniziomovForz,
              t.datfinemoveffettiva    = p_datfinemoveffettForz,
              t.codstatoatto           = p_codstatoatto,
              t.numkloforzamov         =  p_numklomov + 1
          WHERE t.prgforzamov = prgMovForzDett;

   commit;          
 

   return CodeOut;

EXCEPTION
     WHEN OTHERS THEN
         dbms_output.put_line('Errore Aggiorna Movimento Forzato= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return  100; --errore generico
END; 
---------------------------------------------------

FUNCTION AggiornamentoEsitoTabForzatura (prgForzatura IN AM_FORZATURA.PRGFORZATURA%TYPE,
                                         esito        IN AM_FORZATURA.NUMESITO%TYPE) 
         return number  is

PRAGMA AUTONOMOUS_TRANSACTION;
                              
CodeOut number :=0;

BEGIN

       UPDATE AM_FORZATURA t
          SET t.numesito                = esito
           WHERE t.prgforzatura = prgForzatura;

   commit;          
 

   return CodeOut;

EXCEPTION
     WHEN OTHERS THEN
         dbms_output.put_line('Errore Aggiorna Movimento Forzato= ' || sqlcode || ' ' || sqlerrm);
         rollback;
         return  100; --errore generico
END; 
---------------------------------------------------

FUNCTION InserisciErrore (   prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE, 
                               codErrore IN Number
                              ) 
  return number  is

 PRAGMA AUTONOMOUS_TRANSACTION;

BEGIN
  
  INSERT INTO AM_FORZAMOV_ESITO (PRGFORZAMOVESITO, PRGFORZAMOV, NUMESITO)
               VALUES (S_AM_FORZAMOV_ESITO.NEXTVAL, prgMov,CodErrore);
               
   COMMIT;
   
   Return 0;
 
EXCEPTION
     WHEN OTHERS THEN
       dbms_output.put_line('Errore InserisciErrore= ' || sqlcode || ' ' || sqlerrm);
         Return 12; --errore generico
END; 
---------

FUNCTION RicercaPrgDettaglio ( prgMovForz IN AM_FORZATURA.PRGFORZATURA%TYPE,  
                               prgMov     IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE
                              ) 
  return number  is
prgdetail  Am_Forza_Mov.Prgforzamov%TYPE ;
CodeOut number :=0;

BEGIN

select fmov.prgforzamov into prgdetail
      FROM am_forza_mov fmov
       WHERE fmov.prgforzatura = prgMovForz
       and fmov.prgmovimento = prgMov ;            
   
   
   Return prgdetail;
 
EXCEPTION
     WHEN OTHERS THEN
       dbms_output.put_line('Errore InserisciErrore= ' || sqlcode || ' ' || sqlerrm);
         Return -1; --errore generico
END; 

--------------------------------------------------------------
--Procedura di controllo di congruenza delle catene dei movimenti forzati
--------------------------------------------------------------

PROCEDURE CheckCatenaMovForzati(
                      prgMovForz IN AM_FORZA_MOV.PRGFORZAMOV%TYPE,
                      fl_errElab IN OUT NOCOPY boolean) is
                      
p_prgMovimento number :=0 ;
p_CodeOutInsErrore number;
p_CodeOut    number;
     
begin

p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOV_RIPETUTI_FORZ(prgMovForz );

if p_CodeOut != 0 then
   fl_errElab := true;
end if;

p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOV_SUCCESSIVI_FORZ(prgMovForz);

if p_CodeOut != 0 then
   fl_errElab := true;
end if;

p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOV_PRECEDENTI_FORZ(prgMovForz);

if p_CodeOut != 0 then
   fl_errElab := true;
end if;

p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOV_SUCC_APPR_FORZ(prgMovForz);

if p_CodeOut != 0 then
   fl_errElab := true;
end if;

p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOV_PREC_APPR_FORZ(prgMovForz);

if p_CodeOut != 0 then
   fl_errElab := true;
end if;

p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOV_SUCC_PREC_FORZ(prgMovForz);

if p_CodeOut != 0 then
   fl_errElab := true;
end if;

p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOV_PREC_SUCC_FORZ(prgMovForz);

if p_CodeOut != 0 then
   fl_errElab := true;
end if;

p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOV_PREC_AR_AN_FORZ(prgMovForz);

if p_CodeOut != 0 then
   fl_errElab := true;
end if;

p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOV_SUCC_AR_AN_FORZ(prgMovForz);

if p_CodeOut != 0 then
   fl_errElab := true;
end if;

EXCEPTION
     WHEN OTHERS THEN
         fl_errElab := true; --errore generico

END; 

--------------------------------------------------------------
-- Procedura di controllo di congruenza di tutte le catene dei movimenti 
-- del lavoratore
--------------------------------------------------------------                     

PROCEDURE CheckCatenaMovLavoratore(
                      p_CdnLavoratore IN AM_MOVIMENTO.CDNLAVORATORE%TYPE,
                      errCodOut OUT number) is
                      
p_prgMovimento number :=0 ;
p_CodeOutInsErrore number;
p_CodeOut    number;
     
begin

p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOVIMENTI_RIPETUTI(p_CdnLavoratore );

if p_CodeOut >0 then
  errCodOut := -1;
else
  errCodOut := 0;
  p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOVIMENTI_SUCCESSIVI(p_CdnLavoratore);
end if;



if p_CodeOut > 0 then
  errCodOut := -1;
else
  errCodOut := 0;
  p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOVIMENTI_PRECEDENTI(p_CdnLavoratore);
end if;

if p_CodeOut > 0 then
  errCodOut := -1;
else
  errCodOut := 0;
  p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOVIMENTI_SUCC_APPR(p_CdnLavoratore);
end if;

if p_CodeOut > 0 then
  errCodOut := -1;
else
  errCodOut := 0;
  p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOVIMENTI_PREC_APPR(p_CdnLavoratore); 
end if;



if p_CodeOut > 0 then
  errCodOut := -1;
else
  errCodOut := 0;
  p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOVIMENTI_SUCC_PREC(p_CdnLavoratore);
end if;



if p_CodeOut > 0 then
  errCodOut := -1;
else
  errCodOut := 0;
  p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOVIMENTI_PREC_SUCC(p_CdnLavoratore);
end if;


if p_CodeOut > 0 then
  errCodOut := -1;
else
  errCodOut := 0;
  p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOVIMENTI_PREC_AR_AN(p_CdnLavoratore);
end if;


if p_CodeOut > 0 then
  errCodOut := -1;
else
  errCodOut := 0;
  p_CodeOut := PG_MOV_CATENE_ERRATE.CHECK_MOVIMENTI_SUCC_AR_AN(p_CdnLavoratore);
end if;


EXCEPTION
     WHEN OTHERS THEN
         errCodOut :=-1; --errore generico

END;

END PG_MOVIMENTI;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_PORTALE.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_PORTALE IS
FUNCTION getVacancy RETURN VARCHAR2;
FUNCTION getVacancyModify RETURN VARCHAR2;
FUNCTION getXMLVacancy (prgRichiesta do_richiesta_az.prgrichiestaaz%type) RETURN CLOB;
FUNCTION getXMLVacancySIL (prgRichiesta do_richiesta_az.prgrichiestaaz%type, isAnteprima varchar2 DEFAULT 'N') RETURN CLOB;
FUNCTION updateDATA_MYP_VAC RETURN NUMBER;
END PG_PORTALE;
/
CREATE OR REPLACE PACKAGE BODY PG_PORTALE IS

FUNCTION getVacancy RETURN VARCHAR2 IS
	CURSOR cursorVacancy is
	  SELECT DISTINCT DO_RICHIESTA_AZ.PRGRICHIESTAAZ, DO_RICHIESTA_AZ.NUMANNO, DO_RICHIESTA_AZ.NUMRICHIESTA
	  FROM DO_RICHIESTA_AZ
	  INNER JOIN DO_ALTERNATIVA ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_ALTERNATIVA.PRGRICHIESTAAZ)
    INNER JOIN DO_EVASIONE ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_EVASIONE.PRGRICHIESTAAZ)
    INNER JOIN DE_EVASIONE_RICH DEEV ON (DEEV.CODEVASIONE = DO_EVASIONE.CODEVASIONE)
    INNER JOIN AN_AZIENDA AZ ON (DO_RICHIESTA_AZ.PRGAZIENDA = AZ.PRGAZIENDA)
    INNER JOIN AN_UNITA_AZIENDA UAZ ON (AZ.PRGAZIENDA = UAZ.PRGAZIENDA AND DO_RICHIESTA_AZ.PRGUNITA = UAZ.PRGUNITA)
    INNER JOIN DO_MANSIONE ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_MANSIONE.PRGRICHIESTAAZ AND DO_ALTERNATIVA.PRGALTERNATIVA = DO_MANSIONE.PRGALTERNATIVA)
    INNER JOIN DO_COMUNE ON (DO_COMUNE.PRGRICHIESTAAZ = DO_RICHIESTA_AZ.PRGRICHIESTAAZ)
    INNER JOIN DE_CPI ON (DO_RICHIESTA_AZ.CODCPI = DE_CPI.CODCPI)
    WHERE TRUNC(NVL(DO_RICHIESTA_AZ.DATSCADENZA, TO_DATE('01/01/2000 00:00', 'DD/MM/YYYY HH24:MI'))) >= TRUNC(SYSDATE)
    AND TRUNC(NVL(DO_RICHIESTA_AZ.DATSCADENZAPUBBLICAZIONE, TO_DATE('01/01/2000 00:00', 'DD/MM/YYYY HH24:MI'))) >= TRUNC(SYSDATE)
    AND DO_RICHIESTA_AZ.NUMSTORICO = 0
    AND DO_ALTERNATIVA.PRGALTERNATIVA = 1
    AND DEEV.CODEVASIONE IN ('DFA', 'DFD', 'DPR', 'DRA')
    AND DEEV.FLGPUBBLICA = 'S'
    AND DO_EVASIONE.CDNSTATORICH in (1, 2, 3)
    AND DO_RICHIESTA_AZ.FLGPUBBLICATA = 'S'
    AND DO_EVASIONE.FLGPUBBWEB = 'S'
    AND DO_MANSIONE.FLGINVIOCL = 'S'
    AND DO_COMUNE.FLGINVIOCL = 'S'
    AND do_richiesta_az.prgrichiestaaz NOT IN (SELECT PRGRICHIESTAAZ FROM CL_VACANCY CLVAC WHERE do_richiesta_az.prgrichiestaaz = clvac.prgrichiestaaz);

  rec_Vacancy cursorVacancy%ROWTYPE;
  prgRichiestaAzVar do_richiesta_az.prgrichiestaaz%type;

  vacancy_response varchar2(32767);

BEGIN

  vacancy_response := null;

  FOR rec_Vacancy IN cursorVacancy LOOP
    prgRichiestaAzVar := rec_Vacancy.prgRichiestaAz;
    if (vacancy_response is null) then
      vacancy_response := to_char(prgRichiestaAzVar);
    else
      vacancy_response := vacancy_response || '-' || to_char(prgRichiestaAzVar);
    end if;

  END LOOP;

  return vacancy_response;

EXCEPTION
    WHEN OTHERS THEN
      dbms_output.put_line('errore'||sqlcode ||' '||sqlerrm);
      return null;


END getVacancy;

FUNCTION getVacancyModify RETURN VARCHAR2 IS
  CURSOR cursorVacancy is
    SELECT DISTINCT DO_RICHIESTA_AZ.PRGRICHIESTAAZ, DO_RICHIESTA_AZ.NUMANNO, DO_RICHIESTA_AZ.NUMRICHIESTA
    FROM DO_RICHIESTA_AZ
    INNER JOIN DO_ALTERNATIVA ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_ALTERNATIVA.PRGRICHIESTAAZ)
    INNER JOIN DO_EVASIONE ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_EVASIONE.PRGRICHIESTAAZ)
    INNER JOIN DE_EVASIONE_RICH DEEV ON (DEEV.CODEVASIONE = DO_EVASIONE.CODEVASIONE)
    INNER JOIN AN_AZIENDA AZ ON (DO_RICHIESTA_AZ.PRGAZIENDA = AZ.PRGAZIENDA)
    INNER JOIN AN_UNITA_AZIENDA UAZ ON (AZ.PRGAZIENDA = UAZ.PRGAZIENDA AND DO_RICHIESTA_AZ.PRGUNITA = UAZ.PRGUNITA)
    INNER JOIN DO_MANSIONE ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_MANSIONE.PRGRICHIESTAAZ AND DO_ALTERNATIVA.PRGALTERNATIVA = DO_MANSIONE.PRGALTERNATIVA)
    INNER JOIN DO_COMUNE ON (DO_COMUNE.PRGRICHIESTAAZ = DO_RICHIESTA_AZ.PRGRICHIESTAAZ)
    INNER JOIN DE_CPI ON (DO_RICHIESTA_AZ.CODCPI = DE_CPI.CODCPI)
    LEFT JOIN DO_ABILITAZIONE_GEN ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_ABILITAZIONE_GEN.PRGRICHIESTAAZ)
    LEFT JOIN DO_LINGUA ON (DO_ALTERNATIVA.PRGRICHIESTAAZ = DO_LINGUA.PRGRICHIESTAAZ  AND DO_ALTERNATIVA.PRGALTERNATIVA = DO_LINGUA.PRGALTERNATIVA)
    LEFT JOIN DO_ORARIO ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_ORARIO.PRGRICHIESTAAZ)
    LEFT JOIN DO_INFO ON (DO_ALTERNATIVA.PRGRICHIESTAAZ = DO_INFO.PRGRICHIESTAAZ  AND DO_ALTERNATIVA.PRGALTERNATIVA = DO_INFO.PRGALTERNATIVA)
    LEFT JOIN DO_COMPETENZA ON (DO_ALTERNATIVA.PRGRICHIESTAAZ = DO_COMPETENZA.PRGRICHIESTAAZ  AND DO_ALTERNATIVA.PRGALTERNATIVA = DO_COMPETENZA.PRGALTERNATIVA)
    LEFT JOIN DO_STUDIO ON (DO_ALTERNATIVA.PRGRICHIESTAAZ = DO_STUDIO.PRGRICHIESTAAZ  AND DO_ALTERNATIVA.PRGALTERNATIVA = DO_STUDIO.PRGALTERNATIVA)
    LEFT JOIN DO_CONTRATTO ON (DO_ALTERNATIVA.PRGRICHIESTAAZ = DO_CONTRATTO.PRGRICHIESTAAZ  AND DO_ALTERNATIVA.PRGALTERNATIVA = DO_CONTRATTO.PRGALTERNATIVA)
    WHERE TRUNC(NVL(DO_RICHIESTA_AZ.DATSCADENZA, TO_DATE('01/01/2000 00:00', 'DD/MM/YYYY HH24:MI'))) >= TRUNC(SYSDATE)
    AND TRUNC(NVL(DO_RICHIESTA_AZ.DATSCADENZAPUBBLICAZIONE, TO_DATE('01/01/2000 00:00', 'DD/MM/YYYY HH24:MI'))) >= TRUNC(SYSDATE)
    AND DO_RICHIESTA_AZ.NUMSTORICO = 0
    AND DO_ALTERNATIVA.PRGALTERNATIVA = 1
    AND DEEV.CODEVASIONE IN ('DFA', 'DFD', 'DPR', 'DRA')
    AND DEEV.FLGPUBBLICA = 'S'
    AND DO_EVASIONE.CDNSTATORICH in (1, 2, 3, 4, 5)
    AND DO_RICHIESTA_AZ.FLGPUBBLICATA = 'S'
    AND DO_EVASIONE.FLGPUBBWEB = 'S'
    AND DO_MANSIONE.FLGINVIOCL = 'S'
    AND DO_COMUNE.FLGINVIOCL = 'S'
    AND (DO_RICHIESTA_AZ.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE OR
       DO_ALTERNATIVA.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE OR
       DO_EVASIONE.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE OR
       DO_MANSIONE.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE OR
       DO_ABILITAZIONE_GEN.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE OR
       DO_LINGUA.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE OR
       DO_ORARIO.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE OR
       DO_INFO.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE OR
       DO_COMPETENZA.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE OR
       DO_STUDIO.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE OR
       DO_CONTRATTO.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE OR
       DO_COMUNE.DTMMOD BETWEEN (SELECT DATETL FROM TS_MONITORAGGIO WHERE CODAMBITO = 'MYP_VAC') AND SYSDATE)
       AND do_richiesta_az.prgrichiestaaz NOT IN (SELECT PRGRICHIESTAAZ FROM CL_VACANCY CLVAC WHERE do_richiesta_az.prgrichiestaaz = clvac.prgrichiestaaz);

  rec_Vacancy cursorVacancy%ROWTYPE;
  prgRichiestaAzVar do_richiesta_az.prgrichiestaaz%type;

  vacancy_response varchar2(32767);

BEGIN

  vacancy_response := null;

  FOR rec_Vacancy IN cursorVacancy LOOP
    prgRichiestaAzVar := rec_Vacancy.prgRichiestaAz;
    if (vacancy_response is null) then
      vacancy_response := to_char(prgRichiestaAzVar);
    else
      vacancy_response := vacancy_response || '-' || to_char(prgRichiestaAzVar);
    end if;

  END LOOP;

  return vacancy_response;

EXCEPTION
    WHEN OTHERS THEN
      dbms_output.put_line('errore'||sqlcode ||' '||sqlerrm);
      return null;


END getVacancyModify;

FUNCTION getXMLVacancy (prgRichiesta do_richiesta_az.prgrichiestaaz%type) RETURN CLOB IS

  doc xmldom.DOMDocument;
  main_node xmldom.DOMNode;
  root_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;
  item_node xmldom.DOMNode;
  datLav_node xmldom.DOMNode;
  datAnag_node xmldom.DOMNode;
  cf_node xmldom.DOMNode;
  denominazione_node xmldom.DOMNode;
  indlav_node xmldom.DOMNode;
  codcom_node xmldom.DOMNode;
  settore_node xmldom.DOMNode;
  web_node xmldom.DOMNode;
  datContatto_node xmldom.DOMNode;
  datContattoAlter_node xmldom.DOMNode;
  cognref_node xmldom.DOMNode;
  mailContatta_node xmldom.DOMNode;
  mailContattoAlter_node xmldom.DOMNode;
  richiesta_node xmldom.DOMNode;
  profilo_node xmldom.DOMNode;
  numlav_node xmldom.DOMNode;
  attivitaGruppo_node xmldom.DOMNode;
  professione_node xmldom.DOMNode;
  descprofessione_node xmldom.DOMNode;
  descricerca_node xmldom.DOMNode;
  istruzione_node xmldom.DOMNode;
  info_node xmldom.DOMNode;
  trasferta_node xmldom.DOMNode;
  titolo_node xmldom.DOMNode;
  codTitolo_node xmldom.DOMNode;
  descTitolo_node xmldom.DOMNode;
  lingua_node xmldom.DOMNode;
  codLingua_node xmldom.DOMNode;
  letto_node xmldom.DOMNode;
  scritto_node xmldom.DOMNode;
  parlato_node xmldom.DOMNode;
  patente_node xmldom.DOMNode;
  mezzi_node xmldom.DOMNode;
  patentino_node xmldom.DOMNode;
  orario_node xmldom.DOMNode;
  offerte_node xmldom.DOMNode;
  comuneofferte_node xmldom.DOMNode;
  contrattoofferte_node xmldom.DOMNode;
  duratarich_node xmldom.DOMNode;
  datpubb_node xmldom.DOMNode;
  datscadpubb_node xmldom.DOMNode;
  datSistema_node xmldom.DOMNode;
  numOff_node xmldom.DOMNode;
  annoOff_node xmldom.DOMNode;
  provOff_node xmldom.DOMNode;
  cpiOff_node xmldom.DOMNode;
  albo_node xmldom.DOMNode;
  regazienda_node xmldom.DOMNode;
  datRich_node xmldom.DOMNode;
  datiAzienda_node xmldom.DOMNode;
  nomeRif_node xmldom.DOMNode;
  cognomeRif_node xmldom.DOMNode;
  emailRif_node xmldom.DOMNode;
  codFisc_node xmldom.DOMNode;
  ragsoc_node xmldom.DOMNode;
  indsedeop_node xmldom.DOMNode;
  capsedeop_node xmldom.DOMNode;
  comsedeop_node xmldom.DOMNode;
  telsedeop_node xmldom.DOMNode;
  faxsedeop_node xmldom.DOMNode;
  nomereferente_node xmldom.DOMNode;
  cognomereferente_node xmldom.DOMNode;
  telreferente_node xmldom.DOMNode;
  faxreferente_node xmldom.DOMNode;
  flgnullaosta_node xmldom.DOMNode;

  item_text xmldom.DOMText;

  ragSocAz an_azienda.strragionesociale%type;
  codiceFisc an_azienda.strcodicefiscale%type;
  comuneDenominazione de_comune.strdenominazione%type;
  codcomune de_comune.codcom%type;
  emailPortale de_cpi.stremailportale%type;
  emailRif do_richiesta_az.stremailriferimento%type;
  nomeriferimento do_richiesta_az.strnomeriferimento%type;
  cognomeriferimento do_richiesta_az.strcognomeriferimento%type;
  telriferimento  do_richiesta_az.strtelriferimento%type;
  faxriferimento do_richiesta_az.strfaxriferimento%type;

  nomeriferimentopubb do_richiesta_az.strnomerifpubb%type;
  cognomeriferimentopubb do_richiesta_az.strcognomerifpubb%type;
  telriferimentopubb  do_richiesta_az.strtelrifpubb%type;
  faxriferimentopubb do_richiesta_az.strfaxrifpubb%type;
  emailRifpubb do_richiesta_az.stremailrifpubb%type;

  atecoAz de_attivita.codatecodot%type;
  sitoWeb an_azienda.strsitointernet%type;
  descCpi de_cpi.strdescrizione%type;
  numProfili do_richiesta_az.numprofrichiesti%type;
  codMansione de_mansione.codmansionedot%type;
  descMansione de_mansione.strdescrizione%type;
  descMansioneGruppo de_mansione.strdescrizione%type;
  p_attivitaprincipale do_richiesta_az.strmansionepubb%type;
  descRicerca varchar2(20000);
  descConoscenzeInfo varchar2(1000);
  flgTrasferta char;
  codmezzitrasporto char;
  comuneOfferte de_comune.codcom%type;
  contrattoOfferte de_rapporto_lav.codrapportolav%type;
  datpubblicazione varchar2(10);
  datscadenzapubblicazione varchar2(10);
  numrichiesta do_richiesta_az.numrichiesta%type;
  numanno do_richiesta_az.numanno%type;
  codcpi do_richiesta_az.codcpi%type;
  provenienza varchar2(15);
  nomeRif an_az_referente.strnome%type;
  cognomeRif an_az_referente.strcognome%type;
  emailRegistrazione an_az_referente.stremail%type;
  indirizzoSedeOperativa an_unita_azienda.strindirizzo%type;
  capSedeOperativa an_unita_azienda.strcap%type;
  codComuneSedeOperativa an_unita_azienda.codcom%type;
  telefonoSedeOperativa an_unita_azienda.strtel%type;
  faxSedeOperativa an_unita_azienda.strfax%type;
  codevasione de_evasione_rich.codevasione%type;
  flgnullaosta  varchar2(2);

  xml_response CLOB;

  CURSOR cursorConoscInfo (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is Select Tipoinfo.Strdescrizione Tipo, Dettinfo.Strdescrizione Descrizione, grado.strdescrizione Livello
      From do_info di
      inner Join De_Dett_Info Dettinfo On (di.Coddettinfo = Dettinfo.Coddettinfo)
      inner Join De_Tipo_Info Tipoinfo On (di.Codtipoinfo = Tipoinfo.Codtipoinfo)
      inner Join de_grado_info grado On (di.cdngrado = grado.cdngrado)
      where di.prgrichiestaaz = prgRichiesta and di.prgalternativa = 1;

  rec_Info cursorConoscInfo%ROWTYPE;

  tipoInfo De_Tipo_Info.Strdescrizione%type;
  dettInfo De_Dett_Info.Strdescrizione%type;
  strlivello de_grado_info.strdescrizione%type;

  CURSOR cursorStudi (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is select ds.CODTITOLO as codtitolostudio,
        dt.strdescrizione as descrizionestudio
        From Do_Studio Ds
        inner join de_titolo dt on (ds.codtitolo = dt.codtitolo)
        where ds.prgrichiestaaz = prgRichiesta
        and ds.prgalternativa = 1
        and dt.flgmin = 'S';

  rec_Studi cursorStudi%ROWTYPE;
  codiceStudio Do_Studio.CODTITOLO%type;
  descStudio de_titolo.strdescrizione%type;


  CURSOR cursorLingua (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is SELECT l.codlingua AS codlingua,
       SUBSTR((select COD_CONOSCENZA from Ma_GRADO_CONSC_LIN where L.CDNGRADOLETTO = CDNGRADO),0,2) codlivelloletto,
	     substr((select COD_CONOSCENZA from Ma_GRADO_CONSC_LIN where L.CDNGRADOSCRITTO = CDNGRADO),0,2) codlivelloscritto,
	     SUBSTR((select COD_CONOSCENZA from Ma_GRADO_CONSC_LIN where L.CDNGRADOPARLATO = CDNGRADO),0,2) codlivelloparlato
    FROM    do_lingua l
    INNER JOIN de_lingua de ON (de.codlingua = l.codlingua)
    where l.prgrichiestaaz = prgRichiesta
      and l.prgalternativa = 1;

  rec_Lingua cursorLingua%ROWTYPE;
  codLingua do_lingua.codlingua%type;
  codlivelloletto varchar2(8);
  codlivelloscritto varchar2(8);
  codlivelloparlato varchar2(8);

  CURSOR cursorPatente (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is select distinct ma.codabilitazione as codpatenteguida
      From Do_Abilitazione_Gen Dag
      inner Join De_Abilitazione_Gen Da On (Dag.Codabilitazionegen = Da.Codabilitazionegen)
      Left Join Ma_Abilitazione Ma On  Da.Codabilitazionegen = Ma.Codabilitazionegen
      where dag.prgrichiestaaz = prgRichiesta
      and da.codtipoabilitazionegen = 'PG'
      and ma.codabilitazione is not null;

  rec_Patente cursorPatente%ROWTYPE;
  codpatenteguida  Ma_Abilitazione.codabilitazione%type;

  CURSOR cursorPatentini (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is select distinct ma.codabilitazione as codpatentino
      From Do_Abilitazione_Gen Dag
      inner Join De_Abilitazione_Gen Da On (Dag.Codabilitazionegen = Da.Codabilitazionegen)
      Left Join Ma_Abilitazione Ma On  Da.Codabilitazionegen = Ma.Codabilitazionegen
      where dag.prgrichiestaaz = prgRichiesta
      and da.codtipoabilitazionegen = 'PT'
      and ma.codabilitazione is not null;

  rec_Patentino cursorPatentini%ROWTYPE;
  codpatentino Ma_Abilitazione.codabilitazione%type;

  CURSOR cursorOrario (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is select distinct mo.cod_tipoorario
      from do_orario o
      inner join ma_orario mo on mo.codorario = o.codorario
      where o.prgrichiestaaz = prgRichiesta;


  CURSOR cursorAlbo (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is select distinct ma.codabilitazione as codalbo
      from do_abilitazione_gen dag
      inner join de_abilitazione_gen da on (dag.codabilitazionegen = da.codabilitazionegen)
      Left Join Ma_Abilitazione Ma On  Da.Codabilitazionegen = Ma.Codabilitazionegen
      where dag.prgrichiestaaz = prgRichiesta
      and da.codtipoabilitazionegen = 'AL'
      and ma.codabilitazione is not null;

  rec_Orario cursorOrario%ROWTYPE;
  codorario ma_orario.cod_tipoorario%type;

  rec_Albo cursorAlbo%ROWTYPE;
  codalbo  Ma_Abilitazione.codabilitazione%type;


BEGIN
  doc := xmldom.newDOMDocument;
  main_node := xmldom.makeNode(doc);
  root_elmt := xmldom.createElement(doc, 'Vacancy');
  root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));

  SELECT az.strragionesociale as denominazioneAz, az.strcodicefiscale, de_comune.strdenominazione, de_comune.codcom,
    de_cpi.stremailportale, do_richiesta_az.stremailriferimento,
    do_richiesta_az.strnomeriferimento, do_richiesta_az.strcognomeriferimento,
    do_richiesta_az.strtelriferimento, do_richiesta_az.strfaxriferimento,
    do_richiesta_az.STRNOMERIFPUBB,
    do_richiesta_az.STRCOGNOMERIFPUBB,
    do_richiesta_az.STRTELRIFPUBB,
    do_richiesta_az.STRFAXRIFPUBB,
    do_richiesta_az.STREMAILRIFPUBB,
    mn.codatecodot, az.strsitointernet,
    decode(do_richiesta_az.codtrasferta, null, 'N', '1', 'N', 'S') as trasferte,
    decode(do_richiesta_az.flgautomunito, 'S', 'S', 'N', 'N', null) as codmezzitrasporto,
    de_cpi.strdescrizione, do_richiesta_az.numprofrichiesti,
    decode(do_richiesta_az.flgnullaosta, 'N', 'NO', 'S', 'SI', null) as flgnullaosta,
    decode(DE_MANSIONE.CODMANSIONEDOT, null, MANSPADRE.codmansionedot, DE_MANSIONE.CODMANSIONEDOT) codmansione,
    decode(DE_MANSIONE.Strdescrizione, null, MANSPADRE.strdescrizione, DE_MANSIONE.Strdescrizione) strdescrizionemansione,
    MANSPADRE.STRDESCRIZIONE strdescrizionemansionepadre,
    do_richiesta_az.strMansionePubb attivitaprincipale,
          PG_UTILS.TRUNC_DESC_OTTIMIZZATA(nvl(do_richiesta_az.strDatiAziendaPubb, '') || ' ' ||
            nvl(do_richiesta_az.strMansionePubb, '') || ' ' ||
            nvl(do_richiesta_az.txtFiguraProfessionale, '') || ' ' ||
            nvl(do_richiesta_az.strLuogoLavoro, '') || ' ' ||
            nvl(do_richiesta_az.strFormazionePubb, '') || ' ' ||
            nvl(do_richiesta_az.txtCaratteristFigProf, '') || ' ' ||
            nvl(do_richiesta_az.txtCondContrattuale, '') || ' ' ||
            nvl(do_richiesta_az.strConoscenzePubb, '') || ' ' ||
            nvl(do_richiesta_az.strNoteOrarioPubb, '') || ' ' ||
            nvl(do_richiesta_az.strRifCandidaturaPubb, ''), 17990, '...') As Descrizionericerca,
    to_char(do_richiesta_az.datpubblicazione,'yyyy-mm-dd') as datpubblicazione,
    (case
      when DO_EVASIONE.CDNSTATORICH = 5 then to_char((trunc(sysdate)-1), 'yyyy-mm-dd')
      else to_char(do_richiesta_az.datscadenzapubblicazione,'yyyy-mm-dd')
    end) as datscadenzapubblicazione,
    nvl(do_richiesta_az.numrichiestaorig, do_richiesta_az.numrichiesta) as numrichiesta, do_richiesta_az.numanno, do_richiesta_az.codcpi,
	(case
      when de_provincia.codprovincia is not null and de_provincia.strtarga is not null then 'SIL' || upper(de_provincia.strtarga)
      when PROVCPI.codprovincia is not null and PROVCPI.strtarga is not null and
				(select upper(flgpoloreg) from ts_generale where prggenerale = 1) = 'S' then 'SIL' || upper(PROVCPI.strtarga)
      else (select 'SIL' || upper(p.strtarga)
			from ts_generale t
			inner join de_provincia p on t.codprovinciasil = p.codprovincia)
    end) as provenienza,
      azref.strnome as nomeRif,
      azref.strcognome as cognomeRif,
      azref.stremail as emailRegistrazione,
    UAZ.strindirizzo as indirizzoSedeOperativa,
    nvl(UAZ.strcap, DE_COMUNE.strcap)  as capSedeOperativa,
    UAZ.codcom as codComuneSedeOperativa,
    nvl(UAZ.strtel, '0') as telefonoSedeOperativa,
    nvl(UAZ.strfax, '0') as faxSedeOperativa, deev.codevasione, do_comune.codcom
  INTO ragSocAz, codiceFisc, comuneDenominazione, codcomune,
    emailPortale, emailRif,
    nomeriferimento, cognomeriferimento, telriferimento, faxriferimento,
    nomeriferimentopubb, cognomeriferimentopubb, telriferimentopubb, faxriferimentopubb, emailRifpubb,
    atecoAz, sitoWeb, flgTrasferta, codmezzitrasporto,
    descCpi, numProfili,flgnullaosta, codMansione, descMansione, descMansioneGruppo, p_attivitaprincipale,
    descRicerca, datpubblicazione, datscadenzapubblicazione,
    numrichiesta, numanno, codcpi, provenienza,
    nomeRif, cognomeRif, emailRegistrazione,
    indirizzoSedeOperativa, capSedeOperativa, codComuneSedeOperativa,
    telefonoSedeOperativa, faxSedeOperativa, codevasione, comuneOfferte
  FROM DO_RICHIESTA_AZ
  INNER JOIN DO_ALTERNATIVA ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_ALTERNATIVA.PRGRICHIESTAAZ)
  INNER JOIN DO_EVASIONE ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_EVASIONE.PRGRICHIESTAAZ)
  INNER JOIN DE_EVASIONE_RICH DEEV ON (DEEV.CODEVASIONE = DO_EVASIONE.CODEVASIONE)
  INNER JOIN DO_MANSIONE ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_MANSIONE.PRGRICHIESTAAZ AND DO_ALTERNATIVA.PRGALTERNATIVA = DO_MANSIONE.PRGALTERNATIVA)
  INNER JOIN DE_MANSIONE ON (DO_MANSIONE.CODMANSIONE = DE_MANSIONE.CODMANSIONE)
  LEFT JOIN DE_MANSIONE MANSPADRE ON (DE_MANSIONE.CODPADRE = MANSPADRE.CODMANSIONE)
  INNER JOIN DO_COMUNE ON (DO_COMUNE.PRGRICHIESTAAZ = DO_RICHIESTA_AZ.PRGRICHIESTAAZ)
  INNER JOIN AN_AZIENDA AZ ON (DO_RICHIESTA_AZ.PRGAZIENDA = AZ.PRGAZIENDA)
  INNER JOIN AN_UNITA_AZIENDA UAZ ON (AZ.PRGAZIENDA = UAZ.PRGAZIENDA AND DO_RICHIESTA_AZ.PRGUNITA = UAZ.PRGUNITA)
  LEFT JOIN an_az_referente azref on (DO_RICHIESTA_AZ.prgazienda = azref.prgazienda and DO_RICHIESTA_AZ.prgunita = azref.prgunita
                      and azref.codruoloaz = 'RSA')
  INNER JOIN DE_COMUNE ON (UAZ.CODCOM = DE_COMUNE.CODCOM)
  LEFT JOIN DE_ATTIVITA MN ON (UAZ.CODATECO = MN.CODATECO)
  LEFT JOIN de_provincia ON (DO_RICHIESTA_AZ.CODPROVINCIAPROV = de_provincia.CODPROVINCIA)
  INNER JOIN DE_CPI ON (DO_RICHIESTA_AZ.CODCPI = DE_CPI.CODCPI)
  LEFT JOIN DE_COMUNE COMCPI ON (DE_CPI.CODCOM = COMCPI.CODCOM)
  LEFT JOIN DE_PROVINCIA PROVCPI ON (COMCPI.CODPROVINCIA = PROVCPI.CODPROVINCIA)
  WHERE DO_RICHIESTA_AZ.PRGRICHIESTAAZ = prgRichiesta
  AND DO_ALTERNATIVA.PRGALTERNATIVA = 1
  AND DO_MANSIONE.FLGINVIOCL = 'S' AND DO_COMUNE.FLGINVIOCL = 'S';


  item_elmt := xmldom.createElement(doc, 'DatoreLavoro');
  datLav_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));

  --Inizio DatiAnagrafici
  item_elmt := xmldom.createElement(doc, 'DatiAnagrafici');
  datAnag_node := xmldom.appendChild(datLav_node, xmldom.makeNode(item_elmt));

  item_elmt := xmldom.createElement(doc, 'codicefiscale');
  cf_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, codiceFisc);
  item_node := xmldom.appendChild(cf_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'denominazione');
  denominazione_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, ragSocAz);
  item_node := xmldom.appendChild(denominazione_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'indirizzolavoro');
  indlav_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, comuneDenominazione);
  item_node := xmldom.appendChild(indlav_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'codcomunelavoro');
  codcom_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, codcomune);
  item_node := xmldom.appendChild(codcom_node, xmldom.makeNode(item_text));

  if (atecoAz is not null) then
    item_elmt := xmldom.createElement(doc, 'settore');
    settore_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, atecoAz);
    item_node := xmldom.appendChild(settore_node, xmldom.makeNode(item_text));
  end if;


  if (sitoWeb is not null) then
    item_elmt := xmldom.createElement(doc, 'web');
    web_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, sitoWeb);
    item_node := xmldom.appendChild(web_node, xmldom.makeNode(item_text));
  end if;
  --Fine DatiAnagrafici

  -- MyPortal Tracker #589
  -- richieste palesi il contatto principale deve essere l'azienda
  -- per le anonime il cpi

  if ( (codevasione in ('DFD', 'DPR')) and (emailRifpubb is not null) ) then
     --Inizio DatiContatto
     item_elmt := xmldom.createElement(doc, 'DatiContatto');
     datContatto_node := xmldom.appendChild(datLav_node, xmldom.makeNode(item_elmt));

     if (nomeriferimentopubb is not null) then
      item_elmt := xmldom.createElement(doc, 'nomereferente');
      nomereferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, nomeriferimentopubb);
      item_node := xmldom.appendChild(nomereferente_node, xmldom.makeNode(item_text));
     elsif (nomeriferimento is not null) then
      item_elmt := xmldom.createElement(doc, 'nomereferente');
      nomereferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, nomeriferimento);
      item_node := xmldom.appendChild(nomereferente_node, xmldom.makeNode(item_text));
     end if;

     if (cognomeriferimentopubb is not null) then
      item_elmt := xmldom.createElement(doc, 'cognomereferente');
      cognomereferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, cognomeriferimentopubb);
      item_node := xmldom.appendChild(cognomereferente_node, xmldom.makeNode(item_text));
     elsif (cognomeriferimento is not null) then
      item_elmt := xmldom.createElement(doc, 'cognomereferente');
      cognomereferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, cognomeriferimento);
      item_node := xmldom.appendChild(cognomereferente_node, xmldom.makeNode(item_text));
     end if;

     if (telriferimentopubb is not null) then
      item_elmt := xmldom.createElement(doc, 'telefono');
      telreferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, telriferimentopubb);
      item_node := xmldom.appendChild(telreferente_node, xmldom.makeNode(item_text));
     elsif (telriferimento is not null) then
      item_elmt := xmldom.createElement(doc, 'telefono');
      telreferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, telriferimento);
      item_node := xmldom.appendChild(telreferente_node, xmldom.makeNode(item_text));
     end if;

     if (faxriferimentopubb is not null) then
      item_elmt := xmldom.createElement(doc, 'fax');
      faxreferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, faxriferimentopubb);
      item_node := xmldom.appendChild(faxreferente_node, xmldom.makeNode(item_text));
     elsif (faxriferimento is not null) then
      item_elmt := xmldom.createElement(doc, 'fax');
      faxreferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, faxriferimento);
      item_node := xmldom.appendChild(faxreferente_node, xmldom.makeNode(item_text));
     end if;

     if (emailRifpubb is not null) then
        emailRif := emailRifpubb;
     end if;

     item_elmt := xmldom.createElement(doc, 'email');
     mailContatta_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

     item_text := xmldom.createTextNode(doc, emailRif);
     item_node := xmldom.appendChild(mailContatta_node, xmldom.makeNode(item_text));
     --Fine DatiContatto

     --Inizio DatiContattoAlternativo
     item_elmt := xmldom.createElement(doc, 'DatiContattoAlternativo');
     datContattoAlter_node := xmldom.appendChild(datLav_node, xmldom.makeNode(item_elmt));

     item_elmt := xmldom.createElement(doc, 'cognomereferente');
     cognref_node := xmldom.appendChild(datContattoAlter_node, xmldom.makeNode(item_elmt));

     item_text := xmldom.createTextNode(doc, descCpi);
     item_node := xmldom.appendChild(cognref_node, xmldom.makeNode(item_text));

     --Questo e' un elemento obbligatorio
     if (emailPortale is not null) then
       item_elmt := xmldom.createElement(doc, 'email');
       mailContatta_node := xmldom.appendChild(datContattoAlter_node, xmldom.makeNode(item_elmt));

       item_text := xmldom.createTextNode(doc, emailPortale);
       item_node := xmldom.appendChild(mailContatta_node, xmldom.makeNode(item_text));
     end if;
     --Fine DatiContattoAlternativo

  else

     --Inizio DatiContatto
     item_elmt := xmldom.createElement(doc, 'DatiContatto');
     datContatto_node := xmldom.appendChild(datLav_node, xmldom.makeNode(item_elmt));
     --
     item_elmt := xmldom.createElement(doc, 'cognomereferente');
     cognref_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

     item_text := xmldom.createTextNode(doc, descCpi);
     item_node := xmldom.appendChild(cognref_node, xmldom.makeNode(item_text));

     --Questo e' un elemento obbligatorio
     if (emailPortale is not null) then
       item_elmt := xmldom.createElement(doc, 'email');
       mailContatta_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

       item_text := xmldom.createTextNode(doc, emailPortale);
       item_node := xmldom.appendChild(mailContatta_node, xmldom.makeNode(item_text));
     end if;
     --Fine DatiContatto

  end if;

  if (descMansioneGruppo is null) then
    descMansioneGruppo := descMansione;
  end if;
  if (p_attivitaprincipale is null) then
     p_attivitaprincipale := descMansioneGruppo;
  end if;
  if (p_attivitaprincipale is not null and length(p_attivitaprincipale) > 100) then
     p_attivitaprincipale := SUBSTR(p_attivitaprincipale, 1, 97) || '...';
  end if;

  item_elmt := xmldom.createElement(doc, 'Richiesta');
  richiesta_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));

  --Inizio ProfiloRichiesto
  item_elmt := xmldom.createElement(doc, 'ProfiloRichiesto');
  profilo_node := xmldom.appendChild(richiesta_node, xmldom.makeNode(item_elmt));

  item_elmt := xmldom.createElement(doc, 'numerolavoratori');
  numlav_node := xmldom.appendChild(profilo_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, numProfili);
  item_node := xmldom.appendChild(numlav_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'attivitaprincipale');
  attivitaGruppo_node := xmldom.appendChild(profilo_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, p_attivitaprincipale);
  item_node := xmldom.appendChild(attivitaGruppo_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'codprofessione');
  professione_node := xmldom.appendChild(profilo_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, codMansione);
  item_node := xmldom.appendChild(professione_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'descrprofessione');
  descprofessione_node := xmldom.appendChild(profilo_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, descMansione);
  item_node := xmldom.appendChild(descprofessione_node, xmldom.makeNode(item_text));

  if (descRicerca is not null) then
    item_elmt := xmldom.createElement(doc, 'descrizionericerca');
    descricerca_node := xmldom.appendChild(profilo_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, descRicerca);
    item_node := xmldom.appendChild(descricerca_node, xmldom.makeNode(item_text));
  end if;
  --Fine ProfiloRichiesto

  --Inizio IstruzioneFormazione
  item_elmt := xmldom.createElement(doc, 'IstruzioneFormazione');
  istruzione_node := xmldom.appendChild(richiesta_node, xmldom.makeNode(item_elmt));


  --titoli studi
  open cursorStudi(prgRichiesta);
  loop
    fetch cursorStudi into rec_Studi;
    exit when (cursorStudi%notfound);

    codiceStudio := rec_Studi.codtitolostudio;
    descStudio := rec_Studi.descrizionestudio;

    item_elmt := xmldom.createElement(doc, 'titolostudio');
    titolo_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_elmt := xmldom.createElement(doc, 'codtitolostudio');
    codTitolo_node := xmldom.appendChild(titolo_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codiceStudio);
    item_node := xmldom.appendChild(codTitolo_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'descrizionestudio');
    descTitolo_node := xmldom.appendChild(titolo_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, descStudio);
    item_node := xmldom.appendChild(descTitolo_node, xmldom.makeNode(item_text));

  end loop;
  close cursorStudi;


  open cursorAlbo(prgRichiesta);
  loop
    fetch cursorAlbo into rec_Albo;
    exit when (cursorAlbo%notfound);

    codalbo := rec_Albo.codalbo;

    item_elmt := xmldom.createElement(doc, 'codalbo');
    albo_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codalbo);
    item_node := xmldom.appendChild(albo_node, xmldom.makeNode(item_text));

  end loop;
  close cursorAlbo;


  --lingue
  open cursorLingua(prgRichiesta);
  loop
    fetch cursorLingua into rec_Lingua;
    exit when (cursorLingua%notfound);

    codLingua := rec_Lingua.codLingua;
    codlivelloletto := rec_Lingua.codlivelloletto;
    codlivelloscritto := rec_Lingua.codlivelloscritto;
    codlivelloparlato := rec_Lingua.codlivelloparlato;

    item_elmt := xmldom.createElement(doc, 'Lingua');
    lingua_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_elmt := xmldom.createElement(doc, 'codlingua');
    codLingua_node := xmldom.appendChild(lingua_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codLingua);
    item_node := xmldom.appendChild(codLingua_node, xmldom.makeNode(item_text));


    if (codlivelloletto is not null) then

      item_elmt := xmldom.createElement(doc, 'codlivelloletto');
      letto_node := xmldom.appendChild(lingua_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, codlivelloletto);
      item_node := xmldom.appendChild(letto_node, xmldom.makeNode(item_text));

    end if;

    if (codlivelloscritto is not null) then

      item_elmt := xmldom.createElement(doc, 'codlivelloscritto');
      scritto_node := xmldom.appendChild(lingua_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, codlivelloscritto);
      item_node := xmldom.appendChild(scritto_node, xmldom.makeNode(item_text));

    end if;

    if (codlivelloparlato is not null) then

      item_elmt := xmldom.createElement(doc, 'codlivelloparlato');
      parlato_node := xmldom.appendChild(lingua_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, codlivelloparlato);
      item_node := xmldom.appendChild(parlato_node, xmldom.makeNode(item_text));

    end if;

  end loop;
  close cursorLingua;

  --conoscenze informatiche
  descConoscenzeInfo := null;
  open cursorConoscInfo(prgRichiesta);
  loop
    fetch cursorConoscInfo into rec_Info;
    exit when (cursorConoscInfo%notfound);

    tipoInfo := rec_Info.Tipo;
    dettInfo := rec_Info.Descrizione;
    strlivello := rec_Info.Livello;

    if (descConoscenzeInfo is null) then
      descConoscenzeInfo := nvl(tipoInfo, '') || '-' || nvl(dettInfo, '') || '-' || nvl(strlivello, '') || ' ';
    else
      descConoscenzeInfo := descConoscenzeInfo || nvl(tipoInfo, '') || '-' || nvl(dettInfo, '') || '-' || nvl(strlivello, '') || ' ';
    end if;

  end loop;
  close cursorConoscInfo;

  if (descConoscenzeInfo is not null) then
    if (length(descConoscenzeInfo) > 1000) then
      descConoscenzeInfo := SUBSTR(descConoscenzeInfo, 1, 997) || '...';
    end if;

    item_elmt := xmldom.createElement(doc, 'conoscenzeinformatiche');
    info_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, descConoscenzeInfo);
    item_node := xmldom.appendChild(info_node, xmldom.makeNode(item_text));

  end if;

  --trasferte
  item_elmt := xmldom.createElement(doc, 'trasferte');
  trasferta_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, flgTrasferta);
  item_node := xmldom.appendChild(trasferta_node, xmldom.makeNode(item_text));

  --patente guida
  open cursorPatente(prgRichiesta);
  loop
    fetch cursorPatente into rec_Patente;
    exit when (cursorPatente%notfound);

    codpatenteguida := rec_Patente.codpatenteguida;

    item_elmt := xmldom.createElement(doc, 'codpatenteguida');
    patente_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codpatenteguida);
    item_node := xmldom.appendChild(patente_node, xmldom.makeNode(item_text));


  end loop;
  close cursorPatente;


  if (codmezzitrasporto is not null) then

    item_elmt := xmldom.createElement(doc, 'codmezzitrasporto');
    mezzi_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codmezzitrasporto);
    item_node := xmldom.appendChild(mezzi_node, xmldom.makeNode(item_text));

  end if;


  --patentini guida
  open cursorPatentini(prgRichiesta);
  loop
    fetch cursorPatentini into rec_Patentino;
    exit when (cursorPatentini%notfound);

    codpatentino := rec_Patentino.codpatentino;

    item_elmt := xmldom.createElement(doc, 'codpatentino');
    patentino_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codpatentino);
    item_node := xmldom.appendChild(patentino_node, xmldom.makeNode(item_text));

  end loop;
  close cursorPatentini;

  --orario
  open cursorOrario(prgRichiesta);
  loop
    fetch cursorOrario into rec_Orario;
    exit when (cursorOrario%notfound);

    codorario := rec_Orario.Cod_Tipoorario;

    item_elmt := xmldom.createElement(doc, 'codorario');
    orario_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codorario);
    item_node := xmldom.appendChild(orario_node, xmldom.makeNode(item_text));

  end loop;
  close cursorOrario;

  --Fine IstruzioneFormazione


  --Inizio CondizioniOfferte
  item_elmt := xmldom.createElement(doc, 'CondizioniOfferte');
  offerte_node := xmldom.appendChild(richiesta_node, xmldom.makeNode(item_elmt));

  item_elmt := xmldom.createElement(doc, 'codcomune');
  comuneofferte_node := xmldom.appendChild(offerte_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, comuneOfferte);
  item_node := xmldom.appendChild(comuneofferte_node, xmldom.makeNode(item_text));

  -- codtipologiacontratto / codrapportolav

  BEGIN

    select codrapportolav
    into contrattoOfferte
    from do_richiesta_az
    where prgrichiestaaz = prgRichiesta;

  EXCEPTION
    when others then
      contrattoOfferte := null;
  END;

  IF contrattoOfferte is not null THEN

    item_elmt := xmldom.createElement(doc, 'codtipologiacontratto');
    contrattoofferte_node := xmldom.appendChild(offerte_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, trim(contrattoOfferte));
    item_node := xmldom.appendChild(contrattoofferte_node, xmldom.makeNode(item_text));

  END IF;

  --Fine CondizioniOfferte

  --Inizio Flgnullaosta
  IF flgnullaosta is not null THEN
    item_elmt := xmldom.createElement(doc, 'Flgnullaosta');
    flgnullaosta_node := xmldom.appendChild(richiesta_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, trim(flgnullaosta));
    item_node := xmldom.appendChild(flgnullaosta_node, xmldom.makeNode(item_text));
  END IF;
  --Fine Flgnullaosta

  --Inizio DurataRichiesta
  item_elmt := xmldom.createElement(doc, 'DurataRichiesta');
  duratarich_node := xmldom.appendChild(richiesta_node, xmldom.makeNode(item_elmt));

  if (datpubblicazione is not null) then

    item_elmt := xmldom.createElement(doc, 'datapubblicazione');
    datpubb_node := xmldom.appendChild(duratarich_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, datpubblicazione);
    item_node := xmldom.appendChild(datpubb_node, xmldom.makeNode(item_text));

  end if;

  if (datscadenzapubblicazione is not null) then

    item_elmt := xmldom.createElement(doc, 'datascadenzapubblicazione');
    datscadpubb_node := xmldom.appendChild(duratarich_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, datscadenzapubblicazione);
    item_node := xmldom.appendChild(datscadpubb_node, xmldom.makeNode(item_text));

  end if;

  --Fine DurataRichiesta


  if (codevasione in ('DFD', 'DPR')) then
    if ( (nomeRif is null) or (cognomeRif is null) or (emailRegistrazione is null) ) then
      nomeRif := nomeriferimento;
      cognomeRif := cognomeriferimento;
      emailRegistrazione := emailRif;
    end if;

    if ( (nomeRif is not null) and (cognomeRif is not null) and (emailRegistrazione is not null) ) then
      --Inizio RegistrazioneAzienda
      item_elmt := xmldom.createElement(doc, 'RegistrazioneAzienda');
      regazienda_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'DatiRichiedente');
      datRich_node := xmldom.appendChild(regazienda_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'nome');
      nomeRif_node := xmldom.appendChild(datRich_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, nomeRif);
      item_node := xmldom.appendChild(nomeRif_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'cognome');
      cognomeRif_node := xmldom.appendChild(datRich_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, cognomeRif);
      item_node := xmldom.appendChild(cognomeRif_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'emailregistrazione');
      emailRif_node := xmldom.appendChild(datRich_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, emailRegistrazione);
      item_node := xmldom.appendChild(emailRif_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'DatiAzienda');
      datiAzienda_node := xmldom.appendChild(regazienda_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'codicefiscale');
      codFisc_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, codiceFisc);
      item_node := xmldom.appendChild(codFisc_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'ragionesociale');
      ragsoc_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, ragSocAz);
      item_node := xmldom.appendChild(ragsoc_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'indirizzosedeoperativa');
      indsedeop_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, indirizzoSedeOperativa);
      item_node := xmldom.appendChild(indsedeop_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'capsedeoperativa');
      capsedeop_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, capSedeOperativa);
      item_node := xmldom.appendChild(capsedeop_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'codcomunesedeoperativa');
      comsedeop_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, codComuneSedeOperativa);
      item_node := xmldom.appendChild(comsedeop_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'telefonosedeoperativa');
      telsedeop_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, telefonoSedeOperativa);
      item_node := xmldom.appendChild(telsedeop_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'faxsedeoperativa');
      faxsedeop_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, faxSedeOperativa);
      item_node := xmldom.appendChild(faxsedeop_node, xmldom.makeNode(item_text));

      --Fine RegistrazioneAzienda
    end if;
  end if;


  --Inizio DatiSistema
  item_elmt := xmldom.createElement(doc, 'DatiSistema');
  datSistema_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));

  item_elmt := xmldom.createElement(doc, 'numeroofferta');
  numOff_node := xmldom.appendChild(datSistema_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, numrichiesta);
  item_node := xmldom.appendChild(numOff_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'annoofferta');
  annoOff_node := xmldom.appendChild(datSistema_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, numanno);
  item_node := xmldom.appendChild(annoOff_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'provenienza');
  provOff_node := xmldom.appendChild(datSistema_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, provenienza);
  item_node := xmldom.appendChild(provOff_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'cpi');
  cpiOff_node := xmldom.appendChild(datSistema_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, codcpi);
  item_node := xmldom.appendChild(cpiOff_node, xmldom.makeNode(item_text));

  --Fine DatiSistema


  xmldom.writeToBuffer(doc, xml_response);
  xmldom.freeDocument(doc);

  return xml_response;

EXCEPTION
    WHEN OTHERS THEN
      dbms_output.put_line('errore'||sqlcode ||' '||sqlerrm);
      return null;

END getXMLVacancy;


FUNCTION getXMLVacancySIL (prgRichiesta do_richiesta_az.prgrichiestaaz%type,
						   isAnteprima varchar2 ) RETURN CLOB IS

  doc xmldom.DOMDocument;
  main_node xmldom.DOMNode;
  root_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;
  item_node xmldom.DOMNode;
  datLav_node xmldom.DOMNode;
  datAnag_node xmldom.DOMNode;
  cf_node xmldom.DOMNode;
  denominazione_node xmldom.DOMNode;
  indlav_node xmldom.DOMNode;
  codcom_node xmldom.DOMNode;
  settore_node xmldom.DOMNode;
  codateco_node  xmldom.DOMNode;
  web_node xmldom.DOMNode;
  datContatto_node xmldom.DOMNode;
  datContattoAlter_node xmldom.DOMNode;
  cognref_node xmldom.DOMNode;
  mailContatta_node xmldom.DOMNode;
  mailContattoAlter_node xmldom.DOMNode;
  richiesta_node xmldom.DOMNode;
  profilo_node xmldom.DOMNode;
  numlav_node xmldom.DOMNode;
  attivitaGruppo_node xmldom.DOMNode;
  professione_node xmldom.DOMNode;
  codMansione_node xmldom.DOMNode;
  descprofessione_node xmldom.DOMNode;
  descricerca_node xmldom.DOMNode;
  istruzione_node xmldom.DOMNode;
  info_node xmldom.DOMNode;
  trasferta_node xmldom.DOMNode;
  titolo_node xmldom.DOMNode;
  codTitolo_node xmldom.DOMNode;
  descTitolo_node xmldom.DOMNode;
  lingua_node xmldom.DOMNode;
  codLingua_node xmldom.DOMNode;
  letto_node xmldom.DOMNode;
  scritto_node xmldom.DOMNode;
  parlato_node xmldom.DOMNode;
  patente_node xmldom.DOMNode;
  mezzi_node xmldom.DOMNode;
  patentino_node xmldom.DOMNode;
  orario_node xmldom.DOMNode;
  offerte_node xmldom.DOMNode;
  comuneofferte_node xmldom.DOMNode;
  contrattoofferte_node xmldom.DOMNode;
  duratarich_node xmldom.DOMNode;
  datpubb_node xmldom.DOMNode;
  datscadpubb_node xmldom.DOMNode;
  datSistema_node xmldom.DOMNode;
  numOff_node xmldom.DOMNode;
  annoOff_node xmldom.DOMNode;
  provOff_node xmldom.DOMNode;
  cpiOff_node xmldom.DOMNode;
  albo_node xmldom.DOMNode;
  regazienda_node xmldom.DOMNode;
  datRich_node xmldom.DOMNode;
  datiAzienda_node xmldom.DOMNode;
  nomeRif_node xmldom.DOMNode;
  cognomeRif_node xmldom.DOMNode;
  emailRif_node xmldom.DOMNode;
  codFisc_node xmldom.DOMNode;
  ragsoc_node xmldom.DOMNode;
  indsedeop_node xmldom.DOMNode;
  capsedeop_node xmldom.DOMNode;
  comsedeop_node xmldom.DOMNode;
  telsedeop_node xmldom.DOMNode;
  faxsedeop_node xmldom.DOMNode;
  nomereferente_node xmldom.DOMNode;
  cognomereferente_node xmldom.DOMNode;
  telreferente_node xmldom.DOMNode;
  faxreferente_node xmldom.DOMNode;
  flgnullaosta_node xmldom.DOMNode;
  datAggiuntivi_node xmldom.DOMNode;
  datiGenerali_node xmldom.DOMNode;
  cresco_node xmldom.DOMNode;
  candidaturaPalese_node xmldom.DOMNode;
  fuorisede_node xmldom.DOMNode;
  automunito_node xmldom.DOMNode;
  motomunito_node xmldom.DOMNode;
  milite_node xmldom.DOMNode;
  sesso_node xmldom.DOMNode;
  motsesso_node xmldom.DOMNode;
  notamotsesso_node xmldom.DOMNode;
  areainserimento_node xmldom.DOMNode;
  localita_node xmldom.DOMNode;
  alloggio_node xmldom.DOMNode;
  noteoperatore_node xmldom.DOMNode;
  turni_node xmldom.DOMNode;
  codturno_node xmldom.DOMNode;
  esperienze_node xmldom.DOMNode;
  numda_node xmldom.DOMNode;
  numa_node xmldom.DOMNode;
  codmoteta_node xmldom.DOMNode;
  notamotivoeta_node xmldom.DOMNode;
  esperienza_node xmldom.DOMNode;
  anniesperienza_node xmldom.DOMNode;
  formazioneprof_node xmldom.DOMNode;
  notaesperienze_node xmldom.DOMNode;	
  agevolazioni_node xmldom.DOMNode;
  codagevolazione_node xmldom.DOMNode;
  agevolazioneindisp_node xmldom.DOMNode;
  tipoRapporto_node xmldom.DOMNode;
  codcontratto_node xmldom.DOMNode;
  pubblicazione_node xmldom.DOMNode;
   DatiAziendaPub_node xmldom.DOMNode;
  MansionePub_node xmldom.DOMNode;
  LuogoPub_node xmldom.DOMNode;
  ContenutoPub_node xmldom.DOMNode;
  FormazionePub_node xmldom.DOMNode;
  ContrattoPub_node xmldom.DOMNode;
  ConoscenzePub_node xmldom.DOMNode;
  CaratteristichePub_node xmldom.DOMNode;
  OrarioPub_node xmldom.DOMNode;
  CandidaturaPub_node xmldom.DOMNode;
  specifica_node xmldom.DOMNode;
  conseguito_node xmldom.DOMNode;
  titoloindisp_node xmldom.DOMNode;
  alboindisp_node xmldom.DOMNode;
  patenteindisp_node xmldom.DOMNode;
  patentinoindisp_node xmldom.DOMNode;
  linguaindisp_node xmldom.DOMNode;
  trasf_node xmldom.DOMNode;
  opzTipoDec_node xmldom.DOMNode;
  opzInvioClicl_node xmldom.DOMNode; 
  abilitazioni_node xmldom.DOMNode;
  albi_node xmldom.DOMNode;
  patenti_node xmldom.DOMNode;
  patentini_node xmldom.DOMNode;
  codEvasione_node xmldom.DOMNode;
  nomeOperatore_node xmldom.DOMNode;
  cognomeOperatore_node xmldom.DOMNode;
  
  item_text xmldom.DOMText;

  ragSocAz an_azienda.strragionesociale%type;
  codiceFisc an_azienda.strcodicefiscale%type;
  comuneDenominazione de_comune.strdenominazione%type;
  codcomune de_comune.codcom%type;
  emailPortale de_cpi.stremailportale%type;
  emailRif do_richiesta_az.stremailriferimento%type;
  nomeriferimento do_richiesta_az.strnomeriferimento%type;
  cognomeriferimento do_richiesta_az.strcognomeriferimento%type;
  telriferimento  do_richiesta_az.strtelriferimento%type;
  faxriferimento do_richiesta_az.strfaxriferimento%type;

  nomeriferimentopubb do_richiesta_az.strnomerifpubb%type;
  cognomeriferimentopubb do_richiesta_az.strcognomerifpubb%type;
  telriferimentopubb  do_richiesta_az.strtelrifpubb%type;
  faxriferimentopubb do_richiesta_az.strfaxrifpubb%type;
  emailRifpubb do_richiesta_az.stremailrifpubb%type;

  atecoAz de_attivita.codatecodot%type;
  codAtecoAz de_attivita.codateco%type;
  sitoWeb an_azienda.strsitointernet%type;
  descCpi de_cpi.strdescrizione%type;
  numProfili do_richiesta_az.numprofrichiesti%type;
  codMansione de_mansione.codmansionedot%type;
  descMansione de_mansione.strdescrizione%type;
  descMansioneGruppo de_mansione.strdescrizione%type;
  codMansioneId de_mansione.codmansione%type;
  p_attivitaprincipale do_richiesta_az.strmansionepubb%type;
  descRicerca varchar2(20000);
  descConoscenzeInfo varchar2(1000);
  flgTrasferta char;
  codmezzitrasporto char;
  comuneOfferte de_comune.codcom%type;
  contrattoOfferte de_rapporto_lav.codrapportolav%type;
  datpubblicazione varchar2(10);
  datscadenzapubblicazione varchar2(10);
  numrichiesta do_richiesta_az.numrichiesta%type;
  numanno do_richiesta_az.numanno%type;
  codcpi do_richiesta_az.codcpi%type;
  provenienza varchar2(15);
  nomeRif an_az_referente.strnome%type;
  cognomeRif an_az_referente.strcognome%type;
  emailRegistrazione an_az_referente.stremail%type;
  indirizzoSedeOperativa an_unita_azienda.strindirizzo%type;
  capSedeOperativa an_unita_azienda.strcap%type;
  codComuneSedeOperativa an_unita_azienda.codcom%type;
  telefonoSedeOperativa an_unita_azienda.strtel%type;
  faxSedeOperativa an_unita_azienda.strfax%type;
  codevasione de_evasione_rich.codevasione%type;
  nomeOperatore an_spi.strnome%type;
  cognomeOperatore  an_spi.strcognome%type;
  
  flgnullaosta  varchar2(2);
  
  	num_cresco ts_config_loc.num%type;
	num_candidatura ts_config_loc.num%type;
  	cresco do_evasione.flgpubbcresco%type;
	candidaturaPalese do_evasione.flg_candidatura%type;
  	fuorisede do_richiesta_az.Flgfuorisede%type;
	automunito do_richiesta_az.Flgautomunito%type;
	motomunito do_richiesta_az.Flgmotomunito%type;
	milite do_richiesta_az.Flgmilite%type;
	sesso  do_richiesta_az.Strsesso%type;
	motivosesso De_Mot_Genere.Codmotgenere%type;
	notamotivosesso do_richiesta_az.Strmotivsesso%type;
	areainserimento De_Area.Codarea%type;
	localita do_richiesta_az.Strlocalita%type;
	trasferta De_Trasferta.Codtrasferta%type;
	alloggio do_richiesta_az.Flgvittoalloggio%type;
	noteoperatore do_richiesta_az.Txtnoteoperatore%type;
 	numda Do_Alternativa.Numda%type;
	numa Do_Alternativa.Numa%type;
	codmoteta De_Mot_Eta.Codmoteta%type;
	notamotivoeta Do_Alternativa.Strmotiveta%type;
	esperienza Do_Alternativa.Flgesperienza%type;
	anniesperienza Do_Alternativa.Numanniesperienza%type;
	formazioneprof Do_Alternativa.Flgformazioneprof%type;
	notaesperienze Do_Alternativa.Strnote%type;
	DatiAziendaPub Do_Richiesta_Az.Strdatiaziendapubb%type;
	MansionePub Do_Richiesta_Az.Strmansionepubb%type;
	ContenutoPub Do_Richiesta_Az.Txtfiguraprofessionale%type;
	LuogoPub Do_Richiesta_Az.Strluogolavoro%type;
	FormazionePub Do_Richiesta_Az.Strformazionepubb%type;
	ContrattoPub Do_Richiesta_Az.Txtcondcontrattuale%type;
	ConoscenzePub Do_Richiesta_Az.Strconoscenzepubb%type;
	CaratteristichePub Do_Richiesta_Az.Txtcaratteristfigprof%type;
	OrarioPub Do_Richiesta_Az.Strnoteorariopubb%type;
	CandidaturaPub Do_Richiesta_Az.Strrifcandidaturapubb%type;


	 is_found_rec boolean := false;    

  xml_response CLOB;
  
  countOccurences number;

  CURSOR cursorConoscInfo (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is Select Tipoinfo.Strdescrizione Tipo, Dettinfo.Strdescrizione Descrizione, grado.strdescrizione Livello
      From do_info di
      inner Join De_Dett_Info Dettinfo On (di.Coddettinfo = Dettinfo.Coddettinfo)
      inner Join De_Tipo_Info Tipoinfo On (di.Codtipoinfo = Tipoinfo.Codtipoinfo)
      inner Join de_grado_info grado On (di.cdngrado = grado.cdngrado)
      where di.prgrichiestaaz = prgRichiesta and di.prgalternativa = 1;

  rec_Info cursorConoscInfo%ROWTYPE;

  tipoInfo De_Tipo_Info.Strdescrizione%type;
  dettInfo De_Dett_Info.Strdescrizione%type;
  strlivello de_grado_info.strdescrizione%type;

  CURSOR cursorStudi (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is select ds.CODTITOLO as codtitolostudio,
        dt.strdescrizione as descrizionestudio,
		decode(ds.FLGCONSEGUITO , 'S', 'Y','N','N', null) conseguitostudio,
		decode(ds.FLGINDISPENSABILE , 'S', 'Y','N','N', null) indispensabilestudio,
		ds.STRSPECIFICA as specificastudio
        From Do_Studio Ds
        inner join de_titolo dt on (ds.codtitolo = dt.codtitolo)
        where ds.prgrichiestaaz = prgRichiesta
        and ds.prgalternativa = 1
        and dt.flgmin = 'S';

  rec_Studi cursorStudi%ROWTYPE;
  codiceStudio Do_Studio.CODTITOLO%type;
  descStudio de_titolo.strdescrizione%type;
  conseguito Do_Studio.FLGCONSEGUITO%type;
  specifica Do_Studio.STRSPECIFICA%type;
  titoloindisp Do_Studio.FLGINDISPENSABILE%type;


  CURSOR cursorLingua (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is SELECT l.codlingua AS codlingua,
       		L.CDNGRADOLETTO as codlivelloletto,
	   		L.CDNGRADOSCRITTO as codlivelloscritto,
	    	L.CDNGRADOPARLATO as codlivelloparlato,
			decode(L.FLGINDISPENSABILE , 'S', 'Y','N','N', null) indisplingua
    FROM    do_lingua l
    INNER JOIN de_lingua de ON (de.codlingua = l.codlingua)
    where l.prgrichiestaaz = prgRichiesta
      and l.prgalternativa = 1;

  rec_Lingua cursorLingua%ROWTYPE;
  codLingua do_lingua.codlingua%type;
  codlivelloletto do_lingua.CDNGRADOLETTO%type;
  codlivelloscritto do_lingua.CDNGRADOSCRITTO%type;
  codlivelloparlato do_lingua.CDNGRADOPARLATO%type;
  indisplingua do_lingua.FLGINDISPENSABILE%type;

  CURSOR cursorPatente (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is select distinct Dag.Codabilitazionegen as codpatenteguida,
		decode(dag.FLGINDISPENSABILE , 'S', 'Y','N','N', null) patguidaindisp
      From Do_Abilitazione_Gen Dag
      inner Join De_Abilitazione_Gen Da On (Dag.Codabilitazionegen = Da.Codabilitazionegen)
       where dag.prgrichiestaaz = prgRichiesta
      and da.codtipoabilitazionegen = 'PG';

  rec_Patente cursorPatente%ROWTYPE;
  codpatenteguida  Do_Abilitazione_Gen.Codabilitazionegen%type;
  patguidaindisp  Do_Abilitazione_Gen.Codabilitazionegen%type;

  CURSOR cursorPatentini (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is select distinct Dag.Codabilitazionegen as codpatentino,
	decode(dag.FLGINDISPENSABILE , 'S', 'Y','N','N', null) patentinoindisp
      From Do_Abilitazione_Gen Dag
      inner Join De_Abilitazione_Gen Da On (Dag.Codabilitazionegen = Da.Codabilitazionegen)
       where dag.prgrichiestaaz = prgRichiesta
      and da.codtipoabilitazionegen = 'PT';

  rec_Patentino cursorPatentini%ROWTYPE;
  codpatentino Do_Abilitazione_Gen.Codabilitazionegen%type;
  patentinoindisp  Do_Abilitazione_Gen.Codabilitazionegen%type;

  CURSOR cursorOrario (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is select distinct o.codorario
      from do_orario o
       where o.prgrichiestaaz = prgRichiesta;

  rec_Orario cursorOrario%ROWTYPE;
  codorario do_orario.codorario%type;

  CURSOR cursorAlbo (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is select distinct dag.codabilitazionegen  as codalbo,
	 decode(dag.FLGINDISPENSABILE , 'S', 'Y','N','N', null) alboindisp
      from do_abilitazione_gen dag
      inner join de_abilitazione_gen da on (dag.codabilitazionegen = da.codabilitazionegen)
       where dag.prgrichiestaaz = prgRichiesta
      and da.codtipoabilitazionegen = 'AL' ;

  rec_Albo cursorAlbo%ROWTYPE;
  codalbo  do_abilitazione_gen.codabilitazionegen%type;
  alboindisp  do_abilitazione_gen.FLGINDISPENSABILE%type;
  
  CURSOR cursorAgevolazioni (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
     is select distinct De_Agevolazione.Codagevolazione, 
	 	decode( Do_Agevolazione.Flgindispensabile , 'S', 'Y','N','N', null)   Flgindispensabile	
		from Do_Agevolazione
		left join De_Agevolazione on (Do_Agevolazione.Codagevolazione = De_Agevolazione.Codagevolazione)
		where Do_Agevolazione.prgrichiestaaz = prgRichiesta;

  rec_Agevolazioni cursorAgevolazioni%ROWTYPE;
  codagevolazione De_Agevolazione.Codagevolazione%type;
  agevolazioneindisp Do_Agevolazione.Flgindispensabile%type;
 
  CURSOR cursorTipoRapporto (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
    is select distinct De_Contratto.Codcontratto codicecontratto
		from Do_Contratto
		inner join De_Contratto on (De_Contratto.Codcontratto = Do_Contratto.Codcontratto and nvl(De_Contratto.flgido, 'N') = 'S')
		 where Do_Contratto.prgrichiestaaz = prgRichiesta
		 and Do_Contratto.Prgalternativa= 1;

  rec_TipoRapporto cursorTipoRapporto%ROWTYPE;
  codcontratto De_Contratto.Codcontratto%type;
  
  CURSOR cursorTurno (prgRichiesta do_richiesta_az.prgRichiestaAz%TYPE)
   	is select distinct De_Turno.Codturno  codiceturno
		from do_turno
		LEFT JOIN de_turno ON (do_turno.Codturno = De_Turno.Codturno)
      where do_turno.prgrichiestaaz = prgRichiesta;

  rec_Turno cursorTurno%ROWTYPE;
  codturno  De_Turno.Codturno%type;
 
  
BEGIN
  doc := xmldom.newDOMDocument;
  main_node := xmldom.makeNode(doc);
  root_elmt := xmldom.createElement(doc, 'Vacancy');
  root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));

if(isAnteprima is not null and isAnteprima='N') then

    SELECT az.strragionesociale as denominazioneAz, az.strcodicefiscale, de_comune.strdenominazione, de_comune.codcom,
    de_cpi.stremailportale, do_richiesta_az.stremailriferimento,
    do_richiesta_az.strnomeriferimento, do_richiesta_az.strcognomeriferimento,
    do_richiesta_az.strtelriferimento, do_richiesta_az.strfaxriferimento,
    do_richiesta_az.STRNOMERIFPUBB,
    do_richiesta_az.STRCOGNOMERIFPUBB,
    do_richiesta_az.STRTELRIFPUBB,
    do_richiesta_az.STRFAXRIFPUBB,
    do_richiesta_az.STREMAILRIFPUBB,
    mn.codatecodot,mn.codateco, az.strsitointernet,
	decode(do_evasione.flgpubbcresco, 'S', 'Y', 'N', 'N', null) as flgcresco,
    decode(do_richiesta_az.codtrasferta, null, 'N', '1', 'N', 'S') as trasferte,
    decode(do_richiesta_az.flgautomunito, 'S', 'S', 'N', 'N', null) as codmezzitrasporto,
    de_cpi.strdescrizione, do_richiesta_az.numprofrichiesti,
    decode(do_richiesta_az.flgnullaosta, 'N', 'N', 'S', 'S', null) as flgnullaosta,
    decode(DE_MANSIONE.CODMANSIONEDOT, null, MANSPADRE.codmansionedot, DE_MANSIONE.CODMANSIONEDOT) codmansione,
    decode(DE_MANSIONE.Strdescrizione, null, MANSPADRE.strdescrizione, DE_MANSIONE.Strdescrizione) strdescrizionemansione,
    MANSPADRE.STRDESCRIZIONE strdescrizionemansionepadre,
    do_richiesta_az.strMansionePubb attivitaprincipale,
          PG_UTILS.TRUNC_DESC_OTTIMIZZATA(nvl(do_richiesta_az.strDatiAziendaPubb, '') || ' ' ||
            nvl(do_richiesta_az.strMansionePubb, '') || ' ' ||
            nvl(do_richiesta_az.txtFiguraProfessionale, '') || ' ' ||
            nvl(do_richiesta_az.strLuogoLavoro, '') || ' ' ||
            nvl(do_richiesta_az.strFormazionePubb, '') || ' ' ||
            nvl(do_richiesta_az.txtCaratteristFigProf, '') || ' ' ||
            nvl(do_richiesta_az.txtCondContrattuale, '') || ' ' ||
            nvl(do_richiesta_az.strConoscenzePubb, '') || ' ' ||
            nvl(do_richiesta_az.strNoteOrarioPubb, '') || ' ' ||
            nvl(do_richiesta_az.strRifCandidaturaPubb, ''), 17990, '...') As Descrizionericerca,
    to_char(do_richiesta_az.datpubblicazione,'yyyy-mm-dd') as datpubblicazione,
    (case
      when DO_EVASIONE.CDNSTATORICH = 5 then to_char((trunc(sysdate)-1), 'yyyy-mm-dd')
      else to_char(do_richiesta_az.datscadenzapubblicazione,'yyyy-mm-dd')
    end) as datscadenzapubblicazione,
    nvl(do_richiesta_az.numrichiestaorig, do_richiesta_az.numrichiesta) as numrichiesta, do_richiesta_az.numanno, do_richiesta_az.codcpi,
	(case
      when de_provincia.codprovincia is not null and de_provincia.strtarga is not null then 'SIL' || upper(de_provincia.strtarga)
	  when PROVCPI.codprovincia is not null and PROVCPI.strtarga is not null and
				(select upper(flgpoloreg) from ts_generale where prggenerale = 1) = 'S' then 'SIL' || upper(PROVCPI.strtarga)
      else (select 'SIL' || upper(p.strtarga)
			from ts_generale t
			inner join de_provincia p on t.codprovinciasil = p.codprovincia)
    end) as provenienza,
      azref.strnome as nomeRif,
      azref.strcognome as cognomeRif,
      azref.stremail as emailRegistrazione,
    UAZ.strindirizzo as indirizzoSedeOperativa,
    nvl(UAZ.strcap, DE_COMUNE.strcap)  as capSedeOperativa,
    UAZ.codcom as codComuneSedeOperativa,
    nvl(UAZ.strtel, '0') as telefonoSedeOperativa,
    nvl(UAZ.strfax, '0') as faxSedeOperativa, deev.codevasione, do_comune.codcom,
	decode(do_richiesta_az.Flgfuorisede, 'S', 'Y','N','N', null) as Flgfuorisede,
  	decode(do_richiesta_az.Flgautomunito, 'S', 'Y','N','N', 'P','P', null) as Flgautomunito,
  	decode(do_richiesta_az.Flgmotomunito, 'S', 'Y','N','N', 'P','P', null) as Flgmotomunito,
  	decode(do_richiesta_az.Flgmilite, 'S', 'Y','N','N', 'P','P', null) as Flgmilite,
	do_richiesta_az.Strsesso,
	Gen.Codmotgenere,
	do_richiesta_az.Strmotivsesso,
	Ar.Codarea,
	do_richiesta_az.Strlocalita,
	Tr.Codtrasferta,
	decode(do_richiesta_az.Flgvittoalloggio, 'S', 'Y','N','N', null) as Flgvittoalloggio,
	do_richiesta_az.Txtnoteoperatore ,	 Do_Richiesta_Az.Strdatiaziendapubb,Do_Richiesta_Az.Strmansionepubb,
    Do_Richiesta_Az.Txtfiguraprofessionale,Do_Richiesta_Az.Strluogolavoro,Do_Richiesta_Az.Strformazionepubb,
    Do_Richiesta_Az.Txtcondcontrattuale,Do_Richiesta_Az.Strconoscenzepubb,Do_Richiesta_Az.Txtcaratteristfigprof,
    Do_Richiesta_Az.Strnoteorariopubb, Do_Richiesta_Az.Strrifcandidaturapubb,
	decode(DO_EVASIONE.flg_candidatura, 'S', 'Y','N','N', null) as flgCandidatura,
    SPI.STRNOME, SPI.STRCOGNOME,
    decode(DE_MANSIONE.CODMANSIONE, null, MANSPADRE.codmansione, DE_MANSIONE.CODMANSIONE) as codmansioneId
  INTO ragSocAz, codiceFisc, comuneDenominazione, codcomune,
    emailPortale, emailRif,
    nomeriferimento, cognomeriferimento, telriferimento, faxriferimento,
    nomeriferimentopubb, cognomeriferimentopubb, telriferimentopubb, faxriferimentopubb, emailRifpubb,
    atecoAz, codAtecoAz, sitoWeb,cresco, flgTrasferta, codmezzitrasporto,
    descCpi, numProfili,flgnullaosta, codMansione, descMansione, descMansioneGruppo, p_attivitaprincipale,
    descRicerca, datpubblicazione, datscadenzapubblicazione,
    numrichiesta, numanno, codcpi, provenienza,
    nomeRif, cognomeRif, emailRegistrazione,
    indirizzoSedeOperativa, capSedeOperativa, codComuneSedeOperativa,
    telefonoSedeOperativa, faxSedeOperativa, codevasione, comuneOfferte,
	fuorisede,automunito, motomunito, milite, sesso, motivosesso, notamotivosesso, 
	areainserimento,localita, trasferta, alloggio, noteoperatore,	DatiAziendaPub ,
	MansionePub ,	ContenutoPub ,LuogoPub,	FormazionePub ,	ContrattoPub ,
	ConoscenzePub ,	CaratteristichePub ,	OrarioPub ,	CandidaturaPub , candidaturaPalese, nomeOperatore, cognomeOperatore, codMansioneId
  FROM DO_RICHIESTA_AZ
  INNER JOIN DO_ALTERNATIVA ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_ALTERNATIVA.PRGRICHIESTAAZ)
  INNER JOIN DO_EVASIONE ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_EVASIONE.PRGRICHIESTAAZ)
  INNER JOIN DE_EVASIONE_RICH DEEV ON (DEEV.CODEVASIONE = DO_EVASIONE.CODEVASIONE)
  INNER JOIN DO_MANSIONE ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_MANSIONE.PRGRICHIESTAAZ AND DO_ALTERNATIVA.PRGALTERNATIVA = DO_MANSIONE.PRGALTERNATIVA)
  INNER JOIN DE_MANSIONE ON (DO_MANSIONE.CODMANSIONE = DE_MANSIONE.CODMANSIONE)
  LEFT JOIN DE_MANSIONE MANSPADRE ON (DE_MANSIONE.CODPADRE = MANSPADRE.CODMANSIONE)
  LEFT JOIN AN_SPI SPI ON (DO_RICHIESTA_AZ.prgspi = SPI.prgspi )
  INNER JOIN DO_COMUNE ON (DO_COMUNE.PRGRICHIESTAAZ = DO_RICHIESTA_AZ.PRGRICHIESTAAZ)
  INNER JOIN AN_AZIENDA AZ ON (DO_RICHIESTA_AZ.PRGAZIENDA = AZ.PRGAZIENDA)
  INNER JOIN AN_UNITA_AZIENDA UAZ ON (AZ.PRGAZIENDA = UAZ.PRGAZIENDA AND DO_RICHIESTA_AZ.PRGUNITA = UAZ.PRGUNITA)
  LEFT JOIN an_az_referente azref on (DO_RICHIESTA_AZ.prgazienda = azref.prgazienda and DO_RICHIESTA_AZ.prgunita = azref.prgunita
                      and azref.codruoloaz = 'RSA')
  INNER JOIN DE_COMUNE ON (UAZ.CODCOM = DE_COMUNE.CODCOM)
  LEFT JOIN DE_ATTIVITA MN ON (UAZ.CODATECO = MN.CODATECO)
  INNER JOIN DE_CPI ON (DO_RICHIESTA_AZ.CODCPI = DE_CPI.CODCPI)
  LEFT JOIN De_Mot_Genere gen ON (do_richiesta_az.Codmotgenere = Gen.Codmotgenere)
  LEFT JOIN De_Area ar ON (do_richiesta_az.Codarea = Ar.Codarea)
  LEFT JOIN De_Trasferta tr ON (do_richiesta_az.Codtrasferta = Tr.Codtrasferta)
  LEFT JOIN de_provincia ON (DO_RICHIESTA_AZ.CODPROVINCIAPROV = de_provincia.CODPROVINCIA)
  LEFT JOIN DE_COMUNE COMCPI ON (DE_CPI.CODCOM = COMCPI.CODCOM)
  LEFT JOIN DE_PROVINCIA PROVCPI ON (COMCPI.CODPROVINCIA = PROVCPI.CODPROVINCIA)
  WHERE DO_RICHIESTA_AZ.PRGRICHIESTAAZ = prgRichiesta
  AND DO_ALTERNATIVA.PRGALTERNATIVA = 1
  AND DO_MANSIONE.FLGINVIOCL = 'S' AND DO_COMUNE.FLGINVIOCL = 'S';
  
  elsif(isAnteprima = 'S') then
		SELECT az.strragionesociale as denominazioneAz, az.strcodicefiscale, de_comune.strdenominazione, de_comune.codcom,
		de_cpi.stremailportale, do_richiesta_az.stremailriferimento,
		do_richiesta_az.strnomeriferimento, do_richiesta_az.strcognomeriferimento,
		do_richiesta_az.strtelriferimento, do_richiesta_az.strfaxriferimento,
		do_richiesta_az.STRNOMERIFPUBB,
		do_richiesta_az.STRCOGNOMERIFPUBB,
		do_richiesta_az.STRTELRIFPUBB,
		do_richiesta_az.STRFAXRIFPUBB,
		do_richiesta_az.STREMAILRIFPUBB,
		mn.codatecodot,mn.codateco, az.strsitointernet,
		decode(do_evasione.flgpubbcresco, 'S', 'Y', 'N', 'N', null) as flgcresco,
		decode(do_richiesta_az.codtrasferta, null, 'N', '1', 'N', 'S') as trasferte,
		decode(do_richiesta_az.flgautomunito, 'S', 'S', 'N', 'N', null) as codmezzitrasporto,
		de_cpi.strdescrizione, do_richiesta_az.numprofrichiesti,
		decode(do_richiesta_az.flgnullaosta, 'N', 'N', 'S', 'S', null) as flgnullaosta,
		decode(DE_MANSIONE.CODMANSIONEDOT, null, MANSPADRE.codmansionedot, DE_MANSIONE.CODMANSIONEDOT) codmansione,
		decode(DE_MANSIONE.Strdescrizione, null, MANSPADRE.strdescrizione, DE_MANSIONE.Strdescrizione) strdescrizionemansione,
		MANSPADRE.STRDESCRIZIONE strdescrizionemansionepadre,
		do_richiesta_az.strMansionePubb attivitaprincipale,
			  PG_UTILS.TRUNC_DESC_OTTIMIZZATA(nvl(do_richiesta_az.strDatiAziendaPubb, '') || ' ' ||
				nvl(do_richiesta_az.strMansionePubb, '') || ' ' ||
				nvl(do_richiesta_az.txtFiguraProfessionale, '') || ' ' ||
				nvl(do_richiesta_az.strLuogoLavoro, '') || ' ' ||
				nvl(do_richiesta_az.strFormazionePubb, '') || ' ' ||
				nvl(do_richiesta_az.txtCaratteristFigProf, '') || ' ' ||
				nvl(do_richiesta_az.txtCondContrattuale, '') || ' ' ||
				nvl(do_richiesta_az.strConoscenzePubb, '') || ' ' ||
				nvl(do_richiesta_az.strNoteOrarioPubb, '') || ' ' ||
				nvl(do_richiesta_az.strRifCandidaturaPubb, ''), 17990, '...') As Descrizionericerca,
		to_char(do_richiesta_az.datpubblicazione,'yyyy-mm-dd') as datpubblicazione,
		(case
		  when DO_EVASIONE.CDNSTATORICH = 5 then to_char((trunc(sysdate)-1), 'yyyy-mm-dd')
		  else to_char(do_richiesta_az.datscadenzapubblicazione,'yyyy-mm-dd')
		end) as datscadenzapubblicazione,
		nvl(do_richiesta_az.numrichiestaorig, do_richiesta_az.numrichiesta) as numrichiesta, do_richiesta_az.numanno, do_richiesta_az.codcpi,
		(case
		  when de_provincia.codprovincia is not null and de_provincia.strtarga is not null then 'SIL' || upper(de_provincia.strtarga)
		  when PROVCPI.codprovincia is not null and PROVCPI.strtarga is not null and
					(select upper(flgpoloreg) from ts_generale where prggenerale = 1) = 'S' then 'SIL' || upper(PROVCPI.strtarga)
		  else (select 'SIL' || upper(p.strtarga)
				from ts_generale t
				inner join de_provincia p on t.codprovinciasil = p.codprovincia)
		end) as provenienza,
		  azref.strnome as nomeRif,
		  azref.strcognome as cognomeRif,
		  azref.stremail as emailRegistrazione,
		UAZ.strindirizzo as indirizzoSedeOperativa,
		nvl(UAZ.strcap, DE_COMUNE.strcap)  as capSedeOperativa,
		UAZ.codcom as codComuneSedeOperativa,
		nvl(UAZ.strtel, '0') as telefonoSedeOperativa,
		nvl(UAZ.strfax, '0') as faxSedeOperativa, deev.codevasione, do_comune.codcom,
		decode(do_richiesta_az.Flgfuorisede, 'S', 'Y','N','N', null) as Flgfuorisede,
		decode(do_richiesta_az.Flgautomunito, 'S', 'Y','N','N', 'P','P', null) as Flgautomunito,
		decode(do_richiesta_az.Flgmotomunito, 'S', 'Y','N','N', 'P','P', null) as Flgmotomunito,
		decode(do_richiesta_az.Flgmilite, 'S', 'Y','N','N', 'P','P', null) as Flgmilite,
		do_richiesta_az.Strsesso,
		Gen.Codmotgenere,
		do_richiesta_az.Strmotivsesso,
		Ar.Codarea,
		do_richiesta_az.Strlocalita,
		Tr.Codtrasferta,
		decode(do_richiesta_az.Flgvittoalloggio, 'S', 'Y','N','N', null) as Flgvittoalloggio,
		do_richiesta_az.Txtnoteoperatore ,	 Do_Richiesta_Az.Strdatiaziendapubb,Do_Richiesta_Az.Strmansionepubb,
		Do_Richiesta_Az.Txtfiguraprofessionale,Do_Richiesta_Az.Strluogolavoro,Do_Richiesta_Az.Strformazionepubb,
		Do_Richiesta_Az.Txtcondcontrattuale,Do_Richiesta_Az.Strconoscenzepubb,Do_Richiesta_Az.Txtcaratteristfigprof,
		Do_Richiesta_Az.Strnoteorariopubb, Do_Richiesta_Az.Strrifcandidaturapubb,
		decode(DO_EVASIONE.flg_candidatura, 'S', 'Y','N','N', null) as flgCandidatura,
        SPI.STRNOME, SPI.STRCOGNOME,
        decode(DE_MANSIONE.CODMANSIONE, null, MANSPADRE.codmansione, DE_MANSIONE.CODMANSIONE) as codmansioneId
	  INTO ragSocAz, codiceFisc, comuneDenominazione, codcomune,
		emailPortale, emailRif,
		nomeriferimento, cognomeriferimento, telriferimento, faxriferimento,
		nomeriferimentopubb, cognomeriferimentopubb, telriferimentopubb, faxriferimentopubb, emailRifpubb,
		atecoAz, codAtecoAz, sitoWeb,cresco, flgTrasferta, codmezzitrasporto,
		descCpi, numProfili,flgnullaosta, codMansione, descMansione, descMansioneGruppo, p_attivitaprincipale,
		descRicerca, datpubblicazione, datscadenzapubblicazione,
		numrichiesta, numanno, codcpi, provenienza,
		nomeRif, cognomeRif, emailRegistrazione,
		indirizzoSedeOperativa, capSedeOperativa, codComuneSedeOperativa,
		telefonoSedeOperativa, faxSedeOperativa, codevasione, comuneOfferte,
		fuorisede,automunito, motomunito, milite, sesso, motivosesso, notamotivosesso, 
		areainserimento,localita, trasferta, alloggio, noteoperatore,	DatiAziendaPub ,
		MansionePub ,	ContenutoPub ,LuogoPub,	FormazionePub ,	ContrattoPub ,
		ConoscenzePub ,	CaratteristichePub ,	OrarioPub ,	CandidaturaPub, candidaturaPalese,nomeOperatore, cognomeOperatore, codMansioneId
	  FROM DO_RICHIESTA_AZ
	  LEFT JOIN DO_ALTERNATIVA ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_ALTERNATIVA.PRGRICHIESTAAZ AND DO_ALTERNATIVA.PRGALTERNATIVA = 1)
	  LEFT JOIN DO_EVASIONE ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_EVASIONE.PRGRICHIESTAAZ)
	  LEFT JOIN AN_SPI SPI ON (DO_RICHIESTA_AZ.prgspi = SPI.prgspi )
      LEFT JOIN DE_EVASIONE_RICH DEEV ON (DEEV.CODEVASIONE = DO_EVASIONE.CODEVASIONE)
	  LEFT JOIN DO_MANSIONE ON (DO_RICHIESTA_AZ.PRGRICHIESTAAZ = DO_MANSIONE.PRGRICHIESTAAZ AND DO_ALTERNATIVA.PRGALTERNATIVA = DO_MANSIONE.PRGALTERNATIVA AND DO_MANSIONE.FLGINVIOCL = 'S')
	  LEFT JOIN DE_MANSIONE ON (DO_MANSIONE.CODMANSIONE = DE_MANSIONE.CODMANSIONE)
	  LEFT JOIN DE_MANSIONE MANSPADRE ON (DE_MANSIONE.CODPADRE = MANSPADRE.CODMANSIONE)
	  LEFT JOIN DO_COMUNE ON (DO_COMUNE.PRGRICHIESTAAZ = DO_RICHIESTA_AZ.PRGRICHIESTAAZ AND DO_COMUNE.FLGINVIOCL = 'S')
	  INNER JOIN AN_AZIENDA AZ ON (DO_RICHIESTA_AZ.PRGAZIENDA = AZ.PRGAZIENDA)
	  INNER JOIN AN_UNITA_AZIENDA UAZ ON (AZ.PRGAZIENDA = UAZ.PRGAZIENDA AND DO_RICHIESTA_AZ.PRGUNITA = UAZ.PRGUNITA)
	  LEFT JOIN an_az_referente azref on (DO_RICHIESTA_AZ.prgazienda = azref.prgazienda and DO_RICHIESTA_AZ.prgunita = azref.prgunita
						  and azref.codruoloaz = 'RSA')
	  INNER JOIN DE_COMUNE ON (UAZ.CODCOM = DE_COMUNE.CODCOM)
	  LEFT JOIN DE_ATTIVITA MN ON (UAZ.CODATECO = MN.CODATECO)
	  INNER JOIN DE_CPI ON (DO_RICHIESTA_AZ.CODCPI = DE_CPI.CODCPI)
	  LEFT JOIN De_Mot_Genere gen ON (do_richiesta_az.Codmotgenere = Gen.Codmotgenere)
	  LEFT JOIN De_Area ar ON (do_richiesta_az.Codarea = Ar.Codarea)
	  LEFT JOIN De_Trasferta tr ON (do_richiesta_az.Codtrasferta = Tr.Codtrasferta)
	  LEFT JOIN de_provincia ON (DO_RICHIESTA_AZ.CODPROVINCIAPROV = de_provincia.CODPROVINCIA)
	  LEFT JOIN DE_COMUNE COMCPI ON (DE_CPI.CODCOM = COMCPI.CODCOM)
      LEFT JOIN DE_PROVINCIA PROVCPI ON (COMCPI.CODPROVINCIA = PROVCPI.CODPROVINCIA)
	  WHERE DO_RICHIESTA_AZ.PRGRICHIESTAAZ = prgRichiesta;  
  end if;

	
	  select Do_Alternativa.Numda, Do_Alternativa.Numa, De_Mot_Eta.Codmoteta, Do_Alternativa.Strmotiveta, 
	 	 decode(Do_Alternativa.Flgesperienza , 'S', 'Y','N','N', null) Flgesperienza,
		Do_Alternativa.Numanniesperienza, 
		decode(Do_Alternativa.Flgformazioneprof , 'S', 'Y','N','N','P','P', null) Flgformazioneprof,
		Do_Alternativa.Strnote
		INTO numda,numa,codmoteta,notamotivoeta,esperienza,anniesperienza,formazioneprof,notaesperienze  
		from Do_Alternativa
		left join De_Mot_Eta on (Do_Alternativa.Codmoteta = De_Mot_Eta.Codmoteta)
		where Do_Alternativa.Prgrichiestaaz = prgRichiesta
		AND DO_ALTERNATIVA.PRGALTERNATIVA = 1;  
	  	
	

  item_elmt := xmldom.createElement(doc, 'DatoreLavoro');
  datLav_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));

  --Inizio DatiAnagrafici
  item_elmt := xmldom.createElement(doc, 'DatiAnagrafici');
  datAnag_node := xmldom.appendChild(datLav_node, xmldom.makeNode(item_elmt));

  item_elmt := xmldom.createElement(doc, 'codicefiscale');
  cf_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, codiceFisc);
  item_node := xmldom.appendChild(cf_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'denominazione');
  denominazione_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, ragSocAz);
  item_node := xmldom.appendChild(denominazione_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'indirizzolavoro');
  indlav_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, comuneDenominazione);
  item_node := xmldom.appendChild(indlav_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'codcomunelavoro');
  codcom_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, codcomune);
  item_node := xmldom.appendChild(codcom_node, xmldom.makeNode(item_text));

  if (atecoAz is not null) then
    item_elmt := xmldom.createElement(doc, 'settore');
    settore_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, atecoAz);
    item_node := xmldom.appendChild(settore_node, xmldom.makeNode(item_text));
  end if;

	  
  if (codAtecoAz is not null) then
    item_elmt := xmldom.createElement(doc, 'codateco');
    codateco_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codAtecoAz);
    item_node := xmldom.appendChild(codateco_node, xmldom.makeNode(item_text));
  end if;

  if (sitoWeb is not null) then
    item_elmt := xmldom.createElement(doc, 'web');
    web_node := xmldom.appendChild(datAnag_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, sitoWeb);
    item_node := xmldom.appendChild(web_node, xmldom.makeNode(item_text));
  end if;
  --Fine DatiAnagrafici

  -- MyPortal Tracker #589
  -- richieste palesi il contatto principale deve essere l'azienda
  -- per le anonime il cpi

  if ( (codevasione in ('DFD', 'DPR')) and (emailRifpubb is not null) ) then
     --Inizio DatiContatto
     item_elmt := xmldom.createElement(doc, 'DatiContatto');
     datContatto_node := xmldom.appendChild(datLav_node, xmldom.makeNode(item_elmt));

     if (nomeriferimentopubb is not null) then
      item_elmt := xmldom.createElement(doc, 'nomereferente');
      nomereferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, nomeriferimentopubb);
      item_node := xmldom.appendChild(nomereferente_node, xmldom.makeNode(item_text));
     elsif (nomeriferimento is not null) then
      item_elmt := xmldom.createElement(doc, 'nomereferente');
      nomereferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, nomeriferimento);
      item_node := xmldom.appendChild(nomereferente_node, xmldom.makeNode(item_text));
     end if;

     if (cognomeriferimentopubb is not null) then
      item_elmt := xmldom.createElement(doc, 'cognomereferente');
      cognomereferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, cognomeriferimentopubb);
      item_node := xmldom.appendChild(cognomereferente_node, xmldom.makeNode(item_text));
     elsif (cognomeriferimento is not null) then
      item_elmt := xmldom.createElement(doc, 'cognomereferente');
      cognomereferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, cognomeriferimento);
      item_node := xmldom.appendChild(cognomereferente_node, xmldom.makeNode(item_text));
     end if;

     if (telriferimentopubb is not null) then
      item_elmt := xmldom.createElement(doc, 'telefono');
      telreferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, telriferimentopubb);
      item_node := xmldom.appendChild(telreferente_node, xmldom.makeNode(item_text));
     elsif (telriferimento is not null) then
      item_elmt := xmldom.createElement(doc, 'telefono');
      telreferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, telriferimento);
      item_node := xmldom.appendChild(telreferente_node, xmldom.makeNode(item_text));
     end if;

     if (faxriferimentopubb is not null) then
      item_elmt := xmldom.createElement(doc, 'fax');
      faxreferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, faxriferimentopubb);
      item_node := xmldom.appendChild(faxreferente_node, xmldom.makeNode(item_text));
     elsif (faxriferimento is not null) then
      item_elmt := xmldom.createElement(doc, 'fax');
      faxreferente_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, faxriferimento);
      item_node := xmldom.appendChild(faxreferente_node, xmldom.makeNode(item_text));
     end if;
     
     --if (emailRifpubb is not null) then
       -- emailRif := emailRifpubb;
     --end if;

     item_elmt := xmldom.createElement(doc, 'email');
     mailContatta_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

     item_text := xmldom.createTextNode(doc, emailRifpubb);
     item_node := xmldom.appendChild(mailContatta_node, xmldom.makeNode(item_text));
     --Fine DatiContatto

     --Inizio DatiContattoAlternativo
     item_elmt := xmldom.createElement(doc, 'DatiContattoAlternativo');
     datContattoAlter_node := xmldom.appendChild(datLav_node, xmldom.makeNode(item_elmt));

     item_elmt := xmldom.createElement(doc, 'cognomereferente');
     cognref_node := xmldom.appendChild(datContattoAlter_node, xmldom.makeNode(item_elmt));

     item_text := xmldom.createTextNode(doc, descCpi);
     item_node := xmldom.appendChild(cognref_node, xmldom.makeNode(item_text));

     --Questo e' un elemento obbligatorio
     if (emailPortale is not null) then
       item_elmt := xmldom.createElement(doc, 'email');
       mailContatta_node := xmldom.appendChild(datContattoAlter_node, xmldom.makeNode(item_elmt));

       item_text := xmldom.createTextNode(doc, emailPortale);
       item_node := xmldom.appendChild(mailContatta_node, xmldom.makeNode(item_text));
     end if;
     --Fine DatiContattoAlternativo

  else

     --Inizio DatiContatto
     item_elmt := xmldom.createElement(doc, 'DatiContatto');
     datContatto_node := xmldom.appendChild(datLav_node, xmldom.makeNode(item_elmt));
     --
     item_elmt := xmldom.createElement(doc, 'cognomereferente');
     cognref_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

     item_text := xmldom.createTextNode(doc, descCpi);
     item_node := xmldom.appendChild(cognref_node, xmldom.makeNode(item_text));

     --Questo e' un elemento obbligatorio
     if (emailPortale is not null) then
       item_elmt := xmldom.createElement(doc, 'email');
       mailContatta_node := xmldom.appendChild(datContatto_node, xmldom.makeNode(item_elmt));

       item_text := xmldom.createTextNode(doc, emailPortale);
       item_node := xmldom.appendChild(mailContatta_node, xmldom.makeNode(item_text));
     end if;
     --Fine DatiContatto

  end if;

  if (descMansioneGruppo is null) then
    descMansioneGruppo := descMansione;
  end if;
  if (p_attivitaprincipale is null) then
     p_attivitaprincipale := descMansioneGruppo;
  end if;
  if (p_attivitaprincipale is not null and length(p_attivitaprincipale) > 100) then
     p_attivitaprincipale := SUBSTR(p_attivitaprincipale, 1, 97) || '...';
  end if;

  item_elmt := xmldom.createElement(doc, 'Richiesta');
  richiesta_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));

  --Inizio ProfiloRichiesto
  item_elmt := xmldom.createElement(doc, 'ProfiloRichiesto');
  profilo_node := xmldom.appendChild(richiesta_node, xmldom.makeNode(item_elmt));

  item_elmt := xmldom.createElement(doc, 'numerolavoratori');
  numlav_node := xmldom.appendChild(profilo_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, numProfili);
  item_node := xmldom.appendChild(numlav_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'attivitaprincipale');
  attivitaGruppo_node := xmldom.appendChild(profilo_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, p_attivitaprincipale);
  item_node := xmldom.appendChild(attivitaGruppo_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'codprofessione');
  professione_node := xmldom.appendChild(profilo_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, codMansione);
  item_node := xmldom.appendChild(professione_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'descrprofessione');
  descprofessione_node := xmldom.appendChild(profilo_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, descMansione);
  item_node := xmldom.appendChild(descprofessione_node, xmldom.makeNode(item_text));

  if (ContenutoPub is not null) then
  		SELECT count(*)
		into countOccurences
		FROM dual
		WHERE regexp_like (ContenutoPub , '\S') ;	
					
		if(countOccurences >0) then 
			item_elmt := xmldom.createElement(doc, 'descrizionericerca');
			descricerca_node := xmldom.appendChild(profilo_node, xmldom.makeNode(item_elmt));

			item_text := xmldom.createTextNode(doc, ContenutoPub);
			item_node := xmldom.appendChild(descricerca_node, xmldom.makeNode(item_text));
		end if;
		countOccurences := -1;
  end if;
 if (codMansioneId is not null) then
    item_elmt := xmldom.createElement(doc, 'codmansione');
    codMansione_node := xmldom.appendChild(profilo_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codMansioneId);
    item_node := xmldom.appendChild(codMansione_node, xmldom.makeNode(item_text));
 end if;

  --Fine ProfiloRichiesto

  --Inizio IstruzioneFormazione
  item_elmt := xmldom.createElement(doc, 'IstruzioneFormazione');
  istruzione_node := xmldom.appendChild(richiesta_node, xmldom.makeNode(item_elmt));


  --titoli studi
   open cursorStudi(prgRichiesta);
  loop
    fetch cursorStudi into rec_Studi;
    exit when (cursorStudi%notfound);

    codiceStudio := rec_Studi.codtitolostudio;
    descStudio := rec_Studi.descrizionestudio;
	conseguito := rec_Studi.conseguitostudio;
	titoloindisp := rec_Studi.indispensabilestudio;
	specifica := rec_Studi.specificastudio;

    item_elmt := xmldom.createElement(doc, 'titolostudio');
    titolo_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_elmt := xmldom.createElement(doc, 'codtitolostudio');
    codTitolo_node := xmldom.appendChild(titolo_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codiceStudio);
    item_node := xmldom.appendChild(codTitolo_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'descrizionestudio');
    descTitolo_node := xmldom.appendChild(titolo_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, descStudio);
    item_node := xmldom.appendChild(descTitolo_node, xmldom.makeNode(item_text));
	
	if (specifica is not null) then
		item_elmt := xmldom.createElement(doc, 'specifica');
		specifica_node := xmldom.appendChild(titolo_node, xmldom.makeNode(item_elmt));

		item_text := xmldom.createTextNode(doc, specifica);
		item_node := xmldom.appendChild(specifica_node, xmldom.makeNode(item_text));
	end if;
	
	if (conseguito is not null) then
		item_elmt := xmldom.createElement(doc, 'conseguito');
		conseguito_node := xmldom.appendChild(titolo_node, xmldom.makeNode(item_elmt));

		item_text := xmldom.createTextNode(doc, conseguito);
		item_node := xmldom.appendChild(conseguito_node, xmldom.makeNode(item_text));
	end if;
	
	if (titoloindisp is not null) then
		item_elmt := xmldom.createElement(doc, 'titoloindisp');
		titoloindisp_node := xmldom.appendChild(titolo_node, xmldom.makeNode(item_elmt));

		item_text := xmldom.createTextNode(doc, titoloindisp);
		item_node := xmldom.appendChild(titoloindisp_node, xmldom.makeNode(item_text));
	end if;

  end loop;
  close cursorStudi;
 
  --lingue
  open cursorLingua(prgRichiesta);
  loop
    fetch cursorLingua into rec_Lingua;
    exit when (cursorLingua%notfound);

    codLingua := rec_Lingua.codLingua;
    codlivelloletto := rec_Lingua.codlivelloletto;
    codlivelloscritto := rec_Lingua.codlivelloscritto;
    codlivelloparlato := rec_Lingua.codlivelloparlato;
	indisplingua := rec_Lingua.indisplingua;

    item_elmt := xmldom.createElement(doc, 'Lingua');
    lingua_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_elmt := xmldom.createElement(doc, 'codlingua');
    codLingua_node := xmldom.appendChild(lingua_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codLingua);
    item_node := xmldom.appendChild(codLingua_node, xmldom.makeNode(item_text));


    if (codlivelloletto is not null) then

      item_elmt := xmldom.createElement(doc, 'codlivelloletto');
      letto_node := xmldom.appendChild(lingua_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, codlivelloletto);
      item_node := xmldom.appendChild(letto_node, xmldom.makeNode(item_text));

    end if;

    if (codlivelloscritto is not null) then

      item_elmt := xmldom.createElement(doc, 'codlivelloscritto');
      scritto_node := xmldom.appendChild(lingua_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, codlivelloscritto);
      item_node := xmldom.appendChild(scritto_node, xmldom.makeNode(item_text));

    end if;

    if (codlivelloparlato is not null) then

      item_elmt := xmldom.createElement(doc, 'codlivelloparlato');
      parlato_node := xmldom.appendChild(lingua_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, codlivelloparlato);
      item_node := xmldom.appendChild(parlato_node, xmldom.makeNode(item_text));

    end if;
	
	if (indisplingua is not null) then
		item_elmt := xmldom.createElement(doc, 'linguaindisp');
		linguaindisp_node := xmldom.appendChild(lingua_node, xmldom.makeNode(item_elmt));

		item_text := xmldom.createTextNode(doc, indisplingua);
		item_node := xmldom.appendChild(linguaindisp_node, xmldom.makeNode(item_text));
	end if;
  end loop;
  close cursorLingua;

  --conoscenze informatiche
  descConoscenzeInfo := null;
  open cursorConoscInfo(prgRichiesta);
  loop
    fetch cursorConoscInfo into rec_Info;
    exit when (cursorConoscInfo%notfound);

    tipoInfo := rec_Info.Tipo;
    dettInfo := rec_Info.Descrizione;
    strlivello := rec_Info.Livello;

    if (descConoscenzeInfo is null) then
      descConoscenzeInfo := nvl(tipoInfo, '') || '-' || nvl(dettInfo, '') || '-' || nvl(strlivello, '') || ' ';
    else
      descConoscenzeInfo := descConoscenzeInfo || nvl(tipoInfo, '') || '-' || nvl(dettInfo, '') || '-' || nvl(strlivello, '') || ' ';
    end if;

  end loop;
  close cursorConoscInfo;

  if (descConoscenzeInfo is not null) then
    if (length(descConoscenzeInfo) > 1000) then
      descConoscenzeInfo := SUBSTR(descConoscenzeInfo, 1, 997) || '...';
    end if;

    item_elmt := xmldom.createElement(doc, 'conoscenzeinformatiche');
    info_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, descConoscenzeInfo);
    item_node := xmldom.appendChild(info_node, xmldom.makeNode(item_text));

  end if;

  --trasferte
  item_elmt := xmldom.createElement(doc, 'trasferte');
  trasferta_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, flgTrasferta);
  item_node := xmldom.appendChild(trasferta_node, xmldom.makeNode(item_text));

  if (codmezzitrasporto is not null) then

    item_elmt := xmldom.createElement(doc, 'codmezzitrasporto');
    mezzi_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codmezzitrasporto);
    item_node := xmldom.appendChild(mezzi_node, xmldom.makeNode(item_text));

  end if;

  --orario
  open cursorOrario(prgRichiesta);
  loop
    fetch cursorOrario into rec_Orario;
    exit when (cursorOrario%notfound);

    codorario := rec_Orario.Codorario;

    item_elmt := xmldom.createElement(doc, 'codorario');
    orario_node := xmldom.appendChild(istruzione_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, codorario);
    item_node := xmldom.appendChild(orario_node, xmldom.makeNode(item_text));

  end loop;
  close cursorOrario;

  --Fine IstruzioneFormazione


  --Inizio CondizioniOfferte
  item_elmt := xmldom.createElement(doc, 'CondizioniOfferte');
  offerte_node := xmldom.appendChild(richiesta_node, xmldom.makeNode(item_elmt));

  item_elmt := xmldom.createElement(doc, 'codcomune');
  comuneofferte_node := xmldom.appendChild(offerte_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, comuneOfferte);
  item_node := xmldom.appendChild(comuneofferte_node, xmldom.makeNode(item_text));

  -- codtipologiacontratto / codrapportolav

  BEGIN

    select codrapportolav
    into contrattoOfferte
    from do_richiesta_az
    where prgrichiestaaz = prgRichiesta;

  EXCEPTION
    when others then
      contrattoOfferte := null;
  END;

  IF contrattoOfferte is not null THEN

    item_elmt := xmldom.createElement(doc, 'codtipologiacontratto');
    contrattoofferte_node := xmldom.appendChild(offerte_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, trim(contrattoOfferte));
    item_node := xmldom.appendChild(contrattoofferte_node, xmldom.makeNode(item_text));

  END IF;

  --Fine CondizioniOfferte

  --Inizio Flgnullaosta
  IF flgnullaosta is not null THEN
    item_elmt := xmldom.createElement(doc, 'Flgnullaosta');
    flgnullaosta_node := xmldom.appendChild(richiesta_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, trim(flgnullaosta));
    item_node := xmldom.appendChild(flgnullaosta_node, xmldom.makeNode(item_text));
  END IF;
  --Fine Flgnullaosta

  --Inizio DurataRichiesta
  item_elmt := xmldom.createElement(doc, 'DurataRichiesta');
  duratarich_node := xmldom.appendChild(richiesta_node, xmldom.makeNode(item_elmt));

  if (datpubblicazione is not null) then

    item_elmt := xmldom.createElement(doc, 'datapubblicazione');
    datpubb_node := xmldom.appendChild(duratarich_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, datpubblicazione);
    item_node := xmldom.appendChild(datpubb_node, xmldom.makeNode(item_text));

  end if;

  if (datscadenzapubblicazione is not null) then

    item_elmt := xmldom.createElement(doc, 'datascadenzapubblicazione');
    datscadpubb_node := xmldom.appendChild(duratarich_node, xmldom.makeNode(item_elmt));

    item_text := xmldom.createTextNode(doc, datscadenzapubblicazione);
    item_node := xmldom.appendChild(datscadpubb_node, xmldom.makeNode(item_text));

  end if;

  --Fine DurataRichiesta


  if (codevasione in ('DFD', 'DPR')) then
    if ( (nomeRif is null) or (cognomeRif is null) or (emailRegistrazione is null) ) then
      nomeRif := nomeriferimento;
      cognomeRif := cognomeriferimento;
      emailRegistrazione := emailRif;
    end if;

    if ( (nomeRif is not null) and (cognomeRif is not null) and (emailRegistrazione is not null) ) then
      --Inizio RegistrazioneAzienda
      item_elmt := xmldom.createElement(doc, 'RegistrazioneAzienda');
      regazienda_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'DatiRichiedente');
      datRich_node := xmldom.appendChild(regazienda_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'nome');
      nomeRif_node := xmldom.appendChild(datRich_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, nomeRif);
      item_node := xmldom.appendChild(nomeRif_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'cognome');
      cognomeRif_node := xmldom.appendChild(datRich_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, cognomeRif);
      item_node := xmldom.appendChild(cognomeRif_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'emailregistrazione');
      emailRif_node := xmldom.appendChild(datRich_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, emailRegistrazione);
      item_node := xmldom.appendChild(emailRif_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'DatiAzienda');
      datiAzienda_node := xmldom.appendChild(regazienda_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'codicefiscale');
      codFisc_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, codiceFisc);
      item_node := xmldom.appendChild(codFisc_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'ragionesociale');
      ragsoc_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, ragSocAz);
      item_node := xmldom.appendChild(ragsoc_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'indirizzosedeoperativa');
      indsedeop_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, indirizzoSedeOperativa);
      item_node := xmldom.appendChild(indsedeop_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'capsedeoperativa');
      capsedeop_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, capSedeOperativa);
      item_node := xmldom.appendChild(capsedeop_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'codcomunesedeoperativa');
      comsedeop_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, codComuneSedeOperativa);
      item_node := xmldom.appendChild(comsedeop_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'telefonosedeoperativa');
      telsedeop_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, telefonoSedeOperativa);
      item_node := xmldom.appendChild(telsedeop_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'faxsedeoperativa');
      faxsedeop_node := xmldom.appendChild(datiAzienda_node, xmldom.makeNode(item_elmt));

      item_text := xmldom.createTextNode(doc, faxSedeOperativa);
      item_node := xmldom.appendChild(faxsedeop_node, xmldom.makeNode(item_text));

      --Fine RegistrazioneAzienda
    end if;
  end if;


  --Inizio DatiSistema
  item_elmt := xmldom.createElement(doc, 'DatiSistema');
  datSistema_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));

  item_elmt := xmldom.createElement(doc, 'numeroofferta');
  numOff_node := xmldom.appendChild(datSistema_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, numrichiesta);
  item_node := xmldom.appendChild(numOff_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'annoofferta');
  annoOff_node := xmldom.appendChild(datSistema_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, numanno);
  item_node := xmldom.appendChild(annoOff_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'provenienza');
  provOff_node := xmldom.appendChild(datSistema_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, provenienza);
  item_node := xmldom.appendChild(provOff_node, xmldom.makeNode(item_text));

  item_elmt := xmldom.createElement(doc, 'cpi');
  cpiOff_node := xmldom.appendChild(datSistema_node, xmldom.makeNode(item_elmt));

  item_text := xmldom.createTextNode(doc, codcpi);
  item_node := xmldom.appendChild(cpiOff_node, xmldom.makeNode(item_text));

  --Fine DatiSistema

  --Inizio DatiAggiuntivi
  SELECT nvl( (select to_char(ts_config_loc.num) num 
	  from ts_config_loc
	  where strcodrif=(select ts_generale.codprovinciasil from ts_generale) and codtipoconfig='OPZCRESC') , 0) as num 
  INTO num_cresco
  FROM dual;
  
   SELECT nvl( (select to_char(ts_config_loc.num) num 
	  from ts_config_loc
	  where strcodrif=(select ts_generale.codprovinciasil from ts_generale) and codtipoconfig='CANDPALE') , 0) as num 
  INTO num_candidatura
  FROM dual;
  
  item_elmt := xmldom.createElement(doc, 'DatiAggiuntivi');
  datAggiuntivi_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));
	  --Inizio DatiGenerali
	  item_elmt := xmldom.createElement(doc, 'DatiGenerali');
	  datiGenerali_node := xmldom.appendChild(datAggiuntivi_node, xmldom.makeNode(item_elmt));
	
	  if (num_cresco = 1 ) then
		  if (cresco is not null) then

			item_elmt := xmldom.createElement(doc, 'opz_cresco');
			cresco_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

			item_text := xmldom.createTextNode(doc, cresco);
			item_node := xmldom.appendChild(cresco_node, xmldom.makeNode(item_text));
		  end if;		
	  end if;	
	
	  item_elmt := xmldom.createElement(doc, 'opz_tipo_decodifiche');
	  opzTipoDec_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

	  item_text := xmldom.createTextNode(doc, 'S');
	  item_node := xmldom.appendChild(opzTipoDec_node, xmldom.makeNode(item_text));

	  item_elmt := xmldom.createElement(doc, 'opz_invio_clicl');
	  opzInvioClicl_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

	  item_text := xmldom.createTextNode(doc, 'N');
	  item_node := xmldom.appendChild(opzInvioClicl_node, xmldom.makeNode(item_text));
	  
	  if (fuorisede is not null) then
		  item_elmt := xmldom.createElement(doc, 'fuorisede');
		  fuorisede_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, fuorisede);
		  item_node := xmldom.appendChild(fuorisede_node, xmldom.makeNode(item_text));
	  end if;
	  
	  if (automunito is not null) then
		  item_elmt := xmldom.createElement(doc, 'automunito');
		  automunito_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, automunito);
		  item_node := xmldom.appendChild(automunito_node, xmldom.makeNode(item_text));
	 end if;

	 if (motomunito is not null) then
		  item_elmt := xmldom.createElement(doc, 'motomunito');
		  motomunito_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, motomunito);
		  item_node := xmldom.appendChild(motomunito_node, xmldom.makeNode(item_text));
	 end if;
	 
	  if (milite is not null) then
		  item_elmt := xmldom.createElement(doc, 'milite');
		  milite_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, milite);
		  item_node := xmldom.appendChild(milite_node, xmldom.makeNode(item_text));
	 end if;
	 
	if (sesso is not null) then
		  item_elmt := xmldom.createElement(doc, 'sesso');
		  sesso_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, sesso);
		  item_node := xmldom.appendChild(sesso_node, xmldom.makeNode(item_text));
	  end if; 
	  
	  if (motivosesso is not null) then
		  item_elmt := xmldom.createElement(doc, 'motivosesso');
		  motsesso_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, motivosesso);
		  item_node := xmldom.appendChild(motsesso_node, xmldom.makeNode(item_text));
	   end if;
	   
	  if (notamotivosesso is not null) then
	  	 SELECT count(*)
   		   into countOccurences
		   FROM dual
		   WHERE regexp_like (notamotivosesso , '\S') ;		
		   
		   if(countOccurences>0) then
			  item_elmt := xmldom.createElement(doc, 'notamotivosesso');
			  notamotsesso_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

			  item_text := xmldom.createTextNode(doc, notamotivosesso);
			  item_node := xmldom.appendChild(notamotsesso_node, xmldom.makeNode(item_text));
		   end if;
		   countOccurences := -1;
	   end if;
	   
	  if (areainserimento is not null) then
		  item_elmt := xmldom.createElement(doc, 'codarea');
		  areainserimento_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, areainserimento);
		  item_node := xmldom.appendChild(areainserimento_node, xmldom.makeNode(item_text));
	   end if;
	   
	  if (localita is not null) then
		  item_elmt := xmldom.createElement(doc, 'localita');
		  localita_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, localita);
		  item_node := xmldom.appendChild(localita_node, xmldom.makeNode(item_text));
	   end if;
	   
	  if (trasferta is not null) then
		  item_elmt := xmldom.createElement(doc, 'trasferta');
		  trasf_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, trasferta);
		  item_node := xmldom.appendChild(trasf_node, xmldom.makeNode(item_text));
	   end if;
	   
	  if (alloggio is not null) then
		  item_elmt := xmldom.createElement(doc, 'alloggio');
		  alloggio_node := xmldom.appendChild(alloggio_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, alloggio);
		  item_node := xmldom.appendChild(alloggio_node, xmldom.makeNode(item_text));
	   end if;
	   
	  if (noteoperatore is not null) then
			SELECT count(*)
			into countOccurences
			FROM dual
			WHERE regexp_like (noteoperatore , '\S') ;	
			
			if(countOccurences >0) then 
			  item_elmt := xmldom.createElement(doc, 'noteoperatore');
			  noteoperatore_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

			  item_text := xmldom.createTextNode(doc, noteoperatore);
			  item_node := xmldom.appendChild(noteoperatore_node, xmldom.makeNode(item_text));
		   end if;
	   end if;
	   
	   
	   	
	  if (num_candidatura = 1 ) then
		  if (candidaturaPalese is not null) then

			item_elmt := xmldom.createElement(doc, 'flgcandidatura');
			candidaturaPalese_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

			item_text := xmldom.createTextNode(doc, candidaturaPalese);
			item_node := xmldom.appendChild(candidaturaPalese_node, xmldom.makeNode(item_text));
		  end if;		
	  end if;	
	   
      
        if (codEvasione is not null) then
            item_elmt := xmldom.createElement(doc, 'cod_evasione');
            codEvasione_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

            item_text := xmldom.createTextNode(doc, codEvasione);
            item_node := xmldom.appendChild(codEvasione_node, xmldom.makeNode(item_text));
       end if;
       
          if (nomeOperatore is not null) then
            item_elmt := xmldom.createElement(doc, 'nome_operatore');
            nomeOperatore_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

            item_text := xmldom.createTextNode(doc, nomeOperatore);
            item_node := xmldom.appendChild(nomeOperatore_node, xmldom.makeNode(item_text));
       end if;
       
         if (cognomeOperatore is not null) then
            item_elmt := xmldom.createElement(doc, 'cognome_operatore');
            cognomeOperatore_node := xmldom.appendChild(datiGenerali_node, xmldom.makeNode(item_elmt));

            item_text := xmldom.createTextNode(doc, cognomeOperatore);
            item_node := xmldom.appendChild(cognomeOperatore_node, xmldom.makeNode(item_text));
       end if;
       
	   
	  --Fine DatiGenerali
	  
	  --Inizio Turni	  
	  item_elmt := xmldom.createElement(doc, 'Turni');
	  turni_node := xmldom.appendChild(datAggiuntivi_node, xmldom.makeNode(item_elmt));
	  
	  open cursorTurno(prgRichiesta);
	  loop
		fetch cursorTurno into rec_Turno;
		exit when (cursorTurno%notfound);
		  codturno := rec_Turno.codiceturno;

		  item_elmt := xmldom.createElement(doc, 'codturno');
		  codturno_node := xmldom.appendChild(turni_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, codturno);
		  item_node := xmldom.appendChild(codturno_node, xmldom.makeNode(item_text));
		  
	  end loop;
	  close cursorTurno; 
	  --Fine Turni
	  
	  --Inizio Esperienze
	  item_elmt := xmldom.createElement(doc, 'Esperienze');
	  esperienze_node := xmldom.appendChild(datAggiuntivi_node, xmldom.makeNode(item_elmt));
 
 	if(numda is not null) then
	  item_elmt := xmldom.createElement(doc, 'numda');
	  numda_node := xmldom.appendChild(esperienze_node, xmldom.makeNode(item_elmt));

	  item_text := xmldom.createTextNode(doc, numda);
	  item_node := xmldom.appendChild(numda_node, xmldom.makeNode(item_text));
 	end if;
	
	  if(numa is not null) then
		  item_elmt := xmldom.createElement(doc, 'numa');
		  numa_node := xmldom.appendChild(esperienze_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, numa);
		  item_node := xmldom.appendChild(numa_node, xmldom.makeNode(item_text));
	  end if;

 	if(codmoteta is not null) then
	  item_elmt := xmldom.createElement(doc, 'codmoteta');
	  codmoteta_node := xmldom.appendChild(esperienze_node, xmldom.makeNode(item_elmt));

	  item_text := xmldom.createTextNode(doc, codmoteta);
	  item_node := xmldom.appendChild(codmoteta_node, xmldom.makeNode(item_text));
 	end if;
 
	 if(notamotivoeta is not null) then
		SELECT count(*)
		into countOccurences
		FROM dual
		WHERE regexp_like (notamotivoeta , '\S') ;	
					
		if(countOccurences >0) then 
		  item_elmt := xmldom.createElement(doc, 'notamotivoeta');
		  notamotivoeta_node := xmldom.appendChild(esperienze_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, notamotivoeta);
		  item_node := xmldom.appendChild(notamotivoeta_node, xmldom.makeNode(item_text));
		end if;
		countOccurences :=-1;
	end if;
 
	 if(esperienza is not null) then
		  item_elmt := xmldom.createElement(doc, 'esperienza');
		  esperienza_node := xmldom.appendChild(esperienze_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, esperienza);
		  item_node := xmldom.appendChild(esperienza_node, xmldom.makeNode(item_text));
	  end if;
	   
	  if(anniesperienza is not null) then 
		  item_elmt := xmldom.createElement(doc, 'anniesperienza');
		  anniesperienza_node := xmldom.appendChild(esperienze_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, anniesperienza);
		  item_node := xmldom.appendChild(anniesperienza_node, xmldom.makeNode(item_text));
	  end if;
	   
	  if(formazioneprof is not null) then
		  item_elmt := xmldom.createElement(doc, 'formazioneprof');
		  formazioneprof_node := xmldom.appendChild(esperienze_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, formazioneprof);
		  item_node := xmldom.appendChild(formazioneprof_node, xmldom.makeNode(item_text));
	  end if;
	   
	  if(notaesperienze is not null) then
		SELECT count(*)
		into countOccurences
		FROM dual
		WHERE regexp_like (notaesperienze , '\S') ;	
					
		if(countOccurences >0) then 
		  item_elmt := xmldom.createElement(doc, 'notaesperienza');
		  notaesperienze_node := xmldom.appendChild(esperienze_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, notaesperienze);
		  item_node := xmldom.appendChild(notaesperienze_node, xmldom.makeNode(item_text));
	   end if;
	   countOccurences := -1;
	  end if;
	  --Fine Esperienze
	  
	  --Inizio Agevolazioni
	  open cursorAgevolazioni(prgRichiesta);
	  loop
		fetch cursorAgevolazioni into rec_Agevolazioni;
		exit when (cursorAgevolazioni%notfound);

  		item_elmt := xmldom.createElement(doc, 'Agevolazioni');
	    agevolazioni_node := xmldom.appendChild(datAggiuntivi_node, xmldom.makeNode(item_elmt));
		codagevolazione := rec_Agevolazioni.codagevolazione;
		
		if (codagevolazione is not null) then
			item_elmt := xmldom.createElement(doc, 'codagevolazione');
			codagevolazione_node := xmldom.appendChild(agevolazioni_node, xmldom.makeNode(item_elmt));

			item_text := xmldom.createTextNode(doc, codagevolazione);
			item_node := xmldom.appendChild(codagevolazione_node, xmldom.makeNode(item_text));
		end if;
		
		agevolazioneindisp := rec_Agevolazioni.flgindispensabile;
		
		if (agevolazioneindisp is not null) then
			item_elmt := xmldom.createElement(doc, 'agevolazioneindisp');
			agevolazioneindisp_node := xmldom.appendChild(agevolazioni_node, xmldom.makeNode(item_elmt));

			item_text := xmldom.createTextNode(doc, agevolazioneindisp);
			item_node := xmldom.appendChild(agevolazioneindisp_node, xmldom.makeNode(item_text));
		end if;

	  end loop;
	  close cursorAgevolazioni;
	  --Fine Agevolazioni
	  
	  --Inizio TipoRapporto
	 item_elmt := xmldom.createElement(doc, 'TipoRapporto');
	 tipoRapporto_node := xmldom.appendChild(datAggiuntivi_node, xmldom.makeNode(item_elmt));
	  open cursorTipoRapporto(prgRichiesta);
	  loop
		fetch cursorTipoRapporto into rec_TipoRapporto;
		exit when (cursorTipoRapporto%notfound);

		codcontratto := rec_TipoRapporto.codicecontratto;

		item_elmt := xmldom.createElement(doc, 'codcontratto');
		codcontratto_node := xmldom.appendChild(tipoRapporto_node, xmldom.makeNode(item_elmt));

		item_text := xmldom.createTextNode(doc, codcontratto);
		item_node := xmldom.appendChild(codcontratto_node, xmldom.makeNode(item_text));
		
	  end loop;
	  close cursorTipoRapporto;
	  --Fine TipoRapporto
	  
	 --Inizio Abilitazioni
	 item_elmt := xmldom.createElement(doc, 'Abilitazioni');
	 abilitazioni_node := xmldom.appendChild(datAggiuntivi_node, xmldom.makeNode(item_elmt));
	 
	 --albo
	
	  open cursorAlbo(prgRichiesta);
	  loop
		fetch cursorAlbo into rec_Albo;
		exit when (cursorAlbo%notfound);

		codalbo := rec_Albo.codalbo;
		alboindisp := rec_Albo.alboindisp;
		
	    item_elmt := xmldom.createElement(doc, 'Albi');
		albi_node := xmldom.appendChild(abilitazioni_node, xmldom.makeNode(item_elmt));

		if(codalbo is not null) then
			item_elmt := xmldom.createElement(doc, 'codalbo');
			albo_node := xmldom.appendChild(albi_node, xmldom.makeNode(item_elmt));

			item_text := xmldom.createTextNode(doc, codalbo);
			item_node := xmldom.appendChild(albo_node, xmldom.makeNode(item_text));
		end if;

		if(alboindisp is not null) then
			item_elmt := xmldom.createElement(doc, 'alboindisp');
			alboindisp_node := xmldom.appendChild(albi_node, xmldom.makeNode(item_elmt));

			item_text := xmldom.createTextNode(doc, alboindisp);
			item_node := xmldom.appendChild(alboindisp_node, xmldom.makeNode(item_text));
		end if;

	  end loop;
	  close cursorAlbo;

	  --patente guida

	  open cursorPatente(prgRichiesta);
	  loop
		fetch cursorPatente into rec_Patente;
		exit when (cursorPatente%notfound);

		codpatenteguida := rec_Patente.codpatenteguida;
		patguidaindisp := rec_Patente.patguidaindisp;
		
		item_elmt := xmldom.createElement(doc, 'Patenti');
	 	patenti_node := xmldom.appendChild(abilitazioni_node, xmldom.makeNode(item_elmt));

		if(codpatenteguida is not null) then
			item_elmt := xmldom.createElement(doc, 'codpatenteguida');
			patente_node := xmldom.appendChild(patenti_node, xmldom.makeNode(item_elmt));

			item_text := xmldom.createTextNode(doc, codpatenteguida);
			item_node := xmldom.appendChild(patente_node, xmldom.makeNode(item_text));
		end if;
		
		if(patguidaindisp is not null) then
			item_elmt := xmldom.createElement(doc, 'patguidaindisp');
			patenteindisp_node := xmldom.appendChild(patenti_node, xmldom.makeNode(item_elmt));

			item_text := xmldom.createTextNode(doc, patguidaindisp);
			item_node := xmldom.appendChild(patenteindisp_node, xmldom.makeNode(item_text));
		end if;
		
	  end loop;
	  close cursorPatente;


	  --patentini guida
	  open cursorPatentini(prgRichiesta);
	  loop
		fetch cursorPatentini into rec_Patentino;
		exit when (cursorPatentini%notfound);

		codpatentino := rec_Patentino.codpatentino;
		patentinoindisp := rec_Patentino.patentinoindisp;

		item_elmt := xmldom.createElement(doc, 'Patentini');
	 	patentini_node := xmldom.appendChild(abilitazioni_node, xmldom.makeNode(item_elmt));
		
		if(codpatentino is not null) then
			item_elmt := xmldom.createElement(doc, 'codpatentino');
			patentino_node := xmldom.appendChild(patentini_node, xmldom.makeNode(item_elmt));

			item_text := xmldom.createTextNode(doc, codpatentino);
			item_node := xmldom.appendChild(patentino_node, xmldom.makeNode(item_text));
		end if;
		
		if(patentinoindisp is not null) then
			item_elmt := xmldom.createElement(doc, 'patentinoindisp');
			patentinoindisp_node := xmldom.appendChild(patentini_node, xmldom.makeNode(item_elmt));

			item_text := xmldom.createTextNode(doc, patentinoindisp);
			item_node := xmldom.appendChild(patentinoindisp_node, xmldom.makeNode(item_text));
		end if;
	  end loop;
	  close cursorPatentini;
	  --Fine Abilitazioni
	  
	  --Inizio Pubblicazione
	  item_elmt := xmldom.createElement(doc, 'Pubblicazione');
	  pubblicazione_node := xmldom.appendChild(datAggiuntivi_node, xmldom.makeNode(item_elmt));

	 if(DatiAziendaPub is not null) then
	  item_elmt := xmldom.createElement(doc, 'DatiAziendaPub');
	  DatiAziendaPub_node := xmldom.appendChild(pubblicazione_node, xmldom.makeNode(item_elmt));

	  item_text := xmldom.createTextNode(doc,  DatiAziendaPub);
	  item_node := xmldom.appendChild( DatiAziendaPub_node, xmldom.makeNode(item_text));
	 end if;
	 
	 if(MansionePub is not null) then
		  item_elmt := xmldom.createElement(doc, 'MansionePub');
		  MansionePub_node := xmldom.appendChild(pubblicazione_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, MansionePub);
		  item_node := xmldom.appendChild(MansionePub_node, xmldom.makeNode(item_text));
	 end if;
	 
	 -- per ora lo togliamo
	 if(false) then
		  item_elmt := xmldom.createElement(doc, 'ContenutoPub');
		  ContenutoPub_node := xmldom.appendChild(pubblicazione_node, xmldom.makeNode(item_elmt));

		  item_text := xmldom.createTextNode(doc, ContenutoPub);
		  item_node := xmldom.appendChild(ContenutoPub_node, xmldom.makeNode(item_text));
	end if;
	
	 if(LuogoPub is not null) then
	 	   SELECT count(*)
   		   into countOccurences
		   FROM dual
		   WHERE regexp_like (LuogoPub , '\S') ;	
	 		
		   if(countOccurences > 0) then
		   	  item_elmt := xmldom.createElement(doc, 'LuogoPub');
			  LuogoPub_node := xmldom.appendChild(pubblicazione_node, xmldom.makeNode(item_elmt));

			  item_text := xmldom.createTextNode(doc, LuogoPub);
			  item_node := xmldom.appendChild(LuogoPub_node, xmldom.makeNode(item_text));
		  end if;
		  countOccurences := -1;
	  end if;
		
	 if(FormazionePub is not null) then
	 	   SELECT count(*)
   		   into countOccurences
		   FROM dual
		   WHERE regexp_like (FormazionePub , '\S') ;	
	 		
		   if(countOccurences > 0) then
			  item_elmt := xmldom.createElement(doc, 'FormazionePub');
			  FormazionePub_node := xmldom.appendChild(pubblicazione_node, xmldom.makeNode(item_elmt));

			  item_text := xmldom.createTextNode(doc, FormazionePub);
			  item_node := xmldom.appendChild(FormazionePub_node, xmldom.makeNode(item_text));
	  		end if;
			countOccurences := -1;
	end if;
		
	   if(ContrattoPub is not null) then
	 	   SELECT count(*)
   		   into countOccurences
		   FROM dual
		   WHERE regexp_like (ContrattoPub , '\S') ;	
	 		
		   if(countOccurences > 0) then
			  item_elmt := xmldom.createElement(doc, 'ContrattoPub');
			  ContrattoPub_node := xmldom.appendChild(pubblicazione_node, xmldom.makeNode(item_elmt));

			  item_text := xmldom.createTextNode(doc, ContrattoPub);
			  item_node := xmldom.appendChild(ContrattoPub_node, xmldom.makeNode(item_text));
		end if;
		countOccurences := -1;
	end if;
		
	   if(ConoscenzePub is not null) then
	 	   SELECT count(*)
   		   into countOccurences
		   FROM dual
		   WHERE regexp_like (ConoscenzePub , '\S') ;	
	 		
		   if(countOccurences > 0) then
			  item_elmt := xmldom.createElement(doc, 'ConoscenzePub');
			  ConoscenzePub_node := xmldom.appendChild(pubblicazione_node, xmldom.makeNode(item_elmt));

			  item_text := xmldom.createTextNode(doc, ConoscenzePub);
			  item_node := xmldom.appendChild(ConoscenzePub_node, xmldom.makeNode(item_text));
	  		end if;
			countOccurences := -1;
		end if;
		
	   if(CaratteristichePub is not null) then
	 	   SELECT count(*)
   		   into countOccurences
		   FROM dual
		   WHERE regexp_like (CaratteristichePub , '\S') ;	
	 		
		   if(countOccurences > 0) then
			  item_elmt := xmldom.createElement(doc, 'CaratteristichePub');
			  CaratteristichePub_node := xmldom.appendChild(pubblicazione_node, xmldom.makeNode(item_elmt));

			  item_text := xmldom.createTextNode(doc, CaratteristichePub);
			  item_node := xmldom.appendChild(CaratteristichePub_node, xmldom.makeNode(item_text));
	  	 end if;
		 countOccurences := -1;
	end if;
		
	   if(OrarioPub is not null) then
	 	   SELECT count(*)
   		   into countOccurences
		   FROM dual
		   WHERE regexp_like (OrarioPub , '\S') ;	
	 		
		   if(countOccurences > 0) then
			  item_elmt := xmldom.createElement(doc, 'OrarioPub');
			  OrarioPub_node := xmldom.appendChild(pubblicazione_node, xmldom.makeNode(item_elmt));

			  item_text := xmldom.createTextNode(doc, OrarioPub);
			  item_node := xmldom.appendChild(OrarioPub_node, xmldom.makeNode(item_text));
			end if;
			countOccurences := -1;
		end if;
		
	   if(CandidaturaPub is not null) then
	 	   SELECT count(*)
   		   into countOccurences
		   FROM dual
		   WHERE regexp_like (CandidaturaPub , '\S') ;	
	 		
		   if(countOccurences > 0) then
			  item_elmt := xmldom.createElement(doc, 'CandidaturaPub');
			  CandidaturaPub_node := xmldom.appendChild(pubblicazione_node, xmldom.makeNode(item_elmt));

			  item_text := xmldom.createTextNode(doc, CandidaturaPub);
			  item_node := xmldom.appendChild(CandidaturaPub_node, xmldom.makeNode(item_text));
	  		end if;
			countOccurences := -1;
		end if;
	  --Fine Pubblicazione
	  
  --Fine DatiAggiuntivi

  xmldom.writeToBuffer(doc, xml_response);
  xmldom.freeDocument(doc);

  return xml_response;

EXCEPTION
    WHEN OTHERS THEN
      dbms_output.put_line('errore'||sqlcode ||' '||sqlerrm);
      return null;

END getXMLVacancySIL;


FUNCTION updateDATA_MYP_VAC RETURN NUMBER IS
BEGIN

  update ts_monitoraggio set dateTL = sysdate where codambito = 'MYP_VAC';
  commit;
  RETURN 0;
EXCEPTION
    WHEN OTHERS THEN
      rollback;
      return -1;

END updateDATA_MYP_VAC;


END PG_PORTALE;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_PROFILO_LAVORATORE.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_PROFILO_LAVORATORE IS
	
FUNCTION controllaCountRisposte (
	prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type, 
	codiciDomande in varchar2,
	numRisposteMax in NUMBER) RETURN NUMBER;
	
FUNCTION getCountRisposte (
	prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type, 
	codiciDomande in varchar2) RETURN NUMBER;
	
FUNCTION getRispostaDomanda (
	prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type, 
	codiceDomandaVar in DE_RISPOSTA_PROFILO.CODDOMANDAPROF%type) RETURN AM_LAVORATORE_PROFILO_RISPOSTE.CODRISPOSTAPROF%type;
 	
FUNCTION controllaCalcolabilita (prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER;

FUNCTION calcolaDimensioneUno(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER;
FUNCTION calcolaDimensioneDue(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER;
FUNCTION calcolaDimensioneTre(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER;
FUNCTION calcolaDimensioneQuattro(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER;
FUNCTION calcolaDimensioneCinque(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER;
FUNCTION calcolaDimensioneSei(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER;
FUNCTION calcolaDimensioneSette(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER;
	
PROCEDURE calcolaValoreProfilo(
	prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type,
	idUtenteVar in AM_LAVORATORE_PROFILO.CDNUTINS%type,
	eseguiUpdateVar in varchar2,	
	valoreDimensioneVar out AM_LAVORATORE_PROFILO.NUMVALOREPROFILO%type,
	valoreDim1Var out AM_LAVORATORE_PROFILO.NUMDIM01%type,
	valoreDim2Var out AM_LAVORATORE_PROFILO.NUMDIM02%type,
	valoreDim3Var out AM_LAVORATORE_PROFILO.NUMDIM03%type,
	valoreDim4Var out AM_LAVORATORE_PROFILO.NUMDIM04%type,
	valoreDim5Var out AM_LAVORATORE_PROFILO.NUMDIM05%type,
	valoreDim6Var out AM_LAVORATORE_PROFILO.NUMDIM06%type,
	valoreDim7Var out AM_LAVORATORE_PROFILO.NUMDIM07%type,
	indiceDifficoltaVar out varchar2,
	errCodeOut out varchar2);
	
PROCEDURE calcolaScorePersonalita (
	prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type,
	profiloCompleto out varchar2,
	scoreAmicalita out varchar2,
	scoreCoscienzosita out varchar2,
	scoreStabEmotiva out varchar2,
	scoreExtraVersione out varchar2,
	scoreApertura out varchar2,
	errCodeOut out varchar2);
	
END PG_PROFILO_LAVORATORE;
/
CREATE OR REPLACE PACKAGE BODY PG_PROFILO_LAVORATORE IS

FUNCTION controllaCountRisposte (
  prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type,
  codiciDomande in varchar2,
  numRisposteMax in NUMBER) RETURN NUMBER IS

  dataCreazioneVar varchar2(10);
  numRisposteDate NUMBER ;
  numRisposteDateScad NUMBER ;
  strquery  VARCHAR2(4096);
  strqueryScad  VARCHAR2(4096);
BEGIN

  select to_char(Datcreazioneprofilo,'dd/mm/yyyy')
  into dataCreazioneVar
  from AM_LAVORATORE_PROFILO
  where PRGLAVORATOREPROFILO = prgLavoratorepProfiloVar;

  --controlla numero di rispote per domande non scadute
  strquery := 'SELECT count(RISPOSTE.CODRISPOSTAPROF) FROM DE_RISPOSTA_PROFILO ';
    strquery := strquery || 'INNER JOIN DE_DOMANDA_PROFILO ON (DE_RISPOSTA_PROFILO.CODDOMANDAPROF = DE_DOMANDA_PROFILO.CODDOMANDAPROF ) ' ;
    strquery := strquery || 'LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF and RISPOSTE.PRGLAVORATOREPROFILO = ' || prgLavoratorepProfiloVar || ') ' ;
    strquery := strquery || 'LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO ) '   ;
  strquery := strquery || 'WHERE   DE_DOMANDA_PROFILO.CODDOMANDAPROF IN (' ||codiciDomande || ' ) and RISPOSTE.CODRISPOSTAPROF is not null '  ;
  strquery := strquery || 'AND trunc(nvl(PROFILO.Datcreazioneprofilo,(select prof.Datcreazioneprofilo from AM_LAVORATORE_PROFILO prof where prof.PRGLAVORATOREPROFILO = ' || prgLavoratorepProfiloVar || ' ))) ';
  strquery := strquery || 'between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval)' ;
  EXECUTE IMMEDIATE strquery into numRisposteDate;

  --controlla numero di domande scadute per non avere un test falsato
  strqueryScad := 'SELECT count(CODDOMANDAPROF) FROM DE_DOMANDA_PROFILO ';
    strqueryScad := strqueryScad || 'WHERE CODDOMANDAPROF IN (' || codiciDomande || ' )  '  ;
  strqueryScad := strqueryScad || 'AND to_date(''' || dataCreazioneVar || ''', ''dd/mm/yyyy'') > trunc(datfineval) ' ;
  EXECUTE IMMEDIATE strqueryScad into numRisposteDateScad;

  numRisposteDate := numRisposteDate + numRisposteDateScad;

  if (numRisposteDate < numRisposteMax) then
    return -1;
  end if;

return 0;

EXCEPTION
  WHEN OTHERS THEN
    return sqlcode;

END;

FUNCTION getCountRisposte (
  prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type,
  codiciDomande in varchar2) RETURN NUMBER IS

  dataCreazioneVar varchar2(10);
  numRisposteDate NUMBER ;
  numRisposteDateScad NUMBER ;
  strquery  VARCHAR2(4096);
  strqueryScad  VARCHAR2(4096);
BEGIN

  select to_char(Datcreazioneprofilo,'dd/mm/yyyy')
  into dataCreazioneVar
  from AM_LAVORATORE_PROFILO
  where PRGLAVORATOREPROFILO = prgLavoratorepProfiloVar;

  --controlla numero di rispote per domande non scadute
  strquery := 'SELECT count(RISPOSTE.CODRISPOSTAPROF) FROM DE_RISPOSTA_PROFILO ';
    strquery := strquery || 'INNER JOIN DE_DOMANDA_PROFILO ON (DE_RISPOSTA_PROFILO.CODDOMANDAPROF = DE_DOMANDA_PROFILO.CODDOMANDAPROF ) ' ;
    strquery := strquery || 'LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF and RISPOSTE.PRGLAVORATOREPROFILO = ' || prgLavoratorepProfiloVar || ') ' ;
    strquery := strquery || 'LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO ) '   ;
  strquery := strquery || 'WHERE   DE_DOMANDA_PROFILO.CODDOMANDAPROF IN (' ||codiciDomande || ' ) and RISPOSTE.CODRISPOSTAPROF is not null '  ;
  strquery := strquery || 'AND trunc(nvl(PROFILO.Datcreazioneprofilo,(select prof.Datcreazioneprofilo from AM_LAVORATORE_PROFILO prof where prof.PRGLAVORATOREPROFILO = ' || prgLavoratorepProfiloVar || ' ))) ';
  strquery := strquery || 'between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval)' ;
  EXECUTE IMMEDIATE strquery into numRisposteDate;

  --controlla numero di domande scadute per non avere un test falsato
  strqueryScad := 'SELECT count(CODDOMANDAPROF) FROM DE_DOMANDA_PROFILO ';
    strqueryScad := strqueryScad || 'WHERE CODDOMANDAPROF IN (' || codiciDomande || ' )  '  ;
  strqueryScad := strqueryScad || 'AND to_date(''' || dataCreazioneVar || ''', ''dd/mm/yyyy'') > trunc(datfineval) ' ;
  EXECUTE IMMEDIATE strqueryScad into numRisposteDateScad;

  numRisposteDate := numRisposteDate + numRisposteDateScad;

return numRisposteDate;

EXCEPTION
  WHEN OTHERS THEN
    return sqlcode;

END;

FUNCTION getRispostaDomanda (
  prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type,
  codiceDomandaVar in DE_RISPOSTA_PROFILO.CODDOMANDAPROF%type) RETURN AM_LAVORATORE_PROFILO_RISPOSTE.CODRISPOSTAPROF%type IS

  domandaValidaCnt number;
  codRispostaLavVar AM_LAVORATORE_PROFILO_RISPOSTE.CODRISPOSTAPROF%type;
  dataCreazioneVar AM_LAVORATORE_PROFILO.Datcreazioneprofilo%type;
BEGIN

  select Datcreazioneprofilo
  into dataCreazioneVar
  from AM_LAVORATORE_PROFILO
  where PRGLAVORATOREPROFILO = prgLavoratorepProfiloVar;

  select count(*)
  into domandaValidaCnt
  from DE_DOMANDA_PROFILO
  where CODDOMANDAPROF =codiceDomandaVar
  and trunc(dataCreazioneVar) < trunc(datfineval);

  if(domandaValidaCnt = 0) then
    return '';
  end if;

  SELECT RISPOSTE.CODRISPOSTAPROF
  into codRispostaLavVar
  FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON (DE_RISPOSTA_PROFILO.CODDOMANDAPROF = DE_DOMANDA_PROFILO.CODDOMANDAPROF )
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF and RISPOSTE.PRGLAVORATOREPROFILO = prgLavoratorepProfiloVar)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
  WHERE   DE_DOMANDA_PROFILO.CODDOMANDAPROF =codiceDomandaVar and RISPOSTE.CODRISPOSTAPROF is not null;

  return codRispostaLavVar;

EXCEPTION
  WHEN OTHERS THEN
    return 'ERROR_getRispostaDomanda$$' || sqlcode;

END;

FUNCTION controllaCalcolabilita (
    prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER IS

  codRispostaLavVar AM_LAVORATORE_PROFILO_RISPOSTE.CODRISPOSTAPROF%type;
  numRisposteDate number := 0;
  codmonostatoprofVar AM_LAVORATORE_PROFILO.codmonostatoprof%type;
  numMinimoRisposteVar number;
  dataCreazioneVar AM_LAVORATORE_PROFILO.Datcreazioneprofilo%type;
  flagLinguaIta AM_LAVORATORE_PROFILO.FLGCONOSCENZAITA%type;
BEGIN

  select upper(codmonostatoprof)
  into codmonostatoprofVar
  from am_lavoratore_profilo
  where prglavoratoreprofilo = prgLavoratorepProfiloVar;

  if (codmonostatoprofVar <> 'I') then
    return 20;
  end if;

  select upper(FLGCONOSCENZAITA)
  into flagLinguaIta
  from am_lavoratore_profilo
  where prglavoratoreprofilo = prgLavoratorepProfiloVar;

  if (flagLinguaIta = 'N') then
    return 0;
  end if;

  select Datcreazioneprofilo
  into dataCreazioneVar
  from AM_LAVORATORE_PROFILO
  where PRGLAVORATOREPROFILO = prgLavoratorepProfiloVar;

  select count(*)
  into numMinimoRisposteVar
  from De_Domanda_Profilo
  where Flgobbligatoria = 'S'
  AND trunc(dataCreazioneVar) between trunc(datinizioval) and trunc(datfineval);

  select count(*)
  into numRisposteDate
  from am_lavoratore_profilo_risposte profris
  inner join  De_Risposta_Profilo ris on (profris.Codrispostaprof = ris.Codrispostaprof )
  inner join  De_Domanda_Profilo dom on (Dom.Coddomandaprof = Ris.Coddomandaprof  and Flgobbligatoria = 'S')
  where prglavoratoreprofilo = prgLavoratorepProfiloVar ;

  if (numRisposteDate < numMinimoRisposteVar) then
    return 30;
  end if;


  numRisposteDate := controllaCountRisposte(prgLavoratorepProfiloVar, '''D17'',''D18'',''D20'',''D45''', 4);

  if (numRisposteDate < 0) then
    return 30;
  end if;

  codRispostaLavVar := getRispostaDomanda(prgLavoratorepProfiloVar,'D17');

  if( codRispostaLavVar like 'ERROR_getRispostaDomanda$$%') then
    return  TO_NUMBER(REPLACE(codRispostaLavVar, 'ERROR_getRispostaDomanda$$',''));
  end if;

  if (codRispostaLavVar = 'D17_1') then

    codRispostaLavVar := getRispostaDomanda(prgLavoratorepProfiloVar,'D18');

    if( codRispostaLavVar like 'ERROR_getRispostaDomanda$$%') then
      return  TO_NUMBER(REPLACE(codRispostaLavVar, 'ERROR_getRispostaDomanda$$',''));
    end if;


    if (codRispostaLavVar = 'D18_2') then
      return 1718;
    end if;


  end if;

  codRispostaLavVar := getRispostaDomanda(prgLavoratorepProfiloVar,'D20');

  if( codRispostaLavVar like 'ERROR_getRispostaDomanda$$%') then
    return  TO_NUMBER(REPLACE(codRispostaLavVar, 'ERROR_getRispostaDomanda$$',''));
  end if;

  if (codRispostaLavVar = 'D20_2') then
    numRisposteDate := controllaCountRisposte(prgLavoratorepProfiloVar, '''D21''', 1);

    if (numRisposteDate < 0) then
      return 21;
    end if;

  end if;

  codRispostaLavVar := getRispostaDomanda(prgLavoratorepProfiloVar,'D45');

  if( codRispostaLavVar like 'ERROR_getRispostaDomanda$$%') then
    return  TO_NUMBER(REPLACE(codRispostaLavVar, 'ERROR_getRispostaDomanda$$',''));
  end if;

  if (codRispostaLavVar = 'D45_1') then

    numRisposteDate := controllaCountRisposte(prgLavoratorepProfiloVar, '''D22'',''D23'',''D24'',''D25'',''D26'',''D27'',''D28'',''D29''', 8);

    if (numRisposteDate < 0) then
      return 45;
    end if;

  end if;

  return 0;

EXCEPTION
  WHEN OTHERS THEN
    return sqlcode;

END;

FUNCTION calcolaDimensioneUno(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER IS

  isFlagAttivoVar DE_RAGG_DOMANDA_PROF.FLGATTIVO%type;
  valoreDimensioneVar AM_LAVORATORE_PROFILO.NUMVALOREPROFILO%type;

  TYPE rispostaRecord IS RECORD (
      D01 AM_LAVORATORE_PROFILO_RISPOSTE.CODRISPOSTAPROF%type,
    D02 AM_LAVORATORE_PROFILO_RISPOSTE.CODRISPOSTAPROF%type,
    D03 AM_LAVORATORE_PROFILO_RISPOSTE.CODRISPOSTAPROF%type);

   rispostaD123 rispostaRecord;
     pesoD04Var DE_RISPOSTA_PROFILO.NUMPESORISPOSTA%type;

 BEGIN

  select FLGATTIVO
  into isFlagAttivoVar
  from DE_RAGG_DOMANDA_PROF
  where CODDOMANDAPROFRAGG = 'DM1' ;


  if(isFlagAttivoVar = 'N') then
    return 0;
  end if;

  /*
  -- Questa query è completamente errata in quanto fa una join NxNxN della stessa tabella causando problemi di performance in produzione
  SELECT  DISTINCT RISPOSTE1.CODRISPOSTAPROF,  RISPOSTE2.CODRISPOSTAPROF,  RISPOSTE3.CODRISPOSTAPROF
  INTO rispostaD123
  FROM AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE1, AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE2, AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE3
  WHERE
  RISPOSTE1.CODRISPOSTAPROF in (
    SELECT   RISPOSTE.CODRISPOSTAPROF
    FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
    WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF = 'D01'
    AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval)
  )
  AND RISPOSTE2.CODRISPOSTAPROF in (
    SELECT   RISPOSTE.CODRISPOSTAPROF
    FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
    WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF = 'D02'
    AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval)
  )
  AND RISPOSTE3.CODRISPOSTAPROF in (SELECT   RISPOSTE.CODRISPOSTAPROF
    FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
    WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF = 'D03'
    AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval)
  );
  */
  select
  (SELECT  RISPOSTE.CODRISPOSTAPROF
  FROM
  am_lavoratore_profilo profilo
  LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (PROFILO.PRGLAVORATOREPROFILO=RISPOSTE.PRGLAVORATOREPROFILO)
  LEFT JOIN DE_RISPOSTA_PROFILO R ON (RISPOSTE.CODRISPOSTAPROF=R.CODRISPOSTAPROF)
  LEFT JOIN DE_DOMANDA_PROFILO ON (R.CODDOMANDAPROF=DE_DOMANDA_PROFILO.CODDOMANDAPROF)
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
  AND R.CODDOMANDAPROF='D01'
  AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval
  ) as "D01",
  (SELECT  RISPOSTE.CODRISPOSTAPROF
  FROM
  am_lavoratore_profilo profilo
  LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (PROFILO.PRGLAVORATOREPROFILO=RISPOSTE.PRGLAVORATOREPROFILO)
  LEFT JOIN DE_RISPOSTA_PROFILO R ON (RISPOSTE.CODRISPOSTAPROF=R.CODRISPOSTAPROF)
  LEFT JOIN DE_DOMANDA_PROFILO ON (R.CODDOMANDAPROF=DE_DOMANDA_PROFILO.CODDOMANDAPROF)
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
  AND R.CODDOMANDAPROF='D02'
  AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval
  ) as "D02",
  (SELECT  RISPOSTE.CODRISPOSTAPROF
  FROM
  am_lavoratore_profilo profilo
  LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (PROFILO.PRGLAVORATOREPROFILO=RISPOSTE.PRGLAVORATOREPROFILO)
  LEFT JOIN DE_RISPOSTA_PROFILO R ON (RISPOSTE.CODRISPOSTAPROF=R.CODRISPOSTAPROF)
  LEFT JOIN DE_DOMANDA_PROFILO ON (R.CODDOMANDAPROF=DE_DOMANDA_PROFILO.CODDOMANDAPROF)
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
  AND R.CODDOMANDAPROF='D03'
  AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval
  ) as "D03"
  INTO rispostaD123
  FROM DUAL
  ;

  if((rispostaD123.D02 = 'E1' and rispostaD123.D03 = 'GI1') or (rispostaD123.D01 = 'F' and rispostaD123.D02 = 'E1' and rispostaD123.D03 = 'GI2')) then
    valoreDimensioneVar := 8;
  elsif (rispostaD123.D01 = 'F' and rispostaD123.D02 = 'E1' and rispostaD123.D03 = 'GI3') then
    valoreDimensioneVar := 7;
  elsif ((rispostaD123.D01 = 'M' and rispostaD123.D02 = 'E1' and rispostaD123.D03 = 'GI3') or (rispostaD123.D01 = 'F' and rispostaD123.D02 = 'E3' and rispostaD123.D03 = 'GI1')) then
    valoreDimensioneVar := 5;
  elsif ((rispostaD123.D01 = 'M' and rispostaD123.D02 = 'E1' and rispostaD123.D03 = 'GI2') or (rispostaD123.D01 = 'M' and rispostaD123.D02 = 'E2' and rispostaD123.D03 = 'GI1')
     or (rispostaD123.D01 = 'F' and rispostaD123.D02 = 'E1' and rispostaD123.D03 = 'GI4')) then
    valoreDimensioneVar := 4;
  elsif ((rispostaD123.D01 = 'M' and rispostaD123.D02 = 'E1' and rispostaD123.D03 = 'GI4') or (rispostaD123.D01 = 'M' and rispostaD123.D02 = 'E3' and rispostaD123.D03 = 'GI1')
     or (rispostaD123.D01 = 'F' and rispostaD123.D02 = 'E2' and rispostaD123.D03 = 'GI1')  or (rispostaD123.D01 = 'F' and rispostaD123.D02 = 'E2' and rispostaD123.D03 = 'GI2')
     or (rispostaD123.D01 = 'F' and rispostaD123.D02 = 'E2' and rispostaD123.D03 = 'GI4') ) then
    valoreDimensioneVar := 3;
  elsif ((rispostaD123.D02 = 'E2' and rispostaD123.D03 = 'GI3') or (rispostaD123.D02 = 'E3' and rispostaD123.D03 = 'GI2')
      or (rispostaD123.D01 = 'F' and rispostaD123.D02 = 'E3') or (rispostaD123.D02 = 'E4' and rispostaD123.D03 = 'GI1')
      or (rispostaD123.D01 = 'M' and rispostaD123.D02 = 'E2' and rispostaD123.D03 = 'GI2')
      or (rispostaD123.D01 = 'M' and rispostaD123.D02 = 'E4' and rispostaD123.D03 = 'GI3')
      or (rispostaD123.D01 = 'M' and rispostaD123.D02 = 'E5' and rispostaD123.D03 = 'GI1')
      or (rispostaD123.D01 = 'F' and rispostaD123.D02 = 'E5' and rispostaD123.D03 = 'GI2')) then
    valoreDimensioneVar := 2;
  else
    valoreDimensioneVar := 1;
  end if;

  SELECT DE_RISPOSTA_PROFILO.NUMPESORISPOSTA
  INTO pesoD04Var
  FROM DE_RISPOSTA_PROFILO
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar and DE_RISPOSTA_PROFILO.CODDOMANDAPROF = 'D04';

  valoreDimensioneVar := valoreDimensioneVar * pesoD04Var;

  valoreDimensioneVar := round(valoreDimensioneVar,2);

  return valoreDimensioneVar;

EXCEPTION
  WHEN OTHERS THEN
    return 11;

END;

FUNCTION calcolaDimensioneDue(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER IS

  isFlagAttivoVar DE_RAGG_DOMANDA_PROF.FLGATTIVO%type;
  valoreDimensioneVar AM_LAVORATORE_PROFILO.NUMVALOREPROFILO%type;
  peso1718Var DE_RISPOSTA_PROFILO.NUMPESORISPOSTA%type;
  pesoVar DE_RISPOSTA_PROFILO.NUMPESORISPOSTA%type;
  pesoInvVar DE_RISPOSTA_PROFILO.NUMPESORISPOSTA%type;

  TYPE rispostaRecord IS RECORD (ris17 number, ris18 number);

  rispostaR rispostaRecord;
 BEGIN

  select FLGATTIVO
  into isFlagAttivoVar
  from DE_RAGG_DOMANDA_PROF
  where CODDOMANDAPROFRAGG = 'DM2';

  if(isFlagAttivoVar = 'N') then
    return 0;
  end if;

  /*
  -- Questa query è completamente errata in quanto fa una join NxNxN della stessa tabella causando problemi di performance in produzione
  SELECT  DISTINCT RISPOSTE1.Numvalorerisposta,  RISPOSTE2.Numvalorerisposta
  INTO rispostaR
  FROM DE_RISPOSTA_PROFILO RISPOSTE1, DE_RISPOSTA_PROFILO RISPOSTE2
  WHERE
  RISPOSTE1.Numvalorerisposta in (
    SELECT  DE_RISPOSTA_PROFILO.Numvalorerisposta
    FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
    WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF = 'D17'
    AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval)
  )  AND RISPOSTE2.Numvalorerisposta in (
    SELECT  DE_RISPOSTA_PROFILO.Numvalorerisposta
    FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
    WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF = 'D18'
    AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval)
  );
  */

  select
  (SELECT  R.Numvalorerisposta
  FROM
  am_lavoratore_profilo profilo
  LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (PROFILO.PRGLAVORATOREPROFILO=RISPOSTE.PRGLAVORATOREPROFILO)
  LEFT JOIN DE_RISPOSTA_PROFILO R ON (RISPOSTE.CODRISPOSTAPROF=R.CODRISPOSTAPROF)
  LEFT JOIN DE_DOMANDA_PROFILO ON (R.CODDOMANDAPROF=DE_DOMANDA_PROFILO.CODDOMANDAPROF)
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
  AND R.CODDOMANDAPROF='D17'
  AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval
  ) as "D17",
  (SELECT  R.Numvalorerisposta
  FROM
  am_lavoratore_profilo profilo
  LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (PROFILO.PRGLAVORATOREPROFILO=RISPOSTE.PRGLAVORATOREPROFILO)
  LEFT JOIN DE_RISPOSTA_PROFILO R ON (RISPOSTE.CODRISPOSTAPROF=R.CODRISPOSTAPROF)
  LEFT JOIN DE_DOMANDA_PROFILO ON (R.CODDOMANDAPROF=DE_DOMANDA_PROFILO.CODDOMANDAPROF)
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
  AND R.CODDOMANDAPROF='D18'
  AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval
  ) as "D18"
  INTO rispostaR
  FROM DUAL
  ;


  if(rispostaR.ris17 = 1 and rispostaR.ris18 = 1) then
    peso1718Var := 3;
  elsif (rispostaR.ris17 = 1 and rispostaR.ris18 = 0) then
    peso1718Var := 1;
  elsif (rispostaR.ris17 = 0 and rispostaR.ris18 = 0) then
    peso1718Var := 0;
  end if;

  SELECT SUM(DE_RISPOSTA_PROFILO.NUMPESORISPOSTA)
  INTO pesoVar
  FROM DE_RISPOSTA_PROFILO
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar and DE_RISPOSTA_PROFILO.CODDOMANDAPROF in ('D11','D12','D13');

  pesoInvVar := (peso1718Var + pesoVar - 0) * (9/10) + 1;

  valoreDimensioneVar := 11 - pesoInvVar;

  valoreDimensioneVar := round(valoreDimensioneVar,2);

  return valoreDimensioneVar;

EXCEPTION
  WHEN OTHERS THEN
    return 11;

END;

FUNCTION calcolaDimensioneTre(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER IS

  isFlagAttivoVar DE_RAGG_DOMANDA_PROF.FLGATTIVO%type;
  valoreMansioneVar Ts_Qualifica_Profiling.numpunteggioprof%type;
  valoreDimensioneVar AM_LAVORATORE_PROFILO.NUMVALOREPROFILO%type;
  codMansioneVar char(4);
    datCreazioneProfiloVar AM_LAVORATORE_PROFILO.Datcreazioneprofilo%type;
  cntMansioniVar integer;

 BEGIN

  select FLGATTIVO
  into isFlagAttivoVar
  from DE_RAGG_DOMANDA_PROF
  where CODDOMANDAPROFRAGG = 'DM3';

  if(isFlagAttivoVar = 'N') then
    return 0;
  end if;

  SELECT  Substr(Risposte.Strrisposta,1,4)
  INTO codMansioneVar
  FROM DE_RISPOSTA_PROFILO
  INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
  LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
  LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar and  DE_RISPOSTA_PROFILO.CODDOMANDAPROF = 'D08'
  AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval;
  --AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval);

  SELECT Datcreazioneprofilo
  INTO datCreazioneProfiloVar
  FROM AM_LAVORATORE_PROFILO
  WHERE AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar;

  SELECT count(*)
  INTO cntMansioniVar
  FROM Ts_Qualifica_Profiling
  where Codmansione4 = codMansioneVar
  and datCreazioneProfiloVar between datinizioval and nvl(datfineval,sysdate);
  --and trunc(datCreazioneProfiloVar) between trunc(datinizioval) and trunc(nvl(datfineval, sysdate));

  if(cntMansioniVar=0) then

    SELECT count(*)
    INTO cntMansioniVar
    FROM Ts_Qualifica_Profiling
    where
    datCreazioneProfiloVar between datinizioval and nvl(datfineval,sysdate);
    --trunc(datCreazioneProfiloVar) between trunc(datinizioval) and trunc(nvl(datfineval, sysdate));

    if(cntMansioniVar>0) then
      valoreMansioneVar :=1;
    else
      valoreMansioneVar :=0;
    end if;

  else

    SELECT numpunteggioprof
    INTO valoreMansioneVar
    FROM Ts_Qualifica_Profiling
    where Codmansione4 = codMansioneVar
    and datCreazioneProfiloVar between datinizioval and nvl(datfineval,sysdate);
    --and trunc(datCreazioneProfiloVar) between trunc(datinizioval) and trunc(nvl(datfineval, sysdate));

  end if;

  valoreDimensioneVar := 11 - valoreMansioneVar;
  valoreDimensioneVar := round(valoreDimensioneVar,2);
  return valoreDimensioneVar;

EXCEPTION
  WHEN OTHERS THEN
    return 11;

END;

FUNCTION calcolaDimensioneQuattro(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER IS

  isFlagAttivoVar DE_RAGG_DOMANDA_PROF.FLGATTIVO%type;
  valoreDimensioneVar AM_LAVORATORE_PROFILO.NUMVALOREPROFILO%type;
  codRispostaLavVar AM_LAVORATORE_PROFILO_RISPOSTE.CODRISPOSTAPROF%type;
  pesoParzialeVar DE_RISPOSTA_PROFILO.NUMPESORISPOSTA%type;

 BEGIN

  select FLGATTIVO
  into isFlagAttivoVar
  from DE_RAGG_DOMANDA_PROF
  where CODDOMANDAPROFRAGG = 'DM4';

  if(isFlagAttivoVar = 'N') then
    return 0;
  end if;

  codRispostaLavVar := getRispostaDomanda(prgLavoratorepProfiloVar,'D45');

  if (codRispostaLavVar = 'D45_2' or codRispostaLavVar = '') then

    return 0;
  end if;

  SELECT SUM(DE_RISPOSTA_PROFILO.NUMPESORISPOSTA)
  INTO pesoParzialeVar
  FROM DE_RISPOSTA_PROFILO
  INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
  AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF in ('D22','D23','D24','D25','D26','D27','D28','D29')
  AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval;
  --AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval);

  pesoParzialeVar := (pesoParzialeVar * (9/8)) + 1;

  valoreDimensioneVar := 11 - pesoParzialeVar;
  valoreDimensioneVar := round(valoreDimensioneVar,2);
  return valoreDimensioneVar;

EXCEPTION
  WHEN OTHERS THEN
    return 11;

END;

FUNCTION calcolaDimensioneCinque(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER IS

  isFlagAttivoVar DE_RAGG_DOMANDA_PROF.FLGATTIVO%type;
  valoreDimensioneVar AM_LAVORATORE_PROFILO.NUMVALOREPROFILO%type;
  codRispostaLavVar AM_LAVORATORE_PROFILO_RISPOSTE.CODRISPOSTAPROF%type;
  peso2021Var DE_RISPOSTA_PROFILO.NUMPESORISPOSTA%type;
  pesoParzialeVar DE_RISPOSTA_PROFILO.NUMPESORISPOSTA%type;

 BEGIN

  select FLGATTIVO
  into isFlagAttivoVar
  from DE_RAGG_DOMANDA_PROF
  where CODDOMANDAPROFRAGG = 'DM5';

  if(isFlagAttivoVar = 'N') then
    return 0;
  end if;

  peso2021Var := 0;

  codRispostaLavVar := getRispostaDomanda(prgLavoratorepProfiloVar,'D20');

  if (codRispostaLavVar = 'D20_2') then

    SELECT  DE_RISPOSTA_PROFILO.NUMPESORISPOSTA
    INTO peso2021Var
    FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
    WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF = 'D21'
    AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval;
    --AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval);

  end if;

  SELECT SUM(DE_RISPOSTA_PROFILO.NUMPESORISPOSTA)
  INTO pesoParzialeVar
  FROM DE_RISPOSTA_PROFILO
  INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
  AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF in ('D06','D09','D14','D16','D19')
  AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval;
  --AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval);

  pesoParzialeVar := ((peso2021Var + pesoParzialeVar) * (9/7)) + 1;

  valoreDimensioneVar := pesoParzialeVar;
  valoreDimensioneVar := round(valoreDimensioneVar,2);
  return valoreDimensioneVar;

EXCEPTION
  WHEN OTHERS THEN
    return 11;

END;

FUNCTION calcolaDimensioneSei(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER IS

  isFlagAttivoVar DE_RAGG_DOMANDA_PROF.FLGATTIVO%type;
  valoreDimensioneVar AM_LAVORATORE_PROFILO.NUMVALOREPROFILO%type;
  pesoParzialeVar DE_RISPOSTA_PROFILO.NUMPESORISPOSTA%type;
  pesoParzialeRaw float;

 BEGIN

  select FLGATTIVO
  into isFlagAttivoVar
  from DE_RAGG_DOMANDA_PROF
  where CODDOMANDAPROFRAGG = 'DM6';

  if(isFlagAttivoVar = 'N') then
    return 0;
  end if;

  SELECT SUM(DE_RISPOSTA_PROFILO.NUMPESORISPOSTA)
  INTO pesoParzialeVar
  FROM DE_RISPOSTA_PROFILO
  INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
  AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF in ('D30','D31','D32','D33','D34')
  AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval;
  --AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval);

  pesoParzialeRaw :=  pesoParzialeVar / 5;

  if(pesoParzialeRaw<=0.4) then
    valoreDimensioneVar := 1;
  elsif (pesoParzialeRaw <=0.8) then
    valoreDimensioneVar := 2;
  elsif (pesoParzialeRaw <=1.2) then
    valoreDimensioneVar := 3;
  elsif (pesoParzialeRaw <=1.6) then
    valoreDimensioneVar := 4;
  elsif (pesoParzialeRaw <=2.0) then
    valoreDimensioneVar := 5;
  elsif (pesoParzialeRaw <=2.4) then
    valoreDimensioneVar := 6;
  elsif (pesoParzialeRaw <=2.8) then
    valoreDimensioneVar := 7;
  elsif (pesoParzialeRaw <=3.2) then
    valoreDimensioneVar := 8;
  elsif (pesoParzialeRaw <=3.6) then
    valoreDimensioneVar := 9;
  elsif (pesoParzialeRaw >3.6) then
    valoreDimensioneVar := 10;
  end if;
  valoreDimensioneVar := 11-valoreDimensioneVar;
  valoreDimensioneVar := round(valoreDimensioneVar,2);
  return valoreDimensioneVar;

EXCEPTION
  WHEN OTHERS THEN
    return 11;
END;

FUNCTION calcolaDimensioneSette(prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type) RETURN NUMBER IS

  isFlagAttivoVar DE_RAGG_DOMANDA_PROF.FLGATTIVO%type;
  valoreDimensioneVar AM_LAVORATORE_PROFILO.NUMVALOREPROFILO%type;

 BEGIN

  select FLGATTIVO
  into isFlagAttivoVar
  from DE_RAGG_DOMANDA_PROF
  where CODDOMANDAPROFRAGG = 'DM7';

  if(isFlagAttivoVar = 'N') then
    return 0;
  end if;

  SELECT SUM(DE_RISPOSTA_PROFILO.NUMPESORISPOSTA)
  INTO valoreDimensioneVar
  FROM DE_RISPOSTA_PROFILO
  INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
  WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
  AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF in ('D10','D15','D42')
  AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval;
  --AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval);

  valoreDimensioneVar := round(valoreDimensioneVar,2);
  return valoreDimensioneVar;

EXCEPTION
  WHEN OTHERS THEN
    return 11;
END;

PROCEDURE calcolaValoreProfilo(
  prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type,
  idUtenteVar in AM_LAVORATORE_PROFILO.CDNUTINS%type,
  eseguiUpdateVar in varchar2,
  valoreDimensioneVar out AM_LAVORATORE_PROFILO.NUMVALOREPROFILO%type,
  valoreDim1Var out AM_LAVORATORE_PROFILO.NUMDIM01%type,
  valoreDim2Var out AM_LAVORATORE_PROFILO.NUMDIM02%type,
  valoreDim3Var out AM_LAVORATORE_PROFILO.NUMDIM03%type,
  valoreDim4Var out AM_LAVORATORE_PROFILO.NUMDIM04%type,
  valoreDim5Var out AM_LAVORATORE_PROFILO.NUMDIM05%type,
  valoreDim6Var out AM_LAVORATORE_PROFILO.NUMDIM06%type,
  valoreDim7Var out AM_LAVORATORE_PROFILO.NUMDIM07%type,
  indiceDifficoltaVar out varchar2,
  errCodeOut out varchar2
  ) IS

  valoreDifficoltaVar DE_VCH_PROFILING.CODVCHPROFILING%type;
  numKloProfiloVar AM_LAVORATORE_PROFILO.NUMKLOLAVPROFILO%type;
  flagLinguaIta AM_LAVORATORE_PROFILO.FLGCONOSCENZAITA%type;
  skipAll number;
  dividendoVar number;

BEGIN

  skipAll :=0;
  select upper(FLGCONOSCENZAITA)
  into flagLinguaIta
  from am_lavoratore_profilo
  where prglavoratoreprofilo = prgLavoratorepProfiloVar;

  if (flagLinguaIta = 'N') then
    skipAll := 1;
  end if;

  if(skipAll = 0) then
    dividendoVar :=0;
    valoreDimensioneVar :=0;

    valoreDim1Var := calcolaDimensioneUno(prgLavoratorepProfiloVar);
    if(valoreDim1Var > 0 and valoreDim1Var < 11) then
      dividendoVar := dividendoVar +1;
    end if;

    valoreDim2Var := calcolaDimensioneDue(prgLavoratorepProfiloVar);
    if(valoreDim2Var > 0 and valoreDim1Var < 11) then
      dividendoVar := dividendoVar +1;
    end if;

    valoreDim3Var := calcolaDimensioneTre(prgLavoratorepProfiloVar);
    if(valoreDim3Var > 0 and valoreDim1Var < 11) then
      dividendoVar := dividendoVar +1;
    end if;

    valoreDim4Var := calcolaDimensioneQuattro(prgLavoratorepProfiloVar);
    if(valoreDim4Var > 0 and valoreDim1Var < 11) then
      dividendoVar := dividendoVar +1;
    end if;

    valoreDim5Var := calcolaDimensioneCinque(prgLavoratorepProfiloVar);
    if(valoreDim5Var > 0 and valoreDim1Var < 11) then
      dividendoVar := dividendoVar +1;
    end if;

    valoreDim6Var := calcolaDimensioneSei(prgLavoratorepProfiloVar);
    if(valoreDim6Var > 0 and valoreDim1Var < 11) then
      dividendoVar := dividendoVar +1;
    end if;

    valoreDim7Var := calcolaDimensioneSette(prgLavoratorepProfiloVar);
    if(valoreDim7Var > 0 and valoreDim1Var < 11) then
      dividendoVar := dividendoVar +1;
    end if;

    if(valoreDim1Var = 11 or valoreDim2Var = 11 or valoreDim3Var = 11 or valoreDim4Var = 11 or valoreDim5Var = 11 or valoreDim6Var = 11 or valoreDim7Var = 11) then
      dividendoVar :=0;
      valoreDimensioneVar := 11;
    end if;

    if(dividendoVar >0) then
      valoreDimensioneVar := (valoreDim1Var + valoreDim2Var + valoreDim3Var + valoreDim4Var + valoreDim5Var + valoreDim6Var + valoreDim7Var) / dividendoVar;
      valoreDimensioneVar := round(valoreDimensioneVar,2);
    end if;

    if(dividendoVar>0 AND valoreDimensioneVar>0) then
      SELECT CODVCHPROFILING
      INTO valoreDifficoltaVar
      FROM DE_VCH_PROFILING
      WHERE valoreDimensioneVar >= NUMVALMIN AND valoreDimensioneVar < NUMVALMAX;

      SELECT Strdescrizione
      into indiceDifficoltaVar
      FROM DE_VCH_PROFILING
      where CODVCHPROFILING = valoreDifficoltaVar;

    end if;
  end if;

  if(skipAll = 1) then

    valoreDim1Var := 10;
    valoreDim2Var := 10;
    valoreDim3Var := 10;
    valoreDim4Var := 10;
    valoreDim5Var := 10;
    valoreDim6Var := 10;
    valoreDim7Var := 10;
    valoreDimensioneVar := 10;

    SELECT CODVCHPROFILING
    INTO valoreDifficoltaVar
    FROM DE_VCH_PROFILING
    WHERE valoreDimensioneVar >= NUMVALMIN AND valoreDimensioneVar < NUMVALMAX;

    SELECT Strdescrizione
    into indiceDifficoltaVar
    FROM DE_VCH_PROFILING
    where CODVCHPROFILING = valoreDifficoltaVar;

  end if;


      if(eseguiUpdateVar = 'S') then

        SELECT NUMKLOLAVPROFILO
        INTO numKloProfiloVar
        FROM AM_LAVORATORE_PROFILO
        WHERE PRGLAVORATOREPROFILO = prgLavoratorepProfiloVar;

         PG_LOG.doLog ('U', 'AM_LAVORATORE_PROFILO', idUtenteVar, ' WHERE PRGLAVORATOREPROFILO = ' || prgLavoratorepProfiloVar);

        UPDATE AM_LAVORATORE_PROFILO SET
          NUMDIM01 = valoreDim1Var,
          NUMDIM02 = valoreDim2Var,
          NUMDIM03 = valoreDim3Var,
          NUMDIM04 = valoreDim4Var,
          NUMDIM05 = valoreDim5Var,
          NUMDIM06 = valoreDim6Var,
          NUMDIM07 = valoreDim7Var,
          NUMVALOREPROFILO = valoreDimensioneVar,
          CDNUTMOD = idUtenteVar,
          DTMMOD = sysdate,
          CODMONOSTATOPROF = 'C',
          CODVCHPROFILING = valoreDifficoltaVar,
          NUMKLOLAVPROFILO = numKloProfiloVar+1
        WHERE
          PRGLAVORATOREPROFILO = prgLavoratorepProfiloVar;
      end if;


  errCodeOut := 'CALCOLO_OK';

  if(valoreDimensioneVar = 11) then
    errCodeOut := 'CALCOLO_KO';
  end if;


EXCEPTION
  WHEN OTHERS THEN
    errCodeOut:= '' || sqlcode;
END;

PROCEDURE calcolaScorePersonalita (
  prgLavoratorepProfiloVar in AM_LAVORATORE_PROFILO.PRGLAVORATOREPROFILO%type,
  profiloCompleto out varchar2,
  scoreAmicalita out varchar2,
  scoreCoscienzosita out varchar2,
  scoreStabEmotiva out varchar2,
  scoreExtraVersione out varchar2,
  scoreApertura out varchar2,
  errCodeOut out varchar2) IS

  isFlagAttivoVar DE_RAGG_DOMANDA_PROF.FLGATTIVO%type;
  valoreDimensioneVar number;
  numRisposteDate number;

BEGIN

  select FLGATTIVO
  into isFlagAttivoVar
  from DE_RAGG_DOMANDA_PROF
  where CODDOMANDAPROFRAGG = 'DMX';

  if(isFlagAttivoVar = 'N') then
    errCodeOut := '40';
  else

    numRisposteDate := controllaCountRisposte(prgLavoratorepProfiloVar, '''D43'',''D44'',''D46'',''D47'',''D48'',''D49'',''D50'',''D51'',''D52'',''D53''', 10);

    if (numRisposteDate < 0) then
      profiloCompleto := 'INCOMPLETO';
    else
      profiloCompleto := 'COMPLETO';
    end if;

    SELECT SUM(DE_RISPOSTA_PROFILO.NUMPESORISPOSTA)
    INTO valoreDimensioneVar
    FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
    WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
    AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF in ('D44','D50')
    AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval;
    --AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval);

    valoreDimensioneVar := round(valoreDimensioneVar,2);
    scoreAmicalita := '' || valoreDimensioneVar;

    SELECT SUM(DE_RISPOSTA_PROFILO.NUMPESORISPOSTA)
    INTO valoreDimensioneVar
    FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
    WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
    AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF in ('D46','D51')
    AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval;
    --AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval);

    valoreDimensioneVar := round(valoreDimensioneVar,2);
    scoreCoscienzosita :='' || valoreDimensioneVar;


    SELECT SUM(DE_RISPOSTA_PROFILO.NUMPESORISPOSTA)
    INTO valoreDimensioneVar
    FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
    WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
    AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF in ('D47','D52')
    AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval;
    --AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval);

    valoreDimensioneVar := round(valoreDimensioneVar,2);
    scoreStabEmotiva := '' || valoreDimensioneVar;

    SELECT SUM(DE_RISPOSTA_PROFILO.NUMPESORISPOSTA)
    INTO valoreDimensioneVar
    FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
    WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
    AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF in ('D43','D49')
    AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval;
    --AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval);

    valoreDimensioneVar := round(valoreDimensioneVar,2);
    scoreExtraVersione := '' || valoreDimensioneVar;

    SELECT SUM(DE_RISPOSTA_PROFILO.NUMPESORISPOSTA)
    INTO valoreDimensioneVar
    FROM DE_RISPOSTA_PROFILO
    INNER JOIN DE_DOMANDA_PROFILO ON  (DE_RISPOSTA_PROFILO.CODDOMANDAPROF  = DE_DOMANDA_PROFILO.CODDOMANDAPROF)
    LEFT JOIN AM_LAVORATORE_PROFILO_RISPOSTE RISPOSTE ON (DE_RISPOSTA_PROFILO.CODRISPOSTAPROF = RISPOSTE.CODRISPOSTAPROF)
    LEFT JOIN  AM_LAVORATORE_PROFILO PROFILO ON (PROFILO.PRGLAVORATOREPROFILO = RISPOSTE.PRGLAVORATOREPROFILO )
    WHERE PROFILO.PRGLAVORATOREPROFILO= prgLavoratorepProfiloVar
    AND DE_RISPOSTA_PROFILO.CODDOMANDAPROF in ('D48','D53')
    AND PROFILO.Datcreazioneprofilo between DE_DOMANDA_PROFILO.datinizioval and DE_DOMANDA_PROFILO.datfineval;
    --AND trunc(PROFILO.Datcreazioneprofilo) between trunc(DE_DOMANDA_PROFILO.datinizioval) and trunc(DE_DOMANDA_PROFILO.datfineval);

    valoreDimensioneVar := round(valoreDimensioneVar,2);
    scoreApertura := '' || valoreDimensioneVar;

    errCodeOut := '00';
  end if;
EXCEPTION
  WHEN OTHERS THEN
    errCodeOut := '' || sqlcode;
END;

END PG_PROFILO_LAVORATORE;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_PROFIL.sql
************************************************************************************** */


CREATE OR REPLACE package PG_PROFIL is

  -- Author  : VUOTO
  -- Created : 03/08/2004 16.44.07
  -- Purpose :



   procedure set_comp_attr(p_CdnProfilo in INTEGER, p_CodComp in INT_ARRAY, p_CodCompAttr in INT_ARRAY,  p_CodAttr in INT_ARRAY,
   				   p_CodAttrPos in INT_ARRAY,
                   p_CodCompBreak in INT_ARRAY, p_CodAttrBreak in INT_ARRAY,  p_codUtente in Integer  );

   procedure clona_profilo(p_CdnProfilo in INTEGER, p_CdnProfilo_clonato out integer,  p_codUtente in Integer );

   procedure nuovo_profilo(p_CdnProfilo_nuovo out integer,
                           p_STRDENOMINAZIONE IN VARCHAR2,
                           p_STRNOTA IN VARCHAR2,
                           p_codUtente in Integer
                          );

  procedure set_visibilita_grupo ( p_CdnGruppo in INTEGER,
                               p_CodComp in INT_ARRAY,
                               p_CodFiltro in INT_ARRAY,
                               p_codUtente in Integer );
							   
							   
							   
     procedure	crea_voce_menu(	  
   								  p_cdnVoceMenu out integer,  
   								  p_cdnMenu in integer, 
  							   	  p_descVoceMenu in varchar2, 
								  p_prgVoceMenu in integer, 
							   	  p_cdnVoceMenuPadre in integer, 
							   	  p_cdnFunzione in integer 
 							  );  						   


     procedure	cancella_voci_menu(	  
   								  p_cdnMenu in integer 
  							  );  					
  							  	   
	
   procedure	salva_testata_menu(	  
   								  p_cdnMenu in integer, 
  							   	  p_descMenu in varchar2, 
							   	  p_newCdnMenu out integer 
 							  );  
							  
	 procedure clona_menu(p_cdnMenu in INTEGER, p_cdnMenu_clonato out integer );


end PG_PROFIL;
/
CREATE OR REPLACE package body PG_PROFIL is

  procedure set_comp_attr(p_CdnProfilo in INTEGER, p_CodComp in INT_ARRAY, p_CodCompAttr in INT_ARRAY, p_CodAttr in INT_ARRAY ,
    p_CodAttrPos in INT_ARRAY,
    p_CodCompBreak in INT_ARRAY, p_CodAttrBreak in INT_ARRAY, p_codUtente in Integer ) is

  begin

      delete from ts_abi_attributo t where t.cdnprofilo = p_CdnProfilo;
      delete from ts_abi_profilo t where t.cdnprofilo = p_CdnProfilo;


      for i in 1 .. p_CodComp.count
      loop
                insert into ts_abi_profilo
                  (cdnprofilo, cdncomponente, cdnutins, dtmins, cdnutmod, dtmmod)
                values
                  (p_CdnProfilo, p_CodComp(i),  p_codUtente, sysdate,  p_codUtente, sysdate);

      end loop;


      for i in 1 .. p_CodCompAttr.count
      loop


                insert into ts_abi_attributo
                  (cdnprofilo, cdncomponente, prgattributo, dtmins, dtmmod, cdnutins, cdnutmod, prgposizione, flgmostraelencostessariga)
                values
                  (p_CdnProfilo, p_CodCompAttr(i), p_CodAttr(i), sysdate, sysdate,  p_codUtente,  p_codUtente, p_CodAttrPos(i), null);

      end loop;



      for i in 1 .. p_CodCompBreak.count
      loop


                UPDATE ts_abi_attributo
                       set flgmostraelencostessariga='S'
                  where cdnprofilo=p_CdnProfilo
                  and  cdncomponente=p_CodCompBreak(i)
                  and prgattributo=p_CodAttrBreak(i);

      end loop;






  end set_comp_attr;


     procedure clona_profilo(p_CdnProfilo in INTEGER, p_CdnProfilo_clonato out integer,  p_codUtente in Integer ) is

	 --max_cdn_profilo integer;
	 begin
	 	  select S_ts_profilo.nextval into  p_CdnProfilo_clonato from dual;

		  insert into ts_profilo ( CDNPROFILO,STRDENOMINAZIONE, FLGSTANDARD, STRNOTA, CDNPROFILOPADRE,
		  		 	  			   CDNUTINS,  DTMINS, CDNUTMOD, DTMMOD )
		  SELECT  (p_CdnProfilo_clonato), SUBSTR('Clone di ' || STRDENOMINAZIONE, 1, 100 ) , 'N', STRNOTA, cdnprofilo, p_codUtente, sysdate,
		  		  					 p_codUtente, sysdate from ts_profilo
									 where  cdnprofilo = p_CdnProfilo;

      --clono i dati presenti nella tabelle ts_abi_profilo e ts_abi_attributo
		  insert into ts_abi_profilo
            ( CDNPROFILO,
              cdncomponente,
		  		 	  CDNUTINS,  DTMINS, CDNUTMOD, DTMMOD
            )
		  SELECT (p_CdnProfilo_clonato),
              cdncomponente,
              p_codUtente, sysdate, p_codUtente, sysdate
         FROM ts_abi_profilo
			  WHERE cdnprofilo = p_CdnProfilo;


		  insert into ts_abi_attributo
            ( CDNPROFILO,
              cdncomponente,
              prgattributo,
              prgposizione,
              flgmostraelencostessariga,
              CDNUTINS,  DTMINS, CDNUTMOD, DTMMOD
            )
		  SELECT (p_CdnProfilo_clonato),
              cdncomponente,
              prgattributo,
              prgposizione,
              flgmostraelencostessariga,
              p_codUtente, sysdate, p_codUtente, sysdate
         FROM ts_abi_attributo
			  WHERE cdnprofilo = p_CdnProfilo;





	 end clona_profilo;


   --INSERISCE UN NUOVO PROFILO
   procedure nuovo_profilo(p_CdnProfilo_nuovo out integer,
                           p_STRDENOMINAZIONE IN VARCHAR2,
                           p_STRNOTA IN VARCHAR2,
                           p_codUtente in Integer
                          ) IS
   begin
 	  	  select s_Ts_Profilo.Nextval into  p_CdnProfilo_nuovo from dual;

		  insert into ts_profilo
            ( CDNPROFILO,
              STRDENOMINAZIONE,
              FLGSTANDARD,
              STRNOTA,
              CDNPROFILOPADRE,
		  		 	  CDNUTINS,  DTMINS, CDNUTMOD, DTMMOD
            )
		  values
            ((p_CdnProfilo_nuovo),
              p_STRDENOMINAZIONE,
              'N',
              p_STRNOTA,
              null,
              p_codUtente, sysdate, p_codUtente, sysdate
             );

   end;



  -- ====================================================
  -- Imposta i filtri per il gruppo passato come argomento

  procedure set_visibilita_grupo ( p_CdnGruppo in INTEGER,
                               p_CodComp in INT_ARRAY,
                               p_CodFiltro in INT_ARRAY,
                               p_codUtente in Integer ) is

   vExistRecord INTEGER;
  begin
      --Cancello prima tutti i valori di filtro associati al gruppo
      delete from ts_vis_gruppo_comp t where t.cdnGruppo = p_cdnGruppo;

      --inserisco poi i nuovi valori di filtro
      for i in 1 .. p_CodComp.count
      loop

      --La select seguente con relativo controllo tramite IF
      --serve ad evitare l'inserimento nella tabella ts_vis_gruppo_comp di due
      --record contententi lo stesso cdngruppo, cdncomponente, prgfiltrovisibilita.
      --Se ciò accade si hanno dei problemi di visualizzazione nella pagina Gruppo->Visibilità.
      --La "duplicazione" (a meno della chiavve primaria) può avvenire xchè lo stesso componenete
      --può esistere in funzioni diverse ed essere filtrato nello stesso modo.

      select count(1) into vExistRecord
        from ts_vis_gruppo_comp t
       where t.cdngruppo = p_CdnGruppo
         and t.cdncomponente = p_CodComp(i)
         and t.prgfiltrovisibilita = p_CodFiltro(i);

      if (vExistRecord<>1) then

          insert into ts_vis_gruppo_comp
            ( PRGVISGRUPPOCOMP,
              cdnGruppo, cdncomponente, prgfiltrovisibilita,
              cdnutins, dtmins, cdnutmod, dtmmod
            )
          values
            ( S_TS_VIS_GRUPPO_COMP.NEXTVAL,
              p_cdnGruppo, p_CodComp(i),p_CodFiltro(i),
              p_codUtente, sysdate, p_codUtente, sysdate
            );

       end if;

      end loop;

  end set_visibilita_grupo;
  -- ====================================================

  
  
   procedure	crea_voce_menu(	  
   								  p_cdnVoceMenu out integer,  
   								  p_cdnMenu in integer, 
  							   	  p_descVoceMenu in varchar2, 
								  p_prgVoceMenu in integer, 
							   	  p_cdnVoceMenuPadre in integer, 
							   	  p_cdnFunzione in integer 
 							  )   is

  --seqVoceMenu integer;
  begin
     
	select  s_ts_voce_menu.nextval into p_cdnVoceMenu from dual;
	
	
	INSERT INTO TS_VOCE_MENU (
	   CDNVOCEMENU, STRVOCEMENU, CDNFUNZIONE) 
   	VALUES (p_cdnVoceMenu ,p_descVoceMenu,  p_cdnFunzione);
	 
	INSERT INTO TS_MENU (
   		   				 CDNMENU, 
						 CDNVOCEMENU, 
						 PRGVOCEMENU, 
		      			
						 CDNVOCEMENUPADRE 
						) 
			  VALUES ( 
			  		   	 p_cdnMenu,
						 p_cdnVoceMenu,
						 p_prgVoceMenu,
						 p_cdnVoceMenuPadre
					);
	
	
  end crea_voce_menu;
  

     procedure	cancella_voci_menu(	  
   								  p_cdnMenu in integer 
  							  ) is  					

  -- Cursore dlle voci menu da cancellare
   
   CURSOR cur_vm is
         select vm.cdnvocemenu c_cdnvocemenu
		 			from ts_voce_menu vm
					where 
		      		vm.cdnvocemenu in (select m.cdnvocemenu from ts_menu m where m.cdnmenu=p_cdnMenu);


	  begin

			update ts_menu
				set cdnvocemenupadre=null
				where cdnmenu=p_cdnMenu;
			
			 for cur_rec in cur_vm loop
			 
			 		delete from ts_menu
			 			where cdnvocemenu=cur_rec.c_cdnvocemenu;
			 		delete from ts_voce_menu
			 			where cdnvocemenu=cur_rec.c_cdnvocemenu;	
			
			  end loop;
			
		
	  end cancella_voci_menu;
	


   PROCEDURE	salva_testata_menu(	  
   								  p_cdnMenu in integer, 
  							   	  p_descMenu in varchar2, 
							   	  p_newCdnMenu out integer 
 							  )  is

   BEGIN
     
    IF p_cdnMenu=0  THEN
     
				SELECT  s_ts_menu_home.nextval INTO p_newCdnMenu FROM DUAL;
			
				INSERT INTO ts_menu_home
				  (cdnmenu, strdescrizione)
					VALUES
					  (p_newCdnMenu, p_descMenu);


	ELSE 
			  update ts_menu_home
				     set strdescrizione = p_descMenu
				   where cdnmenu = p_cdnMenu;
				   
			  p_newCdnMenu:=p_cdnMenu;	
	
	END IF;
	
	
  end salva_testata_menu;


    procedure clona_menu(p_cdnMenu in INTEGER, p_cdnMenu_clonato out integer ) is
       CURSOR cur_menu is
             select CDNMENU, CDNVOCEMENU, PRGVOCEMENU, CDNMENUPADRE, CDNVOCEMENUPADRE, PRGVOCEMENUPADRE
                        from ts_menu vm
                        where 
                        vm.cdnvocemenu in (select m.cdnvocemenu from ts_menu m where m.cdnmenu=p_cdnMenu)
            order by CDNVOCEMENU, CDNVOCEMENUPADRE nulls first, PRGVOCEMENU;
            p_cdnMenu_seq number;
            p_vocemenu_clonato number;
			TYPE map_codici_tab IS TABLE OF NUMBER(38) INDEX BY BINARY_INTEGER;
			map_codici map_codici_tab;
			p_voce_menu_padre VARCHAR2(30);
	 begin	
			
		  select S_TS_MENU_HOME.nextval into  p_cdnMenu_seq from dual;
		  
		  insert into ts_menu_home  (CDNMENU, STRDESCRIZIONE, FLGSTANDARD)
		  SELECT  (p_cdnMenu_seq), SUBSTR('Clone di ' || STRDESCRIZIONE, 1, 100 ) , FLGSTANDARD 
		  from ts_menu_home
		  where  CDNMENU = p_cdnMenu;
		  
	 	 for cur_rec in cur_menu  loop
					select S_TS_VOCE_MENU.nextval into p_vocemenu_clonato from dual;
					
					--inserisco la nuova voce menu
					insert into ts_voce_menu (CDNVOCEMENU, STRVOCEMENU, CDNFUNZIONE) 
					SELECT (p_vocemenu_clonato), STRVOCEMENU, CDNFUNZIONE
					FROM TS_VOCE_MENU WHERE CDNVOCEMENU = cur_rec.CDNVOCEMENU;					
					
					--associo alla vecchia voce menu la nuova voce menu creata
					map_codici(cur_rec.CDNVOCEMENU) :=  p_vocemenu_clonato;
					
					if map_codici.exists(cur_rec.CDNVOCEMENUPADRE) then
						p_voce_menu_padre:= map_codici(cur_rec.CDNVOCEMENUPADRE);
					else
						p_voce_menu_padre:=null;
					end if;
				
					insert into ts_menu (CDNMENU, CDNVOCEMENU, PRGVOCEMENU, CDNMENUPADRE, CDNVOCEMENUPADRE, PRGVOCEMENUPADRE)
					select (p_cdnMenu_seq), (p_vocemenu_clonato), cur_rec.PRGVOCEMENU, cur_rec.CDNMENUPADRE,p_voce_menu_padre, cur_rec.PRGVOCEMENUPADRE
                    from dual;	
					
		end loop;

		p_cdnMenu_clonato:=p_cdnMenu_seq;

	 end clona_menu;
  

end PG_PROFIL;
/





/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_SAP.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_SAP IS

FUNCTION getXMLSAP (cdnLavVar an_lavoratore.cdnlavoratore%type, p_key varchar2, cdnUtenteVar an_lavoratore.cdnutins%type, codStatoVar ts_tracciamento_sap.codtipovariazione%type, p_datDichiarazione varchar2, cpititSap de_cpi.codcpimin%type, errCodeOut out de_sap_yg_errore.coderrore%type) RETURN CLOB;
FUNCTION getXMLPoliticheAttiveSAP (cdnLavVar an_lavoratore.cdnlavoratore%type, errCodeOut out de_sap_yg_errore.coderrore%type) RETURN CLOB;
FUNCTION getDatiInvioSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type, codStatoVar ts_tracciamento_sap.codtipovariazione%type,  cpititSap de_cpi.codcpimin%type) RETURN de_sap_yg_errore.coderrore%type;
FUNCTION getDatiAnagraficiSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type;
FUNCTION getDatiAmministrativiSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type, cdnLavVarEncrypt varchar2, p_datDichiarazione varchar2) RETURN de_sap_yg_errore.coderrore%type;
FUNCTION getEspLavorativeSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type;
FUNCTION getLivelliIstruzioneSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type;
FUNCTION getAllegatoSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type;
FUNCTION getPoliticheAttive (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type;
FUNCTION getPoliticheAttiveSap2 (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type;
FUNCTION getPoliticheAttiveSIL (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type;
FUNCTION getPoliticheAttiveSIL2 (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type;
FUNCTION inserisciDatiInvio (doc xmldom.DOMDocument, cdnLavVar an_lavoratore.cdnlavoratore%type, codStatoVar sp_lavoratore.codStato%type, cdnUtenteVar an_lavoratore.cdnutins%type) RETURN de_sap_yg_errore.coderrore%type;

FUNCTION getXMLSAPNOCOMPETENZA (cdnLavVar an_lavoratore.cdnlavoratore%type, p_key varchar2, cdnUtenteVar an_lavoratore.cdnutins%type, codStatoVar ts_tracciamento_sap.codtipovariazione%type,  cpititSap de_cpi.codcpimin%type, errCodeOut out de_sap_yg_errore.coderrore%type) RETURN CLOB;
FUNCTION getAllegatoSAPNOCOMPETENZA (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type;

FUNCTION invioXMLSAP (cdnLavVar an_lavoratore.cdnlavoratore%type, p_key varchar2, p_cdnut ts_utente.cdnut%type, codTipoVariazioneVar ts_tracciamento_sap.codtipovariazione%type, codStatoVar sp_lavoratore.codStato%type, errCodeOut out de_sap_yg_errore.coderrore%type) RETURN CLOB;

FUNCTION getLavoratoriBatchSap return INT_ARRAY;

FUNCTION getIdentificativoPolitica (cdnLavVar an_lavoratore.cdnlavoratore%type, prgPattoLavVar AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE%type) RETURN varchar2;
FUNCTION getPoliticaA0205 (cdnLavVar an_lavoratore.cdnlavoratore%type, prgPattoLavVar AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE%type) RETURN varchar2;

FUNCTION getDescrYgProgetti (codprogettoVar MN_YG_TIPO_PROGETTI.CODPROGETTO%type ) RETURN varchar2;

END PG_SAP;
/
CREATE OR REPLACE PACKAGE BODY PG_SAP AS
FUNCTION getDescrYgProgetti (codprogettoVar MN_YG_TIPO_PROGETTI.CODPROGETTO%type ) RETURN varchar2 IS
	
	descrProg MN_YG_TIPO_PROGETTI.STRDESCRIZIONE%type;
	
BEGIN
	
   select prog.STRDESCRIZIONE 
   into descrProg
   from MN_YG_TIPO_PROGETTI prog
   where prog.CODPROGETTO = codprogettoVar;

  return descrProg;

EXCEPTION
  WHEN OTHERS THEN
	  return null;
  
END getDescrYgProgetti;

FUNCTION getXMLSAP (cdnLavVar an_lavoratore.cdnlavoratore%type, p_key varchar2, cdnUtenteVar an_lavoratore.cdnutins%type, codStatoVar ts_tracciamento_sap.codtipovariazione%type, p_datDichiarazione varchar2, cpititSap de_cpi.codcpimin%type, errCodeOut out de_sap_yg_errore.coderrore%type) RETURN CLOB IS
  doc xmldom.DOMDocument;
  doc1 xmldom.DOMDocument;
  main_node xmldom.DOMNode;
  root_node xmldom.DOMNode;

  datiAnagrafici_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt_datianag xmldom.DOMElement;
  datAnagLav_node xmldom.DOMNode;
  esitoDatiInvio de_sap_yg_errore.coderrore%type;
  esitoDatiAnag de_sap_yg_errore.coderrore%type;
  esitoDatiAmm de_sap_yg_errore.coderrore%type;
  esitoDatiEspLav de_sap_yg_errore.coderrore%type;
  esitoDatiIstruz de_sap_yg_errore.coderrore%type;
  esitoDatiAllegato de_sap_yg_errore.coderrore%type;
  esitoDatiPolAtt de_sap_yg_errore.coderrore%type;
  esitoTabella de_sap_yg_errore.coderrore%type;

  xml_response CLOB;
  
  configSezioneAMM Ts_Config_Loc.strvalore%type;

BEGIN

  -- controllo configurazione per compilazione sezione 2 - dati amministrativi
  select ts_config_loc.strvalore
  into configSezioneAMM
  from ts_config_loc, de_tipo_config, ts_generale
  where ts_generale.codprovinciasil = ts_config_loc.strcodrif
  and de_tipo_config.codtipoconfig = ts_config_loc.codtipoconfig
  and trunc(sysdate) between trunc(de_tipo_config.datinizioval) 
  and trunc(de_tipo_config.datfineval)
  and ts_config_loc.codtipoconfig  = 'SAP_AMM';
    
  doc := xmldom.newDOMDocument;
  main_node := xmldom.makeNode(doc);
  root_elmt := xmldom.createElement(doc, 'lavoratore');
  root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
  

  --00 NO ERRORI
  errCodeOut := '00';

  if(configSezioneAMM = '0') then 
esitoDatiInvio := PG_SAP.getDatiInvioSAP(doc, root_node, cdnLavVar, codStatoVar,cpititSap);
  if (esitoDatiInvio <> '00') then  
    errCodeOut := esitoDatiInvio;
  else
    esitoDatiAnag := PG_SAP.getDatiAnagraficiSAP(doc, root_node, cdnLavVar);
    if (esitoDatiAnag <> '00') then
      errCodeOut := esitoDatiAnag;
    else
      esitoDatiAmm := PG_SAP.getDatiAmministrativiSAP(doc, root_node, cdnLavVar, encrypt(cdnLavVar, p_key), p_datDichiarazione);
 
      	if (esitoDatiAmm <> '00') then
       	 errCodeOut := esitoDatiAmm;
     	 else
        esitoDatiEspLav := PG_SAP.getEspLavorativeSAP(doc, root_node, cdnLavVar);
        if (esitoDatiEspLav <> '00') then
          errCodeOut := esitoDatiEspLav;
        else
          esitoDatiIstruz := PG_SAP.getLivelliIstruzioneSAP(doc, root_node, cdnLavVar);
          if (esitoDatiIstruz <> '00') then
            errCodeOut := esitoDatiIstruz;
          else
            esitoDatiAllegato := PG_SAP.getAllegatoSAP(doc, root_node, cdnLavVar);
            if (esitoDatiAllegato <> '00') then
              errCodeOut := esitoDatiAllegato;
            else
              esitoDatiPolAtt := PG_SAP.getPoliticheAttive(doc, root_node, cdnLavVar);
              if (esitoDatiPolAtt <> '00') then
                errCodeOut := esitoDatiPolAtt;
               end if;
			 end if;
            end if;
           end if;
          end if;
        end if;
      end if;
    end if;
   if(configSezioneAMM = '1') then 
esitoDatiInvio := PG_SAP.getDatiInvioSAP(doc, root_node, cdnLavVar, codStatoVar, cpititSap);
  if (esitoDatiInvio <> '00') then  
    errCodeOut := esitoDatiInvio;
  else
    esitoDatiAnag := PG_SAP.getDatiAnagraficiSAP(doc, root_node, cdnLavVar);
    if (esitoDatiAnag <> '00') then
      errCodeOut := esitoDatiAnag;
    else
        esitoDatiEspLav := PG_SAP.getEspLavorativeSAP(doc, root_node, cdnLavVar);
        if (esitoDatiEspLav <> '00') then
          errCodeOut := esitoDatiEspLav;
        else
          esitoDatiIstruz := PG_SAP.getLivelliIstruzioneSAP(doc, root_node, cdnLavVar);
          if (esitoDatiIstruz <> '00') then
            errCodeOut := esitoDatiIstruz;
          else
            esitoDatiAllegato := PG_SAP.getAllegatoSAP(doc, root_node, cdnLavVar);
            if (esitoDatiAllegato <> '00') then
              errCodeOut := esitoDatiAllegato;
            else
              esitoDatiPolAtt := PG_SAP.getPoliticheAttive(doc, root_node, cdnLavVar);
              if (esitoDatiPolAtt <> '00') then
                errCodeOut := esitoDatiPolAtt;
               end if;
			 end if;
            end if;
           end if;
          end if;
        end if;
      end if;

  DBMS_LOB.CreateTemporary(xml_response, TRUE);
  xmldom.WRITETOCLOB(doc, xml_response);
  xmldom.freeDocument(doc);

  return xml_response;

EXCEPTION
  WHEN OTHERS THEN
    errCodeOut := '30';
    if (xmldom.isNull(doc) = FALSE) then
      DBMS_LOB.CreateTemporary(xml_response, TRUE);
      xmldom.WRITETOCLOB(doc, xml_response);
      xmldom.freeDocument(doc);
      return xml_response;
    else
      return null;
    end if;

END getXMLSAP;


FUNCTION getXMLPoliticheAttiveSAP (cdnLavVar an_lavoratore.cdnlavoratore%type, errCodeOut out de_sap_yg_errore.coderrore%type) RETURN CLOB IS
  doc xmldom.DOMDocument;
  main_node xmldom.DOMNode;
  root_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  esitoDatiPolAtt de_sap_yg_errore.coderrore%type;
  xml_response CLOB;

BEGIN
  doc := xmldom.newDOMDocument;
  main_node := xmldom.makeNode(doc);
  root_elmt := xmldom.createElement(doc, 'lavoratore');
  root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));

  --00 NO ERRORI
  errCodeOut := '00';
  
  esitoDatiPolAtt := PG_SAP.getPoliticheAttiveSIL(doc, root_node, cdnLavVar);
  if (esitoDatiPolAtt <> '00') then
	errCodeOut := esitoDatiPolAtt;
  end if;

  DBMS_LOB.CreateTemporary(xml_response, TRUE);
  xmldom.WRITETOCLOB(doc, xml_response);
  xmldom.freeDocument(doc);

  return xml_response;

EXCEPTION
  WHEN OTHERS THEN
    errCodeOut := '30';
    if (xmldom.isNull(doc) = FALSE) then
      DBMS_LOB.CreateTemporary(xml_response, TRUE);
      xmldom.WRITETOCLOB(doc, xml_response);
      xmldom.freeDocument(doc);
      return xml_response;
    else
      return null;
    end if;

END getXMLPoliticheAttiveSAP;


FUNCTION getDatiInvioSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type, codStatoVar ts_tracciamento_sap.codtipovariazione%type, cpititSap de_cpi.codcpimin%type) RETURN de_sap_yg_errore.coderrore%type IS
  main_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;

  item_text xmldom.DOMText;
  item_node xmldom.DOMNode;

  dataultimoagg_node xmldom.DOMNode;
  datanascita_node xmldom.DOMNode;
  cpi_node xmldom.DOMNode;
  variazione_node xmldom.DOMNode;

  datanascita varchar2(10);
  cpitit de_cpi.codcpimin%type;
  codmonotipocpiout an_lav_storia_inf.codmonotipocpi%type;
  cpititorig de_cpi.codcpimin%type;

BEGIN

  select to_char(lav.datnasc, 'yyyy-mm-dd'), de_cpi.codcpimin, inf.codmonotipocpi , cpi_orig.codcpimin 
  into datanascita, cpitit, codmonotipocpiout, cpititorig
  from an_lavoratore lav
  inner join an_lav_storia_inf inf on (lav.cdnlavoratore = inf.cdnlavoratore and inf.datfine is null)
  inner join de_cpi on (inf.codcpitit = de_cpi.codcpi)
  left join de_cpi cpi_orig on (inf.codcpiorig = cpi_orig.codcpi)
  where lav.cdnlavoratore = cdnLavVar;

  -- caso codcpitit quando si e' competenti ( codmonotipocpi = 'C' )
  if (codmonotipocpiout = 'C' and cpitit is not null and cpitit <> '''') then

    if (xmldom.isNull(doc) = FALSE) then
      root_elmt := xmldom.createElement(doc, 'datiinvio');
      main_node := xmldom.appendChild(root_node, xmldom.makeNode(root_elmt));
    else
      doc := xmldom.newDOMDocument;
      main_node := xmldom.makeNode(doc);
      root_elmt := xmldom.createElement(doc, 'datiinvio');
      root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
      main_node := root_node;
    end if;

    item_elmt := xmldom.createElement(doc, 'dataultimoagg');
    dataultimoagg_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, to_char(sysdate, 'yyyy-mm-dd'));
    item_node := xmldom.appendChild(dataultimoagg_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'codiceentetit');
    cpi_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, cpitit);
    item_node := xmldom.appendChild(cpi_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'tipovariazione');
    variazione_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, codStatoVar);
    item_node := xmldom.appendChild(variazione_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'datadinascita');
    datanascita_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, datanascita);
    item_node := xmldom.appendChild(datanascita_node, xmldom.makeNode(item_text));

    return '00';
  elsif  (codmonotipocpiout = 'T' ) then
   
   	if (xmldom.isNull(doc) = FALSE) then
      root_elmt := xmldom.createElement(doc, 'datiinvio');
      main_node := xmldom.appendChild(root_node, xmldom.makeNode(root_elmt));
    else
      doc := xmldom.newDOMDocument;
      main_node := xmldom.makeNode(doc);
      root_elmt := xmldom.createElement(doc, 'datiinvio');
      root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
      main_node := root_node;
    end if;

    item_elmt := xmldom.createElement(doc, 'dataultimoagg');
    dataultimoagg_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, to_char(sysdate, 'yyyy-mm-dd'));
    item_node := xmldom.appendChild(dataultimoagg_node, xmldom.makeNode(item_text));

 
	if(cpititSap is not null and cpititSap  <> '''') then

		item_elmt := xmldom.createElement(doc, 'codiceentetit');
		cpi_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
		item_text := xmldom.createTextNode(doc, cpititSap);
		item_node := xmldom.appendChild(cpi_node, xmldom.makeNode(item_text));
	else
		item_elmt := xmldom.createElement(doc, 'codiceentetit');
		cpi_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
		item_text := xmldom.createTextNode(doc, cpititorig);
		item_node := xmldom.appendChild(cpi_node, xmldom.makeNode(item_text));
	end if;

    item_elmt := xmldom.createElement(doc, 'tipovariazione');
    variazione_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, codStatoVar);
    item_node := xmldom.appendChild(variazione_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'datadinascita');
    datanascita_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, datanascita);
    item_node := xmldom.appendChild(datanascita_node, xmldom.makeNode(item_text));
   
      return '00';
  else
    --errore perch?anca il codice ente titolare nella sezione datiinvio
    return '26';
  end if;

EXCEPTION
  WHEN OTHERS THEN
    return '01';

END getDatiInvioSAP;


FUNCTION getDatiAnagraficiSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type IS
  main_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;
  datPersonaliAnag_node xmldom.DOMNode;
  cf_node xmldom.DOMNode;
  cognome_node xmldom.DOMNode;
  nome_node xmldom.DOMNode;
  sesso_node xmldom.DOMNode;
  datanascita_node xmldom.DOMNode;
  comunenas_node xmldom.DOMNode;
  cittadinanza_node xmldom.DOMNode;

  datiStranieri_node xmldom.DOMNode;
  tipodoc_node xmldom.DOMNode;
  numerodoc_node xmldom.DOMNode;
  motivodoc_node xmldom.DOMNode;
  scadenzadoc_node xmldom.DOMNode;

  item_text xmldom.DOMText;
  item_node xmldom.DOMNode;

  nome an_lavoratore.strnome%type;
  cognome an_lavoratore.strcognome%type;
  codicefiscale an_lavoratore.strcodicefiscale%type;
  sesso an_lavoratore.strsesso%type;
  datanascita varchar2(10);
  codcomunenasc an_lavoratore.codcomnas%type;
  cittadinanza an_lavoratore.codcittadinanza%type;
  codcomdom an_lavoratore.codcomdom%type;
  codcomres an_lavoratore.codcomres%type;
  strlocalitadom an_lavoratore.strlocalitadom%type;
  strlocalitares an_lavoratore.strlocalitares%type;
  strcapdom an_lavoratore.strcapdom%type;
  strcapres an_lavoratore.strcapres%type;
  strindirizzodom an_lavoratore.strindirizzodom%type;
  strindirizzores an_lavoratore.strindirizzores%type;
  strteldom an_lavoratore.strteldom%type;
  strcell an_lavoratore.strcell%type;
  strfax an_lavoratore.strfax%type;
  stremail an_lavoratore.stremail%type;
  datfinevalcittadinanza de_cittadinanza.datfineval%type;

  codcomdom_node xmldom.DOMNode;
  codcomres_node xmldom.DOMNode;
  strlocalitadom_node xmldom.DOMNode;
  strlocalitares_node xmldom.DOMNode;
  strcapdom_node xmldom.DOMNode;
  strcapres_node xmldom.DOMNode;
  strindirizzodom_node xmldom.DOMNode;
  strindirizzores_node xmldom.DOMNode;
  strteldom_node xmldom.DOMNode;
  strcell_node xmldom.DOMNode;
  strfax_node xmldom.DOMNode;
  stremail_node xmldom.DOMNode;

  residenza_node xmldom.DOMNode;
  domicilio_node xmldom.DOMNode;
  recapiti_node xmldom.DOMNode;

  codMotivoRilascio am_ex_perm_sogg.codmotivoril%type;
  numerodocumento am_ex_perm_sogg.strnumdocumento%type;
  codTipoDoc am_ex_perm_sogg.codstatus%type;
  datascadenza varchar2(10);
  dataultimomantenimento varchar2(10);
  cittadinoExtraCE boolean;

BEGIN

  select lav.strcodicefiscale, lav.strcognome, lav.strnome, lav.strsesso, 
  to_char(lav.datnasc, 'yyyy-mm-dd'), lav.codcomnas, lav.codcittadinanza,
  lav.codcomdom, lav.codcomres, 
  regexp_replace(lav.strlocalitadom, '[[:cntrl:]]', ' '), 
  regexp_replace(lav.strlocalitares, '[[:cntrl:]]', ' '), 
  (case when trim(lav.strcapdom) is not null then lav.strcapdom else comdom.strcap end) strcapdom,
  (case when trim(lav.strcapres) is not null then lav.strcapres else comres.strcap end) strcapres,
  (case when trim(lav.strindirizzodom) is null then 'Indirizzo non disponibile' else regexp_replace(lav.strindirizzodom, '[[:cntrl:]]', ' ') end) strindirizzodom,
  (case when trim(lav.strindirizzores) is null then 'Indirizzo non disponibile' else regexp_replace(lav.strindirizzores, '[[:cntrl:]]', ' ') end) strindirizzores,
  lav.strteldom, lav.strcell, lav.strfax, lav.stremail, de_cittadinanza.datfineval
  into codicefiscale, cognome, nome, sesso, datanascita, codcomunenasc, cittadinanza,
  codcomdom, codcomres, strlocalitadom, strlocalitares, strcapdom, strcapres, strindirizzodom, strindirizzores,
  strteldom, strcell, strfax, stremail, datfinevalcittadinanza
  from an_lavoratore lav
  inner join de_comune comdom on (lav.codcomdom = comdom.codcom)
  inner join de_cittadinanza on (lav.codcittadinanza = de_cittadinanza.codcittadinanza)
  left join de_comune comres on (lav.codcomres = comres.codcom)
  where lav.cdnlavoratore = cdnLavVar;

  --controllo obbligatoriet?omicilio, dati personali
  if (codcomdom <> '''' and codcomdom <> 'NT' and
    strcapdom is not null and strcapdom <> '''' and
    cittadinanza <> '''' and cittadinanza <> 'NT' and trunc(datfinevalcittadinanza) >= trunc(sysdate) and
    codcomunenasc <> '''' and codcomunenasc <> 'NT') then

    if (xmldom.isNull(doc) = FALSE) then
      root_elmt := xmldom.createElement(doc, 'datianagrafici');
      main_node := xmldom.appendChild(root_node, xmldom.makeNode(root_elmt));
    else
      doc := xmldom.newDOMDocument;
      main_node := xmldom.makeNode(doc);
      root_elmt := xmldom.createElement(doc, 'datianagrafici');
      root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
      main_node := root_node;
    end if;

    --datipersonali
    item_elmt := xmldom.createElement(doc, 'datipersonali');
    datPersonaliAnag_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));

    item_elmt := xmldom.createElement(doc, 'codicefiscale');
    cf_node := xmldom.appendChild(datPersonaliAnag_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, codicefiscale);
    item_node := xmldom.appendChild(cf_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'cognome');
    cognome_node := xmldom.appendChild(datPersonaliAnag_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, cognome);
    item_node := xmldom.appendChild(cognome_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'nome');
    nome_node := xmldom.appendChild(datPersonaliAnag_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, nome);
    item_node := xmldom.appendChild(nome_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'sesso');
    sesso_node := xmldom.appendChild(datPersonaliAnag_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, sesso);
    item_node := xmldom.appendChild(sesso_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'datanascita');
    datanascita_node := xmldom.appendChild(datPersonaliAnag_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, datanascita);
    item_node := xmldom.appendChild(datanascita_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'codcomune');
    comunenas_node := xmldom.appendChild(datPersonaliAnag_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, codcomunenasc);
    item_node := xmldom.appendChild(comunenas_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'codcittadinanza');
    cittadinanza_node := xmldom.appendChild(datPersonaliAnag_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, cittadinanza);
    item_node := xmldom.appendChild(cittadinanza_node, xmldom.makeNode(item_text));

    --datistranieri
    BEGIN
      select am_ex_perm_sogg.codmotivoril, to_char(am_ex_perm_sogg.DATSCADENZA, 'yyyy-mm-dd'), am_ex_perm_sogg.strnumdocumento, am_ex_perm_sogg.codstatus
      into codMotivoRilascio, datascadenza, numerodocumento, codTipoDoc
      from am_ex_perm_sogg
      where am_ex_perm_sogg.cdnlavoratore = cdnLavVar and ((am_ex_perm_sogg.datscadenza is null or
         (am_ex_perm_sogg.datscadenza > sysdate)) and (am_ex_perm_sogg.datfine is
         null or (am_ex_perm_sogg.datfine > sysdate)));

      item_elmt := xmldom.createElement(doc, 'datistranieri');
      datiStranieri_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));

      if (codTipoDoc is not null and codTipoDoc <> '''') then
        item_elmt := xmldom.createElement(doc, 'codtipodocumento');
        tipodoc_node := xmldom.appendChild(datiStranieri_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, codTipoDoc);
        item_node := xmldom.appendChild(tipodoc_node, xmldom.makeNode(item_text));
      end if;

      if (numerodocumento is not null and numerodocumento <> '''') then
        item_elmt := xmldom.createElement(doc, 'numero');
        numerodoc_node := xmldom.appendChild(datiStranieri_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, numerodocumento);
        item_node := xmldom.appendChild(numerodoc_node, xmldom.makeNode(item_text));
      end if;

      if (codMotivoRilascio is not null and codMotivoRilascio <> '''') then
        item_elmt := xmldom.createElement(doc, 'motivo');
        motivodoc_node := xmldom.appendChild(datiStranieri_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, codMotivoRilascio);
        item_node := xmldom.appendChild(motivodoc_node, xmldom.makeNode(item_text));
      end if;

      if (datascadenza is not null and datascadenza <> '''') then
        item_elmt := xmldom.createElement(doc, 'validoal');
        scadenzadoc_node := xmldom.appendChild(datiStranieri_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, datascadenza);
        item_node := xmldom.appendChild(scadenzadoc_node, xmldom.makeNode(item_text));
      end if;


    EXCEPTION
      WHEN OTHERS THEN
        cittadinoExtraCE := false;
    END;


    --residenza
    if ((codcomres is not null and codcomres <> '''' and codcomres <> 'NT') or
      (strcapres is not null and strcapres <> '''') or
      (strindirizzores is not null and strindirizzores <> '''') or
      (strlocalitares is not null and strlocalitares <> '''')) then

      item_elmt := xmldom.createElement(doc, 'residenza');
      residenza_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));

      if (codcomres is not null and codcomres <> '''' and codcomres <> 'NT') then
        item_elmt := xmldom.createElement(doc, 'codcomune');
        codcomres_node := xmldom.appendChild(residenza_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, codcomres);
        item_node := xmldom.appendChild(codcomres_node, xmldom.makeNode(item_text));
      end if;

      if (strcapres is not null and strcapres <> '''') then
        item_elmt := xmldom.createElement(doc, 'cap');
        strcapres_node := xmldom.appendChild(residenza_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, strcapres);
        item_node := xmldom.appendChild(strcapres_node, xmldom.makeNode(item_text));
      end if;

      if (strindirizzores is not null and strindirizzores <> '''') then
        item_elmt := xmldom.createElement(doc, 'indirizzo');
        strindirizzores_node := xmldom.appendChild(residenza_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, strindirizzores);
        item_node := xmldom.appendChild(strindirizzores_node, xmldom.makeNode(item_text));
      end if;

      if (strlocalitares is not null and strlocalitares <> '''') then
        item_elmt := xmldom.createElement(doc, 'localita');
        strlocalitares_node := xmldom.appendChild(residenza_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, strlocalitares);
        item_node := xmldom.appendChild(strlocalitares_node, xmldom.makeNode(item_text));
      end if;
    end if;


    --domicilio
    item_elmt := xmldom.createElement(doc, 'domicilio');
    domicilio_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));

    item_elmt := xmldom.createElement(doc, 'codcomune');
    codcomdom_node := xmldom.appendChild(domicilio_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, codcomdom);
    item_node := xmldom.appendChild(codcomdom_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'cap');
    strcapdom_node := xmldom.appendChild(domicilio_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, strcapdom);
    item_node := xmldom.appendChild(strcapdom_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'indirizzo');
    strindirizzodom_node := xmldom.appendChild(domicilio_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, strindirizzodom);
    item_node := xmldom.appendChild(strindirizzodom_node, xmldom.makeNode(item_text));

    if (strlocalitadom is not null and strlocalitadom <> '''') then
      item_elmt := xmldom.createElement(doc, 'localita');
      strlocalitadom_node := xmldom.appendChild(domicilio_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, strlocalitadom);
      item_node := xmldom.appendChild(strlocalitadom_node, xmldom.makeNode(item_text));
    end if;


    --recapiti
    if ((strteldom is null or strteldom = '''') and
      (strcell is null or strcell = '''') and
      (strfax is null or strfax = '''') and
      (stremail is null or stremail = '''')) then
      strteldom := '0000000000';
    end if;

    item_elmt := xmldom.createElement(doc, 'recapiti');
    recapiti_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));

    if (strteldom is not null and strteldom <> '''') then
      if (length(strteldom) > 15) then
        strteldom := substr(strteldom, 1, 15);
      end if;
      item_elmt := xmldom.createElement(doc, 'telefono');
      strteldom_node := xmldom.appendChild(recapiti_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, strteldom);
      item_node := xmldom.appendChild(strteldom_node, xmldom.makeNode(item_text));
    end if;

    if (strcell is not null and strcell <> '''') then
      if (length(strcell) > 15) then
        strcell := substr(strcell, 1, 15);
      end if;
      item_elmt := xmldom.createElement(doc, 'cellulare');
      strcell_node := xmldom.appendChild(recapiti_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, strcell);
      item_node := xmldom.appendChild(strcell_node, xmldom.makeNode(item_text));
    end if;

    if (strfax is not null and strfax <> '''') then
      if (length(strfax) > 15) then
        strfax := substr(strfax, 1, 15);
      end if;
      item_elmt := xmldom.createElement(doc, 'fax');
      strfax_node := xmldom.appendChild(recapiti_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, strfax);
      item_node := xmldom.appendChild(strfax_node, xmldom.makeNode(item_text));
    end if;

    if (stremail is not null and stremail <> '''') then
      item_elmt := xmldom.createElement(doc, 'email');
      stremail_node := xmldom.appendChild(recapiti_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, stremail);
      item_node := xmldom.appendChild(stremail_node, xmldom.makeNode(item_text));
    end if;

    return '00';
  else
    --errore perch?ncano i dati del domicilio
    if (strcapdom is null or strcapdom = '''' or codcomdom = '''' or codcomdom = 'NT') then
      return '27';
    else
      if (cittadinanza = '''' or cittadinanza = 'NT' or trunc(datfinevalcittadinanza) < trunc(sysdate) or codcomunenasc = '''' or codcomunenasc = 'NT') then
        return '03';
      else
        return '06';
      end if;
    end if;
  end if;

EXCEPTION
  WHEN OTHERS THEN
    return '02';

END getDatiAnagraficiSAP;


FUNCTION getDatiAmministrativiSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type, cdnLavVarEncrypt varchar2, p_datDichiarazione varchar2)
  RETURN de_sap_yg_errore.coderrore%type IS
  main_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;

  item_text xmldom.DOMText;
  item_node xmldom.DOMNode;

  codstatooccupaz am_stato_occupaz.codstatooccupaz%type;
  codstatooccupazragg de_stato_occupaz.codstatooccupazragg%type;
  codstatoanag ma_status_occupaz.codstatoanag%type;
  codesito ma_status_occupaz.codesito%type;
  mesianzianita vw_am_lav_situaz_ammin.mesianzianita%type;
  cod_categoria MN_CAT_PROTETTE.COD_CATEGORIA%type;
  des_categoria MN_CAT_PROTETTE.DES_CATEGORIA%type;

  cat181 varchar2(1000);
  datdichiarazione varchar2(10);
  datingresso varchar2(10);

  statoinanagrafe_node xmldom.DOMNode;
  periodidisoccupazione_node xmldom.DOMNode;
  codstatooccupaz_node xmldom.DOMNode;
  codstatoanag_node xmldom.DOMNode;
  mesianzianita_node xmldom.DOMNode;
  categoria297_node xmldom.DOMNode;
  datdichiarazione_node xmldom.DOMNode;
  datingresso_node xmldom.DOMNode;
  tipoingresso_node xmldom.DOMNode;
  didprotocollata boolean := true;
  obbligoformativo boolean := true;
  altrenotizielav boolean := false;
  erroreAltreNotizieLav boolean := false;
  listespecialilav boolean := false;
  erroreListeSpecialiCM boolean := false;
  erroreListeSpecialiMOB boolean := false;
  erroreStatoInAnagrafe boolean := false;
  tipoingresso mn_ingr_disoc.cod_ingdisocc%type;

  assolvimentoistruzione_node xmldom.DOMNode;
  obbligoformativo_node xmldom.DOMNode;
  altrenotizie_node xmldom.DOMNode;
  cod_categoria_node xmldom.DOMNode;
  flgobbligoformativo varchar2(2);

  tipoiscr VW_AM_RPT_SCHEDAAPMIN_LS_CM.TIPOISCR%type;
  datinizioiscr varchar2(10);
  datfineiscr varchar2(10);
  datamaxdiff varchar2(10);
  codmin DE_PROVINCIA.CODMIN%type;
  listespeciali_lst_node xmldom.DOMNode;
  listespeciali_node xmldom.DOMNode;
  tipoiscr_node xmldom.DOMNode;
  datinizioiscr_node xmldom.DOMNode;
  datfineiscr_node xmldom.DOMNode;
  codmin_node xmldom.DOMNode;
  datamaxdiff_node xmldom.DOMNode;

  CURSOR cursorIscrCM is
  select VW_AM_RPT_SCHEDAAPMIN_LS_CM.TIPOISCR, to_char(VW_AM_RPT_SCHEDAAPMIN_LS_CM.DATINIZIO, 'yyyy-mm-dd') DATINIZIO,
      to_char(VW_AM_RPT_SCHEDAAPMIN_LS_CM.DATFINE, 'yyyy-mm-dd') DATFINE, DE_PROVINCIA.CODMIN
    from VW_AM_RPT_SCHEDAAPMIN_LS_CM, TS_GENERALE, DE_PROVINCIA
    where TS_GENERALE.CODPROVINCIASIL = DE_PROVINCIA.CODPROVINCIA and
      VW_AM_RPT_SCHEDAAPMIN_LS_CM.CDNLAVORATORE_CRYP = cdnLavVarEncrypt;

  rec_IscrCM cursorIscrCM%ROWTYPE;

BEGIN

  if (xmldom.isNull(doc) = FALSE) then
    root_elmt := xmldom.createElement(doc, 'datiamministrativi');
    main_node := xmldom.appendChild(root_node, xmldom.makeNode(root_elmt));
  else
    doc := xmldom.newDOMDocument;
    main_node := xmldom.makeNode(doc);
    root_elmt := xmldom.createElement(doc, 'datiamministrativi');
    root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
    main_node := root_node;
  end if;

  begin

    select am_stato_occupaz.codstatooccupaz, ma_status_occupaz.codstatoanag, ma_status_occupaz.codesito,
    vw_am_lav_situaz_ammin.mesianzianita, de_stato_occupaz.codstatooccupazragg,
    case
      when am_stato_occupaz.datanzianitadisoc is not null then to_char(am_stato_occupaz.datanzianitadisoc, 'yyyy-mm-dd')
      else to_char(am_stato_occupaz.datinizio, 'yyyy-mm-dd')
    end
    into codstatooccupaz, codstatoanag, codesito, mesianzianita, codstatooccupazragg, datingresso
    from am_stato_occupaz
    inner join de_stato_occupaz on (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
    left join vw_am_lav_situaz_ammin on (am_stato_occupaz.cdnlavoratore=vw_am_lav_situaz_ammin.cdnlavoratore)
    left join ma_status_occupaz on (am_stato_occupaz.codstatooccupaz = ma_status_occupaz.codstatooccupaz)
    where am_stato_occupaz.cdnlavoratore = cdnLavVar and am_stato_occupaz.datfine is null;

    cat181 := GETCAT181PERSTAMPA(cdnLavVar, sysdate);
    if (cat181 <> '''') then
      cat181 := substr(cat181, 1, 1);
    end if;

    --statoinanagrafe
    item_elmt := xmldom.createElement(doc, 'statoinanagrafe');
    statoinanagrafe_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));

    if (codstatoanag is not null and codstatoanag <> '''') then
      item_elmt := xmldom.createElement(doc, 'codstatooccupazionale');
      codstatooccupaz_node := xmldom.appendChild(statoinanagrafe_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codstatoanag);
      item_node := xmldom.appendChild(codstatooccupaz_node, xmldom.makeNode(item_text));
    end if;

    if (codesito is not null and codesito <> '''') then
      item_elmt := xmldom.createElement(doc, 'codstatus');
      codstatoanag_node := xmldom.appendChild(statoinanagrafe_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codesito);
      item_node := xmldom.appendChild(codstatoanag_node, xmldom.makeNode(item_text));
    end if;

    if (codstatooccupazragg in ('D', 'I')) then
      if (cat181 is not null and cat181 <> '''') then
        item_elmt := xmldom.createElement(doc, 'categoria297');
        categoria297_node := xmldom.appendChild(statoinanagrafe_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, cat181);
        item_node := xmldom.appendChild(categoria297_node, xmldom.makeNode(item_text));
      end if;

      if (mesianzianita is not null) then
		if (mesianzianita < 0) then
          mesianzianita := 0;
        end if;
        item_elmt := xmldom.createElement(doc, 'anzianita');
        mesianzianita_node := xmldom.appendChild(statoinanagrafe_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, mesianzianita);
        item_node := xmldom.appendChild(mesianzianita_node, xmldom.makeNode(item_text));
      end if;


      begin
        select to_char(am_dich_disponibilita.datdichiarazione, 'yyyy-mm-dd')
        into datdichiarazione
        from am_elenco_anagrafico
        left join am_dich_disponibilita on (am_elenco_anagrafico.prgelencoanagrafico = am_dich_disponibilita.prgelencoanagrafico)
        where am_elenco_anagrafico.cdnlavoratore = cdnLavVar and
        am_dich_disponibilita.datfine is null and am_dich_disponibilita.codstatoatto = 'PR';

        item_elmt := xmldom.createElement(doc, 'disponibilita');
        datdichiarazione_node := xmldom.appendChild(statoinanagrafe_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, datdichiarazione);
        item_node := xmldom.appendChild(datdichiarazione_node, xmldom.makeNode(item_text));

      exception
        when others then
          didprotocollata := false;
      end;

      --periodidisoccupazione
      item_elmt := xmldom.createElement(doc, 'periodidisoccupazione');
      periodidisoccupazione_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'dataingresso');
      datingresso_node := xmldom.appendChild(periodidisoccupazione_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, datingresso);
      item_node := xmldom.appendChild(datingresso_node, xmldom.makeNode(item_text));

      if (didprotocollata) then
        tipoingresso:= 'D';
      else
        tipoingresso:= 'F';
      end if;

      item_elmt := xmldom.createElement(doc, 'tipoingresso');
      tipoingresso_node := xmldom.appendChild(periodidisoccupazione_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, tipoingresso);
      item_node := xmldom.appendChild(tipoingresso_node, xmldom.makeNode(item_text));
	  
	else
		
		begin
			select to_char(am_dich_disponibilita.datdichiarazione, 'yyyy-mm-dd')
			into datdichiarazione
			from am_elenco_anagrafico
			left join am_dich_disponibilita on (am_elenco_anagrafico.prgelencoanagrafico = am_dich_disponibilita.prgelencoanagrafico)
			where am_elenco_anagrafico.cdnlavoratore = cdnLavVar and am_dich_disponibilita.codstatoatto = 'PR' 
			and trunc(am_dich_disponibilita.datdichiarazione) = to_date(p_datDichiarazione, 'dd/mm/yyyy') 
			and am_dich_disponibilita.datfine is not null and am_dich_disponibilita.codmotivofineatto = 'AV';

			item_elmt := xmldom.createElement(doc, 'disponibilita');
			datdichiarazione_node := xmldom.appendChild(statoinanagrafe_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, datdichiarazione);
			item_node := xmldom.appendChild(datdichiarazione_node, xmldom.makeNode(item_text));

		exception
			when others then
			  didprotocollata := false;
		end;
	
	end if;

  exception
    when others then
      erroreStatoInAnagrafe := true;
  end;


  --listespeciali_lst
  begin
    FOR rec_IscrCM IN cursorIscrCM LOOP
      tipoiscr := rec_IscrCM.TIPOISCR;
      datinizioiscr := rec_IscrCM.DATINIZIO;
      datfineiscr := rec_IscrCM.DATFINE;
      codmin := rec_IscrCM.CODMIN;

      if (not listespecialilav) then
        item_elmt := xmldom.createElement(doc, 'listespeciali_lst');
        listespeciali_lst_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
        listespecialilav := true;
      end if;

      --listespeciali
      item_elmt := xmldom.createElement(doc, 'listespeciali');
      listespeciali_node := xmldom.appendChild(listespeciali_lst_node, xmldom.makeNode(item_elmt));

      if (tipoiscr is not null and tipoiscr <> '''') then
        item_elmt := xmldom.createElement(doc, 'tipolista');
        tipoiscr_node := xmldom.appendChild(listespeciali_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, tipoiscr);
        item_node := xmldom.appendChild(tipoiscr_node, xmldom.makeNode(item_text));
      end if;

      if (datinizioiscr is not null and datinizioiscr <> '''') then
        item_elmt := xmldom.createElement(doc, 'dataiscrizione');
        datinizioiscr_node := xmldom.appendChild(listespeciali_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, datinizioiscr);
        item_node := xmldom.appendChild(datinizioiscr_node, xmldom.makeNode(item_text));
      end if;

      if (datfineiscr is not null and datfineiscr <> '''') then
        item_elmt := xmldom.createElement(doc, 'datafineiscrizione');
        datfineiscr_node := xmldom.appendChild(listespeciali_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, datfineiscr);
        item_node := xmldom.appendChild(datfineiscr_node, xmldom.makeNode(item_text));
      end if;

      if (codmin is not null and codmin <> '''') then
        item_elmt := xmldom.createElement(doc, 'codprovincia');
        codmin_node := xmldom.appendChild(listespeciali_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, codmin);
        item_node := xmldom.appendChild(codmin_node, xmldom.makeNode(item_text));
      end if;

    END LOOP;

  exception
    when others then
      erroreListeSpecialiCM := true;
  end;

  begin
    select VW_AM_RPT_SCHEDAAPMIN_LS_MOB.CODLISTESPEC, to_char(VW_AM_RPT_SCHEDAAPMIN_LS_MOB.DATINIZIO,'yyyy-mm-dd'),
      to_char(VW_AM_RPT_SCHEDAAPMIN_LS_MOB.DATFINE,'yyyy-mm-dd'),
      to_char(VW_AM_RPT_SCHEDAAPMIN_LS_MOB.DATAMAXDIFF,'yyyy-mm-dd'),
       DE_PROVINCIA.CODMIN
    into tipoiscr, datinizioiscr, datfineiscr, datamaxdiff, codmin
    from VW_AM_RPT_SCHEDAAPMIN_LS_MOB, TS_GENERALE, DE_PROVINCIA
    where TS_GENERALE.CODPROVINCIASIL = DE_PROVINCIA.CODPROVINCIA and
      VW_AM_RPT_SCHEDAAPMIN_LS_MOB.CDNLAVORATORE = cdnLavVar;

    if (not listespecialilav) then
      item_elmt := xmldom.createElement(doc, 'listespeciali_lst');
      listespeciali_lst_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
      listespecialilav := true;
    end if;

    --listespeciali
    item_elmt := xmldom.createElement(doc, 'listespeciali');
    listespeciali_node := xmldom.appendChild(listespeciali_lst_node, xmldom.makeNode(item_elmt));

    if (tipoiscr is not null and tipoiscr <> '''') then
      item_elmt := xmldom.createElement(doc, 'tipolista');
      tipoiscr_node := xmldom.appendChild(listespeciali_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, tipoiscr);
      item_node := xmldom.appendChild(tipoiscr_node, xmldom.makeNode(item_text));
    end if;

    if (datinizioiscr is not null and datinizioiscr <> '''') then
      item_elmt := xmldom.createElement(doc, 'dataiscrizione');
      datinizioiscr_node := xmldom.appendChild(listespeciali_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, datinizioiscr);
      item_node := xmldom.appendChild(datinizioiscr_node, xmldom.makeNode(item_text));
    end if;

    if (datfineiscr is not null and datfineiscr <> '''') then
      item_elmt := xmldom.createElement(doc, 'datafineiscrizione');
      datfineiscr_node := xmldom.appendChild(listespeciali_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, datfineiscr);
      item_node := xmldom.appendChild(datfineiscr_node, xmldom.makeNode(item_text));
    end if;

    if (datamaxdiff is not null and datamaxdiff <> '''') then
      item_elmt := xmldom.createElement(doc, 'datamaxdeferimento');
      datamaxdiff_node := xmldom.appendChild(listespeciali_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, datamaxdiff);
      item_node := xmldom.appendChild(datamaxdiff_node, xmldom.makeNode(item_text));
    end if;

    if (codmin is not null and codmin <> '''') then
      item_elmt := xmldom.createElement(doc, 'codprovincia');
      codmin_node := xmldom.appendChild(listespeciali_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codmin);
      item_node := xmldom.appendChild(codmin_node, xmldom.makeNode(item_text));
    end if;

  exception
    when others then
      erroreListeSpecialiMOB := true;
  end;


  --assolvimentoistruzione
  begin
    select case when nvl(am_obbligo_formativo.flgobbligoformativo, 'N') = 'S' then 'SI' else 'NO' end
    into flgobbligoformativo
    from am_obbligo_formativo
    where am_obbligo_formativo.cdnlavoratore = cdnLavVar;

    item_elmt := xmldom.createElement(doc, 'assolvimentoistruzione');
    assolvimentoistruzione_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));

    item_elmt := xmldom.createElement(doc, 'obbligoformativo');
    obbligoformativo_node := xmldom.appendChild(assolvimentoistruzione_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, flgobbligoformativo);
    item_node := xmldom.appendChild(obbligoformativo_node, xmldom.makeNode(item_text));

  exception
    when others then
      obbligoformativo := false;
  end;


  --altrenotizie
  begin
    select MN_CAT_PROTETTE.COD_CATEGORIA, MN_CAT_PROTETTE.DES_CATEGORIA
    into cod_categoria, des_categoria
    from AM_CM_ISCR AM_CM_ISCR,
      MA_CAT_PROTETTE,
      MN_CAT_PROTETTE,
      AM_DOCUMENTO,
      AM_DOCUMENTO_COLL,
      DE_CM_TIPO_ISCR
    where AM_CM_ISCR.CODCMTIPOISCR = MA_CAT_PROTETTE.CODCMTIPOISCR and
         MA_CAT_PROTETTE.COD_CATEGORIA = MN_CAT_PROTETTE.COD_CATEGORIA and
         AM_CM_ISCR.PRGCMISCR = AM_DOCUMENTO_COLL.STRCHIAVETABELLA and
         AM_DOCUMENTO_COLL.PRGDOCUMENTO = AM_DOCUMENTO.PRGDOCUMENTO and
         AM_CM_ISCR.CODCMTIPOISCR = DE_CM_TIPO_ISCR.CODCMTIPOISCR and
         (((AM_CM_ISCR.DATDATAFINE is null and (DE_CM_TIPO_ISCR.CODMONOTIPORAGG =
         'A')) and (AM_DOCUMENTO.CODTIPODOCUMENTO = 'L68')) and
         (AM_DOCUMENTO.CODSTATOATTO = 'PR'))
         and AM_CM_ISCR.CDNLAVORATORE = cdnLavVarEncrypt;


    item_elmt := xmldom.createElement(doc, 'altrenotizie');
    altrenotizie_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    altrenotizielav := true;

    item_elmt := xmldom.createElement(doc, 'categorieprotette');
    cod_categoria_node := xmldom.appendChild(altrenotizie_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, cod_categoria);
    item_node := xmldom.appendChild(cod_categoria_node, xmldom.makeNode(item_text));

  exception
    when others then
      erroreAltreNotizieLav := true;
  end;

  return '00';

EXCEPTION
  WHEN OTHERS THEN
    return '08';

END getDatiAmministrativiSAP;


FUNCTION getEspLavorativeSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type IS
  main_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;

  item_text xmldom.DOMText;
  item_node xmldom.DOMNode;
  esperienzalavoro_node xmldom.DOMNode;
  datainizio_node xmldom.DOMNode;
  azienda_node xmldom.DOMNode;
  aziendautil_node xmldom.DOMNode;
  strcodicefiscale_node xmldom.DOMNode;
  datorelavoro_node xmldom.DOMNode;
  indirizzoazienda_node xmldom.DOMNode;
  codateco_node xmldom.DOMNode;
  cfutilizz_node xmldom.DOMNode;
  denominutilizz_node xmldom.DOMNode;
  indirizzoutilizz_node xmldom.DOMNode;
  atecoutilizz_node xmldom.DOMNode;
  datfinemov_node xmldom.DOMNode;
  datfinepf_node xmldom.DOMNode;
  compiti_node xmldom.DOMNode;
  codmansione_node xmldom.DOMNode;
  tiporapporto_node xmldom.DOMNode;
  tipocontratto_node xmldom.DOMNode;
  assunzioneLegge68_node xmldom.DOMNode;
  lavInMobilita_node xmldom.DOMNode;
  lavoroStagionale_node xmldom.DOMNode;
  lavoroInAgricoltura_node xmldom.DOMNode;
  modalitalavoro_node xmldom.DOMNode;
  codorario_node xmldom.DOMNode;
  luogolavoro_node xmldom.DOMNode;
  indirizzolavoro_node xmldom.DOMNode;
  comunelavoro_node xmldom.DOMNode;

  CURSOR cursorEspLav is
    SELECT VW_RPT_SCHEDAAPMIN_MOVIMENTI.ISMISSIONE,VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTICF,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTIDENOM,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTIIND,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODAZUTIATECO,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTIATECO,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTICFMISS,VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTIDENOMMISS,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTIINDMISS,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODAZUTIATECOMISS,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTIATECOMISS,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.STRDESATTIVITA,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.DESATTIVITAMISS,VW_RPT_SCHEDAAPMIN_MOVIMENTI.STRRAGIONESOCIALE,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.STRCODICEFISCALE, VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODTIPOAZIENDA,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.MANSIONE_DESC, VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODMANSIONE_MIN,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.CONTRATTO_DESC,VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODCONTRATTO,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODAZATECO,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZATECO,
    to_char(VW_RPT_SCHEDAAPMIN_MOVIMENTI.DATINIZIOMOV, 'yyyy-mm-dd') DATINIZIOMOV,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.STRINDIRIZZO,
    to_char(VW_RPT_SCHEDAAPMIN_MOVIMENTI.DATFINEMOV, 'yyyy-mm-dd') DATFINEMOV,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODORARIO, VW_RPT_SCHEDAAPMIN_MOVIMENTI.NUMORESETT,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODTIPOMOV,VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODTIPOTRASF,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.INDDIST,
    to_char(VW_RPT_SCHEDAAPMIN_MOVIMENTI.DATINIZIOMIS, 'yyyy-mm-dd') DATINIZIOMIS,
    to_char(VW_RPT_SCHEDAAPMIN_MOVIMENTI.DATFINEMIS, 'yyyy-mm-dd') DATFINEMIS,
    VW_RPT_SCHEDAAPMIN_MOVIMENTI.MANS_DESC_MISS,
    to_char(VW_RPT_SCHEDAAPMIN_MOVIMENTI.DATFINEPF, 'yyyy-mm-dd') DATFINEPF,
    (case when NVL(VW_RPT_SCHEDAAPMIN_MOVIMENTI.FLGLAVOROINMOBILITA, 'N') = 'S' then 'SI' else 'NO' end) FLGLAVOROINMOBILITA,
    (case when NVL(VW_RPT_SCHEDAAPMIN_MOVIMENTI.FLGLAVOROSTAGIONALE, 'N') = 'S' then 'SI' else 'NO' end) FLGLAVOROSTAGIONALE,
    (case
      when ( (NVL(VW_RPT_SCHEDAAPMIN_MOVIMENTI.FLGLAVOROAGR, 'N') = 'S') or
           (VW_RPT_SCHEDAAPMIN_MOVIMENTI.NUMGGPREVISTIAGR is not null and VW_RPT_SCHEDAAPMIN_MOVIMENTI.NUMGGPREVISTIAGR > 0) )
        then 'SI'
      else 'NO' end) FLGLAVOROAGR,
    (case
      when ( (NVL(VW_RPT_SCHEDAAPMIN_MOVIMENTI.FLGLEGGE68, 'N') = 'S') or
           (VW_RPT_SCHEDAAPMIN_MOVIMENTI.DATCONVENZIONE is not null and
            VW_RPT_SCHEDAAPMIN_MOVIMENTI.NUMCONVENZIONE is not null) or
           (NVL(VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODTIPOASS, '-') in ('NOH', 'NU2')) )
        then 'SI'
      else 'NO' end) FLGLEGGE68,
    DE_COMUNE.CODCOM CODCMOM,DE_COMUNE.STRDENOMINAZIONE STRDENOMINAZIONE, DE_COMUNE_2.CODCOM CODCOM2,
    DE_COMUNE_2.STRDENOMINAZIONE STRDENOMINAZIONE2,DE_COMUNE_3.CODCOM CODCOM3,
    DE_COMUNE_3.STRDENOMINAZIONE STRDENOMINAZIONE3
    FROM  VW_RPT_SCHEDAAPMIN_MOVIMENTI LEFT OUTER JOIN DE_COMUNE DE_COMUNE ON
        (VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTICOM=DE_COMUNE.CODCOM)
      LEFT OUTER JOIN DE_COMUNE DE_COMUNE_2 ON (VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZCOM=DE_COMUNE_2.CODCOM)
      LEFT OUTER JOIN DE_COMUNE DE_COMUNE_3 ON (VW_RPT_SCHEDAAPMIN_MOVIMENTI.COMDIST=DE_COMUNE_3.CODCOM)
    WHERE VW_RPT_SCHEDAAPMIN_MOVIMENTI.CDNLAVORATORE = cdnLavVar;

  rec_EspLav cursorEspLav%ROWTYPE;

  strcodicefiscale VW_RPT_SCHEDAAPMIN_MOVIMENTI.STRCODICEFISCALE%type;
  datorelavoro VW_RPT_SCHEDAAPMIN_MOVIMENTI.STRRAGIONESOCIALE%type;
  indirizzoazienda VW_RPT_SCHEDAAPMIN_MOVIMENTI.STRINDIRIZZO%type;
  codateco DE_ATTIVITA.CODATECODOT%type;
  datainizio varchar2(10);
  ismissione VW_RPT_SCHEDAAPMIN_MOVIMENTI.ISMISSIONE%type;
  codtipoazienda VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODTIPOAZIENDA%type;
  cfutilizz VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTICF%type;
  denominutilizz VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTIDENOM%type;
  indirizzoutilizz VW_RPT_SCHEDAAPMIN_MOVIMENTI.AZUTIIND%type;
  atecoutilizz DE_ATTIVITA.CODATECODOT%type;
  datfinemov varchar2(10);
  datfinepf varchar2(10);
  compiti varchar2(250);
  descmansione DE_MANSIONE.STRDESCRIZIONE%type;
  codmansione_min DE_MANSIONE.codmansionedot%type;
  tipocontratto am_movimento.codtipocontratto%type;
  assunzioneLegge68 varchar2(2);
  lavInMobilita varchar2(2);
  lavoroStagionale varchar2(2);
  lavoroInAgricoltura varchar2(2);
  codorario VW_RPT_SCHEDAAPMIN_MOVIMENTI.CODORARIO%type;
  numoresett VW_RPT_SCHEDAAPMIN_MOVIMENTI.NUMORESETT%type;
  codTipoOrario MA_ORARIO.COD_TIPOORARIO%type;
  indirizzolavoro VW_RPT_SCHEDAAPMIN_MOVIMENTI.STRINDIRIZZO%type;
  comunelavoro de_comune.codcom%type;
  contatoreMob number;
  contatore number;

BEGIN

  contatore := 1;

  FOR rec_EspLav IN cursorEspLav LOOP
    strcodicefiscale := rec_EspLav.strcodicefiscale;
    datorelavoro := rec_EspLav.STRRAGIONESOCIALE;
    indirizzoazienda := rec_EspLav.STRINDIRIZZO;
    codateco := rec_EspLav.CODAZATECO;
    ismissione := rec_EspLav.ISMISSIONE;
    codtipoazienda := rec_EspLav.codtipoazienda;
    datainizio := rec_EspLav.DATINIZIOMOV;
    datfinemov := rec_EspLav.datfinemov;
    datfinepf := rec_EspLav.datfinepf;
    descmansione := rec_EspLav.MANSIONE_DESC;
    codmansione_min := rec_EspLav.codmansione_min;
    tipocontratto := rec_EspLav.CODCONTRATTO;
    assunzioneLegge68 := rec_EspLav.FLGLEGGE68;
    lavInMobilita := rec_EspLav.FLGLAVOROINMOBILITA;
    if (lavInMobilita = 'NO') then
      select count(*)
      into contatoreMob
      from am_mobilita_iscr mob
      inner join de_mb_tipo on (mob.codtipomob = de_mb_tipo.codmbtipo)
      where mob.cdnlavoratore = cdnLavVar and de_mb_tipo.codmonoattiva = 'A'
      and to_date(datainizio, 'yyyy-mm-dd') between trunc(mob.datinizio) and trunc(mob.datfine);

      if (contatoreMob > 0) then
        lavInMobilita := 'SI';
      end if;
    end if;
    lavoroStagionale := rec_EspLav.FLGLAVOROSTAGIONALE;
    lavoroInAgricoltura := rec_EspLav.FLGLAVOROAGR;
    codTipoOrario := '';
    codorario := rec_EspLav.CODORARIO;
    numoresett := rec_EspLav.NUMORESETT;
    if (codorario is not null and codorario <> '''') then
      if (codorario = 'T') then
        codTipoOrario := 'FT';
      else
        if (codorario = 'P') then
          codTipoOrario := 'PT';
        else
          if (codorario = 'N') then
            if (numoresett is null) then
              codTipoOrario := 'FT';
            else
              codTipoOrario := 'PT';
            end if;
          end if;
        end if;
      end if;
    end if;

    if (descmansione is not null and descmansione <> '''') then
      if (length(descmansione) > 250) then
        compiti := substr(descmansione, 1, 250);
      else
        compiti := descmansione;
      end if;
    end if;

    if (ismissione = '1') then
      indirizzolavoro := rec_EspLav.AZUTIIND;
      comunelavoro := rec_EspLav.CODCMOM;
      cfutilizz := rec_EspLav.AZUTICFMISS;
      denominutilizz := rec_EspLav.AZUTIDENOMMISS;
      indirizzoutilizz := rec_EspLav.AZUTIINDMISS;
      atecoutilizz := rec_EspLav.CODAZUTIATECOMISS;
    else
      cfutilizz := rec_EspLav.AZUTICF;
      denominutilizz := rec_EspLav.AZUTIDENOM;
      indirizzoutilizz := rec_EspLav.AZUTIIND;
      atecoutilizz := rec_EspLav.CODAZUTIATECO;
      if (rec_EspLav.CODTIPOMOV = 'TRA' and rec_EspLav.CODTIPOTRASF = 'DL') then
        indirizzolavoro := rec_EspLav.INDDIST;
        comunelavoro := rec_EspLav.CODCOM3;
      else
        indirizzolavoro := rec_EspLav.STRINDIRIZZO;
        comunelavoro := rec_EspLav.CODCOM2;
      end if;
    end if;

    if (codateco is not null and codateco <> '''' and
      codmansione_min is not null and codmansione_min <> '''' and
      codTipoOrario is not null and codTipoOrario <> '''' and
      indirizzolavoro is not null and indirizzolavoro <> '''' and
      comunelavoro is not null and comunelavoro <> '''' and comunelavoro <> 'NT' and
      tipocontratto is not null and tipocontratto <> '''' and tipocontratto <> 'NT') then

      if (contatore = 1) then
        if (xmldom.isNull(doc) = FALSE) then
          root_elmt := xmldom.createElement(doc, 'esperienzelavoro_lst');
          main_node := xmldom.appendChild(root_node, xmldom.makeNode(root_elmt));
        else
          doc := xmldom.newDOMDocument;
          main_node := xmldom.makeNode(doc);
          root_elmt := xmldom.createElement(doc, 'esperienzelavoro_lst');
          root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
          main_node := root_node;
        end if;
      end if;

      item_elmt := xmldom.createElement(doc, 'esperienzalavoro');
      esperienzalavoro_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));

      --azienda
      item_elmt := xmldom.createElement(doc, 'azienda');
      azienda_node := xmldom.appendChild(esperienzalavoro_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'codicefiscale');
      strcodicefiscale_node := xmldom.appendChild(azienda_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, strcodicefiscale);
      item_node := xmldom.appendChild(strcodicefiscale_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'datorelavoro');
      datorelavoro_node := xmldom.appendChild(azienda_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(datorelavoro, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(datorelavoro_node, xmldom.makeNode(item_text));

      if (indirizzoazienda is not null and indirizzoazienda <> '''') then
        if (length(indirizzoazienda) > 100) then
          indirizzoazienda := substr(indirizzoazienda, 1, 100);
        end if;
        item_elmt := xmldom.createElement(doc, 'indirizzoazienda');
        indirizzoazienda_node := xmldom.appendChild(azienda_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, regexp_replace(indirizzoazienda, '[[:cntrl:]]', ' '));
        item_node := xmldom.appendChild(indirizzoazienda_node, xmldom.makeNode(item_text));
      end if;

      item_elmt := xmldom.createElement(doc, 'codateco');
      codateco_node := xmldom.appendChild(azienda_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codateco);
      item_node := xmldom.appendChild(codateco_node, xmldom.makeNode(item_text));

      --utilizzatrice
      if (codtipoazienda = 'INT' and ((cfutilizz is not null and cfutilizz <> '''') or
                      (denominutilizz is not null and denominutilizz <> '''') or
                      (indirizzoutilizz is not null and indirizzoutilizz <> '''') or
                      (atecoutilizz is not null and atecoutilizz <> ''''))) then
        item_elmt := xmldom.createElement(doc, 'utilizzatrice');
        aziendautil_node := xmldom.appendChild(esperienzalavoro_node, xmldom.makeNode(item_elmt));

        if (cfutilizz is not null and cfutilizz <> '''') then
          item_elmt := xmldom.createElement(doc, 'codicefiscale');
          cfutilizz_node := xmldom.appendChild(aziendautil_node, xmldom.makeNode(item_elmt));
          item_text := xmldom.createTextNode(doc, cfutilizz);
          item_node := xmldom.appendChild(cfutilizz_node, xmldom.makeNode(item_text));
        end if;

        if (denominutilizz is not null and denominutilizz <> '''') then
          item_elmt := xmldom.createElement(doc, 'datorelavoro');
          denominutilizz_node := xmldom.appendChild(aziendautil_node, xmldom.makeNode(item_elmt));
          item_text := xmldom.createTextNode(doc, regexp_replace(denominutilizz, '[[:cntrl:]]', ' '));
          item_node := xmldom.appendChild(denominutilizz_node, xmldom.makeNode(item_text));
        end if;

        if (indirizzoutilizz is not null and indirizzoutilizz <> '''') then
          if (length(indirizzoutilizz) > 100) then
            indirizzoutilizz := substr(indirizzoutilizz, 1, 100);
          end if;
          item_elmt := xmldom.createElement(doc, 'indirizzoazienda');
          indirizzoutilizz_node := xmldom.appendChild(aziendautil_node, xmldom.makeNode(item_elmt));
          item_text := xmldom.createTextNode(doc, regexp_replace(indirizzoutilizz, '[[:cntrl:]]', ' '));
          item_node := xmldom.appendChild(indirizzoutilizz_node, xmldom.makeNode(item_text));
        end if;

        if (atecoutilizz is not null and atecoutilizz <> '''') then
          item_elmt := xmldom.createElement(doc, 'codateco');
          atecoutilizz_node := xmldom.appendChild(aziendautil_node, xmldom.makeNode(item_elmt));
          item_text := xmldom.createTextNode(doc, atecoutilizz);
          item_node := xmldom.appendChild(atecoutilizz_node, xmldom.makeNode(item_text));
        end if;

      end if;

      item_elmt := xmldom.createElement(doc, 'datainizio');
      datainizio_node := xmldom.appendChild(esperienzalavoro_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, datainizio);
      item_node := xmldom.appendChild(datainizio_node, xmldom.makeNode(item_text));

      if (datfinemov is not null and datfinemov <> '''') then
        item_elmt := xmldom.createElement(doc, 'datafine');
        datfinemov_node := xmldom.appendChild(esperienzalavoro_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, datfinemov);
        item_node := xmldom.appendChild(datfinemov_node, xmldom.makeNode(item_text));
      end if;

      if (datfinepf is not null and datfinepf <> '''') then
        item_elmt := xmldom.createElement(doc, 'dataFinePeriodoFormativo');
        datfinepf_node := xmldom.appendChild(esperienzalavoro_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, datfinepf);
        item_node := xmldom.appendChild(datfinepf_node, xmldom.makeNode(item_text));
      end if;

      item_elmt := xmldom.createElement(doc, 'codprofessione');
      codmansione_node := xmldom.appendChild(esperienzalavoro_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codmansione_min);
      item_node := xmldom.appendChild(codmansione_node, xmldom.makeNode(item_text));

      if (compiti is not null and compiti <> '''') then
        item_elmt := xmldom.createElement(doc, 'compiti');
        compiti_node := xmldom.appendChild(esperienzalavoro_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, compiti);
        item_node := xmldom.appendChild(compiti_node, xmldom.makeNode(item_text));
      end if;

      --tiporapporto
      item_elmt := xmldom.createElement(doc, 'tiporapporto');
      tiporapporto_node := xmldom.appendChild(esperienzalavoro_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'tipocontratto');
      tipocontratto_node := xmldom.appendChild(tiporapporto_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, tipocontratto);
      item_node := xmldom.appendChild(tipocontratto_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'assunzioneLegge68');
      assunzioneLegge68_node := xmldom.appendChild(tiporapporto_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, assunzioneLegge68);
      item_node := xmldom.appendChild(assunzioneLegge68_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'lavInMobilita');
      lavInMobilita_node := xmldom.appendChild(tiporapporto_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, lavInMobilita);
      item_node := xmldom.appendChild(lavInMobilita_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'lavoroStagionale');
      lavoroStagionale_node := xmldom.appendChild(tiporapporto_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, lavoroStagionale);
      item_node := xmldom.appendChild(lavoroStagionale_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'lavoroInAgricoltura');
      lavoroInAgricoltura_node := xmldom.appendChild(tiporapporto_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, lavoroInAgricoltura);
      item_node := xmldom.appendChild(lavoroInAgricoltura_node, xmldom.makeNode(item_text));

      --modalitalavoro
      item_elmt := xmldom.createElement(doc, 'modalitalavoro');
      modalitalavoro_node := xmldom.appendChild(esperienzalavoro_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'codmodalitalavoro');
      codorario_node := xmldom.appendChild(modalitalavoro_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codTipoOrario);
      item_node := xmldom.appendChild(codorario_node, xmldom.makeNode(item_text));

      --luogolavoro
      item_elmt := xmldom.createElement(doc, 'luogolavoro');
      luogolavoro_node := xmldom.appendChild(esperienzalavoro_node, xmldom.makeNode(item_elmt));

      if (length(indirizzolavoro) > 100) then
        indirizzolavoro := substr(indirizzolavoro, 1, 100);
      end if;
      item_elmt := xmldom.createElement(doc, 'indirizzo');
      indirizzolavoro_node := xmldom.appendChild(luogolavoro_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(indirizzolavoro, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(indirizzolavoro_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'codcomune');
      comunelavoro_node := xmldom.appendChild(luogolavoro_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, comunelavoro);
      item_node := xmldom.appendChild(comunelavoro_node, xmldom.makeNode(item_text));

      contatore := contatore + 1;

    end if;

  END LOOP;

  return '00';

EXCEPTION
  WHEN OTHERS THEN
    return '14';

END getEspLavorativeSAP;


FUNCTION getLivelliIstruzioneSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type IS
  main_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;

  item_text xmldom.DOMText;
  item_node xmldom.DOMNode;

  CURSOR cursorLivIstruzione is
    SELECT RPT_SCHEDAANAGMIN_TITSTUDIO.LEVSCOL
    FROM VW_RPT_SCHEDAANAGMIN_TITSTUDIO RPT_SCHEDAANAGMIN_TITSTUDIO
    INNER JOIN DE_TITOLO ON (DE_TITOLO.CODTITOLO = RPT_SCHEDAANAGMIN_TITSTUDIO.CODTITOLO)
    WHERE  RPT_SCHEDAANAGMIN_TITSTUDIO.CDNLAVORATORE = cdnLavVar and RPT_SCHEDAANAGMIN_TITSTUDIO.CODTITOLO <> 'NT';

  rec_LivIstruzione cursorLivIstruzione%ROWTYPE;
  livelloScolasticoVar VW_RPT_SCHEDAANAGMIN_TITSTUDIO.LEVSCOL%type;
  livelloScolastico_node xmldom.DOMNode;

  contatore number;

BEGIN
  contatore := 1;

  FOR rec_LivIstruzione IN cursorLivIstruzione LOOP
    livelloScolasticoVar := rec_LivIstruzione.LEVSCOL;

    if (contatore = 1) then
      if (xmldom.isNull(doc) = FALSE) then
        root_elmt := xmldom.createElement(doc, 'livelliistruzione_lst');
        main_node := xmldom.appendChild(root_node, xmldom.makeNode(root_elmt));
      else
        doc := xmldom.newDOMDocument;
        main_node := xmldom.makeNode(doc);
        root_elmt := xmldom.createElement(doc, 'livelliistruzione_lst');
        root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
        main_node := root_node;
      end if;
    end if;

    item_elmt := xmldom.createElement(doc, 'codlivelloistruzione');
    livelloScolastico_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, livelloScolasticoVar);
    item_node := xmldom.appendChild(livelloScolastico_node, xmldom.makeNode(item_text));

    contatore := contatore + 1;

  END LOOP;

  return '00';

EXCEPTION
  WHEN OTHERS THEN
    return '19';

END getLivelliIstruzioneSAP;

FUNCTION getAllegatoSAP (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type IS

  main_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;

  item_text xmldom.DOMText;
  item_node xmldom.DOMNode;

  CURSOR cursorTitStudi is
    SELECT RPT_SCHEDAANAGMIN_TITSTUDIO.CODTIT1,RPT_SCHEDAANAGMIN_TITSTUDIO.DESC1,
         RPT_SCHEDAANAGMIN_TITSTUDIO.STRSPECIFICA,RPT_SCHEDAANAGMIN_TITSTUDIO.CODCOM,
         RPT_SCHEDAANAGMIN_TITSTUDIO.STRDENOMINAZIONE,
         RPT_SCHEDAANAGMIN_TITSTUDIO.NUMANNO,RPT_SCHEDAANAGMIN_TITSTUDIO.STRVOTO,
         RPT_SCHEDAANAGMIN_TITSTUDIO.STRESIMI,RPT_SCHEDAANAGMIN_TITSTUDIO.FLGLODE,
         RPT_SCHEDAANAGMIN_TITSTUDIO.LEVSCOL,
         RPT_SCHEDAANAGMIN_TITSTUDIO.LEVSCOLDESC,
         RPT_SCHEDAANAGMIN_TITSTUDIO.NUMANNIFREQ, RPT_SCHEDAANAGMIN_TITSTUDIO.NUMANNIPREV, RPT_SCHEDAANAGMIN_TITSTUDIO.CODMONOSTATO,
         RPT_SCHEDAANAGMIN_TITSTUDIO.CODMONOSTATOTIT
    FROM VW_RPT_SCHEDAANAGMIN_TITSTUDIO RPT_SCHEDAANAGMIN_TITSTUDIO
    INNER JOIN DE_TITOLO ON (DE_TITOLO.CODTITOLO = RPT_SCHEDAANAGMIN_TITSTUDIO.CODTITOLO)
    WHERE RPT_SCHEDAANAGMIN_TITSTUDIO.CDNLAVORATORE = cdnLavVar and RPT_SCHEDAANAGMIN_TITSTUDIO.CODTITOLO <> 'NT';

  rec_TitStudio cursorTitStudi%ROWTYPE;
  livelloScolasticoVar VW_RPT_SCHEDAANAGMIN_TITSTUDIO.LEVSCOL%type;
  livelloScolastico_node xmldom.DOMNode;
  titolostudio_node xmldom.DOMNode;
  titolistudio_lst_node xmldom.DOMNode;
  linguestraniere_lst_node xmldom.DOMNode;
  conoscenzeinf_lst_node xmldom.DOMNode;
  altreinfo_lst_node xmldom.DOMNode;
  altreinformazioni_node xmldom.DOMNode;
  linguastraniera_node xmldom.DOMNode;
  informatica_node xmldom.DOMNode;
  codlingua_node xmldom.DOMNode;
  cdngradoletto_node xmldom.DOMNode;
  cdngradoparlato_node xmldom.DOMNode;
  cdngradoscritto_node xmldom.DOMNode;
  codconoscenza_node xmldom.DOMNode;
  cdngrado_node xmldom.DOMNode;
  strdescinfo_node xmldom.DOMNode;
  strvotazione PR_STUDIO.STRVOTO%TYPE;
  strvotoFinale varchar2(3);
  strvotoFinaleOK varchar2(3);
  votazione_node xmldom.DOMNode;

  CURSOR cursorLingueStran is
    SELECT li.CODLINGUA,
             SUBSTR((select COD_CONOSCENZA from Ma_GRADO_CONSC_LIN where LI.CDNGRADOLETTO = CDNGRADO),0,2) cdngradoletto,
             substr((select COD_CONOSCENZA from Ma_GRADO_CONSC_LIN where LI.CDNGRADOSCRITTO = CDNGRADO),0,2) cdngradoparlato,
             SUBSTR((select COD_CONOSCENZA from Ma_GRADO_CONSC_LIN where LI.CDNGRADOPARLATO = CDNGRADO),0,2) cdngradoscritto
    FROM PR_LINGUA li
    WHERE li.CDNLAVORATORE = cdnLavVar;

  rec_Lingue cursorLingueStran%ROWTYPE;
  codlingua PR_LINGUA.CODLINGUA%type;
  cdngradoletto varchar2(50);
  cdngradoparlato varchar2(50);
  cdngradoscritto varchar2(50);

  CURSOR cursorInformatica is
    select ma_consc_inf.cod_conoscenza, ma_grado_consc_inf.cod_gradoconosc, pr_info.strdescinfo
    from pr_info
    inner join ma_grado_consc_inf on (pr_info.cdngrado = ma_grado_consc_inf.cdngrado)
    inner join ma_consc_inf on (pr_info.coddettinfo = ma_consc_inf.coddettinfo)
    where pr_info.cdnlavoratore = cdnLavVar;

  rec_Informatica cursorInformatica%ROWTYPE;
  codconoscenza ma_consc_inf.cod_conoscenza%type;
  cdngrado ma_grado_consc_inf.cod_gradoconosc%type;
  strdescinfo pr_info.strdescinfo%type;

  CURSOR cursorAbilitazioni is
    SELECT distinct MN_ABILITAZIONE.COD_ABILITAZIONE
    FROM PR_ABILITAZIONE, DE_ABILITAZIONE_GEN,
      DE_TIPO_ABILITAZIONE_GEN, MA_ABILITAZIONE, MN_ABILITAZIONE
    WHERE PR_ABILITAZIONE.CODABILITAZIONEGEN=DE_ABILITAZIONE_GEN.CODABILITAZIONEGEN and
      DE_ABILITAZIONE_GEN.CODTIPOABILITAZIONEGEN=DE_TIPO_ABILITAZIONE_GEN.CODTIPOABILITAZIONEGEN and
      DE_ABILITAZIONE_GEN.CODABILITAZIONEGEN=MA_ABILITAZIONE.CODABILITAZIONEGEN and
      MA_ABILITAZIONE.CODABILITAZIONE=MN_ABILITAZIONE.COD_ABILITAZIONE(+) and
      PR_ABILITAZIONE.CDNLAVORATORE = cdnLavVar and
      DE_ABILITAZIONE_GEN.CODTIPOABILITAZIONEGEN = 'AL';

  CURSOR cursorPatentiniGuida is
    SELECT distinct MN_ABILITAZIONE.COD_ABILITAZIONE
    FROM MA_ABILITAZIONE, MN_ABILITAZIONE,
         PR_ABILITAZIONE, DE_ABILITAZIONE_GEN
    WHERE MA_ABILITAZIONE.CODABILITAZIONE=MN_ABILITAZIONE.COD_ABILITAZIONE and
         PR_ABILITAZIONE.CODABILITAZIONEGEN=MA_ABILITAZIONE.CODABILITAZIONEGEN and
         PR_ABILITAZIONE.CODABILITAZIONEGEN=DE_ABILITAZIONE_GEN.CODABILITAZIONEGEN(+) and
         PR_ABILITAZIONE.CDNLAVORATORE = cdnLavVar and
         DE_ABILITAZIONE_GEN.CODTIPOABILITAZIONEGEN = 'PG';

  CURSOR cursorPatentini is
    SELECT distinct MN_ABILITAZIONE.COD_ABILITAZIONE
    FROM MA_ABILITAZIONE, MN_ABILITAZIONE,
         PR_ABILITAZIONE, DE_ABILITAZIONE_GEN
    WHERE MA_ABILITAZIONE.CODABILITAZIONE=MN_ABILITAZIONE.COD_ABILITAZIONE and
         PR_ABILITAZIONE.CODABILITAZIONEGEN=MA_ABILITAZIONE.CODABILITAZIONEGEN and
         PR_ABILITAZIONE.CODABILITAZIONEGEN=DE_ABILITAZIONE_GEN.CODABILITAZIONEGEN(+) and
         PR_ABILITAZIONE.CDNLAVORATORE = cdnLavVar and
         DE_ABILITAZIONE_GEN.CODTIPOABILITAZIONEGEN = 'PT';

  rec_Abilitazioni cursorAbilitazioni%ROWTYPE;
  rec_PatentiniGuida cursorPatentiniGuida%ROWTYPE;
  rec_Patentini cursorPatentini%ROWTYPE;

  codalbo MA_ABILITAZIONE.CODABILITAZIONE%type;
  codpatenteguida MA_ABILITAZIONE.CODABILITAZIONE%type;
  codpatentino MA_ABILITAZIONE.CODABILITAZIONE%type;

  codalbo_node xmldom.DOMNode;
  codpatenteguida_node xmldom.DOMNode;
  codpatentino_node xmldom.DOMNode;
  codcl MN_ATTESTAZIONE.COD_TIPOATTESTAZ%type;
  codtipocertificato_node xmldom.DOMNode;

  CURSOR cursorFormazione is
    SELECT PR_CORSO.CDNLAVORATORE, PR_CORSO.STRENTE,
     (case when PR_CORSO.STRDESCRIZIONE is null then DE_CORSO.STRDESCRIZIONE
      else PR_CORSO.STRDESCRIZIONE
     end) STRDESCRIZIONE,
       PR_CORSO.NUMMESI,PR_CORSO.NUMORE,
       (case when NVL(PR_CORSO.FLGSTAGE, 'N') = 'S' then 'SI' else 'NO' end) FLGSTAGE,
       PR_CORSO.STRAZIENDA,PR_CORSO.STRLOCALITAAZIENDA,PR_CORSO.STRINDIRIZZOAZIENDA,
       DE_PROVINCIA_2.STRTARGA,
       DE_COMUNE_2.STRCAP,DE_REGIONE.CODMIN CODREGIONE,
       MN_ATTESTAZIONE.COD_TIPOATTESTAZ
    FROM PR_CORSO, DE_CORSO, DE_AMB_DISCIP,
         DE_TIPO_CORSO, DE_COMUNE DE_COMUNE,
         DE_PROVINCIA DE_PROVINCIA,
         DE_PROVINCIA DE_PROVINCIA_2,
         DE_COMUNE DE_COMUNE_2,
         DE_REGIONE, MN_ATTESTAZIONE
    WHERE PR_CORSO.CODCORSO=DE_CORSO.CODCORSO(+) and
         PR_CORSO.CODCOMENTE=DE_COMUNE.CODCOM(+) and
         DE_COMUNE.CODPROVINCIA=DE_PROVINCIA.CODPROVINCIA(+) and
         PR_CORSO.CODTIPOCERTIFICATO=DE_TIPO_CORSO.CODTIPOCERTIFICATO(+) and
         PR_CORSO.CDNAMBITODISCIPLINARE=DE_AMB_DISCIP.CDNAMBITODISCIPLINARE(+) and
         PR_CORSO.CODCOMAZIENDA=DE_COMUNE_2.CODCOM(+) and
         DE_COMUNE_2.CODPROVINCIA=DE_PROVINCIA_2.CODPROVINCIA(+) and DE_PROVINCIA.CODREGIONE=DE_REGIONE.CODREGIONE(+) and
         DE_TIPO_CORSO.CODCL=MN_ATTESTAZIONE.COD_TIPOATTESTAZ(+) and
         PR_CORSO.CDNLAVORATORE = cdnLavVar and
         (not ( ((SUBSTR(NVL(DE_COMUNE.CODCOM, 'A'), 0,1)) = 'Z') ));

  rec_Formazione cursorFormazione%ROWTYPE;
  formazione_lst_node xmldom.DOMNode;
  formazione_node xmldom.DOMNode;

  ente PR_CORSO.STRENTE%type;
  strdescrizione pr_corso.STRDESCRIZIONE%type;
  ente_node xmldom.DOMNode;
  strdescrizione_node xmldom.DOMNode;
  codregione DE_REGIONE.CODREGIONE%type;
  codregione_node xmldom.DOMNode;
  duratamesi PR_CORSO.NUMMESI%type;
  durataore PR_CORSO.NUMORE%type;
  durata PR_CORSO.NUMMESI%type;
  flgstage varchar2(2);
  straziendastage PR_CORSO.strazienda%type;
  flgstage_node xmldom.DOMNode;
  durata_node xmldom.DOMNode;
  codtipologiadurata_node xmldom.DOMNode;
  straziendastage_node xmldom.DOMNode;
  codtipologiadurata mn_yg_tipologia_durata.codtipologiadurata%type;

  codtit1 DE_TITOLO.CODTITOLO%type;
  strdescrizioneTit DE_TITOLO.STRDESCRIZIONE%type;
  strdescrTitolo_node xmldom.DOMNode;
  corsostudio_node xmldom.DOMNode;
  codcomtitolo DE_COMUNE.CODCOM%type;
  codcomtitolo_node xmldom.DOMNode;
  numannoconseg PR_STUDIO.NUMANNO%type;
  numannoconseg_node xmldom.DOMNode;
  numannifreq PR_STUDIO.NUMANNIFREQ%type;
  numannifreq_node xmldom.DOMNode;
  codmonostato PR_STUDIO.CODMONOSTATO%type;
  codmonostatotit PR_STUDIO.CODMONOSTATOTIT%type;
  riconosciuto_node xmldom.DOMNode;
  riconosciuto varchar2(2);
  nvoto number(38,0);
  valPosIVoto number(38,0);
  contatoreVoto number;
  contatore number;

BEGIN
  --allegato
  if (xmldom.isNull(doc) = FALSE) then
    root_elmt := xmldom.createElement(doc, 'allegato');
    main_node := xmldom.appendChild(root_node, xmldom.makeNode(root_elmt));
  else
    doc := xmldom.newDOMDocument;
    main_node := xmldom.makeNode(doc);
    root_elmt := xmldom.createElement(doc, 'allegato');
    root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
    main_node := root_node;
  end if;

  contatore := 1;

  FOR rec_TitStudio IN cursorTitStudi LOOP
    livelloScolasticoVar := rec_TitStudio.LEVSCOL;
    codtit1 := rec_TitStudio.codtit1;
    strdescrizioneTit := '';
    strvotoFinale := '';
    strvotoFinaleOK := '';
    if (codtit1 is not null and codtit1 <> '''') then
      strdescrizioneTit := rec_TitStudio.DESC1;
    end if;
    codcomtitolo := rec_TitStudio.CODCOM;
    numannoconseg := rec_TitStudio.NUMANNO;
    numannifreq := rec_TitStudio.NUMANNIFREQ;
    codmonostato := rec_TitStudio.CODMONOSTATO;
    codmonostatotit := rec_TitStudio.CODMONOSTATOTIT;
    strvotazione := rec_TitStudio.STRVOTO;
    if (strvotazione is not null and strvotazione <> '''') then
      if (length(strvotazione) > 3) then
        strvotoFinale := substr(strvotazione, 1, 3);
      else
        strvotoFinale := strvotazione;
      end if;
      begin
        contatoreVoto := 1;
        while (contatoreVoto <= length(strvotoFinale)) loop
          valPosIVoto := to_number(substr(strvotoFinale, contatoreVoto, 1));
          strvotoFinaleOK := strvotoFinaleOK || to_char(valPosIVoto);
          contatoreVoto := contatoreVoto + 1;
        end loop;
      exception
        when others then
          if (length(strvotoFinaleOK) < 2) then
            strvotoFinaleOK := '';
          end if;
      end;
    end if;

    if (contatore = 1) then
      item_elmt := xmldom.createElement(doc, 'titolistudio_lst');
      titolistudio_lst_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    end if;

    item_elmt := xmldom.createElement(doc, 'titolostudio');
    titolostudio_node := xmldom.appendChild(titolistudio_lst_node, xmldom.makeNode(item_elmt));

    item_elmt := xmldom.createElement(doc, 'codlivelloistruzione');
    livelloScolastico_node := xmldom.appendChild(titolostudio_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, livelloScolasticoVar);
    item_node := xmldom.appendChild(livelloScolastico_node, xmldom.makeNode(item_text));

    if (codtit1 is not null and codtit1 <> '''') then
      item_elmt := xmldom.createElement(doc, 'corsostudio');
      corsostudio_node := xmldom.appendChild(titolostudio_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(codtit1, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(corsostudio_node, xmldom.makeNode(item_text));
    end if;

    if (strdescrizioneTit is not null and strdescrizioneTit <> '''') then
      item_elmt := xmldom.createElement(doc, 'descrizionecorsostudio');
      strdescrTitolo_node := xmldom.appendChild(titolostudio_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(strdescrizioneTit, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(strdescrTitolo_node, xmldom.makeNode(item_text));

    end if;

    if (codcomtitolo is not null and codcomtitolo <> '''' and codcomtitolo <> 'NT') then
      item_elmt := xmldom.createElement(doc, 'codcomunefrequenza');
      codcomtitolo_node := xmldom.appendChild(titolostudio_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codcomtitolo);
      item_node := xmldom.appendChild(codcomtitolo_node, xmldom.makeNode(item_text));
    end if;

    riconosciuto := '';
    if (livelloScolasticoVar <> '00') then
      if (codmonostatotit is null or codmonostatotit = 'T') then
        riconosciuto := 'SI';
      else
        riconosciuto := 'NO';
      end if;
    end if;
    if (riconosciuto <> '''') then
      item_elmt := xmldom.createElement(doc, 'riconosciutoin');
      riconosciuto_node := xmldom.appendChild(titolostudio_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, riconosciuto);
      item_node := xmldom.appendChild(riconosciuto_node, xmldom.makeNode(item_text));
    end if;

    if (strvotoFinaleOK <> '''') then
      item_elmt := xmldom.createElement(doc, 'votazione');
      votazione_node := xmldom.appendChild(titolostudio_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, strvotoFinaleOK);
      item_node := xmldom.appendChild(votazione_node, xmldom.makeNode(item_text));
    end if;

    if (numannoconseg is not null ) then
      item_elmt := xmldom.createElement(doc, 'annotermine');
      numannoconseg_node := xmldom.appendChild(titolostudio_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, numannoconseg);
      item_node := xmldom.appendChild(numannoconseg_node, xmldom.makeNode(item_text));
    end if;

    if (codmonostato is not null) then
      if (codmonostato = 'I') then
        if (numannifreq is not null) then
          item_elmt := xmldom.createElement(doc, 'annofrequenza');
          numannifreq_node := xmldom.appendChild(titolostudio_node, xmldom.makeNode(item_elmt));
          item_text := xmldom.createTextNode(doc, numannifreq);
          item_node := xmldom.appendChild(numannifreq_node, xmldom.makeNode(item_text));
        end if;
      else
        if (codmonostato = 'A') then
          if (numannifreq is not null) then
            item_elmt := xmldom.createElement(doc, 'annofrequentato');
            numannifreq_node := xmldom.appendChild(titolostudio_node, xmldom.makeNode(item_elmt));
            item_text := xmldom.createTextNode(doc, numannifreq);
            item_node := xmldom.appendChild(numannifreq_node, xmldom.makeNode(item_text));
          end if;
        end if;
      end if;
    end if;

    contatore := contatore + 1;

  END LOOP;

  contatore := 1;

  FOR rec_Formazione IN cursorFormazione LOOP
    durata := null;
    codtipologiadurata := null;
    ente := rec_Formazione.STRENTE;
    strdescrizione := rec_Formazione.strdescrizione;
    if (strdescrizione is not null and length(strdescrizione) > 100) then
      strdescrizione := substr(strdescrizione, 1, 100);
    end if;
    codregione := rec_Formazione.codregione;
    duratamesi := rec_Formazione.NUMMESI;
    durataore := rec_Formazione.NUMORE;
    codcl := rec_Formazione.COD_TIPOATTESTAZ;

    if (duratamesi is not null) then
      codtipologiadurata := 'M';
      durata := duratamesi;
    else
      if (durataore is not null) then
        codtipologiadurata := 'O';
        durata := durataore;
      end if;
    end if;

    flgstage := rec_Formazione.flgstage;
    straziendastage := rec_Formazione.strazienda;

    if (strdescrizione is not null and strdescrizione <> '''') then

      if (contatore = 1) then
        item_elmt := xmldom.createElement(doc, 'formazioneprofessionale_lst');
        formazione_lst_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
      end if;

      item_elmt := xmldom.createElement(doc, 'formazioneprofessionale');
      formazione_node := xmldom.appendChild(formazione_lst_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'titolocorso');
      strdescrizione_node := xmldom.appendChild(formazione_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(strdescrizione, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(strdescrizione_node, xmldom.makeNode(item_text));

      if (ente is not null and ente <> '''') then
        item_elmt := xmldom.createElement(doc, 'ente');
        ente_node := xmldom.appendChild(formazione_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, ente);
        item_node := xmldom.appendChild(ente_node, xmldom.makeNode(item_text));
      end if;

      if (codregione is not null and codregione <> '''') then
        item_elmt := xmldom.createElement(doc, 'codregione');
        codregione_node := xmldom.appendChild(formazione_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, codregione);
        item_node := xmldom.appendChild(codregione_node, xmldom.makeNode(item_text));
      end if;

      if (durata is not null) then
        item_elmt := xmldom.createElement(doc, 'durata');
        durata_node := xmldom.appendChild(formazione_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, durata);
        item_node := xmldom.appendChild(durata_node, xmldom.makeNode(item_text));

        item_elmt := xmldom.createElement(doc, 'codtipologiadurata');
        codtipologiadurata_node := xmldom.appendChild(formazione_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, codtipologiadurata);
        item_node := xmldom.appendChild(codtipologiadurata_node, xmldom.makeNode(item_text));

      end if;

      --certificazioniattestati
      if (codcl is not null and codcl <> '''') then
        item_elmt := xmldom.createElement(doc, 'certificazioniattestati');
        codtipocertificato_node := xmldom.appendChild(formazione_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, regexp_replace(codcl, '[[:cntrl:]]', ' '));
        item_node := xmldom.appendChild(codtipocertificato_node, xmldom.makeNode(item_text));
      end if;

      if (flgstage is not null and flgstage <> '''') then
        item_elmt := xmldom.createElement(doc, 'stage');
        flgstage_node := xmldom.appendChild(formazione_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, flgstage);
        item_node := xmldom.appendChild(flgstage_node, xmldom.makeNode(item_text));
      end if;

      if (straziendastage is not null and straziendastage <> '''') then
        item_elmt := xmldom.createElement(doc, 'denominazioneaziendastage');
        straziendastage_node := xmldom.appendChild(formazione_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, regexp_replace(straziendastage, '[[:cntrl:]]', ' '));
        item_node := xmldom.appendChild(straziendastage_node, xmldom.makeNode(item_text));
      end if;

      contatore := contatore + 1;

    end if;

  END LOOP;

  contatore := 1;

  FOR rec_Lingue IN cursorLingueStran LOOP
    cdngradoletto := rec_Lingue.cdngradoletto;
    cdngradoparlato := rec_Lingue.cdngradoparlato;
    cdngradoscritto := rec_Lingue.cdngradoscritto;
    codlingua := rec_Lingue.codlingua;

  if (cdngradoletto is not null and cdngradoletto <> '''' and
    cdngradoscritto is not null and cdngradoscritto <> '''' and
    cdngradoparlato is not null and cdngradoparlato <> '''') then

    if (contatore = 1) then
      item_elmt := xmldom.createElement(doc, 'linguestraniere_lst');
      linguestraniere_lst_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    end if;

    item_elmt := xmldom.createElement(doc, 'linguastraniera');
    linguastraniera_node := xmldom.appendChild(linguestraniere_lst_node, xmldom.makeNode(item_elmt));

    item_elmt := xmldom.createElement(doc, 'codlingua');
    codlingua_node := xmldom.appendChild(linguastraniera_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, codlingua);
    item_node := xmldom.appendChild(codlingua_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'codlivelloletto');
    cdngradoletto_node := xmldom.appendChild(linguastraniera_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, cdngradoletto);
    item_node := xmldom.appendChild(cdngradoletto_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'codlivelloscritto');
    cdngradoscritto_node := xmldom.appendChild(linguastraniera_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, cdngradoscritto);
    item_node := xmldom.appendChild(cdngradoscritto_node, xmldom.makeNode(item_text));

    item_elmt := xmldom.createElement(doc, 'codlivelloparlato');
    cdngradoparlato_node := xmldom.appendChild(linguastraniera_node, xmldom.makeNode(item_elmt));
    item_text := xmldom.createTextNode(doc, cdngradoparlato);
    item_node := xmldom.appendChild(cdngradoparlato_node, xmldom.makeNode(item_text));

    contatore := contatore + 1;

  end if;

  END LOOP;

  contatore := 1;

  FOR rec_Informatica IN cursorInformatica LOOP
    codconoscenza := rec_Informatica.cod_conoscenza;
    cdngrado := rec_Informatica.cod_gradoconosc;
    strdescinfo := rec_Informatica.strdescinfo;

    if (codconoscenza is not null and codconoscenza <> '''') then

    if (contatore = 1) then
    item_elmt := xmldom.createElement(doc, 'conoscenzeinformatiche_lst');
    conoscenzeinf_lst_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
    end if;

    item_elmt := xmldom.createElement(doc, 'conoscenzainformatica');
    informatica_node := xmldom.appendChild(conoscenzeinf_lst_node, xmldom.makeNode(item_elmt));

      item_elmt := xmldom.createElement(doc, 'codconoscenzainformatica');
      codconoscenza_node := xmldom.appendChild(informatica_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codconoscenza);
      item_node := xmldom.appendChild(codconoscenza_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'codgrado');
      cdngrado_node := xmldom.appendChild(informatica_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, cdngrado);
      item_node := xmldom.appendChild(cdngrado_node, xmldom.makeNode(item_text));

      if (strdescinfo is not null and strdescinfo <> '''') then
        item_elmt := xmldom.createElement(doc, 'specificheinformatica');
        strdescinfo_node := xmldom.appendChild(informatica_node, xmldom.makeNode(item_elmt));
        item_text := xmldom.createTextNode(doc, regexp_replace(strdescinfo, '[[:cntrl:]]', ' '));
        item_node := xmldom.appendChild(strdescinfo_node, xmldom.makeNode(item_text));
      end if;

    contatore := contatore + 1;

  end if;

  END LOOP;

  contatore := 1;

  FOR rec_Abilitazioni IN cursorAbilitazioni LOOP
    codalbo := rec_Abilitazioni.COD_ABILITAZIONE;
	
	if (codalbo is not null and codalbo <> '''') then

		if (contatore = 1) then
		  item_elmt := xmldom.createElement(doc, 'altreinformazioni_lst');
		  altreinfo_lst_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
		end if;

		item_elmt := xmldom.createElement(doc, 'altreinformazioni');
		altreinformazioni_node := xmldom.appendChild(altreinfo_lst_node, xmldom.makeNode(item_elmt));

		item_elmt := xmldom.createElement(doc, 'codalbo');
		codalbo_node := xmldom.appendChild(altreinformazioni_node, xmldom.makeNode(item_elmt));
		item_text := xmldom.createTextNode(doc, codalbo);
		item_node := xmldom.appendChild(codalbo_node, xmldom.makeNode(item_text));

		contatore := contatore + 1;
		
	end if;

  END LOOP;

  FOR rec_PatentiniGuida IN cursorPatentiniGuida LOOP
    codpatenteguida := rec_PatentiniGuida.COD_ABILITAZIONE;
	
	if (codpatenteguida is not null and codpatenteguida <> '''') then

		if (contatore = 1) then
		  item_elmt := xmldom.createElement(doc, 'altreinformazioni_lst');
		  altreinfo_lst_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
		end if;

		item_elmt := xmldom.createElement(doc, 'altreinformazioni');
		altreinformazioni_node := xmldom.appendChild(altreinfo_lst_node, xmldom.makeNode(item_elmt));

		item_elmt := xmldom.createElement(doc, 'codpatenteguida');
		codpatenteguida_node := xmldom.appendChild(altreinformazioni_node, xmldom.makeNode(item_elmt));
		item_text := xmldom.createTextNode(doc, codpatenteguida);
		item_node := xmldom.appendChild(codpatenteguida_node, xmldom.makeNode(item_text));

		contatore := contatore + 1;
		
	end if;

  END LOOP;

  FOR rec_Patentini IN cursorPatentini LOOP
    codpatentino := rec_Patentini.COD_ABILITAZIONE;
	
	if (codpatentino is not null and codpatentino <> '''') then

		if (contatore = 1) then
		  item_elmt := xmldom.createElement(doc, 'altreinformazioni_lst');
		  altreinfo_lst_node := xmldom.appendChild(main_node, xmldom.makeNode(item_elmt));
		end if;

		item_elmt := xmldom.createElement(doc, 'altreinformazioni');
		altreinformazioni_node := xmldom.appendChild(altreinfo_lst_node, xmldom.makeNode(item_elmt));

		item_elmt := xmldom.createElement(doc, 'codpatentino');
		codpatentino_node := xmldom.appendChild(altreinformazioni_node, xmldom.makeNode(item_elmt));
		item_text := xmldom.createTextNode(doc, codpatentino);
		item_node := xmldom.appendChild(codpatentino_node, xmldom.makeNode(item_text));

		contatore := contatore + 1;
		
	end if;

  END LOOP;

  return '00';

EXCEPTION
  WHEN OTHERS THEN
    return '18';

END getAllegatoSAP;


FUNCTION getPoliticheAttive (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type IS

  controlSap2 number;
  root_node_var xmldom.DOMNode;
    
BEGIN
	
  root_node_var := root_node;
  
--  select 
--    extract( day from diff ) Days
--	into controlSap2
--	from (
--       select (CAST(sysdate as timestamp) - CAST(datsap2 as timestamp)) diff   
--        from ts_generale
 --    );
  
  --if(controlSap2 >=0) then
  		return getPoliticheAttiveSap2(doc, root_node_var, cdnLavVar);
  --else
  	--	return getPoliticheAttiveSap1(doc, root_node_var, cdnLavVar);
  --end if;	

END getPoliticheAttive;
 

FUNCTION getPoliticheAttiveSap2 (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type IS

  main_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;

  item_text xmldom.DOMText;
  item_node xmldom.DOMNode;
  politiche_attive_lst_node xmldom.DOMNode;
  politiche_attive_node xmldom.DOMNode;
   
  CURSOR cursorPoliticheAtt is
     SELECT MA_AZIONE_TIPOATTIVITA.CODTIPOATTIVITA, MN_YG_TIPO_ATTIVITA.STRDESCRIZIONE, CONC.PRGPERCORSO,
      TO_CHAR(CONC.DATSTIMATA, 'YYYY-MM-DD') DATSTIMATA,
	  TO_CHAR(CONC.DATAVVIOAZIONE, 'YYYY-MM-DD') DATAVVIOAZIONE,
      TO_CHAR(COLL.DATCOLLOQUIO, 'YYYY-MM-DD') DATCOLLOQUIO,
	  TO_CHAR(COLL.DATCOLLOQUIO, 'YYYYMMDD') DATPROPOSTA,
      TO_CHAR(CONC.DATEFFETTIVA, 'YYYY-MM-DD') DATEFFETTIVA,
	  COLL.DATCOLLOQUIO DTCOLLOQUIO,
	  CONC.DATSTIMATA DTDATSTIMATA, CONC.DATAVVIOAZIONE DTDATAVVIOAZIONE,
      CONC.STRCFDATORELAVORO as STRCFDATORELAVORO,	    
      DE_CPI.CODCPIMIN, NVL(DE_AZIONE_RAGG.FLG_MISURAYEI, 'N') FLG_MISURAYEI,DE_ESITO.Codeventomin,
	  CONC.CODESITO, CONC.codesitorendicont, NVL(CONC.FLGPOLITICAFSE, 'N') FLGPOLITICAFSE, DE_AZIONE.CODPROGETTO,
	  DE_AZIONE.STRDESCRIZIONE DESCRIZIONEAZIONE, DE_AZIONE_RAGG.STRDESCRIZIONE DESCRIZIONEAZIONERAGG,
	  Am_Patto_Lavoratore.PRGPATTOLAVORATORE, Am_Patto_Lavoratore.Numindicesvantaggio2, Am_Patto_Lavoratore.Numindicesvantaggio150,
	  CONC.Numygdurataeff, CONC.Codtipologiadurata, 
	 NVL(DE_AZIONE.FLGPATTORDC, 'N') FLGPATTORDC, CONC.PRGRDC, AM_RDC.STRPROTOCOLLOINPS,
	 TO_CHAR(AM_RDC.DATDOMANDA, 'YYYY-MM-DD') DATDOMANDA, AM_RDC.DATDOMANDA DTDATDOMANDA,
	 TO_CHAR(AM_RDC.DATRENDICONTAZIONE, 'YYYY-MM-DD') DATRENDICONTAZIONE, AM_RDC.CODMONORUOLO
    FROM OR_COLLOQUIO COLL
      INNER JOIN OR_PERCORSO_CONCORDATO CONC
            ON (CONC.PRGCOLLOQUIO = COLL.PRGCOLLOQUIO)
      INNER JOIN MA_AZIONE_TIPOATTIVITA
      ON (CONC.PRGAZIONI = MA_AZIONE_TIPOATTIVITA.PRGAZIONI)
	    INNER JOIN DE_AZIONE
      ON (CONC.PRGAZIONI = DE_AZIONE.PRGAZIONI)
      INNER JOIN DE_AZIONE_RAGG
      ON (DE_AZIONE.PRGAZIONERAGG = DE_AZIONE_RAGG.PRGAZIONIRAGG)
      INNER JOIN MN_YG_TIPO_ATTIVITA 
      ON (MA_AZIONE_TIPOATTIVITA.CODTIPOATTIVITA = MN_YG_TIPO_ATTIVITA.CODTIPOATTIVITA)
      INNER JOIN DE_CPI_VALIDITA_MIN DE_CPI
            ON (COLL.CODCPI = DE_CPI.CODCPISIL)
	   INNER JOIN DE_ESITO
        ON (DE_ESITO.CODESITO = CONC.CODESITO AND DE_ESITO.Codeventomin IS NOT NULL )
	  LEFT JOIN AM_LAV_PATTO_SCELTA
	  		ON (TO_NUMBER(STRCHIAVETABELLA) = CONC.PRGPERCORSO AND UPPER(CODLSTTAB) = 'OR_PER')
	  LEFT JOIN AM_PATTO_LAVORATORE
	  		ON (AM_LAV_PATTO_SCELTA.PRGPATTOLAVORATORE = AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE)
		  LEFT JOIN AM_RDC	ON (AM_RDC.PRGRDC = CONC.PRGRDC)
    WHERE (COLL.CDNLAVORATORE = cdnLavVar) and 
	(trunc(COLL.DATCOLLOQUIO) between trunc(MA_AZIONE_TIPOATTIVITA.DATINIZIOVAL) and trunc(MA_AZIONE_TIPOATTIVITA.DATFINEVAL)) and
	(trunc(COLL.DATCOLLOQUIO) between trunc(DE_CPI.DATINIZIOVAL) and trunc(DE_CPI.DATFINEVAL)) 
	ORDER BY COLL.DATCOLLOQUIO desc, MA_AZIONE_TIPOATTIVITA.CODTIPOATTIVITA asc;

  
	CURSOR codiciProvinciali IS
		select codprovincia 
		from de_provincia , de_regione, Ts_Generale 
		where de_provincia.codregione = de_regione.codregione 
		and codRegioneSil = de_regione.codregione;
		
  rec_Politica cursorPoliticheAtt%ROWTYPE;
  rec_Provincie codiciProvinciali%ROWTYPE;
 
  codAttivita MA_AZIONE_TIPOATTIVITA.CODTIPOATTIVITA%type;
  strdescrizione MN_YG_TIPO_ATTIVITA.STRDESCRIZIONE%type;
  dtdatstimata OR_PERCORSO_CONCORDATO.datstimata%type;
  dtdatavvioazione OR_PERCORSO_CONCORDATO.datavvioazione%type;
  codEsitoAzione OR_PERCORSO_CONCORDATO.CODESITO%type;
  codEventoMinistero DE_ESITO.Codeventomin%type;
  codEsitoRendic OR_PERCORSO_CONCORDATO.codesitorendicont%type;
  flgmisurayei DE_AZIONE_RAGG.FLG_MISURAYEI%type;
  flgpoliticafse OR_PERCORSO_CONCORDATO.FLGPOLITICAFSE%type;
  titoloprogetto MN_YG_TIPO_PROGETTI.CODPROGETTO%type;
  p_codiceprogetto DE_AZIONE.CODPROGETTO%type;
  p_descrizioneazione DE_AZIONE.STRDESCRIZIONE%type;
  p_descrizioneazioneragg DE_AZIONE_RAGG.STRDESCRIZIONE%type;
  descrizioneprogetto MN_YG_TIPO_PROGETTI.STRDESCRIZIONE%type;
  codcpimin_rec de_cpi.codcpimin%type;
  dataValiditaEntePromotore mn_st_cpi.DATINIZIOVAL%type;
  codProv de_provincia.codprovincia%type;
  numSvantaggio2  Am_Patto_Lavoratore.Numindicesvantaggio2%type;
  numSvantaggio150 Am_Patto_Lavoratore.Numindicesvantaggio150%type;
  prgPatto AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE%type;
  prgPercorso OR_PERCORSO_CONCORDATO.PRGPERCORSO%type; 
  cfEntePromPolAttive OR_PERCORSO_CONCORDATO.STRCFDATORELAVORO%type;
  indice_profiling varchar2(20);
  currentProvincia TS_GENERALE.codprovinciasil%type;
  codMinSap SP_LAVORATORE.codminsap%type;
  soggettoId DE_REGIONE.codmin%type;
  codcpimin_a02 de_cpi.codcpimin%type;
  dtcolloquio OR_COLLOQUIO.DATCOLLOQUIO%type;
  
  datstimata_node xmldom.DOMNode;
  dateffettiva_node xmldom.DOMNode;
  titolo_progetto_node xmldom.DOMNode;
  datainizio_node xmldom.DOMNode;
  indice_profiling_node xmldom.DOMNode;
  identificativo_politica_node xmldom.DOMNode;
  id_presa_in_carico_node xmldom.DOMNode;
  codcpi_node xmldom.DOMNode;
  descrizioneatt_node xmldom.DOMNode;
  datevento_node xmldom.DOMNode;
  ultimo_evento_node xmldom.DOMNode;
  tipo_ev_node xmldom.DOMNode;
  codAttivita_node xmldom.DOMNode;
  strdescrizione_node xmldom.DOMNode;
  durata_node xmldom.DOMNode;
  tip_durata_node xmldom.DOMNode;

  estraiPolAttive varchar2(2);
  estraiDataInizio varchar2(2);
  estraiDataFine varchar2(2);
  estraiUltimoEvento varchar2(2);
  assegnaIdPresaInCarico varchar2(2);
  
  contatore number;
  controlloUltimoEvento number;
  contatoreProvincia number;
  lengthStr number;
  numggDFINSAP number;
  
  datstimata varchar2(10);
  datcolloquio varchar2(10);
  datavvioazione varchar2(10);
  dateffettiva varchar2(10);
  dateffettivaIniziale varchar2(10);
  datInizio varchar2(10);
  datevento varchar2(10);
  cod4_10 varchar2(7);
  dataProposta varchar2(8);
  testo_codice_controllo varchar2(33);
  identificativo_politica varchar2(11);
  identificativo_politica_a02 varchar2(11);  
  codice_controllo varchar2(5);  
  prgPercorso_hex varchar2(7);
  cod3 varchar2(10);
  controlloDataA0205 varchar2(2);
  durata OR_PERCORSO_CONCORDATO.Numygdurataeff%type;
  tipodurata OR_PERCORSO_CONCORDATO.Codtipologiadurata%type;
   
  azioneRedditoCittadinanza varchar2(2);
  flgInvioRc  TS_GENERALE.FLGINVIORC1%type;
  flgAzioneRedditoCitt DE_AZIONE.FLGPATTORDC%type;
  prg_rdc OR_PERCORSO_CONCORDATO.PRGRDC%type;
  protocolloInps_rdc AM_RDC.STRPROTOCOLLOINPS%type;
  datDomandaStr varchar2(10);
  datRendicontazioneStr varchar2(10);
  codMonoRuolo_rdc AM_RDC.CODMONORUOLO%type;
  dataDomanda_rdc AM_RDC.DATDOMANDA%type;
  
BEGIN

  select nvl((select to_number(strvalore)
			   from ts_config_loc
			   where codtipoconfig = 'DTFINSAP' and strcodrif = (select codprovinciasil from ts_generale)), 0)
  into numggDFINSAP
  from dual;
  
 	 
  select codmin , nvl(FLGINVIORC1, 'N') FLGINVIORC1
  into soggettoId , flgInvioRc
  from DE_REGIONE, TS_GENERALE
  where codRegioneSil = codregione;
    
  select codprovinciasil 
  into currentProvincia
  from ts_generale;
   
  contatoreProvincia := 1;
  
  FOR rec_Provincie IN codiciProvinciali LOOP
  	codProv := rec_Provincie.codprovincia;
	if(codProv = currentProvincia) then
		cod3 := to_char(contatoreProvincia);
	end if;
  	contatoreProvincia := contatoreProvincia + 1;
  END LOOP;

BEGIN
  select SP_LAVORATORE.CODMINSAP
  into codMinSap
  from SP_LAVORATORE
  WHERE CDNLAVORATORE = cdnLavVar
  and SP_LAVORATORE.DATFINEVAL is null;
 EXCEPTION
  WHEN OTHERS THEN
    codMinSap :='';
 END;
  
  contatore := 1;

  FOR rec_Politica IN cursorPoliticheAtt LOOP
  	controlloDataA0205 := '';
	estraiPolAttive := 'S';
	estraiDataInizio := 'S';
	estraiDataFine := 'S';
	estraiUltimoEvento :='N';
	assegnaIdPresaInCarico := 'N';
    codAttivita := rec_Politica.CODTIPOATTIVITA;
    strdescrizione := rec_Politica.STRDESCRIZIONE;
	if (length(strdescrizione) > 100) then
		strdescrizione := substr(strdescrizione, 1, 100);
	end if;
    datstimata := rec_Politica.DATSTIMATA;
    datcolloquio := rec_Politica.DATCOLLOQUIO;
	datInizio := datcolloquio;
    dateffettiva := rec_Politica.DATEFFETTIVA;
	dateffettivaIniziale := dateffettiva;
    codcpimin_rec := rec_Politica.CODCPIMIN;
    flgmisurayei := rec_Politica.FLG_MISURAYEI;
	flgpoliticafse := rec_Politica.FLGPOLITICAFSE;
	cfEntePromPolAttive := rec_Politica.STRCFDATORELAVORO;
	datavvioazione := rec_Politica.DATAVVIOAZIONE;
	codEsitoAzione := rec_Politica.CODESITO;
	codEventoMinistero :=rec_Politica.Codeventomin;
	codEsitoRendic := rec_Politica.codesitorendicont;
	dtdatstimata := rec_Politica.dtdatstimata;
	dtdatavvioazione := rec_Politica.dtdatavvioazione;
	p_codiceprogetto := rec_Politica.CODPROGETTO;
	p_descrizioneazione := rec_Politica.DESCRIZIONEAZIONE;
	p_descrizioneazioneragg := rec_Politica.DESCRIZIONEAZIONERAGG;
	prgPatto := rec_Politica.PRGPATTOLAVORATORE;
	numSvantaggio2 := rec_Politica.Numindicesvantaggio2;
	numSvantaggio150 := rec_Politica.Numindicesvantaggio150;
	dataProposta := rec_Politica.DATPROPOSTA;
	prgPercorso := rec_Politica.PRGPERCORSO;
	dtcolloquio := rec_Politica.DTCOLLOQUIO;
	identificativo_politica := null;
	identificativo_politica_a02 := null;
	durata := rec_Politica.Numygdurataeff;
	tipodurata := rec_Politica.Codtipologiadurata;
	
	flgAzioneRedditoCitt := rec_Politica.FLGPATTORDC;
	prg_rdc := 	rec_Politica.PRGRDC;
	protocolloInps_rdc := rec_Politica.STRPROTOCOLLOINPS;
	datDomandaStr := rec_Politica.DATDOMANDA;
	datRendicontazioneStr := rec_Politica.DATRENDICONTAZIONE;
	codMonoRuolo_rdc := nvl(rec_Politica.CODMONORUOLO,'');
	dataDomanda_rdc := rec_Politica.DTDATDOMANDA;
	
	select 
    extract( day from diff ) Days
	into controlloUltimoEvento
	from (
        select (CAST(dtcolloquio as timestamp) - CAST(datsap2 as timestamp)) diff   
        from ts_generale
     );
		
	if(controlloUltimoEvento >=0 ) then
		estraiUltimoEvento := 'S';
	end if;
		
	testo_codice_controllo := '';
	codice_controllo := '';
	
	if(estraiUltimoEvento='S') then
		if(codMinSap is not null and codMinSap <> '''') then
			testo_codice_controllo := codMinSap;
		end if;

		if(codcpimin_rec is not null and codcpimin_rec <> '''') then
			testo_codice_controllo := testo_codice_controllo || codcpimin_rec;
		end if;

		if(codAttivita is not null and codAttivita <> '''') then
			testo_codice_controllo := testo_codice_controllo || codAttivita;
		end if;

		if(dataProposta is not null and dataProposta <> '''') then
			testo_codice_controllo := testo_codice_controllo || dataProposta;
		end if;

		codice_controllo := PG_UTIL_CF_PARTIVA.codice_controllo(testo_codice_controllo);
	end if;
	
	  prgPercorso_hex :='';
	  lengthStr := null;
  
	  prgPercorso_hex := PG_UTIL_NUMBER.to_hex(prgPercorso);

	  lengthStr := length(prgPercorso_hex);

	  cod4_10 := ''; 

	  select substr('0000000', 1 ,7- lengthStr)  
	  into cod4_10
	  from dual;

	  cod4_10 := cod4_10 || prgPercorso_hex;

	  identificativo_politica := soggettoId || cod3 || cod4_10 || codice_controllo;
	  
	  if( (prgPatto is not null) and (codAttivita <> 'A02' or p_codiceprogetto is null or p_codiceprogetto <> '05') ) then
	  	controlloDataA0205 := getPoliticaA0205(cdnLavVar, prgPatto);
		if(controlloDataA0205 is not null and controlloDataA0205 = 'OK') then
			identificativo_politica_a02 := getIdentificativoPolitica(cdnLavVar, prgPatto);
	  		assegnaIdPresaInCarico := 'S';
		else
			assegnaIdPresaInCarico := 'N';
		end if;
	  end if; 

	if (codEsitoAzione = 'AVV' or codEsitoAzione = 'INT' or codEsitoAzione = 'FC' or codEsitoAzione = 'NR'
	   or codEsitoAzione = 'DEC' or codEsitoAzione = 'ESN' or codEsitoAzione = 'TRA' or codEsitoAzione = 'ESC') then 
    	if (dateffettiva is null or dateffettiva = '''') then
			if(dtdatavvioazione is not null) then
				if (trunc(dtdatstimata) > trunc(dtdatavvioazione)) then
					dateffettiva := datstimata;
				else
					estraiPolAttive := 'N';
				end if;
			else
				dateffettiva := datstimata;
			end if;	
    	end if;
	end if;	
	
	if ( codEsitoAzione = 'PRG' or codEsitoAzione = 'PRI') then
        estraiPolAttive := 'N';
    end if;
	
	if ((codEsitoAzione = 'AVV' ) and dtdatavvioazione is not null) then 
		datevento := to_char(dtdatavvioazione, 'yyyy-mm-dd');
	end if;
	
	if (( codEsitoAzione = 'FC' or codEsitoAzione = 'NR' or codEsitoAzione = 'INT'
	    or codEsitoAzione = 'DEC' or codEsitoAzione = 'ESN' or codEsitoAzione = 'TRA' or codEsitoAzione = 'ESC') and dateffettiva is not null) then 
		datevento := dateffettiva;
	end if;
		
	if (flgpoliticafse = 'S') then
		
 			if (p_codiceprogetto is not null and p_codiceprogetto <> '''') then
				titoloprogetto := p_codiceprogetto;
			else
				titoloprogetto := '01';
			end if;
			 
			if ( codAttivita = 'D01' or codAttivita = 'E01' or codAttivita = 'E02' or codAttivita = 'E03' or codAttivita = 'H01' or codAttivita = 'H02' or codAttivita = 'H03' or codAttivita='C06') then
				descrizioneprogetto := cfEntePromPolAttive;
			else
				descrizioneprogetto :=  getDescrYgProgetti(titoloprogetto);
			end if;
	
	else
		
		if (codEsitoAzione = 'FC' or codEsitoAzione = 'AVV' or codEsitoAzione = 'INT' or codEsitoAzione='NR'
		 or codEsitoAzione = 'DEC' or codEsitoAzione = 'ESN' or codEsitoAzione = 'TRA' or codEsitoAzione = 'ESC') then
			if (datavvioazione is not null and datavvioazione <> '''') then
				datInizio := datavvioazione;
			else
				estraiPolAttive := 'N';
			end if;
		else
			if (codEsitoAzione = 'RIF' or codEsitoAzione = 'RES' or codEsitoAzione = 'CAN' or codEsitoAzione = 'NI') then
				datInizio := datcolloquio;
				dateffettiva := datcolloquio;
				datevento := datcolloquio;
			end if;
		end if;
				
		if (flgmisurayei = 'S') then
			--if (codEsitoAzione = 'FC' or codEsitoAzione = 'AVV' or codEsitoAzione = 'INT' or codEsitoAzione = 'RIF' or codEsitoAzione = 'INF' or codEsitoAzione = 'NI'
			--or codEsitoAzione = 'DEC' or codEsitoAzione = 'ESN' or codEsitoAzione = 'TRA' or codEsitoAzione = 'ESC') then
				if (p_codiceprogetto is not null and p_codiceprogetto <> '''') then
					titoloprogetto := p_codiceprogetto;
				else
					titoloprogetto := '02';
				end if;
		 
			if ( codAttivita = 'D01' or codAttivita = 'E01' or codAttivita = 'E02' or codAttivita = 'E03' or codAttivita = 'H01' or codAttivita = 'H02' or codAttivita = 'H03' or codAttivita='C06') then
					descrizioneprogetto := cfEntePromPolAttive;
				else
					descrizioneprogetto :=  getDescrYgProgetti(titoloprogetto);
				end if;
 
			--end if;
		else
			if (p_codiceprogetto is not null and p_codiceprogetto <> '''') then
				titoloprogetto := p_codiceprogetto;
			else
				titoloprogetto := '01';
			end if;
			 
			if ( codAttivita = 'D01' or codAttivita = 'E01' or codAttivita = 'E02' or codAttivita = 'E03' or codAttivita = 'H01' or codAttivita = 'H02' or codAttivita = 'H03' or codAttivita='C06') then
				descrizioneprogetto := cfEntePromPolAttive;
			else
				descrizioneprogetto :=  getDescrYgProgetti(titoloprogetto);
				--if (titoloprogetto = '05') then
					--descrizioneprogetto := 'Presa in carico D.Lgs. 150';
				--else
					--descrizioneprogetto := 'Progetto di politica attiva regionale/provinciale';
				--end if
			end if;
 
		end if;
	
	end if;
	
	if (codEsitoAzione = 'PRO' or codEsitoAzione = 'NA' or codEsitoAzione = 'PRG' or codEsitoAzione = 'PRI') then
		datInizio := datcolloquio;
		dateffettiva := datcolloquio;
		datevento := datcolloquio;
	end if;
	
	
	azioneRedditoCittadinanza := 'N';

	if(flgAzioneRedditoCitt = 'S' and flgInvioRc = 'S' ) then
		azioneRedditoCittadinanza := 'S'; 
			if(codEventoMinistero = '01' or codEventoMinistero = '02' or codEventoMinistero='04' or codEventoMinistero='10' 
				or codEventoMinistero='12' or codEventoMinistero='13' or codEventoMinistero='14' or codEventoMinistero='15') then
				azioneRedditoCittadinanza := 'S'; 
			else
				azioneRedditoCittadinanza := 'N'; 
			end if;
	end if;
	
	
    if (codcpimin_rec is not null and codcpimin_rec <> '''' and
		datcolloquio is not null and datcolloquio <> '''' and
		estraiPolAttive ='S') then
		
		if (contatore = 1) then
			if (xmldom.isNull(doc) = FALSE) then
    			item_elmt := xmldom.createElement(doc, 'politiche_attive_lst');
    			politiche_attive_lst_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));
			else
				doc := xmldom.newDOMDocument;
          		main_node := xmldom.makeNode(doc);
          		root_elmt := xmldom.createElement(doc, 'politiche_attive_lst');
         		politiche_attive_lst_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
          		root_node := main_node;
       		end if;
    	end if;
		 
      item_elmt := xmldom.createElement(doc, 'politiche_attive');
      politiche_attive_node := xmldom.appendChild(politiche_attive_lst_node, xmldom.makeNode(item_elmt));
      

      item_elmt := xmldom.createElement(doc, 'tipo_attivita');
      codAttivita_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codAttivita);
      item_node := xmldom.appendChild(codAttivita_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'titolo_denominazione');
      strdescrizione_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(strdescrizione, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(strdescrizione_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'data_proposta');
      datstimata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, datcolloquio);
      item_node := xmldom.appendChild(datstimata_node, xmldom.makeNode(item_text));

	  if (estraiDataInizio='S') then
		  item_elmt := xmldom.createElement(doc, 'data');
		  datainizio_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, datInizio);
		  item_node := xmldom.appendChild(datainizio_node, xmldom.makeNode(item_text));
	  end if;

	  if (estraiDataFine='S') then
		  if (dateffettiva is not null and dateffettiva <> '''') then
			item_elmt := xmldom.createElement(doc, 'data_fine');
			dateffettiva_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, dateffettiva);
			item_node := xmldom.appendChild(dateffettiva_node, xmldom.makeNode(item_text));
		  end if;
	  end if;
	  
	  if(tipodurata is not null and tipodurata <> '''' and tipodurata <> 'Y' and durata is not null and durata > 0) then
	  
	  	item_elmt := xmldom.createElement(doc, 'durata');
      	durata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      	item_text := xmldom.createTextNode(doc, durata);
      	item_node := xmldom.appendChild(durata_node, xmldom.makeNode(item_text));
		
		item_elmt := xmldom.createElement(doc, 'tipologia_durata');
		tip_durata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		item_text := xmldom.createTextNode(doc, tipodurata);
		item_node := xmldom.appendChild(tip_durata_node, xmldom.makeNode(item_text));
		
	  end if;
 
	  if (descrizioneprogetto is not null and descrizioneprogetto <> '''') then
		  item_elmt := xmldom.createElement(doc, 'descrizione');
		  descrizioneatt_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, regexp_replace(descrizioneprogetto, '[[:cntrl:]]', ' '));
		  item_node := xmldom.appendChild(descrizioneatt_node, xmldom.makeNode(item_text));
	  else 
		  item_elmt := xmldom.createElement(doc, 'descrizione');
		  descrizioneatt_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, 'Garanzia Giovani');
		  item_node := xmldom.appendChild(descrizioneatt_node, xmldom.makeNode(item_text));	
	  end if;

      item_elmt := xmldom.createElement(doc, 'titolo_progetto');
      titolo_progetto_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(titoloprogetto, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(titolo_progetto_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'codice_ente_promotore');
      codcpi_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codcpimin_rec);
      item_node := xmldom.appendChild(codcpi_node, xmldom.makeNode(item_text));
	  
	  if(estraiUltimoEvento='S') then	  
		  if(identificativo_politica is not null and identificativo_politica <> '''') then
			item_elmt := xmldom.createElement(doc, 'identificativo_politica');
			identificativo_politica_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, identificativo_politica);
			item_node := xmldom.appendChild(identificativo_politica_node, xmldom.makeNode(item_text));	
		  end if;

		  if(prgPatto is not null and (numSvantaggio2 is not null or numSvantaggio150 is not null)) then
			if(numSvantaggio2 is not null) then
				indice_profiling := trim(to_char(numSvantaggio2));
			elsif (numSvantaggio150 is not null) then
				indice_profiling := trim(to_char(numSvantaggio150,'999990.99'));
			end if;
			item_elmt := xmldom.createElement(doc, 'indice_profiling');
			indice_profiling_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, indice_profiling);
			item_node := xmldom.appendChild(indice_profiling_node, xmldom.makeNode(item_text));	
		  end if;
	    
		  if(assegnaIdPresaInCarico='S' and identificativo_politica_a02 is not null and identificativo_politica_a02 <> '''') then
			item_elmt := xmldom.createElement(doc, 'identificativo_presa_in_carico');
			id_presa_in_carico_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, identificativo_politica_a02);
			item_node := xmldom.appendChild(id_presa_in_carico_node, xmldom.makeNode(item_text));	
		  end if;
		  
	  end if;
	   
	  if (estraiUltimoEvento='S' or titoloprogetto = '05') then
	  	item_elmt := xmldom.createElement(doc, 'ultimo_evento');
		ultimo_evento_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		item_elmt := xmldom.createElement(doc, 'evento');
		tipo_ev_node := xmldom.appendChild(ultimo_evento_node, xmldom.makeNode(item_elmt));
		item_text := xmldom.createTextNode(doc, codEventoMinistero);
		item_node := xmldom.appendChild(tipo_ev_node, xmldom.makeNode(item_text));	
		item_elmt := xmldom.createElement(doc, 'data_evento');
		datevento_node := xmldom.appendChild(ultimo_evento_node, xmldom.makeNode(item_elmt));
		item_text := xmldom.createTextNode(doc, datevento);
		item_node := xmldom.appendChild(datevento_node, xmldom.makeNode(item_text));	
	  end if;
		
		if(azioneRedditoCittadinanza ='S' and codAttivita = 'A02' and p_codiceprogetto = '08' and prg_rdc is not null) then
		 
		 		 			
			if(codEventoMinistero = '01') then
				dateffettiva := datDomandaStr;
				datevento := datDomandaStr;
			end if;
			
			if(codEventoMinistero = '02') then
				dateffettiva := datRendicontazioneStr;
				datevento := datRendicontazioneStr;
			end if;
			
		--	if(codEventoMinistero='13' or codEventoMinistero='12' or codEventoMinistero='14' or codEventoMinistero='15') then
		--		dateffettiva := datstimata;
		--		datevento := datstimata;
		--	end if;
				
			--if( codEventoMinistero='04' or codEventoMinistero='10' ) then
			if( codEventoMinistero='04' ) then
				dateffettiva := datcolloquio;
				datevento := datcolloquio;
			end if;
		 
			select DATINIZIOVAL
			into dataValiditaEntePromotore
			from mn_st_cpi  where CODCPIMIN = codcpimin_rec;
		
			 
				if(trunc(dataDomanda_rdc) >= trunc(dataValiditaEntePromotore))  then
					datcolloquio := datDomandaStr;
				else 
					datcolloquio := to_char(dataValiditaEntePromotore, 'yyyy-mm-dd');
				end if;
			 
				
			
			codAttivita := 'RC1';
			strdescrizione := 'Beneficiario del reddito di cittadinanza tenuto al patto per il lavoro';
			descrizioneprogetto := protocolloInps_rdc || '-' || codMonoRuolo_rdc;
			datInizio := datRendicontazioneStr;
			durata := 18;
			tipodurata := 'M';
			titoloprogetto := '08';
			indice_profiling := null;
			identificativo_politica_a02 := null;
			
			prgPercorso_hex :='';
			lengthStr := null;
	  
			--prgPercorso_hex := PG_UTIL_NUMBER.to_hex(prg_rdc || prgPercorso);
			prgPercorso_hex := PG_UTIL_NUMBER.to_hex(prg_rdc); 

			lengthStr := length(prgPercorso_hex);

			cod4_10 := ''; 

			select substr('0000000', 1 ,7- lengthStr)  
			into cod4_10
			from dual;

			cod4_10 := cod4_10 || prgPercorso_hex;

			identificativo_politica := soggettoId || cod3 || cod4_10 || codice_controllo;
						
			item_elmt := xmldom.createElement(doc, 'politiche_attive');
			politiche_attive_node := xmldom.appendChild(politiche_attive_lst_node, xmldom.makeNode(item_elmt));
		  

		  item_elmt := xmldom.createElement(doc, 'tipo_attivita');
		  codAttivita_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, codAttivita);
		  item_node := xmldom.appendChild(codAttivita_node, xmldom.makeNode(item_text));

		  item_elmt := xmldom.createElement(doc, 'titolo_denominazione');
		  strdescrizione_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, regexp_replace(strdescrizione, '[[:cntrl:]]', ' '));
		  item_node := xmldom.appendChild(strdescrizione_node, xmldom.makeNode(item_text));

		  item_elmt := xmldom.createElement(doc, 'data_proposta');
		  datstimata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, datcolloquio);
		  item_node := xmldom.appendChild(datstimata_node, xmldom.makeNode(item_text));

		  if (estraiDataInizio='S') then
			  item_elmt := xmldom.createElement(doc, 'data');
			  datainizio_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			  item_text := xmldom.createTextNode(doc, datInizio);
			  item_node := xmldom.appendChild(datainizio_node, xmldom.makeNode(item_text));
		  end if;

		  if (estraiDataFine='S') then
			  if (dateffettiva is not null and dateffettiva <> '''') then
				item_elmt := xmldom.createElement(doc, 'data_fine');
				dateffettiva_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
				item_text := xmldom.createTextNode(doc, dateffettiva);
				item_node := xmldom.appendChild(dateffettiva_node, xmldom.makeNode(item_text));
			  end if;
		  end if;
		  
		  if(tipodurata is not null and tipodurata <> '''' and tipodurata <> 'Y' and durata is not null and durata > 0) then
		  
			item_elmt := xmldom.createElement(doc, 'durata');
			durata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, durata);
			item_node := xmldom.appendChild(durata_node, xmldom.makeNode(item_text));
			
			item_elmt := xmldom.createElement(doc, 'tipologia_durata');
			tip_durata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, tipodurata);
			item_node := xmldom.appendChild(tip_durata_node, xmldom.makeNode(item_text));
			
		  end if;
	 
		  if (descrizioneprogetto is not null and descrizioneprogetto <> '''') then
			  item_elmt := xmldom.createElement(doc, 'descrizione');
			  descrizioneatt_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			  item_text := xmldom.createTextNode(doc, regexp_replace(descrizioneprogetto, '[[:cntrl:]]', ' '));
			  item_node := xmldom.appendChild(descrizioneatt_node, xmldom.makeNode(item_text));
		  else 
			  item_elmt := xmldom.createElement(doc, 'descrizione');
			  descrizioneatt_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			  item_text := xmldom.createTextNode(doc, 'Garanzia Giovani');
			  item_node := xmldom.appendChild(descrizioneatt_node, xmldom.makeNode(item_text));	
		  end if;

		  item_elmt := xmldom.createElement(doc, 'titolo_progetto');
		  titolo_progetto_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, regexp_replace(titoloprogetto, '[[:cntrl:]]', ' '));
		  item_node := xmldom.appendChild(titolo_progetto_node, xmldom.makeNode(item_text));

		  item_elmt := xmldom.createElement(doc, 'codice_ente_promotore');
		  codcpi_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, codcpimin_rec);
		  item_node := xmldom.appendChild(codcpi_node, xmldom.makeNode(item_text));
		  
		  if(estraiUltimoEvento='S') then	  
			  if(identificativo_politica is not null and identificativo_politica <> '''') then
				item_elmt := xmldom.createElement(doc, 'identificativo_politica');
				identificativo_politica_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
				item_text := xmldom.createTextNode(doc, identificativo_politica);
				item_node := xmldom.appendChild(identificativo_politica_node, xmldom.makeNode(item_text));	
			  end if;

			  if(prgPatto is not null and (numSvantaggio2 is not null or numSvantaggio150 is not null)) then
				if(numSvantaggio2 is not null) then
					indice_profiling := trim(to_char(numSvantaggio2));
				elsif (numSvantaggio150 is not null) then
					indice_profiling := trim(to_char(numSvantaggio150,'999990.99'));
				end if;
				item_elmt := xmldom.createElement(doc, 'indice_profiling');
				indice_profiling_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
				item_text := xmldom.createTextNode(doc, indice_profiling);
				item_node := xmldom.appendChild(indice_profiling_node, xmldom.makeNode(item_text));	
			  end if;
			
			  if(assegnaIdPresaInCarico='S' and identificativo_politica_a02 is not null and identificativo_politica_a02 <> '''') then
				item_elmt := xmldom.createElement(doc, 'identificativo_presa_in_carico');
				id_presa_in_carico_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
				item_text := xmldom.createTextNode(doc, identificativo_politica_a02);
				item_node := xmldom.appendChild(id_presa_in_carico_node, xmldom.makeNode(item_text));	
			  end if;
			  
		  end if;
		   
		  if (estraiUltimoEvento='S' or titoloprogetto = '05') then
			item_elmt := xmldom.createElement(doc, 'ultimo_evento');
			ultimo_evento_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_elmt := xmldom.createElement(doc, 'evento');
			tipo_ev_node := xmldom.appendChild(ultimo_evento_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, codEventoMinistero);
			item_node := xmldom.appendChild(tipo_ev_node, xmldom.makeNode(item_text));	
			item_elmt := xmldom.createElement(doc, 'data_evento');
			datevento_node := xmldom.appendChild(ultimo_evento_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, datevento);
			item_node := xmldom.appendChild(datevento_node, xmldom.makeNode(item_text));	
		  end if;
		
	end if;
		
		
      contatore := contatore + 1;

    end if;

  END LOOP;
   
  return '00';

EXCEPTION
  WHEN OTHERS THEN
    return '24';

END getPoliticheAttiveSap2;

FUNCTION getPoliticheAttiveSIL (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type IS

  controlSap2 number;
  root_node_var xmldom.DOMNode;
    
BEGIN
	
  root_node_var := root_node;
   -- commentato obsoleto: adeguamento esito rendicontazione sap 2.0 orioli
   -- select 
   -- extract( day from diff ) Days
   -- into controlSap2
   --	from (
   --     select (CAST(sysdate as timestamp) - CAST(datsap2 as timestamp)) diff   
   --     from ts_generale
   --  );
   
  
 -- if(controlSap2 >=0) then
  		return getPoliticheAttiveSIL2(doc, root_node_var, cdnLavVar);
 -- else
 -- 		return getPoliticheAttiveSIL1(doc, root_node_var, cdnLavVar);
 -- end if;	

END getPoliticheAttiveSIL;

FUNCTION getPoliticheAttiveSIL2 (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type IS

 main_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;

  item_text xmldom.DOMText;
  item_node xmldom.DOMNode;
  politiche_attive_lst_node xmldom.DOMNode;
  politiche_attive_node xmldom.DOMNode;
   
  CURSOR cursorPoliticheAtt is
     SELECT MA_AZIONE_TIPOATTIVITA.CODTIPOATTIVITA, MN_YG_TIPO_ATTIVITA.STRDESCRIZIONE, CONC.PRGPERCORSO,
      TO_CHAR(CONC.DATSTIMATA, 'YYYY-MM-DD') DATSTIMATA,
	  TO_CHAR(CONC.DATAVVIOAZIONE, 'YYYY-MM-DD') DATAVVIOAZIONE,
      TO_CHAR(COLL.DATCOLLOQUIO, 'YYYY-MM-DD') DATCOLLOQUIO,
	  TO_CHAR(COLL.DATCOLLOQUIO, 'YYYYMMDD') DATPROPOSTA,
      TO_CHAR(CONC.DATEFFETTIVA, 'YYYY-MM-DD') DATEFFETTIVA,
	  COLL.DATCOLLOQUIO DTCOLLOQUIO,
	  CONC.DATSTIMATA DTDATSTIMATA, CONC.DATAVVIOAZIONE DTDATAVVIOAZIONE,
      CONC.STRCFDATORELAVORO as STRCFDATORELAVORO,	    
      DE_CPI.CODCPIMIN, NVL(DE_AZIONE_RAGG.FLG_MISURAYEI, 'N') FLG_MISURAYEI,DE_ESITO.Codeventomin,
	  CONC.CODESITO, CONC.codesitorendicont, NVL(CONC.FLGPOLITICAFSE, 'N') FLGPOLITICAFSE, DE_AZIONE.CODPROGETTO,
	  DE_AZIONE.STRDESCRIZIONE DESCRIZIONEAZIONE, DE_AZIONE_RAGG.STRDESCRIZIONE DESCRIZIONEAZIONERAGG,
	  Am_Patto_Lavoratore.PRGPATTOLAVORATORE, Am_Patto_Lavoratore.Numindicesvantaggio2, Am_Patto_Lavoratore.Numindicesvantaggio150,
	  CONC.Numygdurataeff, CONC.Codtipologiadurata, 
	 NVL(DE_AZIONE.FLGPATTORDC, 'N') FLGPATTORDC, CONC.PRGRDC, AM_RDC.STRPROTOCOLLOINPS,
	 TO_CHAR(AM_RDC.DATDOMANDA, 'YYYY-MM-DD') DATDOMANDA, AM_RDC.DATDOMANDA DTDATDOMANDA, 
	 TO_CHAR(AM_RDC.DATRENDICONTAZIONE, 'YYYY-MM-DD') DATRENDICONTAZIONE,
	 DE_ESITO.STRDESCRIZIONE ESITOSIL, AM_RDC.CODMONORUOLO
    FROM OR_COLLOQUIO COLL
      INNER JOIN OR_PERCORSO_CONCORDATO CONC
            ON (CONC.PRGCOLLOQUIO = COLL.PRGCOLLOQUIO)
      INNER JOIN MA_AZIONE_TIPOATTIVITA
      ON (CONC.PRGAZIONI = MA_AZIONE_TIPOATTIVITA.PRGAZIONI)
	    INNER JOIN DE_AZIONE
      ON (CONC.PRGAZIONI = DE_AZIONE.PRGAZIONI)
      INNER JOIN DE_AZIONE_RAGG
      ON (DE_AZIONE.PRGAZIONERAGG = DE_AZIONE_RAGG.PRGAZIONIRAGG)
      INNER JOIN MN_YG_TIPO_ATTIVITA 
      ON (MA_AZIONE_TIPOATTIVITA.CODTIPOATTIVITA = MN_YG_TIPO_ATTIVITA.CODTIPOATTIVITA)
      INNER JOIN DE_CPI_VALIDITA_MIN DE_CPI
            ON (COLL.CODCPI = DE_CPI.CODCPISIL)
	   INNER JOIN DE_ESITO
        ON (DE_ESITO.CODESITO = CONC.CODESITO AND DE_ESITO.Codeventomin IS NOT NULL )
	  LEFT JOIN AM_LAV_PATTO_SCELTA
	  		ON (TO_NUMBER(STRCHIAVETABELLA) = CONC.PRGPERCORSO AND UPPER(CODLSTTAB) = 'OR_PER')
	  LEFT JOIN AM_PATTO_LAVORATORE
	  		ON (AM_LAV_PATTO_SCELTA.PRGPATTOLAVORATORE = AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE)
		  LEFT JOIN AM_RDC	ON (AM_RDC.PRGRDC = CONC.PRGRDC)
    WHERE (COLL.CDNLAVORATORE = cdnLavVar) and 
	(trunc(COLL.DATCOLLOQUIO) between trunc(MA_AZIONE_TIPOATTIVITA.DATINIZIOVAL) and trunc(MA_AZIONE_TIPOATTIVITA.DATFINEVAL)) and
	(trunc(COLL.DATCOLLOQUIO) between trunc(DE_CPI.DATINIZIOVAL) and trunc(DE_CPI.DATFINEVAL)) 
	ORDER BY COLL.DATCOLLOQUIO desc, MA_AZIONE_TIPOATTIVITA.CODTIPOATTIVITA asc;

  
	CURSOR codiciProvinciali IS
		select codprovincia 
		from de_provincia , de_regione, Ts_Generale 
		where de_provincia.codregione = de_regione.codregione 
		and codRegioneSil = de_regione.codregione;
		
  rec_Politica cursorPoliticheAtt%ROWTYPE;
  rec_Provincie codiciProvinciali%ROWTYPE;
 
  codAttivita MA_AZIONE_TIPOATTIVITA.CODTIPOATTIVITA%type;
  strdescrizione MN_YG_TIPO_ATTIVITA.STRDESCRIZIONE%type;
  dtdatstimata OR_PERCORSO_CONCORDATO.datstimata%type;
  dtdatavvioazione OR_PERCORSO_CONCORDATO.datavvioazione%type;
  codEsitoAzione OR_PERCORSO_CONCORDATO.CODESITO%type;
  codEventoMinistero DE_ESITO.Codeventomin%type;
  codEsitoRendic OR_PERCORSO_CONCORDATO.codesitorendicont%type;
  flgmisurayei DE_AZIONE_RAGG.FLG_MISURAYEI%type;
  flgpoliticafse OR_PERCORSO_CONCORDATO.FLGPOLITICAFSE%type;
  titoloprogetto MN_YG_TIPO_PROGETTI.CODPROGETTO%type;
  p_codiceprogetto DE_AZIONE.CODPROGETTO%type;
  p_descrizioneazione DE_AZIONE.STRDESCRIZIONE%type;
  p_descrizioneazioneragg DE_AZIONE_RAGG.STRDESCRIZIONE%type;
  descrizioneprogetto MN_YG_TIPO_PROGETTI.STRDESCRIZIONE%type;
  codcpimin_rec de_cpi.codcpimin%type;
  dataValiditaEntePromotore mn_st_cpi.DATINIZIOVAL%type;
  codProv de_provincia.codprovincia%type;
  numSvantaggio2  Am_Patto_Lavoratore.Numindicesvantaggio2%type;
  numSvantaggio150 Am_Patto_Lavoratore.Numindicesvantaggio150%type;
  prgPatto AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE%type;
  prgPercorso OR_PERCORSO_CONCORDATO.PRGPERCORSO%type; 
  cfEntePromPolAttive OR_PERCORSO_CONCORDATO.STRCFDATORELAVORO%type;
  indice_profiling varchar2(20);
  currentProvincia TS_GENERALE.codprovinciasil%type;
  codMinSap SP_LAVORATORE.codminsap%type;
  soggettoId DE_REGIONE.codmin%type;
  codcpimin_a02 de_cpi.codcpimin%type;
  dtcolloquio OR_COLLOQUIO.DATCOLLOQUIO%type;
  
  datproposta_node xmldom.DOMNode;
  dateffettiva_node xmldom.DOMNode;
  titolo_progetto_node xmldom.DOMNode;
  datainizio_node xmldom.DOMNode;
  indice_profiling_node xmldom.DOMNode;
  identificativo_politica_node xmldom.DOMNode;
  id_presa_in_carico_node xmldom.DOMNode;
  codcpi_node xmldom.DOMNode;
  descrizioneatt_node xmldom.DOMNode;
  datevento_node xmldom.DOMNode;
  ultimo_evento_node xmldom.DOMNode;
  tipo_ev_node xmldom.DOMNode;
  codAttivita_node xmldom.DOMNode;
  strdescrizione_node xmldom.DOMNode;
  durata_node xmldom.DOMNode;
  tip_durata_node xmldom.DOMNode;
  esito_sil_node xmldom.DOMNode;
  descr_sil_node xmldom.DOMNode;
  datstimata_node xmldom.DOMNode;

  estraiPolAttive varchar2(2);
  estraiDataInizio varchar2(2);
  estraiDataFine varchar2(2);
  estraiUltimoEvento varchar2(2);
  assegnaIdPresaInCarico varchar2(2);
  
  contatore number;
  controlloUltimoEvento number;
  contatoreProvincia number;
  lengthStr number;
  numggDFINSAP number;
  
  datstimata varchar2(10);
  datcolloquio varchar2(10);
  datavvioazione varchar2(10);
  dateffettiva varchar2(10);
  dateffettivaIniziale varchar2(10);
  datInizio varchar2(10);
  datevento varchar2(10);
  cod4_10 varchar2(7);
  dataProposta varchar2(8);
  testo_codice_controllo varchar2(33);
  identificativo_politica varchar2(11);
  identificativo_politica_a02 varchar2(11);  
  codice_controllo varchar2(5);  
  prgPercorso_hex varchar2(7);
  cod3 varchar2(10);
  controlloDataA0205 varchar2(2);
  durata OR_PERCORSO_CONCORDATO.Numygdurataeff%type;
  tipodurata OR_PERCORSO_CONCORDATO.Codtipologiadurata%type;
   
  azioneRedditoCittadinanza varchar2(2);
  flgInvioRc  TS_GENERALE.FLGINVIORC1%type;
  flgAzioneRedditoCitt DE_AZIONE.FLGPATTORDC%type;
  prg_rdc OR_PERCORSO_CONCORDATO.PRGRDC%type;
  protocolloInps_rdc AM_RDC.STRPROTOCOLLOINPS%type;
  datDomandaStr varchar2(10);
  datRendicontazioneStr varchar2(10);
  strEsitoSil DE_ESITO.STRDESCRIZIONE%type;
  codMonoRuolo_rdc AM_RDC.CODMONORUOLO%type;
  dataDomanda_rdc AM_RDC.DATDOMANDA%type;

BEGIN

 select nvl((select to_number(strvalore)
			   from ts_config_loc
			   where codtipoconfig = 'DTFINSAP' and strcodrif = (select codprovinciasil from ts_generale)), 0)
  into numggDFINSAP
  from dual;
  
 	 
  select codmin , nvl(FLGINVIORC1, 'N') FLGINVIORC1
  into soggettoId , flgInvioRc
  from DE_REGIONE, TS_GENERALE
  where codRegioneSil = codregione;
    
  select codprovinciasil 
  into currentProvincia
  from ts_generale;
   
  contatoreProvincia := 1;
  
  FOR rec_Provincie IN codiciProvinciali LOOP
  	codProv := rec_Provincie.codprovincia;
	if(codProv = currentProvincia) then
		cod3 := to_char(contatoreProvincia);
	end if;
  	contatoreProvincia := contatoreProvincia + 1;
  END LOOP;

BEGIN
  select SP_LAVORATORE.CODMINSAP
  into codMinSap
  from SP_LAVORATORE
  WHERE CDNLAVORATORE = cdnLavVar
  and SP_LAVORATORE.DATFINEVAL is null;
 EXCEPTION
  WHEN OTHERS THEN
    codMinSap :='';
 END;
  
  contatore := 1;

  FOR rec_Politica IN cursorPoliticheAtt LOOP
  	controlloDataA0205 := '';
	estraiPolAttive := 'S';
	estraiDataInizio := 'S';
	estraiDataFine := 'S';
	estraiUltimoEvento :='N';
	assegnaIdPresaInCarico := 'N';
    codAttivita := rec_Politica.CODTIPOATTIVITA;
    strdescrizione := rec_Politica.STRDESCRIZIONE;
	if (length(strdescrizione) > 100) then
		strdescrizione := substr(strdescrizione, 1, 100);
	end if;
    datstimata := rec_Politica.DATSTIMATA;
    datcolloquio := rec_Politica.DATCOLLOQUIO;
	datInizio := datcolloquio;
    dateffettiva := rec_Politica.DATEFFETTIVA;
	dateffettivaIniziale := dateffettiva;
    codcpimin_rec := rec_Politica.CODCPIMIN;
    flgmisurayei := rec_Politica.FLG_MISURAYEI;
	flgpoliticafse := rec_Politica.FLGPOLITICAFSE;
	cfEntePromPolAttive := rec_Politica.STRCFDATORELAVORO;
	datavvioazione := rec_Politica.DATAVVIOAZIONE;
	codEsitoAzione := rec_Politica.CODESITO;
	codEventoMinistero :=rec_Politica.Codeventomin;
	codEsitoRendic := rec_Politica.codesitorendicont;
	dtdatstimata := rec_Politica.dtdatstimata;
	dtdatavvioazione := rec_Politica.dtdatavvioazione;
	p_codiceprogetto := rec_Politica.CODPROGETTO;
	p_descrizioneazione := rec_Politica.DESCRIZIONEAZIONE;
	p_descrizioneazioneragg := rec_Politica.DESCRIZIONEAZIONERAGG;
	prgPatto := rec_Politica.PRGPATTOLAVORATORE;
	numSvantaggio2 := rec_Politica.Numindicesvantaggio2;
	numSvantaggio150 := rec_Politica.Numindicesvantaggio150;
	dataProposta := rec_Politica.DATPROPOSTA;
	prgPercorso := rec_Politica.PRGPERCORSO;
	dtcolloquio := rec_Politica.DTCOLLOQUIO;
	identificativo_politica := null;
	identificativo_politica_a02 := null;
	durata := rec_Politica.Numygdurataeff;
	tipodurata := rec_Politica.Codtipologiadurata;
	
	flgAzioneRedditoCitt := rec_Politica.FLGPATTORDC;
	prg_rdc := 	rec_Politica.PRGRDC;
	protocolloInps_rdc := rec_Politica.STRPROTOCOLLOINPS;
	datDomandaStr := rec_Politica.DATDOMANDA;
	datRendicontazioneStr := rec_Politica.DATRENDICONTAZIONE;
	codMonoRuolo_rdc := nvl(rec_Politica.CODMONORUOLO,'');
    dataDomanda_rdc := rec_Politica.DTDATDOMANDA;

	
	strEsitoSil := rec_Politica.ESITOSIL;
	
	select 
    extract( day from diff ) Days
	into controlloUltimoEvento
	from (
        select (CAST(dtcolloquio as timestamp) - CAST(datsap2 as timestamp)) diff   
        from ts_generale
     );
		
	if(controlloUltimoEvento >=0 ) then
		estraiUltimoEvento := 'S';
	end if;
		
	testo_codice_controllo := '';
	codice_controllo := '';
	
	if(estraiUltimoEvento='S') then
		if(codMinSap is not null and codMinSap <> '''') then
			testo_codice_controllo := codMinSap;
		end if;

		if(codcpimin_rec is not null and codcpimin_rec <> '''') then
			testo_codice_controllo := testo_codice_controllo || codcpimin_rec;
		end if;

		if(codAttivita is not null and codAttivita <> '''') then
			testo_codice_controllo := testo_codice_controllo || codAttivita;
		end if;

		if(dataProposta is not null and dataProposta <> '''') then
			testo_codice_controllo := testo_codice_controllo || dataProposta;
		end if;

		codice_controllo := PG_UTIL_CF_PARTIVA.codice_controllo(testo_codice_controllo);
	end if;
	
	  prgPercorso_hex :='';
	  lengthStr := null;
  
	  prgPercorso_hex := PG_UTIL_NUMBER.to_hex(prgPercorso);

	  lengthStr := length(prgPercorso_hex);

	  cod4_10 := ''; 

	  select substr('0000000', 1 ,7- lengthStr)  
	  into cod4_10
	  from dual;

	  cod4_10 := cod4_10 || prgPercorso_hex;

	  identificativo_politica := soggettoId || cod3 || cod4_10 || codice_controllo;
	  
	  if( (prgPatto is not null) and (codAttivita <> 'A02' or p_codiceprogetto is null or p_codiceprogetto <> '05') ) then
	  	controlloDataA0205 := getPoliticaA0205(cdnLavVar, prgPatto);
		if(controlloDataA0205 is not null and controlloDataA0205 = 'OK') then
			identificativo_politica_a02 := getIdentificativoPolitica(cdnLavVar, prgPatto);
	  		assegnaIdPresaInCarico := 'S';
		else
			assegnaIdPresaInCarico := 'N';
		end if;
	  end if; 

	if (codEsitoAzione = 'AVV' or codEsitoAzione = 'INT' or codEsitoAzione = 'FC' or codEsitoAzione = 'NR'
	   or codEsitoAzione = 'DEC' or codEsitoAzione = 'ESN' or codEsitoAzione = 'TRA' or codEsitoAzione = 'ESC') then 
    	if (dateffettiva is null or dateffettiva = '''') then
			if(dtdatavvioazione is not null) then
				if (trunc(dtdatstimata) > trunc(dtdatavvioazione)) then
					dateffettiva := datstimata;
				else
					estraiPolAttive := 'N';
				end if;
			else
				dateffettiva := datstimata;
			end if;	
    	end if;
	end if;	
	
	if ((codEsitoAzione = 'AVV' ) and dtdatavvioazione is not null) then 
		datevento := to_char(dtdatavvioazione, 'yyyy-mm-dd');
	end if;
	
	if (( codEsitoAzione = 'FC' or codEsitoAzione = 'NR' or codEsitoAzione = 'INT'
	    or codEsitoAzione = 'DEC' or codEsitoAzione = 'ESN' or codEsitoAzione = 'TRA' or codEsitoAzione = 'ESC') and dateffettiva is not null) then 
		datevento := dateffettiva;
	end if;
		
	if (flgpoliticafse = 'S') then
		
 			if (p_codiceprogetto is not null and p_codiceprogetto <> '''') then
				titoloprogetto := p_codiceprogetto;
			else
				titoloprogetto := '01';
			end if;
			 
			if ( codAttivita = 'D01' or codAttivita = 'E01' or codAttivita = 'E02' or codAttivita = 'E03' or codAttivita = 'H01' or codAttivita = 'H02' or codAttivita = 'H03' or codAttivita='C06') then
				descrizioneprogetto := cfEntePromPolAttive;
			else
				descrizioneprogetto :=  getDescrYgProgetti(titoloprogetto);
			end if;
	
	else
		
		if (codEsitoAzione = 'FC' or codEsitoAzione = 'AVV' or codEsitoAzione = 'INT' or codEsitoAzione='NR'
		 or codEsitoAzione = 'DEC' or codEsitoAzione = 'ESN' or codEsitoAzione = 'TRA' or codEsitoAzione = 'ESC') then
			if (datavvioazione is not null and datavvioazione <> '''') then
				datInizio := datavvioazione;
			else
				estraiPolAttive := 'N';
			end if;
		else
			if (codEsitoAzione = 'RIF' or codEsitoAzione = 'RES' or codEsitoAzione = 'CAN' or codEsitoAzione = 'NI') then
				datInizio := datcolloquio;
				dateffettiva := datcolloquio;
				datevento := datcolloquio; 
			end if;
		end if;
				
		if (flgmisurayei = 'S') then
		--	if (codEsitoAzione = 'FC' or codEsitoAzione = 'AVV' or codEsitoAzione = 'INT' or codEsitoAzione = 'RIF' or codEsitoAzione = 'INF' or codEsitoAzione = 'NI'
		--	or codEsitoAzione = 'DEC' or codEsitoAzione = 'ESN' or codEsitoAzione = 'TRA' or codEsitoAzione = 'ESC') then
				if (p_codiceprogetto is not null and p_codiceprogetto <> '''') then
					titoloprogetto := p_codiceprogetto;
				else
					titoloprogetto := '02';
				end if;
		 
			if ( codAttivita = 'D01' or codAttivita = 'E01' or codAttivita = 'E02' or codAttivita = 'E03' or codAttivita = 'H01' or codAttivita = 'H02' or codAttivita = 'H03' or codAttivita='C06') then
					descrizioneprogetto := cfEntePromPolAttive;
				else
					descrizioneprogetto :=  getDescrYgProgetti(titoloprogetto);
				end if;
 
		--	end if;
		else
			if (p_codiceprogetto is not null and p_codiceprogetto <> '''') then
				titoloprogetto := p_codiceprogetto;
			else
				titoloprogetto := '01';
			end if;
			 
			if ( codAttivita = 'D01' or codAttivita = 'E01' or codAttivita = 'E02' or codAttivita = 'E03' or codAttivita = 'H01' or codAttivita = 'H02' or codAttivita = 'H03' or codAttivita='C06') then
				descrizioneprogetto := cfEntePromPolAttive;
			else
				descrizioneprogetto :=  getDescrYgProgetti(titoloprogetto);
				--if (titoloprogetto = '05') then
					--descrizioneprogetto := 'Presa in carico D.Lgs. 150';
				--else
					--descrizioneprogetto := 'Progetto di politica attiva regionale/provinciale';
				--end if
			end if;
 
		end if;
	
	end if;
	
	if (codEsitoAzione = 'PRO' or codEsitoAzione = 'NA' or codEsitoAzione = 'PRG' or codEsitoAzione = 'PRI') then
		datInizio := datcolloquio;
		dateffettiva := datcolloquio;
		datevento := datcolloquio;
	end if;
	
	
	azioneRedditoCittadinanza := 'N';

	if(flgAzioneRedditoCitt = 'S' and flgInvioRc = 'S' ) then
		azioneRedditoCittadinanza := 'S'; 
			if(codEventoMinistero = '01' or codEventoMinistero = '02' or codEventoMinistero='04' or codEventoMinistero='10' 
				or codEventoMinistero='12' or codEventoMinistero='13' or codEventoMinistero='14' or codEventoMinistero='15') then
				azioneRedditoCittadinanza := 'S'; 
			else
				azioneRedditoCittadinanza := 'N'; 
			end if;
	end if;
	
	
    if (codcpimin_rec is not null and codcpimin_rec <> '''' and
		datcolloquio is not null and datcolloquio <> '''' and
		estraiPolAttive='S') then
		
		if (contatore = 1) then
			if (xmldom.isNull(doc) = FALSE) then
    			item_elmt := xmldom.createElement(doc, 'politiche_attive_lst');
    			politiche_attive_lst_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));
			else
				doc := xmldom.newDOMDocument;
          		main_node := xmldom.makeNode(doc);
          		root_elmt := xmldom.createElement(doc, 'politiche_attive_lst');
         		politiche_attive_lst_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
          		root_node := main_node;
       		end if;
    	end if;
		 
      item_elmt := xmldom.createElement(doc, 'politiche_attive');
      politiche_attive_node := xmldom.appendChild(politiche_attive_lst_node, xmldom.makeNode(item_elmt));
      

      item_elmt := xmldom.createElement(doc, 'tipo_attivita');
      codAttivita_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codAttivita);
      item_node := xmldom.appendChild(codAttivita_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'titolo_denominazione');
      strdescrizione_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(strdescrizione, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(strdescrizione_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'data_proposta');
      datproposta_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, datcolloquio);
      item_node := xmldom.appendChild(datproposta_node, xmldom.makeNode(item_text));

	  if (estraiDataInizio='S') then
		  item_elmt := xmldom.createElement(doc, 'data');
		  datainizio_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, datInizio);
		  item_node := xmldom.appendChild(datainizio_node, xmldom.makeNode(item_text));
	  end if;

	  if (estraiDataFine='S') then
		  if (dateffettiva is not null and dateffettiva <> '''') then
			item_elmt := xmldom.createElement(doc, 'data_fine');
			dateffettiva_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, dateffettiva);
			item_node := xmldom.appendChild(dateffettiva_node, xmldom.makeNode(item_text));
		  end if;
	  end if;
	  
	  if(tipodurata is not null and tipodurata <> '''' and tipodurata <> 'Y' and durata is not null and durata > 0) then
	  
	  	item_elmt := xmldom.createElement(doc, 'durata');
      	durata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      	item_text := xmldom.createTextNode(doc, durata);
      	item_node := xmldom.appendChild(durata_node, xmldom.makeNode(item_text));
		
		item_elmt := xmldom.createElement(doc, 'tipologia_durata');
		tip_durata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		item_text := xmldom.createTextNode(doc, tipodurata);
		item_node := xmldom.appendChild(tip_durata_node, xmldom.makeNode(item_text));
		
	  end if;
 
	  if (descrizioneprogetto is not null and descrizioneprogetto <> '''') then
		  item_elmt := xmldom.createElement(doc, 'descrizione');
		  descrizioneatt_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, regexp_replace(descrizioneprogetto, '[[:cntrl:]]', ' '));
		  item_node := xmldom.appendChild(descrizioneatt_node, xmldom.makeNode(item_text));
	  else 
		  item_elmt := xmldom.createElement(doc, 'descrizione');
		  descrizioneatt_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, 'Garanzia Giovani');
		  item_node := xmldom.appendChild(descrizioneatt_node, xmldom.makeNode(item_text));	
	  end if;

      item_elmt := xmldom.createElement(doc, 'titolo_progetto');
      titolo_progetto_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(titoloprogetto, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(titolo_progetto_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'codice_ente_promotore');
      codcpi_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, codcpimin_rec);
      item_node := xmldom.appendChild(codcpi_node, xmldom.makeNode(item_text));

      item_elmt := xmldom.createElement(doc, 'descrizione_azione_sil');
      descr_sil_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(p_descrizioneazione, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(descr_sil_node, xmldom.makeNode(item_text));
      
      item_elmt := xmldom.createElement(doc, 'esito_azione_sil');
      esito_sil_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(strEsitoSil, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(esito_sil_node, xmldom.makeNode(item_text));
      
      if (datstimata is not null and datstimata <> '''') then
			item_elmt := xmldom.createElement(doc, 'data_stimata');
			datstimata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, datstimata);
			item_node := xmldom.appendChild(datstimata_node, xmldom.makeNode(item_text));
	  end if;
	  
	  if(estraiUltimoEvento='S') then	  
		  if(identificativo_politica is not null and identificativo_politica <> '''') then
			item_elmt := xmldom.createElement(doc, 'identificativo_politica');
			identificativo_politica_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, identificativo_politica);
			item_node := xmldom.appendChild(identificativo_politica_node, xmldom.makeNode(item_text));	
		  end if;

		  if(prgPatto is not null and (numSvantaggio2 is not null or numSvantaggio150 is not null)) then
			if(numSvantaggio2 is not null) then
				indice_profiling := trim(to_char(numSvantaggio2));
			elsif (numSvantaggio150 is not null) then
				indice_profiling := trim(to_char(numSvantaggio150,'999990.99'));
			end if;
			item_elmt := xmldom.createElement(doc, 'indice_profiling');
			indice_profiling_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, indice_profiling);
			item_node := xmldom.appendChild(indice_profiling_node, xmldom.makeNode(item_text));	
		  end if;
	    
		  if(assegnaIdPresaInCarico='S' and identificativo_politica_a02 is not null and identificativo_politica_a02 <> '''') then
			item_elmt := xmldom.createElement(doc, 'identificativo_presa_in_carico');
			id_presa_in_carico_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, identificativo_politica_a02);
			item_node := xmldom.appendChild(id_presa_in_carico_node, xmldom.makeNode(item_text));	
		  end if;
		  
	  end if;
	   
	  if (estraiUltimoEvento='S' or titoloprogetto = '05') then
	  	item_elmt := xmldom.createElement(doc, 'ultimo_evento');
		ultimo_evento_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		item_elmt := xmldom.createElement(doc, 'evento');
		tipo_ev_node := xmldom.appendChild(ultimo_evento_node, xmldom.makeNode(item_elmt));
		item_text := xmldom.createTextNode(doc, codEventoMinistero);
		item_node := xmldom.appendChild(tipo_ev_node, xmldom.makeNode(item_text));	
		item_elmt := xmldom.createElement(doc, 'data_evento');
		datevento_node := xmldom.appendChild(ultimo_evento_node, xmldom.makeNode(item_elmt));
		item_text := xmldom.createTextNode(doc, datevento);
		item_node := xmldom.appendChild(datevento_node, xmldom.makeNode(item_text));	
	  end if;
		
		if(azioneRedditoCittadinanza='S' and codAttivita = 'A02' and p_codiceprogetto = '08' and prg_rdc is not null) then
		 
		 		 			
			if(codEventoMinistero = '01') then
				dateffettiva := datDomandaStr;
				datevento := datDomandaStr;
			end if;
			
			if(codEventoMinistero = '02') then
				dateffettiva := datRendicontazioneStr;
				datevento := datRendicontazioneStr;
			end if;
			
		--	if(codEventoMinistero='13' or codEventoMinistero='12' or codEventoMinistero='14' or codEventoMinistero='15') then
		--		dateffettiva := datstimata;
		--		datevento := datstimata;
		--	end if;
				
			if( codEventoMinistero='04' or codEventoMinistero='10' ) then
				dateffettiva := datcolloquio;
				datevento := datcolloquio;
			end if;
		 
			select DATINIZIOVAL
			into dataValiditaEntePromotore
			from mn_st_cpi  where CODCPIMIN = codcpimin_rec;
		
			 
				if(trunc(dataDomanda_rdc) >= trunc(dataValiditaEntePromotore))  then
					datcolloquio := datDomandaStr;
				else 
					datcolloquio := to_char(dataValiditaEntePromotore, 'yyyy-mm-dd');
				end if;
			 
							
			codAttivita := 'RC1';
			strdescrizione := 'Beneficiario del reddito di cittadinanza tenuto al patto per il lavoro';
			descrizioneprogetto := protocolloInps_rdc || '-' || codMonoRuolo_rdc;
			datInizio := datRendicontazioneStr;
			durata := 18;
			tipodurata := 'M';
			titoloprogetto := '08';
			indice_profiling := null;
			identificativo_politica_a02 := null;
			
			prgPercorso_hex :='';
			lengthStr := null;
	  
			--prgPercorso_hex := PG_UTIL_NUMBER.to_hex(prg_rdc || prgPercorso);
			prgPercorso_hex := PG_UTIL_NUMBER.to_hex(prg_rdc); 

			lengthStr := length(prgPercorso_hex);

			cod4_10 := ''; 

			select substr('0000000', 1 ,7- lengthStr)  
			into cod4_10
			from dual;

			cod4_10 := cod4_10 || prgPercorso_hex;

			identificativo_politica := soggettoId || cod3 || cod4_10 || codice_controllo;
			
			
			if(codEventoMinistero = '01') then
				dateffettiva := datDomandaStr;
				datevento := datDomandaStr;
			end if;
			
			if(codEventoMinistero = '02') then
				dateffettiva := datRendicontazioneStr;
				datevento := datRendicontazioneStr;
			end if;
				
			if(codEventoMinistero='13' or codEventoMinistero='04' or codEventoMinistero='10' or codEventoMinistero='12' or codEventoMinistero='14' or codEventoMinistero='15') then
				dateffettiva := rec_Politica.DATEFFETTIVA;
				datevento := rec_Politica.DATEFFETTIVA;
			end if;

						
			item_elmt := xmldom.createElement(doc, 'politiche_attive');
			politiche_attive_node := xmldom.appendChild(politiche_attive_lst_node, xmldom.makeNode(item_elmt));
		  

		  item_elmt := xmldom.createElement(doc, 'tipo_attivita');
		  codAttivita_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, codAttivita);
		  item_node := xmldom.appendChild(codAttivita_node, xmldom.makeNode(item_text));

		  item_elmt := xmldom.createElement(doc, 'titolo_denominazione');
		  strdescrizione_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, regexp_replace(strdescrizione, '[[:cntrl:]]', ' '));
		  item_node := xmldom.appendChild(strdescrizione_node, xmldom.makeNode(item_text));

		  item_elmt := xmldom.createElement(doc, 'data_proposta');
		  datproposta_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, datcolloquio);
		  item_node := xmldom.appendChild(datproposta_node, xmldom.makeNode(item_text));

		  if (estraiDataInizio='S') then
			  item_elmt := xmldom.createElement(doc, 'data');
			  datainizio_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			  item_text := xmldom.createTextNode(doc, datInizio);
			  item_node := xmldom.appendChild(datainizio_node, xmldom.makeNode(item_text));
		  end if;

		  if (estraiDataFine='S') then
			  if (dateffettiva is not null and dateffettiva <> '''') then
				item_elmt := xmldom.createElement(doc, 'data_fine');
				dateffettiva_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
				item_text := xmldom.createTextNode(doc, dateffettiva);
				item_node := xmldom.appendChild(dateffettiva_node, xmldom.makeNode(item_text));
			  end if;
		  end if;
		  
		  if(tipodurata is not null and tipodurata <> '''' and tipodurata <> 'Y' and durata is not null and durata > 0) then
		  
			item_elmt := xmldom.createElement(doc, 'durata');
			durata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, durata);
			item_node := xmldom.appendChild(durata_node, xmldom.makeNode(item_text));
			
			item_elmt := xmldom.createElement(doc, 'tipologia_durata');
			tip_durata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, tipodurata);
			item_node := xmldom.appendChild(tip_durata_node, xmldom.makeNode(item_text));
			
		  end if;
	 
		  if (descrizioneprogetto is not null and descrizioneprogetto <> '''') then
			  item_elmt := xmldom.createElement(doc, 'descrizione');
			  descrizioneatt_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			  item_text := xmldom.createTextNode(doc, regexp_replace(descrizioneprogetto, '[[:cntrl:]]', ' '));
			  item_node := xmldom.appendChild(descrizioneatt_node, xmldom.makeNode(item_text));
		  else 
			  item_elmt := xmldom.createElement(doc, 'descrizione');
			  descrizioneatt_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			  item_text := xmldom.createTextNode(doc, 'Garanzia Giovani');
			  item_node := xmldom.appendChild(descrizioneatt_node, xmldom.makeNode(item_text));	
		  end if;

		  item_elmt := xmldom.createElement(doc, 'titolo_progetto');
		  titolo_progetto_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, regexp_replace(titoloprogetto, '[[:cntrl:]]', ' '));
		  item_node := xmldom.appendChild(titolo_progetto_node, xmldom.makeNode(item_text));

		  item_elmt := xmldom.createElement(doc, 'codice_ente_promotore');
		  codcpi_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
		  item_text := xmldom.createTextNode(doc, codcpimin_rec);
		  item_node := xmldom.appendChild(codcpi_node, xmldom.makeNode(item_text));
		  
      item_elmt := xmldom.createElement(doc, 'descrizione_azione_sil');
      descr_sil_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(p_descrizioneazione, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(descr_sil_node, xmldom.makeNode(item_text));
      
      item_elmt := xmldom.createElement(doc, 'esito_azione_sil');
      esito_sil_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
      item_text := xmldom.createTextNode(doc, regexp_replace(strEsitoSil, '[[:cntrl:]]', ' '));
      item_node := xmldom.appendChild(esito_sil_node, xmldom.makeNode(item_text));	  
      
	  if (datstimata is not null and datstimata <> '''') then
			item_elmt := xmldom.createElement(doc, 'data_stimata');
			datstimata_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, datstimata);
			item_node := xmldom.appendChild(datstimata_node, xmldom.makeNode(item_text));
	  end if;
      
		  
		  if(estraiUltimoEvento='S') then	  
			  if(identificativo_politica is not null and identificativo_politica <> '''') then
				item_elmt := xmldom.createElement(doc, 'identificativo_politica');
				identificativo_politica_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
				item_text := xmldom.createTextNode(doc, identificativo_politica);
				item_node := xmldom.appendChild(identificativo_politica_node, xmldom.makeNode(item_text));	
			  end if;

			  if(prgPatto is not null and (numSvantaggio2 is not null or numSvantaggio150 is not null)) then
				if(numSvantaggio2 is not null) then
					indice_profiling := trim(to_char(numSvantaggio2));
				elsif (numSvantaggio150 is not null) then
					indice_profiling := trim(to_char(numSvantaggio150,'999990.99'));
				end if;
				item_elmt := xmldom.createElement(doc, 'indice_profiling');
				indice_profiling_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
				item_text := xmldom.createTextNode(doc, indice_profiling);
				item_node := xmldom.appendChild(indice_profiling_node, xmldom.makeNode(item_text));	
			  end if;
			
			  if(assegnaIdPresaInCarico='S' and identificativo_politica_a02 is not null and identificativo_politica_a02 <> '''') then
				item_elmt := xmldom.createElement(doc, 'identificativo_presa_in_carico');
				id_presa_in_carico_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
				item_text := xmldom.createTextNode(doc, identificativo_politica_a02);
				item_node := xmldom.appendChild(id_presa_in_carico_node, xmldom.makeNode(item_text));	
			  end if;
			  
		  end if;
		   
		  if (estraiUltimoEvento='S' or titoloprogetto = '05') then
			item_elmt := xmldom.createElement(doc, 'ultimo_evento');
			ultimo_evento_node := xmldom.appendChild(politiche_attive_node, xmldom.makeNode(item_elmt));
			item_elmt := xmldom.createElement(doc, 'evento');
			tipo_ev_node := xmldom.appendChild(ultimo_evento_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, codEventoMinistero);
			item_node := xmldom.appendChild(tipo_ev_node, xmldom.makeNode(item_text));	
			item_elmt := xmldom.createElement(doc, 'data_evento');
			datevento_node := xmldom.appendChild(ultimo_evento_node, xmldom.makeNode(item_elmt));
			item_text := xmldom.createTextNode(doc, datevento);
			item_node := xmldom.appendChild(datevento_node, xmldom.makeNode(item_text));	
		  end if;
		
	end if;
		
		
      contatore := contatore + 1;

    end if;

  END LOOP;
   
  return '00';


EXCEPTION
  WHEN OTHERS THEN
    return '24';

END getPoliticheAttiveSIL2;

FUNCTION inserisciDatiInvio (doc xmldom.DOMDocument, cdnLavVar an_lavoratore.cdnlavoratore%type, codStatoVar sp_lavoratore.codStato%type, cdnUtenteVar an_lavoratore.cdnutins%type) RETURN de_sap_yg_errore.coderrore%type IS
  nl xmldom.DOMNodeList;
  n xmldom.DOMNode;
  lenDom number;
  nnm xmldom.DOMNamedNodeMap;
  attrname varchar2(100);
  codiceentetit_val SP_LAVORATORE.CODENTETIT%type;
  datadinascita_val SP_LAVORATORE.DATNASC%type;
  codicefiscalelav an_lavoratore.strcodicefiscale%type;
  progressivolav sp_lavoratore.prgsplav%type;
  inserisci boolean := false;
  numklo sp_lavoratore.numklosap%type;

BEGIN

  begin

    select prgsplav, numklosap
    into progressivolav, numklo
    from sp_lavoratore
    where cdnlavoratore = cdnLavVar and datfineval is null;

  exception
    when NO_DATA_FOUND then
      inserisci := true;
    when OTHERS then
      return '29';

  end;

  if (inserisci) then
    --INSERIMENTO
    select strcodicefiscale
    into codicefiscalelav
    from an_lavoratore
    where CDNLAVORATORE = cdnLavVar;

    nl := xmldom.getElementsByTagName(doc, '*');
    lenDom := xmldom.getLength(nl);

    for i in 0..lenDom-1 loop
      n := xmldom.item(nl, i);
      if (xmldom.getNodeName(n) = 'codiceentetit') then
        n := xmldom.getFirstChild(n);
        if xmldom.getNodeType(n) = xmldom.TEXT_NODE then
          codiceentetit_val := xmldom.getNodeValue(n);
        end if;
      else
        if (xmldom.getNodeName(n) = 'datadinascita') then
          n := xmldom.getFirstChild(n);
          if xmldom.getNodeType(n) = xmldom.TEXT_NODE then
            datadinascita_val := to_date(xmldom.getNodeValue(n), 'yyyy-mm-dd');
          end if;
        end if;
      end if;

    end loop;

    insert into SP_LAVORATORE (PRGSPLAV, DATAINVIOMIN, CODENTETIT, DATNASC, CDNLAVORATORE, STRCODICEFISCALE, CODSTATO, DATINIZIOVAL, CDNUTINS, DTMINS, CDNUTMOD, DTMMOD) values
      (S_SP_LAVORATORE.nextval, sysdate, codiceentetit_val, datadinascita_val, cdnLavVar, codicefiscalelav, codStatoVar, sysdate, cdnUtenteVar, sysdate, cdnUtenteVar, sysdate);

  else
    --AGGIORNAMENTO
    numklo := numklo + 1;
    update SP_LAVORATORE set DATAINVIOMIN = sysdate, CDNUTMOD = cdnUtenteVar, DTMMOD = sysdate, CODSTATO = codStatoVar, NUMKLOSAP = numklo
    where PRGSPLAV = progressivolav;

  end if;

  --COMMIT;

  RETURN '00';

EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RETURN '29';

END inserisciDatiInvio;

FUNCTION getXMLSAPNOCOMPETENZA (cdnLavVar an_lavoratore.cdnlavoratore%type, p_key varchar2, cdnUtenteVar an_lavoratore.cdnutins%type, codStatoVar ts_tracciamento_sap.codtipovariazione%type, cpititSap de_cpi.codcpimin%type, errCodeOut out de_sap_yg_errore.coderrore%type) RETURN CLOB IS
  doc xmldom.DOMDocument;
  doc1 xmldom.DOMDocument;
  main_node xmldom.DOMNode;
  root_node xmldom.DOMNode;

  datiAnagrafici_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt_datianag xmldom.DOMElement;
  datAnagLav_node xmldom.DOMNode;
  esitoDatiInvio de_sap_yg_errore.coderrore%type;
  esitoDatiAnag de_sap_yg_errore.coderrore%type;
  esitoDatiAmm de_sap_yg_errore.coderrore%type;
  esitoDatiEspLav de_sap_yg_errore.coderrore%type;
  esitoDatiIstruz de_sap_yg_errore.coderrore%type;
  esitoDatiAllegato de_sap_yg_errore.coderrore%type;
  esitoDatiPolAtt de_sap_yg_errore.coderrore%type;
  esitoTabella de_sap_yg_errore.coderrore%type;

  xml_response CLOB;

BEGIN
  doc := xmldom.newDOMDocument;
  main_node := xmldom.makeNode(doc);
  root_elmt := xmldom.createElement(doc, 'lavoratore');
  root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));

  --00 NO ERRORI
  errCodeOut := '00';

  esitoDatiInvio := PG_SAP.getDatiInvioSAP(doc, root_node, cdnLavVar, codStatoVar, cpititSap);
  if (esitoDatiInvio <> '00') then
    errCodeOut := esitoDatiInvio;
  else
        esitoDatiPolAtt := PG_SAP.getPoliticheAttive(doc, root_node, cdnLavVar);
        if (esitoDatiPolAtt <> '00') then
          errCodeOut := esitoDatiPolAtt;
        end if;
  end if;

  DBMS_LOB.CreateTemporary(xml_response, TRUE);
  xmldom.WRITETOCLOB(doc, xml_response);
  xmldom.freeDocument(doc);

  return xml_response;

EXCEPTION
  WHEN OTHERS THEN
    errCodeOut := '30';
    if (xmldom.isNull(doc) = FALSE) then
      DBMS_LOB.CreateTemporary(xml_response, TRUE);
      xmldom.WRITETOCLOB(doc, xml_response);
      xmldom.freeDocument(doc);
      return xml_response;
    else
      return null;
    end if;

END getXMLSAPNOCOMPETENZA;

FUNCTION getAllegatoSAPNOCOMPETENZA (doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode, cdnLavVar an_lavoratore.cdnlavoratore%type) RETURN de_sap_yg_errore.coderrore%type IS

  main_node xmldom.DOMNode;
  root_elmt xmldom.DOMElement;
  item_elmt xmldom.DOMElement;

  item_text xmldom.DOMText;
  item_node xmldom.DOMNode;


BEGIN
  --allegato
  if (xmldom.isNull(doc) = FALSE) then
    root_elmt := xmldom.createElement(doc, 'allegato');
    main_node := xmldom.appendChild(root_node, xmldom.makeNode(root_elmt));
  else
    doc := xmldom.newDOMDocument;
    main_node := xmldom.makeNode(doc);
    root_elmt := xmldom.createElement(doc, 'allegato');
    root_node := xmldom.appendChild(main_node, xmldom.makeNode(root_elmt));
    main_node := root_node;
  end if;

  return '00';

EXCEPTION
  WHEN OTHERS THEN
    return '18';

END getAllegatoSAPNOCOMPETENZA;


/***************************
* funzione per la creazione dell'xml da inviare a YG
* inserisce il clob nella tabella TS_TRACCIAMENTO_SAP
***************************/
FUNCTION invioXMLSAP (cdnLavVar an_lavoratore.cdnlavoratore%type, p_key varchar2, p_cdnut ts_utente.cdnut%type, codTipoVariazioneVar ts_tracciamento_sap.codtipovariazione%type, codStatoVar sp_lavoratore.codStato%type, errCodeOut out de_sap_yg_errore.coderrore%type) RETURN CLOB IS
  xml_response CLOB;

BEGIN

   -- genero l'xml SAP (dalla 0 alla 6)
   -- viene inserito anche il record in SP_LAVORATORE
   xml_response := pg_sap.getXMLSAP(cdnLavVar, p_key, p_cdnut, codStatoVar, null, null, errCodeOut);

   INSERT INTO TS_TRACCIAMENTO_SAP (PRGESTRAZIONESAP, CDNLAVORATORE, DTMESTRAZIONE, STRXMLINVIATO, CODERRESTRAZIONE, DATINVIOMIN, CODTIPOVARIAZIONE) values
      (S_TS_TRACCIAMENTO_SAP.nextval, cdnLavVar, sysdate, xml_response, errCodeOut, sysdate, codTipoVariazioneVar);

   return xml_response;

EXCEPTION
  WHEN OTHERS THEN
      return null;

END invioXMLSAP;

FUNCTION getLavoratoriBatchSap return INT_ARRAY is

   p_codminsap sp_lavoratore.codminsap%type ;
   p_coderrestrazione ts_tracciamento_sap.coderrestrazione%type;
   p_stresitomin ts_tracciamento_sap.stresitomin%type;
   maxPrgTs ts_tracciamento_sap.prgestrazionesap%type;
   checkSpLav number;
   checkTsLav number;

   skipLavoratore number;
   countLavBatch number;

   CURSOR cursorLavoratori is
    SELECT DISTINCT l.cdnLavoratore
    from an_lavoratore l
    INNER JOIN an_lav_storia_inf ai ON (l.cdnlavoratore=ai.cdnlavoratore AND ai.datfine IS NULL)        
    where l.datnasc >= to_date('01/01/1949','dd/mm/yyyy')
    and ai.codmonotipocpi = 'C'   
        minus 
    select distinct ts.cdnlavoratore
    from ts_tracciamento_sap ts     
    where ts.codminsap is not null
    ;

   rec_Lavoratori cursorLavoratori%ROWTYPE;
   cdnLavoratoreVar an_lavoratore.cdnLavoratore%type;

   arrayLavoratori INT_ARRAY := INT_ARRAY(1);
   numArray number;
   totArray number;

BEGIN
   countLavBatch := 0;

   FOR rec_Lavoratori IN cursorLavoratori LOOP
      skipLavoratore := 0;
      cdnLavoratoreVar := rec_Lavoratori.cdnLavoratore;


      -- verifica esistenza CODMINSAP per il lavoratore
      /*select count(1)
      into checkSpLav
      from ts_tracciamento_sap sp
      where sp.cdnlavoratore = cdnLavoratoreVar
      and sp.codminsap is not null;

      if (checkSpLav > 0) then
         skipLavoratore := 1;
      end if;
      */
      
      -- verifica errore nella generazione dell'xml
      -- verifica se l'esito dell'invio prec ha una anomalia
      if (skipLavoratore = 0) then
         select count(ts.coderrestrazione)
         into checkTsLav
         from ts_tracciamento_sap ts
         where ts.cdnlavoratore = cdnLavoratoreVar;

         if (checkTsLav > 0) then
            select max(ts.prgestrazionesap)
            into maxPrgTs
            from ts_tracciamento_sap ts
            where ts.cdnlavoratore = cdnLavoratoreVar;

            select ts.coderrestrazione, ts.stresitomin
            into p_coderrestrazione, p_stresitomin
            from ts_tracciamento_sap ts
            where ts.prgestrazionesap = maxPrgTs;

            if (p_coderrestrazione <> '00') then
               skipLavoratore := 1;
            elsif (trim(p_stresitomin) = 'KO') then
               skipLavoratore := 1;
            end if;          
         end if;
      end if;


      if (skipLavoratore = 0) then
        arrayLavoratori.Extend;
        arrayLavoratori(countLavBatch+1) := cdnLavoratoreVar;

        countLavBatch := countLavBatch+1;
        EXIT WHEN countLavBatch = 3000;
      end if;
   END LOOP;

   arrayLavoratori.Trim;

   --dbms_output.put_line(arrayLavoratori.Count);
   return arrayLavoratori;

EXCEPTION
  WHEN OTHERS THEN
      dbms_output.put_line('errore irreversibile');
      return null;

END getLavoratoriBatchSap;



FUNCTION getIdentificativoPolitica ( cdnLavVar an_lavoratore.cdnlavoratore%type,prgPattoLavVar AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE%type ) RETURN varchar2 IS
 
	CURSOR codiciProvinciali IS
		select codprovincia 
		from de_provincia , de_regione, Ts_Generale 
		where de_provincia.codregione = de_regione.codregione 
		and codRegioneSil = de_regione.codregione
		order by codprovincia;
 
  rec_Provincie codiciProvinciali%ROWTYPE;
  prgPatto_a02 AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE%type;
  prgPercorso_a02 OR_PERCORSO_CONCORDATO.PRGPERCORSO%type;
  currentProvincia TS_GENERALE.codprovinciasil%type;
  codMinSap SP_LAVORATORE.codminsap%type;
  soggettoId DE_REGIONE.codmin%type;
  codcpimin_a02 de_cpi.codcpimin%type;
  codProv de_provincia.codprovincia%type;
  
  contatoreProvincia number;
  lengthStr number;
     
  identificativo_politica_a02 varchar2(11);  
  codice_controllo varchar2(5);  
  prgPercorso_hex varchar2(7);
  cod3 varchar2(10);
  data_coll_a02 varchar2(8); 
  cod4_10 varchar2(7);
  testo_codice_controllo varchar2(33);
  
BEGIN
 	 
  select codmin 
  into soggettoId
  from DE_REGIONE, TS_GENERALE
  where codRegioneSil = codregione;
  
  select codprovinciasil 
  into currentProvincia
  from ts_generale;
   
  contatoreProvincia := 1;
  
  FOR rec_Provincie IN codiciProvinciali LOOP
  	codProv := rec_Provincie.codprovincia;
	if(codProv = currentProvincia) then
		cod3 := to_char(contatoreProvincia);
	end if;
  	contatoreProvincia := contatoreProvincia + 1;
  END LOOP;

BEGIN
  select SP_LAVORATORE.CODMINSAP
  into codMinSap
  from SP_LAVORATORE
  WHERE CDNLAVORATORE = cdnLavVar
  and SP_LAVORATORE.DATFINEVAL is null;
 EXCEPTION
  WHEN OTHERS THEN
    codMinSap :='';
 END;
  
  codice_controllo := '';
 
BEGIN 
SELECT CODCPIMIN, dataColl, PRGPATTOLAVORATORE, PRGPERCORSO 
 into codcpimin_a02, data_coll_a02, prgPatto_a02, prgPercorso_a02 
FROM (
 SELECT  DE_CPI.CODCPIMIN , TO_CHAR(COLL.DATCOLLOQUIO, 'YYYYMMDD') as dataColl,
  	AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE, CONC.PRGPERCORSO
    FROM OR_COLLOQUIO COLL
      INNER JOIN OR_PERCORSO_CONCORDATO CONC
            ON (CONC.PRGCOLLOQUIO = COLL.PRGCOLLOQUIO)
      INNER JOIN MA_AZIONE_TIPOATTIVITA
      ON (CONC.PRGAZIONI = MA_AZIONE_TIPOATTIVITA.PRGAZIONI)
	  INNER JOIN DE_AZIONE
      ON (CONC.PRGAZIONI = DE_AZIONE.PRGAZIONI)
      INNER JOIN DE_CPI_VALIDITA_MIN DE_CPI
            ON (COLL.CODCPI = DE_CPI.CODCPISIL)
	 INNER JOIN DE_ESITO
        ON (DE_ESITO.CODESITO = CONC.CODESITO AND DE_ESITO.Codeventomin IS NOT NULL )
	  LEFT JOIN AM_LAV_PATTO_SCELTA
	  		ON (TO_NUMBER(STRCHIAVETABELLA) = CONC.PRGPERCORSO AND UPPER(CODLSTTAB) = 'OR_PER')
	  INNER JOIN AM_PATTO_LAVORATORE
	  		ON (AM_LAV_PATTO_SCELTA.PRGPATTOLAVORATORE = AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE)
    WHERE (COLL.CDNLAVORATORE = cdnLavVar) and MA_AZIONE_TIPOATTIVITA.CODTIPOATTIVITA = 'A02' and AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE = prgPattoLavVar and
	(trunc(COLL.DATCOLLOQUIO) between trunc(MA_AZIONE_TIPOATTIVITA.DATINIZIOVAL) and trunc(MA_AZIONE_TIPOATTIVITA.DATFINEVAL)) and
	(trunc(COLL.DATCOLLOQUIO) between trunc(DE_CPI.DATINIZIOVAL) and trunc(DE_CPI.DATFINEVAL)) and
	(DE_AZIONE.CODPROGETTO = '05')
	ORDER BY COLL.DATCOLLOQUIO desc)  tabPolitica 
	 where rownum = 1;
 EXCEPTION
  WHEN OTHERS THEN
    codcpimin_a02 :='';
	data_coll_a02 :='';
	prgPatto_a02 := null;
	prgPercorso_a02 := null;
 END;
	 	
	testo_codice_controllo := codMinSap || codcpimin_a02 || 'A02' || data_coll_a02;

	if(testo_codice_controllo is not null and testo_codice_controllo <> '''') then
		codice_controllo := PG_UTIL_CF_PARTIVA.codice_controllo(testo_codice_controllo);
	end if;
  
  prgPercorso_hex :='';
  cod4_10 := ''; 
  
  if(prgPercorso_a02 is not null) then
  
  	prgPercorso_hex := PG_UTIL_NUMBER.to_hex(prgPercorso_a02);
	lengthStr := length(prgPercorso_hex);
	select substr('0000000', 1 ,7- lengthStr)  
  	into cod4_10
  	from dual;
	
  end if;
  
  cod4_10 := cod4_10 || prgPercorso_hex;
  
  identificativo_politica_a02 := soggettoId || cod3 || cod4_10 || codice_controllo;
  
  return identificativo_politica_a02;

EXCEPTION
  WHEN OTHERS THEN
    return null;

END getIdentificativoPolitica;

FUNCTION getPoliticaA0205 ( cdnLavVar an_lavoratore.cdnlavoratore%type,prgPattoLavVar AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE%type ) RETURN varchar2 IS

  data_coll_a02 OR_COLLOQUIO.datcolloquio%type; 
  controlloData number;
  returnStr varchar2(2);

BEGIN 

	BEGIN
	SELECT dataColl
	 into data_coll_a02
	FROM (
	 SELECT  COLL.DATCOLLOQUIO as dataColl
		FROM OR_COLLOQUIO COLL
		  INNER JOIN OR_PERCORSO_CONCORDATO CONC
				ON (CONC.PRGCOLLOQUIO = COLL.PRGCOLLOQUIO)
		  INNER JOIN MA_AZIONE_TIPOATTIVITA
		  ON (CONC.PRGAZIONI = MA_AZIONE_TIPOATTIVITA.PRGAZIONI)
		  INNER JOIN DE_AZIONE
		  ON (CONC.PRGAZIONI = DE_AZIONE.PRGAZIONI)
		  INNER JOIN DE_CPI_VALIDITA_MIN DE_CPI
				ON (COLL.CODCPI = DE_CPI.CODCPISIL)
		 INNER JOIN DE_ESITO
			ON (DE_ESITO.CODESITO = CONC.CODESITO AND DE_ESITO.Codeventomin IS NOT NULL )
		  LEFT JOIN AM_LAV_PATTO_SCELTA
				ON (TO_NUMBER(STRCHIAVETABELLA) = CONC.PRGPERCORSO AND UPPER(CODLSTTAB) = 'OR_PER')
		  INNER JOIN AM_PATTO_LAVORATORE
				ON (AM_LAV_PATTO_SCELTA.PRGPATTOLAVORATORE = AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE)
		WHERE (COLL.CDNLAVORATORE = cdnLavVar) and MA_AZIONE_TIPOATTIVITA.CODTIPOATTIVITA = 'A02' and AM_PATTO_LAVORATORE.PRGPATTOLAVORATORE = prgPattoLavVar and
		(trunc(COLL.DATCOLLOQUIO) between trunc(MA_AZIONE_TIPOATTIVITA.DATINIZIOVAL) and trunc(MA_AZIONE_TIPOATTIVITA.DATFINEVAL)) and
		(trunc(COLL.DATCOLLOQUIO) between trunc(DE_CPI.DATINIZIOVAL) and trunc(DE_CPI.DATFINEVAL)) and
		(DE_AZIONE.CODPROGETTO = '05')
		ORDER BY COLL.DATCOLLOQUIO desc)  tabPolitica 
		 where rownum = 1;
	 EXCEPTION
	  WHEN OTHERS THEN
		data_coll_a02 := null;
	 END;
 
	returnStr:='';
	if (data_coll_a02 is not null) then
		select 
		extract( day from diff ) Days
		into controlloData
		from (
			select (CAST(data_coll_a02 as timestamp) - CAST(datsap2 as timestamp)) diff   
			from ts_generale
		 );
			
		if(controlloData >=0 ) then
			returnStr := 'OK';
		end if;
	end if;
  
	return returnStr;

EXCEPTION
  WHEN OTHERS THEN
    return null;

END getPoliticaA0205;

END PG_SAP;
/



/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_SIL_MONIT.sql
************************************************************************************** */


create or replace
package PG_SIL_MONIT is
  -- Author  : RICCARDI
  -- Created : 20/09/2006 16:28:18
  -- Purpose : Package di estrazione dati SIL per il monitoraggio

  -- Aggiunte funzioni estrazione mansione, contratto e orario
  --19/09/2008 Alessandro Pegoraro

 --*******************************************************
 --* PUBLIC                                              *
 --*******************************************************
function pdMaxTitoloStudio(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type) return VARCHAR2;
--
function pdMaxQualifica(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type) return VARCHAR2;
--
function pdDataMaxQualifica(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type) return DATE;
--
function pdLaureaConseguita(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type) return CHAR;
--
function getIdProvincia return varchar2;
--
function pdCalcoloEta(cdnLav in AN_LAVORATORE.CDNLAVORATORE%type, dataRif in DATE) return VARCHAR2;
--
function pdDataEtl return DATE;
--
function pdDataEtlarea(targetarea IN TS_MONITORAGGIO.CODAMBITO%TYPE) return DATE;
--
function recupera_prg_avviamento(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE) return AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
--
function pdColloquioEsistente(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type,
varDatInizio in AM_STATO_OCCUPAZ.DATINIZIO%type, varDatFine in AM_STATO_OCCUPAZ.DATFINE%type) return CHAR;
--
function pdLmpEsistente(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type,
varDatInizio in AM_STATO_OCCUPAZ.DATINIZIO%type, varDatFine in AM_STATO_OCCUPAZ.DATFINE%type) return CHAR;
--
function pdGetCat181 (cdnParLav an_lavoratore.CDNLAVORATORE%type,
dataParCalcolo an_lavoratore.DATNASC%type, flgVarObbScol am_obbligo_formativo.FLGOBBLIGOSCOLASTICO%type,
dataVarNascita an_lavoratore.DATNASC%type, sessoVarLav an_lavoratore.STRSESSO%type) return CHAR;
--
function pdMesiInAttivita (cdnParLav an_lavoratore.CDNLAVORATORE%type, dataParCalcolo an_lavoratore.DATNASC%type) return int;
--
function pdDonnaInReinserimento (mesiInattivita int, sessoParLav an_lavoratore.STRSESSO%type, eta int,
flgVarLaurea de_titolo.FLGLAUREA%type) return boolean;
--
function pdQualificaIscr (cdnParLav an_lavoratore.CDNLAVORATORE%type, dataParCalcolo an_lavoratore.DATNASC%type)
return am_movimento.CODMANSIONE%type;
--
function pdDisInocLungaDurata (cdnParLav an_lavoratore.CDNLAVORATORE%type, dataVarNascita an_lavoratore.DATNASC%type,
dataParCalcolo an_lavoratore.DATNASC%type, flgVarObbScol am_obbligo_formativo.FLGOBBLIGOSCOLASTICO%type) return CHAR;
--
function pdDurataDisInocPrec (cdnParLav an_lavoratore.CDNLAVORATORE%type, dataParCalcolo an_lavoratore.DATNASC%type) return NUMBER;
--
function pdDisInocLungaDurataUsc (cdnParLav an_lavoratore.CDNLAVORATORE%type, dataVarNascita an_lavoratore.DATNASC%type,
dataParCalcolo an_lavoratore.DATNASC%type, flgVarObbScol am_obbligo_formativo.FLGOBBLIGOSCOLASTICO%type) return CHAR;
--
/* Aggiunte 19/09/2008 Alessandro P. */
function getMansioneric(prgrich DO_RICHIESTA_AZ.prgrichiestaaz%type) return VARCHAR2;
--
function getcodcontrattoric(prgrich DO_RICHIESTA_AZ.prgrichiestaaz%type) return VARCHAR2;
--
function getcodorarioric(prgrich DO_RICHIESTA_AZ.prgrichiestaaz%type) return VARCHAR2;

function getMansioneusc(prgmob am_mobilita_iscr.PRGMOBILITAISCR%type)return VARCHAR2;

function no_dot(p_value varchar2) return varchar2;
/* * * * * * * * * * * * * * * * * * */

function GetPrgNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.PRGNULLAOSTA%TYPE;

function GetTipoNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOTIPO%TYPE;

function GetCatNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                 Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                     Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                     Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOCATEGORIA%TYPE;

function GetStatoNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN am_documento.CODSTATOATTO%TYPE;

function GetDtmModNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.DTMMOD%TYPE;

function GetDtmInsNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.DTMINS%TYPE;

function GetTipoIscrCmCompatibile(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   PprgAzienda IN am_movimento.PRGAZIENDA%TYPE,
                                     PdatInizioMov IN am_movimento.DATINIZIOMOV%TYPE,
                                    PchiaveCrypt IN varchar2) RETURN AM_CM_ISCR.CODCMTIPOISCR%TYPE;

function GetTipoInvIscrCmCompatibile(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                     PprgAzienda IN am_movimento.PRGAZIENDA%TYPE,
                                     PdatInizioMov IN am_movimento.DATINIZIOMOV%TYPE,
                                    PchiaveCrypt IN varchar2) RETURN AM_CM_ISCR.CODTIPOINVALIDITA%TYPE;

function GetPercInvIscrCmCompatibile(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                     PprgAzienda IN am_movimento.PRGAZIENDA%TYPE,
                                     PdatInizioMov IN am_movimento.DATINIZIOMOV%TYPE,
                                    PchiaveCrypt IN varchar2) RETURN AM_CM_ISCR.NUMPERCINVALIDITA%TYPE;

function recupera_prg_avv_effettivo(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE) return AM_MOVIMENTO.PRGMOVIMENTO%TYPE;

function recupera_ultimo_mov(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE, prgMovSucc IN AM_MOVIMENTO.PRGMOVIMENTOSUCC%TYPE)
            RETURN AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
            
function checkflgAgevolazione(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE) return CHAR;

function recupera_codContratto(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)  RETURN AM_MOVIMENTO.CODCONTRATTO%TYPE;

function calcolaPrecedente(prgMovprec IN AM_MOVIMENTO.PRGMOVIMENTOPREC%TYPE)
            RETURN AM_MOVIMENTO.PRGMOVIMENTOPREC%TYPE;  
            
function calcolaSuccessivo(prgMovSucc IN AM_MOVIMENTO.PRGMOVIMENTOSUCC%TYPE)
            RETURN AM_MOVIMENTO.PRGMOVIMENTO%TYPE;   
            
function recupera_codMansione(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)  RETURN AM_MOVIMENTO.CODMANSIONE%TYPE;

function GetPrgComputoDaMov(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                   Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                   Pdatfinemov IN am_movimento.DATFINEMOV%TYPE) RETURN CM_RICH_COMPUTO.PRGRICHCOMPUTO%TYPE;
                                   
function GetTipoAssunzioneDaMov(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                  Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pprgunita IN AM_MOVIMENTO.PRGUNITA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pdatfinemov IN AM_MOVIMENTO.DATFINEMOV%TYPE,
                                  Pcodtipoass IN AM_MOVIMENTO.CODTIPOASS%TYPE,
                                  PFlag68 IN AM_MOVIMENTO.FLGLEGGE68%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOTIPO%TYPE;
                                  
function GetPrgNullaOstaDaMovProt(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.PRGNULLAOSTA%TYPE;
                                  
function GetCatNullaOstaDaMovProt(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOCATEGORIA%TYPE;
                                  
function GetTipoIscrCmComp(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                     PprgAzienda IN am_movimento.PRGAZIENDA%TYPE,
                                     PdatInizioMov IN am_movimento.DATINIZIOMOV%TYPE,
                                     PchiaveCrypt IN varchar2) RETURN DE_CM_TIPO_ISCR.CODMONOTIPORAGG%TYPE;
                                     
                                     
function GetTipoDisabDF(Pcdnlavoratore IN am_cm_iscr.CDNLAVORATORE%TYPE) RETURN varchar2;

function GetMinDtInizioIscrCM(Pcdnlavoratore IN am_cm_iscr.CDNLAVORATORE%TYPE) RETURN Number;

function GetFlgIscrCm( pi_cdnlavoratore IN am_movimento.cdnlavoratore%TYPE, pi_datiniziomov IN am_movimento.datiniziomov%TYPE, pi_chiaveCrypt IN varchar2) RETURN VARCHAR2;

end PG_SIL_MONIT;
/

create or replace
package body           PG_SIL_MONIT is
/**
estrae la mansione di uscita per il monitoraggio.
join con AM_MOVIMENTO per la condizione sulla data fine mobilità
*/
function getMansioneusc(prgmob am_mobilita_iscr.PRGMOBILITAISCR%type) return VARCHAR2 IS
ret_val VARCHAR2(8) := 1;
cod_man AM_MOVIMENTO.CODMANSIONE%TYPE;
cod_fine AM_MOBILITA_ISCR.CODMOTIVOFINE%TYPE;
cdn_lav  AM_MOBILITA_ISCR.CDNLAVORATORE%TYPE;
dat_fine_mb AM_MOBILITA_ISCR.DATFINE%TYPE;
cnt   number := 0;
v_error_code       PLS_INTEGER;
v_error_message    VARCHAR2 (500);
begin

select cdnlavoratore,codmotivofine,datfine into cdn_lav,cod_fine,dat_fine_mb from am_mobilita_iscr where PRGMOBILITAISCR = prgmob;

cod_man := 'NP';
select mov_ass.codmansione into cod_man from am_movimento mov_ass
    where (MOV_ASS.CDNLAVORATORE = cdn_lav)
    and mov_ass.datiniziomov = dat_fine_mb + 1 and MOV_ASS.CODTIPOMOV = 'AVV'
    and mov_ass.codmonotempo = 'I' and mov_ass.codorario = 'F' and mov_ass.codstatoatto = 'PR';
IF (cod_fine <> 'G' ) THEN
 return 'NP';
END IF;

return cod_man;
/* if empty return NP */
EXCEPTION
    when NO_DATA_FOUND then
        return 'NP';
     when OTHERS then
        v_error_code := SQLCODE;
        v_error_message := SQLERRM;
        dbms_output.put_line(v_error_message);
        return '1';
end getMansioneusc;
--
/***
Estrae il codorario della richiesta
join con la do_orario, torna 2 se per il profilo sono stati inseriti 2 o più orari */
function getcodorarioric(prgrich DO_RICHIESTA_AZ.prgrichiestaaz%type) return VARCHAR2 IS
ret_val VARCHAR2(8) := 1;
cod_ora DO_CONTRATTO.CODCONTRATTO%TYPE;
cnt   number := 0;
begin
select count(1) into cnt FROM DO_ALTERNATIVA do_alt2 INNER JOIN DO_ORARIO do_ora  ON do_alt2.prgrichiestaaz = do_ora.prgrichiestaaz AND do_alt2.prgalternativa = '1' WHERE do_alt2.prgrichiestaaz = prgrich;
     IF (cnt = 1) THEN
     select do_ora.codorario INTO cod_ora FROM DO_ALTERNATIVA do_alt2 INNER JOIN DO_ORARIO do_ora  ON do_alt2.prgrichiestaaz = do_ora.prgrichiestaaz AND do_alt2.prgalternativa = '1' WHERE do_alt2.prgrichiestaaz = prgrich;
      RETURN cod_ora;
  ELSIF (cnt > 1) THEN
    RETURN '2';
  ELSE RETURN '1';
 END IF;
EXCEPTION when OTHERS then
    return '1';
end getcodorarioric;
--
/*
Estrae il numero dei contratti del profilo aventi prgalternativa =1
torna il codcontratto se ne trova solo 1
*/
function getcodcontrattoric(prgrich do_richiesta_az.prgrichiestaaz%type) return varchar2 is
ret_val varchar2(8) := 1;
cod_cont do_contratto.codcontratto%type;
cnt   number := 0;
begin
select count(1) into cnt from do_alternativa do_alt2 inner join do_contratto do_con  on do_alt2.prgrichiestaaz = do_con.prgrichiestaaz and do_alt2.prgalternativa = '1' where do_alt2.prgrichiestaaz = prgrich;
     if (cnt = 1) then
     select do_con.codcontratto into cod_cont from do_alternativa do_alt inner join do_contratto do_con  on do_alt.prgrichiestaaz = do_con.prgrichiestaaz and do_alt.prgalternativa = '1' where do_alt.prgrichiestaaz = prgrich;
      return cod_cont;
  elsif (cnt > 1) then
    return '2';
  else return '1';
 end if;
exception when others then
    return '1';
end getcodcontrattoric;
--
/**
Si effettua la ricerca su prgrichiestaaz, con alternativa = 1, ritornando il codmansione se ne viene trovata
solo 1. 2, o 1 altrimenti
*/
function getmansioneric(prgrich do_richiesta_az.prgrichiestaaz%type) return varchar2 is
ret_val varchar2(8);
cod_mans do_mansione.codmansione%type;
cnt   number := 0;
begin
 select count(1) into cnt
 from do_alternativa do_alt1
   inner join do_mansione do_man  on do_alt1.prgrichiestaaz = do_man.prgrichiestaaz and do_alt1.prgalternativa = '1'
 where do_alt1.prgrichiestaaz = prgrich;
      if (cnt = 1)
    then select codmansione into ret_val from do_mansione doman where doman.prgrichiestaaz = prgrich;
    elsif (cnt > 1)
     then ret_val := '2';
    else ret_val := '1';
   end if;
 return (ret_val);
exception when others then
    return '1';
end getmansioneric;
--
function pdMaxTitoloStudio(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type) return VARCHAR2 IS
    varTitolo pr_studio.codTitolo%type;
begin
    select codtitolo into varTitolo
   from (
   select strPeso,st.codTitolo
   from pr_studio st, de_rel_titolo_monit rt
   where (st.CODTITOLO=rt.CODTITOLO)
   and st.cdnlavoratore=varCdnLavoratore
   and st.CODMONOSTATO='C'
   order by 1 desc, 2 desc
   )where rownum=1;

   return(varTitolo);
 exception
  when OTHERS then
    return null;
end pdMaxTitoloStudio;
--
function pdMaxQualifica(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type) return VARCHAR2 IS
    varQualifica pr_mansione.codmansione%type;
begin
    select nvl(min(pr_mansione.codmansione), 'NT')
   into varQualifica
   from pr_mansione
  where pr_mansione.cdnlavoratore=varCdnLavoratore and
        pr_mansione.flgdisponibile='S';

    return(varQualifica);
exception
    when OTHERS then
       return 'NT';
end pdMaxQualifica;
--
function pdDataMaxQualifica(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type) return DATE IS
    datQualifica date;
begin
    select dtmins
 into datQualifica
 from pr_mansione
 where cdnlavoratore = varCdnLavoratore
      and codmansione = PG_SIL_MONIT.pdMaxQualifica(varCdnlavoratore);
 return datQualifica;
exception when others then
    return null;
end pdDataMaxQualifica;
--
function pdLaureaConseguita(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type) return CHAR IS
    flg_laurea char;
begin
 select decode(count(pr_studio.PRGSTUDIO), 0, 'N','S' )
   into flg_laurea
   from pr_studio, de_titolo
  where pr_studio.CDNLAVORATORE = varCdnLavoratore and
        pr_studio.CODMONOSTATO = 'C' and
        pr_studio.CODTITOLO = de_titolo.CODTITOLO and
     de_titolo.FLGLAUREA = 'S';
    return flg_laurea;
exception when others then
    return null;
end pdLaureaConseguita;
--
function getIdProvincia return varchar2 is
      idProvincia VARCHAR2(8);
begin
  select ts_generale.CODPROVINCIASIL into idProvincia from TS_GENERALE;
  return idProvincia;
  exception
  when OTHERS then
       return null;
end getIdProvincia;
--
function pdCalcoloEta(cdnLav in AN_LAVORATORE.CDNLAVORATORE%type, dataRif in DATE) return VARCHAR2 IS
    v_id_eta VARCHAR2(3);
	v_data_nascita DATE;
	v_diff_anni    NUMBER;
    v_mese_ass     NUMBER;
    v_mese_nas     NUMBER;
    v_gg_ass       NUMBER;
    v_gg_nas       NUMBER;
begin
	select datnasc 
		into v_data_nascita
	from an_lavoratore where cdnlavoratore = cdnLav;

	-- DIFFERENZA in anni
    SELECT (extract(YEAR FROM dataRif) - extract(YEAR FROM v_data_nascita))
		INTO v_diff_anni
    FROM DUAL;
    SELECT extract(MONTH FROM v_data_nascita) INTO v_mese_nas FROM DUAL;
    SELECT extract(MONTH FROM dataRif) INTO v_mese_ass FROM DUAL;
    SELECT extract(DAY FROM v_data_nascita) INTO v_gg_nas FROM DUAL;
    SELECT extract(DAY FROM dataRif) INTO v_gg_ass FROM DUAL;
    IF v_mese_ass       > v_mese_nas THEN
      v_id_eta   := v_diff_anni;
    ELSIF( v_mese_ass   < v_mese_nas) THEN
      v_id_eta   := v_diff_anni - 1;
    ELSIF( v_mese_ass   = v_mese_nas) THEN
      IF(v_gg_ass      >= v_gg_nas) THEN
        v_id_eta := v_diff_anni;
      ELSE
        v_id_eta := v_diff_anni - 1;
      END IF;
    END IF;

	if (v_id_eta>99 OR v_id_eta<15) then
		v_id_eta :=1;
	end if;
	return v_id_eta;
  exception
   when OTHERS then
         return 1;
end pdCalcoloEta;
--  v2.0 le dateETL sono suddivise per area
function pdDataEtlarea(targetarea IN TS_MONITORAGGIO.CODAMBITO%TYPE) return DATE IS
 datEtl date;
begin
    select datEtl into datEtl from ts_monitoraggio WHERE CODAMBITO = targetarea;
 return datEtl;

 exception
 when OTHERS then
      return null;
end pdDataEtlarea;
-- DEPRECATA - NON USARE sta qui per compatibilità
function pdDataEtl return DATE IS
 datEtl date;
begin
    select datEtl into datEtl from ts_generale;
 return datEtl;

 exception
 when OTHERS then
      return null;
end pdDataEtl;
--
function recupera_prg_avviamento(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
            RETURN AM_MOVIMENTO.PRGMOVIMENTO%TYPE
IS
 rowMov AM_MOVIMENTO%ROWTYPE;
 prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
BEGIN

 -- Continuo a recuperare il record del movimento precedente finche' non trovo quello con 'AVV' (o non ce l'ho).
 prgMovCiclo := prgMov;
 LOOP

  IF prgMovCiclo IS NULL THEN
     EXIT;
  END IF;

  -- Recupero il record relativo al prgMovimento in ingresso
  SELECT MOV.*
  INTO rowMov
  FROM AM_MOVIMENTO MOV
  WHERE MOV.PRGMOVIMENTO = prgMovCiclo;

  -- Se non trovato, esco dal ciclo
  EXIT WHEN SQL%NOTFOUND;

  -- Se ho trovato il movimento con 'AVV', rendo il record
  IF rowMov.CODTIPOMOV = 'AVV' THEN
   RETURN rowMov.PRGMOVIMENTO;
  END IF;

  -- Continuo a ciclare (passo al movimento precedente)
  prgMovCiclo := rowMov.PRGMOVIMENTOPREC;

 END LOOP;

 RETURN NULL;

END recupera_prg_avviamento;
--
function pdColloquioEsistente(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type,
varDatInizio in AM_STATO_OCCUPAZ.DATINIZIO%type, varDatFine in AM_STATO_OCCUPAZ.DATFINE%type) return CHAR IS
    flg_colloquio char;
 num_coll number;
begin
 select count(*)
 into num_coll
 from or_colloquio coll, de_servizio serv
 where coll.cdnlavoratore = varCdnLavoratore and coll.codservizio = serv.codservizio
 and (serv.prgservizioarea = 2)
 and (nvl(varDatFine,to_date('31/12/9999','dd/mm/yyyy')) >= trunc(coll.datcolloquio)
   and varDatInizio <= trunc(coll.datcolloquio));

 if (num_coll > 0) then
  flg_colloquio := 'S';
 else
  flg_colloquio := 'N';
 end if;
    return flg_colloquio;
exception when others then
    return null;
end pdColloquioEsistente;
--
function pdLmpEsistente(varCdnLavoratore in AN_LAVORATORE.CDNLAVORATORE%type,
varDatInizio in AM_STATO_OCCUPAZ.DATINIZIO%type, varDatFine in AM_STATO_OCCUPAZ.DATFINE%type) return CHAR IS
    flg_lmp char;
 num_lmp number;
begin
 select count(*)
 into num_lmp
 from or_colloquio coll, de_servizio serv
 where coll.cdnlavoratore = varCdnLavoratore and coll.codservizio = serv.codservizio
 and (serv.prgservizioarea in (3,7,10,11,12))
 and (nvl(varDatFine,to_date('31/12/9999','dd/mm/yyyy')) >= trunc(coll.datcolloquio)
   and varDatInizio <= trunc(coll.datcolloquio));

 if (num_lmp > 0) then
  flg_lmp := 'S';
 else
  flg_lmp := 'N';
 end if;
    return flg_lmp;
exception when others then
    return null;
end pdLmpEsistente;
--
function pdGetCat181 (cdnParLav an_lavoratore.CDNLAVORATORE%type,
dataParCalcolo an_lavoratore.DATNASC%type, flgVarObbScol am_obbligo_formativo.FLGOBBLIGOSCOLASTICO%type,
dataVarNascita an_lavoratore.DATNASC%type, sessoVarLav an_lavoratore.STRSESSO%type) return CHAR is

resultVar char := '-';
eta int;
flgVarLaurea de_titolo.FLGLAUREA%type;
mesiVarInattivita int;

begin
 eta:= trunc(months_between(dataParCalcolo, dataVarNascita)/12);
 flgVarLaurea := pg_sil_monit.pdLaureaConseguita(cdnParLav);
 if (eta >= 15 and eta <= 18 and flgVarObbScol = 'S') then
  resultVar:= 'A';

 else
  if (eta > 18 and ((eta < 30 and flgVarLaurea = 'S') or eta < 26)) then
     resultVar:= 'G';
  end if;
 end if;

 mesiVarInattivita := pdMesiInAttivita(cdnParLav, dataParCalcolo);
 if (pdDonnaInReinserimento(mesiVarInattivita,sessoVarLav,eta,flgVarLaurea)) then
       resultVar := 'D';
 end if;

 return resultVar;

exception
   when others then
         return 'condizione non calcolabile';
end pdGetCat181;
--
function pdMesiInAttivita (cdnParLav an_lavoratore.CDNLAVORATORE%type, dataParCalcolo an_lavoratore.DATNASC%type) return int is
  mesiVar int:=0;
  numVarMovimenti int;
begin
  select count(*)
  into numVarMovimenti
  from am_movimento mov
  WHERE mov.cdnlavoratore = cdnParLav and mov.CODTIPOMOV <> 'CES'
  and mov.CODSTATOATTO = 'PR';

  if (numVarMovimenti > 0) then
   SELECT MIN(TRUNC (MONTHS_BETWEEN (dataParCalcolo,nvl(mov.datfinemovEffettiva,dataParCalcolo)))) as mesiInattivita
   into mesiVar
      FROM am_movimento mov
      WHERE mov.cdnlavoratore = cdnParLav and mov.CODTIPOMOV <> 'CES'
   and mov.CODSTATOATTO = 'PR';
  end if;
  return mesiVar;
  exception
     when others then --return 0;
     raise;
end pdMesiInAttivita;
--
function pdDonnaInReinserimento (mesiInattivita int, sessoParLav an_lavoratore.STRSESSO%type, eta int,
flgVarLaurea de_titolo.FLGLAUREA%type) return boolean is
  anni int;
  res boolean;
begin
  anni := trunc(mesiInattivita/12);
  res := (anni >= 2 and sessoParLav = 'F' and ((eta>25 and flgVarLaurea = 'N') or (eta>29 and flgVarLaurea = 'S')));
  return res;
end pdDonnaInReinserimento;
--
function pdQualificaIscr (cdnParLav an_lavoratore.CDNLAVORATORE%type, dataParCalcolo an_lavoratore.DATNASC%type)
return am_movimento.CODMANSIONE%type is
  cod_mans am_movimento.CODMANSIONE%type;
begin
  select codmansione into cod_mans
  from (
  select codmansione
  from am_movimento
  where cdnlavoratore = cdnParLav and datinizioavv <= dataParCalcolo
  and codtipomov = 'AVV' and codstatoatto = 'PR'
  order by datiniziomov desc )
  where rownum = 1;

  return cod_mans;
exception
  when others then
     return null;
end pdQualificaIscr;
--
function pdDisInocLungaDurata (cdnParLav an_lavoratore.CDNLAVORATORE%type, dataVarNascita an_lavoratore.DATNASC%type,
dataParCalcolo an_lavoratore.DATNASC%type, flgVarObbScol am_obbligo_formativo.FLGOBBLIGOSCOLASTICO%type) return CHAR is
  resultVar char := '-';
  flgVarLaurea de_titolo.FLGLAUREA%type;
  codVarStatoOccupaz am_stato_occupaz.codstatooccupaz%type;
  codVarStatoOccupazRagg de_stato_occupaz_ragg.codstatooccupazragg%type;
  codVarCat181 am_stato_occupaz.codcategoria181%type;
  catVar181 char := '';
  datVarInizio varchar2(12);
  datVarFine   varchar2(12);
  datVarAnzDisocc varchar2(12);
  datVarCalcoloAnzianita varchar2(12);
  datVarCalcoloSosp varchar2(12);
  numVarMesiTotAnz int;
  numVarCont int;
  eta int;

begin
  select count(*)
  into numVarCont
  from am_stato_occupaz, an_lav_storia_inf
  where am_stato_occupaz.CDNLAVORATORE = an_lav_storia_inf.CDNLAVORATORE
  and am_stato_occupaz.CDNLAVORATORE = cdnParLav
  and am_stato_occupaz.datfine IS NULL
  and an_lav_storia_inf.datfine IS NULL;

  if (numVarCont > 0) then

   SELECT am_stato_occupaz.codstatooccupaz,
           de_stato_occupaz_ragg.codstatooccupazragg,
           am_stato_occupaz.codcategoria181,
           TO_CHAR (am_stato_occupaz.datinizio, 'DD/MM/YYYY') datinizio,
           TO_CHAR (am_stato_occupaz.datfine, 'DD/MM/YYYY') datfine,
           TO_CHAR (am_stato_occupaz.datanzianitadisoc,'DD/MM/YYYY') datanzianitadisoc,
		   nvl(to_number(substr(PG_MOVIMENTI.CalcolaAnzianita(cdnParLav, to_char(dataParCalcolo, 'dd/mm/yyyy')), 1,
						 instr(PG_MOVIMENTI.CalcolaAnzianita(cdnParLav, to_char(dataParCalcolo, 'dd/mm/yyyy')), '-', 1)-1)), 0) mesi_anz_calc,
          to_char(am_stato_occupaz.datcalcoloanzianita,'DD/MM/YYYY') datcalcoloanzianita,
          to_char(am_stato_occupaz.datcalcolomesisosp,'DD/MM/YYYY') datcalcolomesisosp
  into codVarStatoOccupaz, codVarStatoOccupazRagg, codVarCat181, datVarInizio, datVarFine, datVarAnzDisocc, numVarMesiTotAnz,
	   datVarCalcoloAnzianita, datVarCalcoloSosp
     FROM am_stato_occupaz
          LEFT JOIN de_stato_atto ON (am_stato_occupaz.codstatoatto = de_stato_atto.codstatoatto)
          INNER JOIN de_stato_occupaz ON (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
          INNER JOIN de_stato_occupaz_ragg ON (de_stato_occupaz.codstatooccupazragg = de_stato_occupaz_ragg.codstatooccupazragg)
          INNER JOIN an_lav_storia_inf inf ON (am_stato_occupaz.cdnlavoratore = inf.cdnlavoratore)
        left JOIN de_cpi ON (de_cpi.codcpi = inf.codcpitit)
    WHERE trunc(am_stato_occupaz.DATINIZIO) <= trunc(dataParCalcolo) and
       (am_stato_occupaz.datfine IS NULL or trunc(am_stato_occupaz.datfine) >= trunc(dataParCalcolo))
          AND am_stato_occupaz.cdnlavoratore = cdnParLav
          AND inf.datfine IS NULL;

  
  eta:= trunc(months_between(dataParCalcolo, dataVarNascita)/12);
  flgVarLaurea := pg_sil_monit.pdLaureaConseguita(cdnParLav);
  if (eta >= 15 and eta <= 18 and flgVarObbScol = 'S') then
   catVar181:= 'A';

  else
   if (eta > 18 and ((eta < 30 and flgVarLaurea = 'S') or eta < 26)) then
      catVar181:= 'G';
   end if;
  end if;

  if (codVarStatoOccupazRagg is not null and
     ((numVarMesiTotAnz > 12) or (numVarMesiTotAnz > 6 and catVar181 = 'G'))) then
   if (codVarStatoOccupazRagg = 'D') then
    resultVar := 'D';
   else
    if (codVarStatoOccupazRagg = 'I') then
      resultVar := 'I';
 end if;
   end if;
  end if;
 end if;
 return resultVar;
 exception
  when others then
 --dbms_output.ENABLE( 1000 );
 --dbms_output.put_line(substr(sqlerrm, 1, 255));
   return '-';

end pdDisInocLungaDurata;
--
function pdDurataDisInocPrec (cdnParLav an_lavoratore.CDNLAVORATORE%type, dataParCalcolo an_lavoratore.DATNASC%type) return NUMBER is
  resultVar char := '-';
  codVarStatoOccupaz am_stato_occupaz.codstatooccupaz%type;
  codVarStatoOccupazRagg de_stato_occupaz_ragg.codstatooccupazragg%type;
  codVarCat181 am_stato_occupaz.codcategoria181%type;
  datVarInizio varchar2(12);
  datVarFine   varchar2(12);
  datVarAnzDisocc varchar2(12);
  datVarCalcoloAnzianita varchar2(12);
  datVarCalcoloSosp varchar2(12);
  numVarMesiTotAnz number := 1000;
  numVarCont int;
  ris int := 1;

begin
  select count(*)
  into numVarCont
  from am_stato_occupaz, an_lav_storia_inf
  where am_stato_occupaz.CDNLAVORATORE = an_lav_storia_inf.CDNLAVORATORE
  and am_stato_occupaz.CDNLAVORATORE = cdnParLav
  and am_stato_occupaz.datfine IS NULL
  and an_lav_storia_inf.datfine IS NULL;

  if (numVarCont > 0) then

    begin
	
	SELECT am_stato_occupaz.codstatooccupaz,
            de_stato_occupaz_ragg.codstatooccupazragg,
            am_stato_occupaz.codcategoria181,
            TO_CHAR (am_stato_occupaz.datinizio, 'DD/MM/YYYY') datinizio,
            TO_CHAR (am_stato_occupaz.datfine, 'DD/MM/YYYY') datfine,
            TO_CHAR (am_stato_occupaz.datanzianitadisoc,'DD/MM/YYYY') datanzianitadisoc,
			nvl(to_number(substr(PG_MOVIMENTI.CalcolaAnzianita(cdnParLav, to_char(dataParCalcolo, 'dd/mm/yyyy')), 1,
						  instr(PG_MOVIMENTI.CalcolaAnzianita(cdnParLav, to_char(dataParCalcolo, 'dd/mm/yyyy')), '-', 1)-1)), 0) mesi_anz_calc,
           to_char(am_stato_occupaz.datcalcoloanzianita,'DD/MM/YYYY') datcalcoloanzianita,
           to_char(am_stato_occupaz.datcalcolomesisosp,'DD/MM/YYYY') datcalcolomesisosp
    INTO codVarStatoOccupaz, codVarStatoOccupazRagg, codVarCat181, datVarInizio, datVarFine, datVarAnzDisocc, numVarMesiTotAnz,
       datVarCalcoloAnzianita, datVarCalcoloSosp
     FROM am_stato_occupaz
          LEFT JOIN de_stato_atto ON (am_stato_occupaz.codstatoatto = de_stato_atto.codstatoatto)
          INNER JOIN de_stato_occupaz ON (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
          INNER JOIN de_stato_occupaz_ragg ON (de_stato_occupaz.codstatooccupazragg = de_stato_occupaz_ragg.codstatooccupazragg)
          INNER JOIN an_lav_storia_inf inf ON (am_stato_occupaz.cdnlavoratore = inf.cdnlavoratore)
          left JOIN de_cpi ON (de_cpi.codcpi = inf.codcpitit)
     WHERE trunc(am_stato_occupaz.DATINIZIO) <= trunc(dataParCalcolo)
       -- AND (am_stato_occupaz.datfine IS NULL or trunc(am_stato_occupaz.datfine) >= trunc(dataParCalcolo))
          AND (trunc(am_stato_occupaz.datfine) = trunc(dataParCalcolo - 1))
    AND am_stato_occupaz.cdnlavoratore = cdnParLav
          AND inf.datfine IS NULL;

	exception
		when others
			then ris := 0;
	end;
	
	if (ris = 0) then
		numVarMesiTotAnz := 1000;
	end if;
   
  end if;

  return numVarMesiTotAnz;

end pdDurataDisInocPrec;
--
function pdDisInocLungaDurataUsc (cdnParLav an_lavoratore.CDNLAVORATORE%type, dataVarNascita an_lavoratore.DATNASC%type,
dataParCalcolo an_lavoratore.DATNASC%type, flgVarObbScol am_obbligo_formativo.FLGOBBLIGOSCOLASTICO%type) return CHAR is
  resultVar char := '-';
  flgVarLaurea de_titolo.FLGLAUREA%type;
  codVarStatoOccupaz am_stato_occupaz.codstatooccupaz%type;
  codVarStatoOccupazRagg de_stato_occupaz_ragg.codstatooccupazragg%type;
  codVarCat181 am_stato_occupaz.codcategoria181%type;
  catVar181 char := '';
  datVarInizio varchar2(12);
  datVarFine   varchar2(12);
  datVarAnzDisocc varchar2(12);
  datVarCalcoloAnzianita varchar2(12);
  datVarCalcoloSosp varchar2(12);
  numVarMesiTotAnz number;
  numVarCont int;
  eta int;
  ris int := 1;

begin
  select count(*)
  into numVarCont
  from am_stato_occupaz, an_lav_storia_inf
  where am_stato_occupaz.CDNLAVORATORE = an_lav_storia_inf.CDNLAVORATORE
  and am_stato_occupaz.CDNLAVORATORE = cdnParLav
  and am_stato_occupaz.datfine IS NULL
  and an_lav_storia_inf.datfine IS NULL;

  if (numVarCont > 0) then

    begin
	
	SELECT am_stato_occupaz.codstatooccupaz,
            de_stato_occupaz_ragg.codstatooccupazragg,
            am_stato_occupaz.codcategoria181,
            TO_CHAR (am_stato_occupaz.datinizio, 'DD/MM/YYYY') datinizio,
            TO_CHAR (am_stato_occupaz.datfine, 'DD/MM/YYYY') datfine,
            TO_CHAR (am_stato_occupaz.datanzianitadisoc,'DD/MM/YYYY') datanzianitadisoc,
			nvl(to_number(substr(PG_MOVIMENTI.CalcolaAnzianita(cdnParLav, to_char(dataParCalcolo, 'dd/mm/yyyy')), 1,
						  instr(PG_MOVIMENTI.CalcolaAnzianita(cdnParLav, to_char(dataParCalcolo, 'dd/mm/yyyy')), '-', 1)-1)), 0) mesi_anz_calc,
           to_char(am_stato_occupaz.datcalcoloanzianita,'DD/MM/YYYY') datcalcoloanzianita,
           to_char(am_stato_occupaz.datcalcolomesisosp,'DD/MM/YYYY') datcalcolomesisosp
     INTO codVarStatoOccupaz, codVarStatoOccupazRagg, codVarCat181, datVarInizio, datVarFine, datVarAnzDisocc, numVarMesiTotAnz,
		  datVarCalcoloAnzianita, datVarCalcoloSosp
     FROM am_stato_occupaz
          LEFT JOIN de_stato_atto ON (am_stato_occupaz.codstatoatto = de_stato_atto.codstatoatto)
          INNER JOIN de_stato_occupaz ON (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
          INNER JOIN de_stato_occupaz_ragg ON (de_stato_occupaz.codstatooccupazragg = de_stato_occupaz_ragg.codstatooccupazragg)
          INNER JOIN an_lav_storia_inf inf ON (am_stato_occupaz.cdnlavoratore = inf.cdnlavoratore)
          left JOIN de_cpi ON (de_cpi.codcpi = inf.codcpitit)
     WHERE trunc(am_stato_occupaz.DATINIZIO) <= trunc(dataParCalcolo)
          AND (trunc(am_stato_occupaz.datfine) = trunc(dataParCalcolo - 1))
       AND am_stato_occupaz.cdnlavoratore = cdnParLav
          AND inf.datfine IS NULL;

	exception
      when others then
         ris := 0;
	end;
     
	if (ris = 1) then
      eta:= trunc(months_between(dataParCalcolo, dataVarNascita)/12);
      flgVarLaurea := pg_sil_monit.pdLaureaConseguita(cdnParLav);
      if (eta >= 15 and eta <= 18 and flgVarObbScol = 'S') then
           catVar181:= 'A';
      else
          if (eta > 18 and ((eta < 30 and flgVarLaurea = 'S') or eta < 26)) then
              catVar181:= 'G';
          end if;
      end if;

      if (codVarStatoOccupazRagg is not null and ((numVarMesiTotAnz > 12) or (numVarMesiTotAnz > 6 and catVar181 = 'G'))) then
		if (codVarStatoOccupazRagg = 'D') then
         resultVar := 'D';
        else
			if (codVarStatoOccupazRagg = 'I') then
				resultVar := 'I';
			end if;
        end if;
      end if;
   
   else
     resultVar := '-';
   end if;
   
 end if;

 return resultVar;
end pdDisInocLungaDurataUsc;

FUNCTION no_dot (p_value VARCHAR2)
      RETURN VARCHAR2
   IS
      ret   VARCHAR2 (10);
   BEGIN
      IF (p_value IS NULL OR LENGTH (p_value) <= 6)
      THEN
         RETURN p_value;
      END IF;

      ret := REPLACE (p_value, '.');

      IF (LENGTH (p_value) = 9)
      THEN
         ret := SUBSTR (ret, 1, 4) || '0' || SUBSTR (ret, 5, 1);
      END IF;

      RETURN ret;
   END no_dot;
--
function GetPrgNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.PRGNULLAOSTA%TYPE
   IS
     varPrgNullaOsta cm_nulla_osta.PRGNULLAOSTA%TYPE;

  BEGIN

   select PRGNULLAOSTA
   into varPrgNullaOsta
   from (select abs(nuos.DATINIZIO - Pdatiniziomov), nuos.PRGNULLAOSTA
     from cm_nulla_osta nuos
     inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA)
     inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
     where (doc.CODSTATOATTO = 'PR' OR doc.CODSTATOATTO = 'AN')
     and doc.CODTIPODOCUMENTO = 'NULOST'
     and nuos.cdnlavoratore = Pcdnlavoratore
     and nuos.prgazienda= Pprgazienda
     and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni
     order by abs(nuos.DATINIZIO - Pdatiniziomov) asc)
   where rownum = 1;

   return varPrgNullaOsta;

   Exception
         when no_data_found then
        return -1;
END GetPrgNullaOstaDaMovimento;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- DUPLICO LA FUNZIONE GetPrgNullaOstaDaMovimento perchè per le ETSRAZIONI CM per il MONITORAGGIO ho bisogno solo dei NULLA OSTA PROTOCOLLATI e non anche DEGLI ANNULLATI
-- N.B. RICORDARSI DI VERIFICARE dove viene utilizzata la funzione sopra, file di estrazioni ETL a parte  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function GetPrgNullaOstaDaMovProt(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.PRGNULLAOSTA%TYPE
   IS
     varPrgNullaOsta cm_nulla_osta.PRGNULLAOSTA%TYPE;

  BEGIN

   select PRGNULLAOSTA
   into varPrgNullaOsta
   from (select abs(nuos.DATINIZIO - Pdatiniziomov), nuos.PRGNULLAOSTA
     from cm_nulla_osta nuos
     inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA)
     inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
     where doc.CODSTATOATTO = 'PR' 
     and doc.CODTIPODOCUMENTO = 'NULOST'
     and nuos.cdnlavoratore = Pcdnlavoratore
     and nuos.prgazienda= Pprgazienda
     and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni
     order by abs(nuos.DATINIZIO - Pdatiniziomov) asc)
   where rownum = 1;

   return varPrgNullaOsta;

   Exception
         when no_data_found then
        return -1;
END GetPrgNullaOstaDaMovProt;
--
function GetTipoNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOTIPO%TYPE
   IS
     varCodMonoTipoNullaOsta cm_nulla_osta.CODMONOTIPO%TYPE;

  BEGIN

   select CODMONOTIPO
   into varCodMonoTipoNullaOsta
   from (select abs(nuos.DATINIZIO - Pdatiniziomov), nuos.CODMONOTIPO
     from cm_nulla_osta nuos
     inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA)
     inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
     where (doc.CODSTATOATTO = 'PR' OR doc.CODSTATOATTO = 'AN')
     and doc.CODTIPODOCUMENTO = 'NULOST'
     and nuos.cdnlavoratore = Pcdnlavoratore
     and nuos.prgazienda= Pprgazienda
     and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni
     order by abs(nuos.DATINIZIO - Pdatiniziomov) asc)
   where rownum = 1;

   return varCodMonoTipoNullaOsta;

   Exception
         when no_data_found then
        return null;
END GetTipoNullaOstaDaMovimento;
--
function GetCatNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOCATEGORIA%TYPE
   IS
     varCodMonoCatNullaOsta cm_nulla_osta.CODMONOCATEGORIA%TYPE;

  BEGIN

   select CODMONOCATEGORIA
   into varCodMonoCatNullaOsta
   from (select abs(nuos.DATINIZIO - Pdatiniziomov), nuos.CODMONOCATEGORIA
     from cm_nulla_osta nuos
     inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA)
     inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
     where (doc.CODSTATOATTO = 'PR' OR doc.CODSTATOATTO = 'AN')
     and doc.CODTIPODOCUMENTO = 'NULOST'
     and nuos.cdnlavoratore = Pcdnlavoratore
     and nuos.prgazienda= Pprgazienda
     and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni
     order by abs(nuos.DATINIZIO - Pdatiniziomov) asc)
   where rownum = 1;

   return varCodMonoCatNullaOsta;

   Exception
         when no_data_found then
        return null;
END GetCatNullaOstaDaMovimento;

function GetStatoNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN am_documento.codstatoatto%TYPE
   IS
     varCodStatoAttoNullaOsta am_documento.codstatoatto%TYPE;

  BEGIN

   select CODSTATOATTO
   into varCodStatoAttoNullaOsta
   from (select abs(nuos.DATINIZIO - Pdatiniziomov), doc.codstatoatto
     from cm_nulla_osta nuos
     inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA)
     inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
     where (doc.CODSTATOATTO = 'PR' OR doc.CODSTATOATTO = 'AN')
     and doc.CODTIPODOCUMENTO = 'NULOST'
     and nuos.cdnlavoratore = Pcdnlavoratore
     and nuos.prgazienda= Pprgazienda
     and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni
     order by abs(nuos.DATINIZIO - Pdatiniziomov) asc)
   where rownum = 1;

   return varCodStatoAttoNullaOsta;

   Exception
         when no_data_found then
        return null;
END GetStatoNullaOstaDaMovimento;
--
function GetDtmModNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.DTMMOD%TYPE
   IS
     varDtmModNullaOsta CM_NULLA_OSTA.DTMMOD%TYPE;

  BEGIN

   select DTMMOD
   into varDtmModNullaOsta
   from (select abs(nuos.DATINIZIO - Pdatiniziomov), nuos.DTMMOD
     from cm_nulla_osta nuos
     inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA)
     inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
     where (doc.CODSTATOATTO = 'PR' OR doc.CODSTATOATTO = 'AN')
     and doc.CODTIPODOCUMENTO = 'NULOST'
     and nuos.cdnlavoratore = Pcdnlavoratore
     and nuos.prgazienda= Pprgazienda
     and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni
     order by abs(nuos.DATINIZIO - Pdatiniziomov) asc)
   where rownum = 1;

   return varDtmModNullaOsta;

   Exception
         when no_data_found then
        return null;
END GetDtmModNullaOstaDaMovimento;
--
function GetDtmInsNullaOstaDaMovimento(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.DTMINS%TYPE
   IS
     varDtmInsNullaOsta CM_NULLA_OSTA.DTMINS%TYPE;

  BEGIN

   select DTMINS
   into varDtmInsNullaOsta
   from (select abs(nuos.DATINIZIO - Pdatiniziomov), nuos.DTMINS
     from cm_nulla_osta nuos
     inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA)
     inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
     where (doc.CODSTATOATTO = 'PR' OR doc.CODSTATOATTO = 'AN')
     and doc.CODTIPODOCUMENTO = 'NULOST'
     and nuos.cdnlavoratore = Pcdnlavoratore
     and nuos.prgazienda= Pprgazienda
     and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni
     order by abs(nuos.DATINIZIO - Pdatiniziomov) asc)
   where rownum = 1;

   return varDtmInsNullaOsta;

   Exception
         when no_data_found then
        return null;
END GetDtmInsNullaOstaDaMovimento;
--
function GetTipoIscrCmCompatibile(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                     PprgAzienda IN am_movimento.PRGAZIENDA%TYPE,
                                     PdatInizioMov IN am_movimento.DATINIZIOMOV%TYPE,
                                     PchiaveCrypt IN varchar2) RETURN AM_CM_ISCR.CODCMTIPOISCR%TYPE IS

    VarTipoCmIscr am_cm_iscr.CODCMTIPOISCR%type;
    VcodMonoCategoria cm_nulla_osta.CODMONOCATEGORIA%type;
begin
     VcodMonoCategoria := GetCatNullaOstaDaMovimento(Pcdnlavoratore, PprgAzienda, PdatInizioMov, 30);

     select cm.codcmtipoiscr
     into VarTipoCmIscr
     from am_cm_iscr cm, de_cm_tipo_iscr deTipoCm
     where encrypt(Pcdnlavoratore, PchiaveCrypt) = cm.CDNLAVORATORE
       and cm.DATDATAINIZIO <= PdatInizioMov
       and ( (cm.DATDATAFINE is null) or (cm.DATDATAFINE >= PdatInizioMov) )
       and cm.CODCMTIPOISCR = deTipoCm.CODCMTIPOISCR
       and decode(VcodMonoCategoria,null,deTipoCm.CODMONOTIPORAGG,VcodMonoCategoria) = deTipoCm.CODMONOTIPORAGG
       and rownum = 1
     order by cm.DATDATAINIZIO desc;

     return VarTipoCmIscr;

     Exception
         when no_data_found then
        return null;
end GetTipoIscrCmCompatibile;
--
function GetTipoInvIscrCmCompatibile(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                     PprgAzienda IN am_movimento.PRGAZIENDA%TYPE,
                                     PdatInizioMov IN am_movimento.DATINIZIOMOV%TYPE,
                                    PchiaveCrypt IN varchar2) RETURN AM_CM_ISCR.CODTIPOINVALIDITA%TYPE IS

    VarTipoInvCmIscr AM_CM_ISCR.CODTIPOINVALIDITA%type;
VcodMonoCategoria cm_nulla_osta.CODMONOCATEGORIA%type;
begin
     VcodMonoCategoria := GetCatNullaOstaDaMovimento(Pcdnlavoratore, PprgAzienda, PdatInizioMov, 30);
     select cm.CODTIPOINVALIDITA
     into VarTipoInvCmIscr
     from am_cm_iscr cm, de_cm_tipo_iscr deTipoCm
     where encrypt(Pcdnlavoratore, PchiaveCrypt) = cm.CDNLAVORATORE
       and cm.DATDATAINIZIO <= PdatInizioMov
       and ( (cm.DATDATAFINE is null) or (cm.DATDATAFINE >= PdatInizioMov) )
       and cm.CODCMTIPOISCR = deTipoCm.CODCMTIPOISCR
       and decode(VcodMonoCategoria,null,deTipoCm.CODMONOTIPORAGG,VcodMonoCategoria) = deTipoCm.CODMONOTIPORAGG
       and rownum = 1
     order by cm.DATDATAINIZIO desc;

     return VarTipoInvCmIscr;

     Exception
         when no_data_found then
        return null;
end GetTipoInvIscrCmCompatibile;
--
function GetPercInvIscrCmCompatibile(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                     PprgAzienda IN am_movimento.PRGAZIENDA%TYPE,
                                     PdatInizioMov IN am_movimento.DATINIZIOMOV%TYPE,
                                    PchiaveCrypt IN varchar2) RETURN AM_CM_ISCR.NUMPERCINVALIDITA%TYPE IS

    VarPercInvCmIscr AM_CM_ISCR.NUMPERCINVALIDITA%type;
VcodMonoCategoria cm_nulla_osta.CODMONOCATEGORIA%type;
begin
     VcodMonoCategoria := GetCatNullaOstaDaMovimento(Pcdnlavoratore, PprgAzienda, PdatInizioMov, 30);

     select cm.NUMPERCINVALIDITA
     into VarPercInvCmIscr
     from am_cm_iscr cm, de_cm_tipo_iscr deTipoCm
     where encrypt(Pcdnlavoratore, PchiaveCrypt) = cm.CDNLAVORATORE
       and cm.DATDATAINIZIO <= PdatInizioMov
       and ( (cm.DATDATAFINE is null) or (cm.DATDATAFINE >= PdatInizioMov) )
       and cm.CODCMTIPOISCR = deTipoCm.CODCMTIPOISCR
       and decode(VcodMonoCategoria,null,deTipoCm.CODMONOTIPORAGG,VcodMonoCategoria) = deTipoCm.CODMONOTIPORAGG
       and rownum = 1
     order by cm.DATDATAINIZIO desc;

     return VarPercInvCmIscr;

     Exception
         when no_data_found then
        return null;
end GetPercInvIscrCmCompatibile;
--

function recupera_prg_avv_effettivo(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
            RETURN AM_MOVIMENTO.PRGMOVIMENTO%TYPE
IS
rowMov AM_MOVIMENTO%ROWTYPE;
prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
prgMovCes AM_MOVIMENTO.PRGMOVIMENTO%TYPE;

p_datInizioMov date;
p_listaPrgProcessati varchar2(32000) := 0;

p_queryCess varchar2(32000);

BEGIN
 -- Continuo a recuperare il record del movimento precedente finche' non trovo quello con 'AVV' (o non ce l'ho).
 prgMovCiclo := prgMov;
 LOOP
  IF prgMovCiclo IS NULL THEN
      RETURN 0;
  END IF;
  -- Recupero il record relativo al prgMovimento in ingresso
  SELECT MOV.*
  INTO rowMov
  FROM AM_MOVIMENTO MOV
  WHERE MOV.PRGMOVIMENTO = prgMovCiclo;

  -- Se non trovato, esco dal ciclo
  EXIT WHEN SQL%NOTFOUND;
  
        IF rowMov.CODTIPOMOV = 'AVV' and (rowMov.CODTIPOCONTRATTO = 'Z.09.00' OR rowMov.CODTIPOCONTRATTO = 'Z.09.01' OR rowMov.CODTIPOCONTRATTO = 'Z.09.02') 
        THEN
            p_datInizioMov := rowMov.datiniziomov;
            p_queryCess := 
            'select prgmovcurr ' ||            
            ' from ( SELECT MOV.PRGMOVIMENTO prgmovcurr ' ||
            ' FROM AM_MOVIMENTO MOV ' ||
            ' WHERE MOV.CODTIPOMOV = ''CES'' AND MOV.CODMVCESSAZIONE = ''SC'' AND MOV.PRGAZIENDA = '|| rowMov.PRGAZIENDA  || 
            ' AND MOV.PRGMOVIMENTOSUCC IS NULL AND MOV.CODSTATOATTO = ''PR''  '||
            ' AND TRUNC(DATINIZIOMOV) <= to_date(to_char(cast('''||p_datInizioMov||''' as DATE), ''dd/mm/yyyy''),''dd/mm/yyyy'')  '|| 
            ' AND MOV.CDNLAVORATORE = '||rowMov.CDNLAVORATORE||' ' ||  
            ' AND MOV.PRGMOVIMENTO not in ('|| p_listaPrgProcessati||')'||                               
            '         order by DATINIZIOMOV desc ' || 
            '        )' ||
            ' where rownum = 1';
   
            execute immediate p_queryCess into prgMovCes;
  
            IF prgMovCes IS NOT NULL THEN
                prgMovCiclo := prgMovCes;
            END IF;
        ELSE 
            IF rowMov.CODTIPOMOV = 'AVV' THEN
                RETURN rowMov.PRGMOVIMENTO;
            END IF;
            -- Continuo a ciclare (passo al movimento precedente)
            prgMovCiclo := rowMov.PRGMOVIMENTOPREC;
        END IF;
     
        p_listaPrgProcessati := p_listaPrgProcessati || ',' ||prgMovCiclo;     

 END LOOP;

 RETURN 0;
 EXCEPTION WHEN OTHERS THEN RETURN 0;

END recupera_prg_avv_effettivo;

function recupera_ultimo_mov(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE, prgMovSucc IN AM_MOVIMENTO.PRGMOVIMENTOSUCC%TYPE)
            RETURN AM_MOVIMENTO.PRGMOVIMENTO%TYPE
IS
rowMov AM_MOVIMENTO%ROWTYPE;
prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
prgMovApp AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
prgMovAvv AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
p_codmvCessazione varchar2(1000);
p_codTipoMov varchar2(10);
p_prgMovCes number;

p_datInizioMov date;
p_listaPrgProcessati varchar2(1000) := 0;

p_queryAvv varchar2(2000);
BEGIN
prgMovApp := prgMov;
prgMovCiclo := prgMovSucc;
LOOP
  --Se il successivo non c'è ritorno il movimento stesso
    IF prgMovCiclo IS NULL THEN
        RETURN NULL;
    END IF;
 
  -- Recupero il record relativo al prgMovimento isuccessivo
  SELECT MOV.*
  INTO rowMov
  FROM AM_MOVIMENTO MOV
  WHERE MOV.PRGMOVIMENTO = prgMovCiclo;

  -- Se non trovato, esco dal ciclo
  EXIT WHEN SQL%NOTFOUND;
        IF (rowMov.CODTIPOMOV = 'CES' and rowMov.CODMVCESSAZIONE = 'SC') then
                IF(rowMov.PRGMOVIMENTOSUCC IS NOT NULL) THEN
                    SELECT MOV.CODMVCESSAZIONE, MOV.PRGMOVIMENTO
                    INTO p_codmvCessazione, p_prgMovCes
                    FROM AM_MOVIMENTO MOV
                    WHERE MOV.PRGMOVIMENTO = rowMov.PRGMOVIMENTOSUCC;
                    
                    IF (p_codmvCessazione <> 'SC') then 
                        return p_prgMovCes;
                    ELSE
                        prgMovCiclo := rowMov.PRGMOVIMENTOSUCC;
                    END IF;
                ELSE
                    p_datInizioMov := rowMov.datiniziomov;
                    p_queryAvv := 
                    'select prgmovcurr ' ||            
                    ' from ( SELECT MOV.PRGMOVIMENTO prgmovcurr ' ||
                    ' FROM AM_MOVIMENTO MOV ' ||
                    ' WHERE MOV.CODTIPOMOV = ''AVV'' AND (MOV.CODTIPOCONTRATTO = ''Z.09.00'' OR MOV.CODTIPOCONTRATTO = ''Z.09.01'' OR MOV.CODTIPOCONTRATTO = ''Z.09.02'')  '|| 
                    ' AND MOV.PRGAZIENDA = '|| rowMov.PRGAZIENDA  || 
                    ' AND MOV.CODSTATOATTO = ''PR''  '||
                    ' AND TRUNC(DATINIZIOMOV) >= to_date(to_char(cast('''||p_datInizioMov||''' as DATE), ''dd/mm/yyyy''),''dd/mm/yyyy'')  '|| 
                    ' AND MOV.CDNLAVORATORE = '||rowMov.CDNLAVORATORE||' ' ||  
                    ' AND MOV.PRGMOVIMENTO not in ('|| p_listaPrgProcessati||')'||    
                    '         order by DATINIZIOMOV  ' || 
                    ' )' ||
                    ' where rownum = 1';
            
                    execute immediate p_queryAvv into prgMovAvv;
                    IF prgMovAvv IS NOT NULL THEN
                        prgMovCiclo := prgMovAvv;
                    END IF;
                END IF;
        ELSE
          IF (rowMov.PRGMOVIMENTOSUCC IS NOT NULL) THEN
            IF( rowMov.CODTIPOMOV <> 'AVV'  OR (rowMov.CODTIPOMOV = 'AVV' AND (rowMov.CODTIPOCONTRATTO <> 'Z.09.00' AND rowMov.CODTIPOCONTRATTO <> 'Z.09.01' AND rowMov.CODTIPOCONTRATTO <> 'Z.09.02')  ) ) then
                prgMovApp := prgMovCiclo;
            END IF;
            prgMovCiclo := rowMov.PRGMOVIMENTOSUCC;
          ELSE
            IF( rowMov.CODTIPOMOV = 'AVV' AND (rowMov.CODTIPOCONTRATTO = 'Z.09.00' OR rowMov.CODTIPOCONTRATTO = 'Z.09.01' OR rowMov.CODTIPOCONTRATTO =  'Z.09.02') ) then
                    
                    SELECT MOV.CODTIPOMOV
                    INTO p_codTipoMov
                    FROM AM_MOVIMENTO MOV
                    WHERE MOV.PRGMOVIMENTO = prgMovApp;
                    
                    IF(p_codTipoMov <> 'AVV') 
                        THEN RETURN prgMovApp;
                    ELSE 
                        RETURN NULL;
                    END IF;
            ELSE 
                    RETURN prgMovCiclo;
            END IF;
            -- Continuo a ciclare (passo al movimento successivo)
          END IF;    
        END IF;  
        p_listaPrgProcessati := p_listaPrgProcessati || ',' ||prgMovCiclo;  
    END LOOP;
    RETURN prgMovCiclo;
    
    EXCEPTION WHEN OTHERS THEN RETURN NULL;

END recupera_ultimo_mov;

function checkflgAgevolazione(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE) return CHAR IS 

flg_agevolazione char;
flaAge number;
begin
 select count(1)
 into flaAge
 from am_movimento_agevolazioni
 where prgmovimento = prgMov;

 if (flaAge > 0) then
  flg_agevolazione := 'S';
 else
  flg_agevolazione := 'N';
 end if;
    return flg_agevolazione;
exception when others then
    return null;
end checkflgAgevolazione;


function recupera_codContratto(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
            RETURN AM_MOVIMENTO.CODCONTRATTO%TYPE
IS
rowMov AM_MOVIMENTO%ROWTYPE;
prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
prgMovCes AM_MOVIMENTO.PRGMOVIMENTO%TYPE;

p_datInizioMov date;
p_listaPrgProcessati varchar2(1000) := 0;

p_queryCess varchar2(2000);

BEGIN
 prgMovCiclo := prgMov;
 LOOP
    SELECT MOV.*
    INTO rowMov
    FROM AM_MOVIMENTO MOV
    WHERE MOV.PRGMOVIMENTO = prgMovCiclo;
    
     EXIT WHEN SQL%NOTFOUND;
        
        IF (rowMov.CODTIPOCONTRATTO <> 'Z.09.00' AND rowMov.CODTIPOCONTRATTO <> 'Z.09.01' AND rowMov.CODTIPOCONTRATTO <> 'Z.09.02') THEN
            return rowMov.CODTIPOCONTRATTO;
        END IF;
     
        IF rowMov.CODTIPOMOV = 'AVV' and (rowMov.CODTIPOCONTRATTO = 'Z.09.00' OR rowMov.CODTIPOCONTRATTO = 'Z.09.01' OR rowMov.CODTIPOCONTRATTO = 'Z.09.02') THEN
            p_datInizioMov := rowMov.datiniziomov;
            p_queryCess := 
            'select prgmovcurr ' ||            
            ' from ( SELECT MOV.PRGMOVIMENTO prgmovcurr ' ||
            ' FROM AM_MOVIMENTO MOV ' ||
            ' WHERE MOV.CODTIPOMOV = ''CES'' AND MOV.CODMVCESSAZIONE = ''SC'' AND MOV.PRGAZIENDA = '|| rowMov.PRGAZIENDA  || 
            ' AND MOV.PRGMOVIMENTOSUCC IS NULL AND MOV.CODSTATOATTO = ''PR''  '||
            ' AND TRUNC(DATINIZIOMOV) <= to_date(to_char(cast('''||p_datInizioMov||''' as DATE), ''dd/mm/yyyy''),''dd/mm/yyyy'')  '|| 
            ' AND MOV.CDNLAVORATORE = '||rowMov.CDNLAVORATORE||' ' ||  
            ' AND MOV.PRGMOVIMENTO not in ('|| p_listaPrgProcessati||')'||                               
            '         order by DATINIZIOMOV desc ' || 
            '        )' ||
            ' where rownum = 1';
   
            execute immediate p_queryCess into prgMovCes;
            
            IF prgMovCes IS NOT NULL THEN
                prgMovCiclo := prgMovCes;
            END IF;
        ELSE 
            IF rowMov.CODTIPOMOV = 'AVV' THEN
                RETURN rowMov.CODTIPOCONTRATTO;
            END IF;
            -- Continuo a ciclare (passo al movimento precedente)
        prgMovCiclo := rowMov.PRGMOVIMENTOPREC;
        END IF;
     
        p_listaPrgProcessati := p_listaPrgProcessati || ',' ||prgMovCiclo;    
        
        END LOOP;
        
        RETURN '--';
    
    EXCEPTION WHEN OTHERS THEN RETURN '--';      

end recupera_codContratto;

function calcolaSuccessivo(prgMovSucc IN AM_MOVIMENTO.PRGMOVIMENTOSUCC%TYPE)
           RETURN AM_MOVIMENTO.PRGMOVIMENTO%TYPE
IS

p_codTipoMov varchar2(10);
p_motivoCess varchar2(10);

begin
    if(prgMovSucc is not null ) then
        SELECT codtipomov, codmvcessazione
        INTO p_codTipoMov, p_motivoCess
        FROM AM_MOVIMENTO MOV
        WHERE MOV.PRGMOVIMENTO = prgMovSucc;
            
            if(p_codTipoMov = 'CES' AND p_motivoCess = 'SC') then 
                return -1;
            end if;
    else
         RETURN 0;
    end if;
     
     return prgMovSucc; 
end calcolaSuccessivo;

function calcolaPrecedente(prgMovPrec IN AM_MOVIMENTO.PRGMOVIMENTOPREC%TYPE)
           RETURN AM_MOVIMENTO.PRGMOVIMENTOPREC%TYPE
IS

p_codTipoMov varchar2(10);
p_motivoCess varchar2(10);
p_codTipoContratto varchar2(20);

begin
    if(prgMovPrec is not null ) then
        SELECT codtipomov, codmvcessazione, codTipoContratto
        INTO p_codTipoMov, p_motivoCess, p_codTipoContratto
        FROM AM_MOVIMENTO MOV
        WHERE MOV.PRGMOVIMENTO = prgMovPrec;
            
            if( (p_codTipoMov = 'CES' AND p_motivoCess = 'SC') OR ( p_codTipoMov = 'AVV' 
                 AND (p_codTipoContratto = 'Z.09.00' OR p_codTipoContratto = 'Z.09.01' OR p_codTipoContratto = 'Z.09.02')  )   ) then 
                return -1;
            end if;
     else
         RETURN 0;
    end if;
    
    return prgMovPrec; 
end calcolaPrecedente;

function recupera_codMansione(prgMov IN AM_MOVIMENTO.PRGMOVIMENTO%TYPE)
            RETURN AM_MOVIMENTO.CODMANSIONE%TYPE
IS
rowMov AM_MOVIMENTO%ROWTYPE;
prgMovCiclo AM_MOVIMENTO.PRGMOVIMENTO%TYPE;
prgMovCes AM_MOVIMENTO.PRGMOVIMENTO%TYPE;

p_datInizioMov date;
p_listaPrgProcessati varchar2(1000) := 0;

p_queryCess varchar2(2000);

BEGIN
 prgMovCiclo := prgMov;
 LOOP
    SELECT MOV.*
    INTO rowMov
    FROM AM_MOVIMENTO MOV
    WHERE MOV.PRGMOVIMENTO = prgMovCiclo;
    
     EXIT WHEN SQL%NOTFOUND;
        
        IF (rowMov.CODTIPOCONTRATTO <> 'Z.09.00' AND rowMov.CODTIPOCONTRATTO <> 'Z.09.01' AND rowMov.CODTIPOCONTRATTO <> 'Z.09.02') THEN
            return rowMov.CODMANSIONE;
        END IF;
     
        IF rowMov.CODTIPOMOV = 'AVV' and (rowMov.CODTIPOCONTRATTO = 'Z.09.00' OR rowMov.CODTIPOCONTRATTO = 'Z.09.01' OR rowMov.CODTIPOCONTRATTO = 'Z.09.02') THEN
            p_datInizioMov := rowMov.datiniziomov;
            p_queryCess := 
            'select prgmovcurr ' ||            
            ' from ( SELECT MOV.PRGMOVIMENTO prgmovcurr ' ||
            ' FROM AM_MOVIMENTO MOV ' ||
            ' WHERE MOV.CODTIPOMOV = ''CES'' AND MOV.CODMVCESSAZIONE = ''SC'' AND MOV.PRGAZIENDA = '|| rowMov.PRGAZIENDA  || 
            ' AND MOV.PRGMOVIMENTOSUCC IS NULL AND MOV.CODSTATOATTO = ''PR''  '||
            ' AND TRUNC(DATINIZIOMOV) <= to_date(to_char(cast('''||p_datInizioMov||''' as DATE), ''dd/mm/yyyy''),''dd/mm/yyyy'')  '|| 
            ' AND MOV.CDNLAVORATORE = '||rowMov.CDNLAVORATORE||' ' ||  
            ' AND MOV.PRGMOVIMENTO not in ('|| p_listaPrgProcessati||')'||                               
            '         order by DATINIZIOMOV desc ' || 
            '        )' ||
            ' where rownum = 1';
   
            execute immediate p_queryCess into prgMovCes;
            
            IF prgMovCes IS NOT NULL THEN
                prgMovCiclo := prgMovCes;
            END IF;
        ELSE 
            IF rowMov.CODTIPOMOV = 'AVV' THEN
                RETURN rowMov.CODMANSIONE;
            END IF;
            -- Continuo a ciclare (passo al movimento precedente)
        prgMovCiclo := rowMov.PRGMOVIMENTOPREC;
        END IF;
     
        p_listaPrgProcessati := p_listaPrgProcessati || ',' ||prgMovCiclo;    
        
        END LOOP;
        
        RETURN '2';
    
    EXCEPTION WHEN OTHERS THEN RETURN '2';      

end recupera_codMansione;

function GetPrgComputoDaMov(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                   Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                   Pdatfinemov IN am_movimento.DATFINEMOV%TYPE) RETURN CM_RICH_COMPUTO.PRGRICHCOMPUTO%TYPE
   IS
     varPrgComputo cm_rich_computo.PRGRICHCOMPUTO%TYPE;

  BEGIN
    
    select PRGRICHCOMPUTO
    into varPrgComputo
    from cm_rich_computo comp
    inner join am_documento_coll coll on (comp.PRGRICHCOMPUTO = coll.STRCHIAVETABELLA)
    inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
    where doc.CODSTATOATTO = 'PR' 
             and doc.CODTIPODOCUMENTO = 'CMDCOMP'
             and comp.cdnlavoratore = Pcdnlavoratore
             and comp.prgazienda= Pprgazienda
             and trunc(comp.DATINIZIO) between trunc(Pdatiniziomov) and trunc(Pdatfinemov)
             --and to_char(comp.DATINIZIO,'yyyy') between '2007' and '2011'
             and rownum = 1
     order by comp.DATINIZIO desc;
    
    return varPrgComputo;

   Exception
         when no_data_found then
        return -1;
END GetPrgComputoDaMov;

function GetCatNullaOstaDaMovProt(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                   Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOCATEGORIA%TYPE
   IS
     varCodMonoCatNullaOsta cm_nulla_osta.CODMONOCATEGORIA%TYPE;

  BEGIN

   select CODMONOCATEGORIA
   into varCodMonoCatNullaOsta
   from (select abs(nuos.DATINIZIO - Pdatiniziomov), nuos.CODMONOCATEGORIA
     from cm_nulla_osta nuos
     inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA)
     inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
     where doc.CODSTATOATTO = 'PR'
     and doc.CODTIPODOCUMENTO = 'NULOST'
     and nuos.cdnlavoratore = Pcdnlavoratore
     and nuos.prgazienda= Pprgazienda
     and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni
     order by abs(nuos.DATINIZIO - Pdatiniziomov) asc)
   where rownum = 1;

   return varCodMonoCatNullaOsta;

   Exception
         when no_data_found then
        return null;
END GetCatNullaOstaDaMovProt;

function GetTipoIscrCmComp(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                     PprgAzienda IN am_movimento.PRGAZIENDA%TYPE,
                                     PdatInizioMov IN am_movimento.DATINIZIOMOV%TYPE,
                                     PchiaveCrypt IN varchar2) RETURN DE_CM_TIPO_ISCR.CODMONOTIPORAGG%TYPE IS

    VarTipoCateg DE_CM_TIPO_ISCR.CODMONOTIPORAGG%type;
    VcodMonoCategoria cm_nulla_osta.CODMONOCATEGORIA%type;
begin
     
     VcodMonoCategoria := GetCatNullaOstaDaMovProt(Pcdnlavoratore, PprgAzienda, PdatInizioMov, 60);
     
     IF VcodMonoCategoria is not null THEN
       return VcodMonoCategoria;
     END IF;

     select CODMONOTIPORAGG
     into VarTipoCateg
     from (select deTipoCm.CODMONOTIPORAGG
            from am_cm_iscr cm, de_cm_tipo_iscr deTipoCm
            where encrypt(Pcdnlavoratore, PchiaveCrypt) = cm.CDNLAVORATORE
                      and cm.DATDATAINIZIO <= PdatInizioMov
                      and ( (cm.DATDATAFINE is null) or (cm.DATDATAFINE >= PdatInizioMov - 1) )
                      and cm.CODCMTIPOISCR = deTipoCm.CODCMTIPOISCR
                      --and decode(VcodMonoCategoria,null,deTipoCm.CODMONOTIPORAGG,VcodMonoCategoria) = deTipoCm.CODMONOTIPORAGG
                      order by deTipoCm.CODMONOTIPORAGG desc)
          where rownum = 1;
   
     return VarTipoCateg;

     Exception
         when no_data_found then
        return null;
end GetTipoIscrCmComp;

function GetTipoAssunzioneDaMov(Pcdnlavoratore IN am_movimento.CDNLAVORATORE%TYPE,
                                  Pprgazienda IN am_movimento.PRGAZIENDA%TYPE,
                                  Pprgunita IN AM_MOVIMENTO.PRGUNITA%TYPE,
                                  Pdatiniziomov IN am_movimento.DATINIZIOMOV%TYPE,
                                  Pdatfinemov IN AM_MOVIMENTO.DATFINEMOV%TYPE,
                                  Pcodtipoass IN AM_MOVIMENTO.CODTIPOASS%TYPE,
                                  PFlag68 IN AM_MOVIMENTO.FLGLEGGE68%TYPE,
                                  Pgiorni in NUMBER) RETURN CM_NULLA_OSTA.CODMONOTIPO%TYPE
   IS
     varCodMonoTipo CM_NULLA_OSTA.CODMONOTIPO%TYPE;
     varCodMonoNuos CM_NULLA_OSTA.CODMONOTIPO%TYPE;
     varPrgComputo cm_rich_computo.PRGRICHCOMPUTO%TYPE;
     varProvAzi number;
     varTipoResult CM_NULLA_OSTA.CODMONOTIPO%TYPE;
 
 BEGIN
    
    if(Pcodtipoass = 'NOH') then  
        varCodMonoTipo := 'M';
    end if;
    
    if(Pcodtipoass = 'NU2') then  
        varCodMonoTipo := 'R';
    end if;
    
    if(Pcodtipoass IS NULL OR (Pcodtipoass <> 'NOH' AND Pcodtipoass <> 'NU2') ) then 
        -- VEDO SE ESISTE NULLA OSTA COMPATIBILE
        BEGIN
            select codmonotipo
            into varCodMonoNuos
            from (select abs(nuos.DATINIZIO - Pdatiniziomov), nuos.codmonotipo
                    from cm_nulla_osta nuos
                    inner join am_documento_coll coll on (nuos.PRGNULLAOSTA = coll.STRCHIAVETABELLA)
                    inner join am_documento doc on (coll.PRGDOCUMENTO = doc.PRGDOCUMENTO)
                    where doc.CODSTATOATTO = 'PR' 
                             and doc.CODTIPODOCUMENTO = 'NULOST'
                             and nuos.cdnlavoratore = Pcdnlavoratore
                             and nuos.prgazienda= Pprgazienda
                             and (nuos.DATINIZIO - Pdatiniziomov) between -Pgiorni and Pgiorni
                    order by abs(nuos.DATINIZIO - Pdatiniziomov) asc)
            where rownum = 1;
           
           Exception
           when no_data_found then
           varCodMonoNuos := NULL;
        END;
      
        IF(varCodMonoNuos IS NOT NULL) THEN
            IF(varCodMonoNuos = 'M') THEN
                varCodMonoTipo := 'M';
            ELSIF (varCodMonoNuos = 'R') THEN       
                varCodMonoTipo := 'R';
            END IF;
        ELSE
        -- SE CODTIPOASS E' DIVERSO DA NOH e NU2 E NON ESISTE NULLA OSTA COMPATIBILE CONTROLLO IL FLG ISCRIZIONE CM
            IF(PFlag68 = 'S') THEN
                --SE FLAG SETTATO AD S VERIFICO CHE LA SEDE DELL'AZIENDA DEL MOVIMENTO CERCATO APPARTIENE ALLA PROVINCIA
                BEGIN
                     select count(AZI.CODCOM)
                     into varProvAzi
                     from am_movimento mov
                     inner join an_unita_azienda azi on AZI.PRGAZIENDA = MOV.PRGAZIENDA and AZI.PRGUNITA = MOV.PRGUNITA
                     inner join de_comune com on COM.CODCOM = AZI.CODCOM
                     inner join ts_generale gen on GEN.CODPROVINCIASIL = COM.CODPROVINCIA
                     where mov.cdnlavoratore = Pcdnlavoratore
                               and mov.prgazienda= Pprgazienda
                               and mov.prgunita = Pprgunita;
                    
                    Exception
                        when no_data_found then
                            varProvAzi := 0;
                END;
                
                IF (varProvAzi > 0) THEN
                    varCodMonoTipo := 'R';
                END IF;
            ELSE
                -- ALTRIMENTI SE FLGLEGGE68 diverso da S setto NOMINATIVA
                    varCodMonoTipo := 'M';
            END IF; 
        END IF;   
    END IF;  
    
     return varCodMonoTipo;
     
     Exception
        when no_data_found then
            return null;
END GetTipoAssunzioneDaMov;

function GetTipoDisabDF(Pcdnlavoratore IN am_cm_iscr.CDNLAVORATORE%TYPE) 
        RETURN varchar2 IS

    varTipoDiagnosi varchar2(50);
    
begin
     select flginvalidfisica || '|' || flginvalidpsichica || '|' || flginvalidsensoriale || '|' || flginvalidintellettiva || '|' || datdiagnosi
     into varTipoDiagnosi
     from (select flginvalidfisica, flginvalidpsichica, flginvalidsensoriale, flginvalidintellettiva, datdiagnosi
           from cm_diagnosi_funzionale dia
           where dia.cdnlavoratore = Pcdnlavoratore
           order by dia.datdiagnosi asc)
     where rownum = 1;
   
   return varTipoDiagnosi;

     Exception
         when no_data_found then
        return '||||';
end GetTipoDisabDF;

function GetMinDtInizioIscrCM(Pcdnlavoratore IN am_cm_iscr.CDNLAVORATORE%TYPE) 
        RETURN Number IS
    
     varPrgIscr Number;
    
begin
     select prgcmiscr into varPrgIscr
     from am_cm_iscr
     where datdatainizio = (select min(datdatainizio) 
                            from am_cm_iscr iscr1
                            where iscr1.cdnlavoratore = Pcdnlavoratore
                            and rownum = 1)
      and am_cm_iscr.cdnlavoratore = Pcdnlavoratore
      and rownum = 1;
   
   return varPrgIscr;

     Exception
         when no_data_found then
        return null;
end GetMinDtInizioIscrCM;

function GetFlgIscrCm( 
						pi_cdnlavoratore IN am_movimento.cdnlavoratore%TYPE, 
						pi_datiniziomov IN am_movimento.datiniziomov%TYPE, 
						pi_chiaveCrypt IN varchar2
						) 
		RETURN VARCHAR2 IS
	v_conta 		NUMBER;
	v_outFlgIscrCM	VARCHAR2(1);
BEGIN

	select 
		count(*) 
	INTO v_conta
	from AM_CM_ISCR cm
	where cm.codstatoatto = 'PR'
	and cm.cdnlavoratore = encrypt( pi_cdnlavoratore, pi_chiaveCrypt)
	and (TO_DATE(pi_datiniziomov, 'DD-MM-YY') - 1) BETWEEN cm.datdatainizio AND NVL(cm.datdatafine, SYSDATE);
	
	IF (v_conta > 0) THEN
		v_outFlgIscrCM := 'S';
	ELSE
		v_outFlgIscrCM := 'N';
	END IF;
	
	RETURN v_outFlgIscrCM;
end GetFlgIscrCm;

end PG_SIL_MONIT;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_SISTEMA.sql
************************************************************************************** */


CREATE OR REPLACE package PG_SISTEMA is
function pdConcorrenzaIns
return integer;
function pdConcorrenzaUpd (oldNumKlo in integer, newNumKlo in integer)
return integer;
end;
/
CREATE OR REPLACE package BODY PG_SISTEMA  is
function  pdConcorrenzaIns  return integer is
begin
return dbms_utility.get_time;
end;
function pdConcorrenzaUpd (oldNumKlo in integer, newNumKlo in integer) return integer  is
begin
	if (newNumKlo != oldNumKlo+1) then
		raise_application_error (-20990, 'Fallito aggiornamento.  Concorrenza. Il codice di errore sql mappa un messaggio in messages_it_IT.properties');
	end if;
	return newNumKlo; -- non è corretto far tornare pdConcorrenzaIns (salti di numerazione e due insert di seguito devono rileggere)

end;

end;
/





/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_SOGG_ESTERNI.sql
************************************************************************************** */


CREATE OR REPLACE package PG_SOGG_ESTERNI is

procedure pdModValiditaCurriculum (cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
		  					   	   cdnParUtMod in TS_UTENTE.CDNUTMOD%TYPE,
		  					       dtmParMod in date,
		  					       codParLstTab in DE_LST_TAB.codLstTab%type := null);


end PG_SOGG_ESTERNI;
/

CREATE OR REPLACE package BODY PG_SOGG_ESTERNI is

procedure pdModValiditaCurriculum ( cdnParLavoratore in AN_LAVORATORE.cdnLavoratore%TYPE,
                 cdnParUtMod in TS_UTENTE.CDNUTMOD%TYPE,
                 dtmParMod in date,
                 codParLstTab in DE_LST_TAB.codLstTab%type := null) is

  -- variabili
 cdnVarLavoratore AN_LAVORATORE.cdnLavoratore%TYPE;
 cdnVarLav AN_LAVORATORE.cdnLavoratore%TYPE;
 varNummRec integer;
 varNummValid integer;
 dataConc NUMBER;
 flgData NUMBER;

 datIn   PR_VALIDITA.DATINIZIOCURR%TYPE;
 datFine PR_VALIDITA.DATFINECURR%TYPE;

 datInPresente   PR_VALIDITA.DATINIZIOCURR%TYPE;
 datFinePresente PR_VALIDITA.DATFINECURR%TYPE;
 
 datFineIns PR_VALIDITA.DATFINECURR%TYPE;
 datFineIns180 PR_VALIDITA.DATFINECURR%TYPE;
 
 datCurr PR_VALIDITA.DATFINECURR%TYPE;
 
 prgValid PR_VALIDITA.PRGVALIDITA%TYPE;
 numKlo PR_VALIDITA.PRGVALIDITA%TYPE;
 numKloIns PR_VALIDITA.PRGVALIDITA%TYPE;

 
begin

 cdnVarLavoratore := cdnParLavoratore;

 select count(1)
 into varNummRec
 from ts_profilatura_utente pu, ts_gruppo g
 where pu.cdngruppo=g.cdngruppo
 and g.CDNTIPOGRUPPO=10
 and cdnut=cdnParUtMod;

 if not codParLstTab is null then
   if codParLstTab  in ('PR_D_CON', 'PR_D_TUR', 'PR_D_ORA', 'PR_D_COM', 'PR_D_REG', 'PR_D_STA', 'PR_D_PRO', 'PR_MO_GE', 'PR_ESP_L' ) then
      select cdnLavoratore
      into cdnVarLav
      from PR_MANSIONE pma
     where pma.PRGMANSIONE = cdnParLavoratore;  -- parametro utilizzato per la chiave della tabella specifica  in questo caso
     
     cdnVarLavoratore := cdnVarLav;
   end if;
 end if;

 
 DECLARE

	 CURSOR validCur IS
	 Select datInizioCurr, datFineCurr, numKloValidita
	   From PR_VALIDITA
	  where cdnLavoratore = cdnVarLavoratore; 

 BEGIN
 
	 if(varNummRec > 0) then
	   select count(1)
	   into varNummValid
	   from PR_VALIDITA
	   where CDNLAVORATORE = cdnVarLavoratore and CODTIPOVALIDITA='DL';
	
	   if(varNummValid > 0) then
			
		    select num
		    into dataConc
		    from ts_config_loc
		    where codtipoconfig='VMXSLAV'
		      and strcodrif = (select codprovinciasil from ts_generale where strvalore='DL');
	
			flgData := 0;
			datFineIns180 := (sysdate + dataConc) - 1;
			datCurr := datFineIns180;
			datFineIns := datFineIns180;
			
			Open validCur;
			Loop
				Fetch validCur into datIn,datFine,numKlo;
				EXIT WHEN validCur%NOTFOUND;
				if sysdate >= datIn then
				   if sysdate <= datFine then
				   	  flgData:=1;
					  datInPresente:=datIn;
					  datFinePresente:=datFine;
					  numKloIns := numKlo;
					  Exit;
				   end if;
				end if;
				if datIn > sysdate then
				   if datIn > datFineIns180 then
				   	  datFineIns := datFineIns180;
					  datCurr := datFineIns180;
				   elsif datIn < datCurr then
				   	  datCurr := datIn - 1;
					  datFineIns := datIn - 1;
				   end if;	  
				end if;
			End Loop;
			Close validCur;
			
			if flgData = 1 then  -- se esiste già un periodo di validità
			    update PR_VALIDITA
			     set CODSTATOLAV = 'VAL',
			     CDNUTMOD = cdnParUtMod,
			     DTMMOD = dtmParMod,
				 NUMKLOVALIDITA = numKloIns + 1
			    where CDNLAVORATORE = cdnVarLavoratore
				  and datInizioCurr = datInPresente
				  and datFineCurr = datFinePresente;		       
			else               -- se non esiste già un periodo di validita		   
				   SELECT S_PR_VALIDITA.NEXTVAL 
				     INTO prgValid
					 FROM DUAL;
				   
				   insert into PR_VALIDITA
					    (PRGVALIDITA,
						CDNLAVORATORE,
					    CODTIPOVALIDITA,
					    DATINIZIOCURR,
					    DATFINECURR,
					    CODSTATOLAV,
					    CDNUTINS,
					    DTMINS,
					    CDNUTMOD,
					    DTMMOD
					    )
					    VALUES (prgValid,
							cdnVarLavoratore,
					        'DL',
							to_date(to_char(sysdate,'dd/mm/yyyy'),'dd/mm/yyyy'),
							to_date(to_char(datFineIns,'dd/mm/yyyy'),'dd/mm/yyyy'),						
					        'VAL',
					        cdnParUtMod,
					        dtmParMod,
					        cdnParUtMod,
					        dtmParMod);			
			end if;
			
	   else
	      select num
	      into dataConc
	      from ts_config_loc
	      where codtipoconfig='VMXSLAV'
	        and strcodrif = (select codprovinciasil from ts_generale where strvalore='DL');
	
			
		   SELECT S_PR_VALIDITA.NEXTVAL 
		     INTO prgValid
			 FROM DUAL;
	
	       insert into PR_VALIDITA
			    (PRGVALIDITA,
				CDNLAVORATORE,
			    CODTIPOVALIDITA,
			    DATINIZIOCURR,
			    DATFINECURR,
			    CODSTATOLAV,
			    CDNUTINS,
			    DTMINS,
			    CDNUTMOD,
			    DTMMOD
			    )
			    VALUES (prgValid,
					cdnVarLavoratore,
			        'DL',
					to_date(to_char(sysdate,'dd/mm/yyyy'),'dd/mm/yyyy'),
			        to_date(to_char((sysdate + dataConc) - 1,'dd/mm/yyyy'),'dd/mm/yyyy'),
			        'VAL',
			        cdnParUtMod,
			        dtmParMod,
			        cdnParUtMod,
			        dtmParMod);
	   end if;
	 end if;
 end;
end;


end PG_SOGG_ESTERNI;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_STORIA_ROSA.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_STORIA_ROSA AS

/**********************************
* Versione 0_9                    *
*                                 *
* autore: Stefania Orioli         *
*                                 *
* Funzioni per la gestione della  *
* storia dei lavoratori in merito *
* alle rose candidati.            *
***********************************/

-- Effettua un inserimento o un update in seguito alla cancellazione
-- di un nominativo da una rosa grezza o alla sua esclusione per
-- l'applicazione di un filtro su una rosa grezza.
-- Viene attivata da un trigger su DO_NOMINATIVO.
Procedure pdAggStoriaRosaXCanc(
    p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%TYPE, -- codice del lavoratore
    p_prgRosa DO_LAV_STORIA_ROSA.PRGROSA%TYPE,                -- codice della rosa di riferimento
    p_codTipoCanc DO_LAV_STORIA_ROSA.CODTIPOCANC%TYPE,   -- codice del tipo di cancellazione
    p_dtmCanc DO_LAV_STORIA_ROSA.DTMCANC%TYPE);    -- data della cancellazione
--
Procedure PORT_pdAggStoriaRosaXCanc(
    p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%TYPE, -- codice del lavoratore
    p_prgRosa DO_LAV_STORIA_ROSA.PRGROSA%TYPE,                -- codice della rosa di riferimento
    p_codTipoCanc DO_LAV_STORIA_ROSA.CODTIPOCANC%TYPE,   -- codice del tipo di cancellazione
    p_dtmCanc DO_LAV_STORIA_ROSA.DTMCANC%TYPE);    -- data della cancellazione
-- Effettua uno o più inserimenti o uno o più update in seguito
-- all'inserimento o alla modifica di una disponibilita di un candidato
-- relativamente ad un determinata richiesta da parte di una azienda
Procedure pdAggStoriaRosaXDispo(
    p_prgOriginale DO_LAV_STORIA_ROSA.PRGRICHIESTA%TYPE,  -- codice richiesta originale
    p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%TYPE, -- codice del lavoratore
    p_codDisponibilitaRosa DO_LAV_STORIA_ROSA.CODDISPONIBILITAROSA%TYPE, -- codice disponibilita
    p_datDisponibilita DO_LAV_STORIA_ROSA.DATDISPONIBILITA%TYPE);
--
Procedure PORT_pdAggStoriaRosaXDispo(
    p_prgOriginale DO_LAV_STORIA_ROSA.PRGRICHIESTA%TYPE,  -- codice richiesta originale
    p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%TYPE, -- codice del lavoratore
    p_codDisponibilitaRosa DO_LAV_STORIA_ROSA.CODDISPONIBILITAROSA%TYPE, -- codice disponibilita
    p_datDisponibilita DO_LAV_STORIA_ROSA.DATDISPONIBILITA%TYPE);

-- Al passaggio di stato della rosa da grezza a definitiva vengono inseriti in DO_LAV_STORIA_ROSA
-- tutti i candidati che fanno parte della rosa definitiva, ovvero quei candidati che non sono
-- stati cancellati e che hanno coddisponibilita='A'.
Procedure pdAggStoriaRosaXStato(
    p_prgRosa DO_LAV_STORIA_ROSA.PRGROSA%TYPE    -- codice della rosa
    );


-- Aggiorna la data di invio di una rosa
Procedure pdAggStoriaRosaXInvio(
    p_prgRosa DO_LAV_STORIA_ROSA.PRGROSA%TYPE,     -- codice della rosa
    p_prgTipoRosa DO_LAV_STORIA_ROSA.PRGTIPOROSA%TYPE,   -- codice tipo rosa
    p_datInvio DO_LAV_STORIA_ROSA.DATINVIO%TYPE     -- data dell'invio
    );


-- Effettua uno o più inserimenti o uno o più update in seguito
-- all'inserimento o alla modifica di un esito di un candidato
-- relativamente ad un determinata richiesta da parte di una azienda
Procedure pdAggStoriaRosaXEsito(
    p_prgOriginale DO_LAV_STORIA_ROSA.PRGRICHIESTA%TYPE,  -- codice richiesta originale
    p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%TYPE, -- codice del lavoratore
    p_codEsitoDaAzienda DO_LAV_STORIA_ROSA.CODESITODAAZIENDA%TYPE,
    p_codEsitoDaLavoratore DO_LAV_STORIA_ROSA.CODESITODALAVORATORE%TYPE
);

-- Restituisce il numero di esclusioni da una rosa di un lavoratore
Function nroEsclusioniRosa(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return number;

-- Restituisce si/no a seconda che il lavoratore sia stato precedentemente segnalato oppure no ad una certa azienda
Function flagStessaAz(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type,
        p_prgAzienda DO_LAV_STORIA_ROSA.PRGAZIENDA%type) return char;


-- Restituisce l'elenco delle liste speciali di un lavoratore per la visualizzazione nell'elenco
-- candidati del matching
Function candidatoRosaListeSpeciali(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return varchar;

-- Restituisce l'elenco delle liste speciali di un lavoratore per la visualizzazione nella stampa
-- candidati del matching
Function candidatoRosaListeSpecialiCC(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return varchar;

-- Restituisce un numero in relazione alla did di un lavoratore per l'ordinamento nella
-- visualizzazione dell'elenco candidati del matching
Function ordineDidRosa(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return varchar;

-- Restituisce il numero di candidati disoccupati appartenenti ad una certa rosa
Function numDisoccupatiRosa(p_prgRosa DO_NOMINATIVO.PRGROSA%type) return number;

Function numDisoccupati150(p_prgRosa DO_NOMINATIVO.PRGROSA%type) return number;
Function numOccupati150(p_prgRosa DO_NOMINATIVO.PRGROSA%type) return number;

-- Restituisce l'elenco delle condizioni di un lavoratore per la visualizzazione nell'elenco
-- candidati del matching
-- (Aggiunto da Paolo Roccetti il 08/09/2004)
Function candidatoRosaCondizioni(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return varchar2;

-- Restituisce l'elenco delle condizioni di un lavoratore per la stampa
-- dell'elenco
-- candidati del matching
-- (Aggiunto da Maurizio Discepolo il 24/09/2004)
Function candidatoRosaCondizioniCC(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return varchar2;
--
Function mesiAnzianita(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type) return NUMBER;
--
Function statoDid(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type) return VARCHAR2;
END PG_STORIA_ROSA;
/
CREATE OR REPLACE PACKAGE BODY PG_STORIA_ROSA AS

/***************
* Versione 0_9 *
***************/


Procedure pdAggStoriaRosaXCanc(
    p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%TYPE, -- codice del lavoratore
    p_prgRosa DO_LAV_STORIA_ROSA.PRGROSA%TYPE,                -- codice della rosa di riferimento
    p_codTipoCanc DO_LAV_STORIA_ROSA.CODTIPOCANC%TYPE,   -- codice del tipo di cancellazione
    p_dtmCanc DO_LAV_STORIA_ROSA.DTMCANC%TYPE)    -- data della cancellazione

IS



 par_prgDoLavStoriaRosa DO_LAV_STORIA_ROSA.PRGDOLAVSTORIAROSA%TYPE;
 par_prgOriginale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;   -- progressivo della richiesta originale (numStorico=0)
 par_codProvinciaSil TS_GENERALE.CODPROVINCIASIL%TYPE;      -- codice provincia master
 par_prgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;     -- codice Azienda
 par_prgUnita DO_RICHIESTA_AZ.PRGUNITA%TYPE;      -- codice sede azienda
 par_prgTipoRosa DO_ROSA.PRGTIPOROSA%TYPE;      -- codice tipo rosa
 par_codEsitoDaAzienda DO_ESITO_CANDIDATO.CODESITODAAZIENDA%TYPE;
 par_codEsitoDaLavoratore DO_ESITO_CANDIDATO.CODESITODACANDIDATO%TYPE;
 par_codDisponibilitaRosa DO_DISPONIBILITA.CODDISPONIBILITAROSA%TYPE;
 par_datDisponibilita DO_DISPONIBILITA.DATDISPONIBILITA%TYPE;
 par_conta number;

BEGIN
 -- Determino la provincia del master
 select codProvinciaSil into par_codProvinciaSil
 from TS_GENERALE;

 -- Determino il progressivo della richiesta originale
 SELECT RICH2.PRGRICHIESTAAZ into par_prgOriginale
 FROM
   DO_ROSA
   INNER JOIN DO_INCROCIO ON (DO_ROSA.PRGINCROCIO = DO_INCROCIO.PRGINCROCIO)
   INNER JOIN DO_RICHIESTA_AZ RICH1 ON (DO_INCROCIO.PRGRICHIESTAAZ = RICH1.PRGRICHIESTAAZ)
   INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
 WHERE DO_ROSA.PRGROSA = p_prgRosa;


 -- Controllo se il record corrispondente al lavoratore "cancellato" o "filtrato" esiste già
 select count(st.PRGDOLAVSTORIAROSA) into par_conta
 from DO_LAV_STORIA_ROSA st
 where
   st.CODPROVINCIA = par_codProvinciaSil
   and st.CDNLAVORATORE = p_cdnLavoratore
   and st.PRGROSA = p_prgRosa
   and st.PRGRICHIESTA = par_prgOriginale;

 if(par_conta > 0) then
  select st.PRGDOLAVSTORIAROSA into par_prgDoLavStoriaRosa
  from DO_LAV_STORIA_ROSA st
  where
    st.CODPROVINCIA = par_codProvinciaSil
    and st.CDNLAVORATORE = p_cdnLavoratore
    and st.PRGROSA = p_prgRosa
    and st.PRGRICHIESTA = par_prgOriginale;
 end if;
 --dbms_output.put_line('prgDoLavStoriaRosa = ' || par_prgDoLavStoriaRosa);

 if(par_prgDoLavStoriaRosa is not null) then
   -- si tratta di fare un UPDATE
   update do_lav_storia_rosa
   set codTipoCanc = p_codTipoCanc,
    dtmCanc = to_date(p_dtmCanc, 'dd/mm/yyyy')
   where
    prgDoLavStoriaRosa = par_prgDoLavStoriaRosa;
 else
   -- si tratta di fare una INSERT

   -- reperisco i valori che mi servono per l'inserimento
   select
      prgAzienda, prgUnita
   into
      par_prgAzienda,
      par_prgUnita
   from do_richiesta_az where prgRichiestaAz = par_prgOriginale;

   select prgTipoRosa into par_prgTipoRosa
   from DO_ROSA where prgRosa = p_prgRosa;

   -- codEsitoDaAzienda e codEsitoDaCandidato potrebbero non esserci o non essere valorizzati
   select count(1) into par_conta
   from DO_ESITO_CANDIDATO
   where prgRichiestaAz = par_prgOriginale and cdnLavoratore = p_cdnLavoratore;
   if(par_conta>0) then
    select
        codEsitoDaAzienda, codEsitoDaCandidato
    into
        par_codEsitoDaAzienda, par_codEsitoDaLavoratore
    from DO_ESITO_CANDIDATO
    where prgRichiestaAz = par_prgOriginale and cdnLavoratore = p_cdnLavoratore;
   end if;

   -- codDisponibilita e datDisponibilita potrebbero non esserci o non essere valorizzati
   select count(1) into par_conta
   from DO_DISPONIBILITA
   where prgRichiestaAz = par_prgOriginale and cdnLavoratore = p_cdnLavoratore;

   if(par_conta>0) then
    select
        codDisponibilitaRosa, datDisponibilita
    into
        par_codDisponibilitaRosa, par_datDisponibilita
       from DO_DISPONIBILITA
    where prgRichiestaAz = par_prgOriginale and cdnLavoratore = p_cdnLavoratore;
   end if;

   -- inserisco il record in DO_LAV_STORIA_ROSA
   insert into DO_LAV_STORIA_ROSA
   (prgDoLavStoriaRosa, codProvincia, cdnLavoratore,
   prgRichiesta, prgAzienda, prgUnita,
   prgRosa, prgTipoRosa,
   codEsitoDaAzienda, codEsitoDaLavoratore,
   codTipoCanc, dtmCanc,
   codDisponibilitaRosa, datDisponibilita)
   VALUES
   (S_DO_LAV_STORIA_ROSA.nextval, par_codProvinciaSil, p_cdnLavoratore,
    par_prgOriginale, par_prgAzienda, par_prgUnita,
    p_prgRosa, par_prgTipoRosa,
    par_codEsitoDaAzienda, par_codEsitoDaLavoratore,
    p_codTipoCanc, p_dtmCanc,
    par_codDisponibilitaRosa, par_datDisponibilita);
 end if;


 exception
   when others then
      dbms_output.PUT_LINE('Errore = ' || sqlcode);

END pdAggStoriaRosaXCanc;

-- Identica alla precedente ma con alcune rettifiche sul tipo di rosa per il porting
Procedure PORT_pdAggStoriaRosaXCanc(
    p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%TYPE, -- codice del lavoratore
    p_prgRosa DO_LAV_STORIA_ROSA.PRGROSA%TYPE,                -- codice della rosa di riferimento
    p_codTipoCanc DO_LAV_STORIA_ROSA.CODTIPOCANC%TYPE,   -- codice del tipo di cancellazione
    p_dtmCanc DO_LAV_STORIA_ROSA.DTMCANC%TYPE)    -- data della cancellazione

IS



 par_prgDoLavStoriaRosa DO_LAV_STORIA_ROSA.PRGDOLAVSTORIAROSA%TYPE;
 par_prgOriginale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;   -- progressivo della richiesta originale (numStorico=0)
 par_codProvinciaSil TS_GENERALE.CODPROVINCIASIL%TYPE;      -- codice provincia master
 par_prgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;     -- codice Azienda
 par_prgUnita DO_RICHIESTA_AZ.PRGUNITA%TYPE;      -- codice sede azienda
 par_prgTipoRosa DO_ROSA.PRGTIPOROSA%TYPE;      -- codice tipo rosa
 par_codEsitoDaAzienda DO_ESITO_CANDIDATO.CODESITODAAZIENDA%TYPE;
 par_codEsitoDaLavoratore DO_ESITO_CANDIDATO.CODESITODACANDIDATO%TYPE;
 par_codDisponibilitaRosa DO_DISPONIBILITA.CODDISPONIBILITAROSA%TYPE;
 par_datDisponibilita DO_DISPONIBILITA.DATDISPONIBILITA%TYPE;
 par_conta number;

BEGIN
 -- Determino la provincia del master
 select codProvinciaSil into par_codProvinciaSil
 from TS_GENERALE;

 -- Determino il progressivo della richiesta originale
 SELECT RICH2.PRGRICHIESTAAZ into par_prgOriginale
 FROM
   DO_ROSA
   INNER JOIN DO_INCROCIO ON (DO_ROSA.PRGINCROCIO = DO_INCROCIO.PRGINCROCIO)
   INNER JOIN DO_RICHIESTA_AZ RICH1 ON (DO_INCROCIO.PRGRICHIESTAAZ = RICH1.PRGRICHIESTAAZ)
   INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
 WHERE DO_ROSA.PRGROSA = p_prgRosa;


 -- Controllo se il record corrispondente al lavoratore "cancellato" o "filtrato" esiste già
 select count(st.PRGDOLAVSTORIAROSA) into par_conta
 from DO_LAV_STORIA_ROSA st
 where
   st.CODPROVINCIA = par_codProvinciaSil
   and st.CDNLAVORATORE = p_cdnLavoratore
   and st.PRGROSA = p_prgRosa
   and st.PRGRICHIESTA = par_prgOriginale;

 if(par_conta > 0) then
  select st.PRGDOLAVSTORIAROSA into par_prgDoLavStoriaRosa
  from DO_LAV_STORIA_ROSA st
  where
    st.CODPROVINCIA = par_codProvinciaSil
    and st.CDNLAVORATORE = p_cdnLavoratore
    and st.PRGROSA = p_prgRosa
    and st.PRGRICHIESTA = par_prgOriginale;
 end if;
 --dbms_output.put_line('prgDoLavStoriaRosa = ' || par_prgDoLavStoriaRosa);

 if(par_prgDoLavStoriaRosa is not null) then
   -- si tratta di fare un UPDATE
   update do_lav_storia_rosa
   set codTipoCanc = p_codTipoCanc,
    dtmCanc = to_date(p_dtmCanc, 'dd/mm/yyyy')
   where
    prgDoLavStoriaRosa = par_prgDoLavStoriaRosa;
 else
   -- si tratta di fare una INSERT

   -- reperisco i valori che mi servono per l'inserimento
   select
      prgAzienda, prgUnita
   into
      par_prgAzienda,
      par_prgUnita
   from do_richiesta_az where prgRichiestaAz = par_prgOriginale;

   --select prgTipoRosa into par_prgTipoRosa
   --from DO_ROSA where prgRosa = p_prgRosa;
   par_prgTipoRosa := 2;

   -- codEsitoDaAzienda e codEsitoDaCandidato potrebbero non esserci o non essere valorizzati
   select count(1) into par_conta
   from DO_ESITO_CANDIDATO
   where prgRichiestaAz = par_prgOriginale and cdnLavoratore = p_cdnLavoratore;
   if(par_conta>0) then
    select
        codEsitoDaAzienda, codEsitoDaCandidato
    into
        par_codEsitoDaAzienda, par_codEsitoDaLavoratore
    from DO_ESITO_CANDIDATO
    where prgRichiestaAz = par_prgOriginale and cdnLavoratore = p_cdnLavoratore;
   end if;

   -- codDisponibilita e datDisponibilita potrebbero non esserci o non essere valorizzati
   select count(1) into par_conta
   from DO_DISPONIBILITA
   where prgRichiestaAz = par_prgOriginale and cdnLavoratore = p_cdnLavoratore;

   if(par_conta>0) then
    select
        codDisponibilitaRosa, datDisponibilita
    into
        par_codDisponibilitaRosa, par_datDisponibilita
       from DO_DISPONIBILITA
    where prgRichiestaAz = par_prgOriginale and cdnLavoratore = p_cdnLavoratore;
   end if;

   -- inserisco il record in DO_LAV_STORIA_ROSA
   insert into DO_LAV_STORIA_ROSA
   (prgDoLavStoriaRosa, codProvincia, cdnLavoratore,
   prgRichiesta, prgAzienda, prgUnita,
   prgRosa, prgTipoRosa,
   codEsitoDaAzienda, codEsitoDaLavoratore,
   codTipoCanc, dtmCanc,
   codDisponibilitaRosa, datDisponibilita)
   VALUES
   (S_DO_LAV_STORIA_ROSA.nextval, par_codProvinciaSil, p_cdnLavoratore,
    par_prgOriginale, par_prgAzienda, par_prgUnita,
    p_prgRosa, par_prgTipoRosa,
    par_codEsitoDaAzienda, par_codEsitoDaLavoratore,
    p_codTipoCanc, p_dtmCanc,
    par_codDisponibilitaRosa, par_datDisponibilita);
 end if;


 exception
   when others then
      dbms_output.PUT_LINE('Errore = ' || sqlcode);

END PORT_pdAggStoriaRosaXCanc;



Procedure pdAggStoriaRosaXDispo(
    p_prgOriginale DO_LAV_STORIA_ROSA.PRGRICHIESTA%TYPE,  -- codice richiesta originale
    p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%TYPE, -- codice del lavoratore
    p_codDisponibilitaRosa DO_LAV_STORIA_ROSA.CODDISPONIBILITAROSA%TYPE, -- codice disponibilita
    p_datDisponibilita DO_LAV_STORIA_ROSA.DATDISPONIBILITA%TYPE)

IS

 par_prgDoLavStoriaRosa DO_LAV_STORIA_ROSA.PRGDOLAVSTORIAROSA%TYPE;
 par_codProvinciaSil TS_GENERALE.CODPROVINCIASIL%TYPE;      -- codice provincia master
 par_prgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;     -- codice Azienda
 par_prgUnita DO_RICHIESTA_AZ.PRGUNITA%TYPE;      -- codice sede azienda
 par_prgTipoRosa DO_ROSA.PRGTIPOROSA%TYPE;      -- codice tipo rosa
 par_codEsitoDaAzienda DO_ESITO_CANDIDATO.CODESITODAAZIENDA%TYPE;
 par_codEsitoDaLavoratore DO_ESITO_CANDIDATO.CODESITODACANDIDATO%TYPE;
 par_conta number;
 par_prgRosa DO_LAV_STORIA_ROSA.PRGROSA%TYPE;

 CURSOR curRose is
     select do_rosa.PRGROSA, do_rosa.PRGTIPOROSA
     from do_rosa
       inner join do_incrocio on (do_rosa.PRGINCROCIO = do_incrocio.PRGINCROCIO)
     where
       (do_rosa.prgTipoRosa=2 or do_rosa.prgTipoRosa=3) and
       do_incrocio.PRGRICHIESTAAZ in
    (SELECT RICH2.PRGRICHIESTAAZ
     FROM DO_RICHIESTA_AZ RICH1
          INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA)
     WHERE RICH1.PRGRICHIESTAAZ = p_prgOriginale);

BEGIN
  -- Determino la provincia del master
 select codProvinciaSil into par_codProvinciaSil
 from TS_GENERALE;

 FOR rec in curRose LOOP
  par_prgRosa := rec.prgRosa;
  par_prgTipoRosa := rec.prgTipoRosa;

  -- Controllo se il record corrispondente al lavoratore esiste già per la rosa che sto esaminando
  select count(st.PRGDOLAVSTORIAROSA) into par_conta
  from DO_LAV_STORIA_ROSA st
  where
    st.CODPROVINCIA = par_codProvinciaSil
    and st.CDNLAVORATORE = p_cdnLavoratore
    and st.PRGROSA = par_prgRosa
    and st.PRGRICHIESTA = p_prgOriginale;
  if(par_conta > 0) then
   select st.PRGDOLAVSTORIAROSA into par_prgDoLavStoriaRosa
   from DO_LAV_STORIA_ROSA st
   where
     st.CODPROVINCIA = par_codProvinciaSil
     and st.CDNLAVORATORE = p_cdnLavoratore
     and st.PRGROSA = par_prgRosa
     and st.PRGRICHIESTA = p_prgOriginale;
  end if;


  if(par_prgDoLavStoriaRosa is not null) then
    -- si tratta di fare un UPDATE
    update do_lav_storia_rosa
    set codDisponibilitaRosa = p_codDisponibilitaRosa,
     datDisponibilita = p_datDisponibilita
    where
     prgDoLavStoriaRosa = par_prgDoLavStoriaRosa;
  else
    -- si tratta di fare una INSERT

    -- reperisco i valori che mi servono per l'inserimento
    select
       prgAzienda, prgUnita
    into
       par_prgAzienda,
       par_prgUnita
    from do_richiesta_az where prgRichiestaAz = p_prgOriginale;

    -- codEsitoDaAzienda e codEsitoDaCandidato potrebbero non esserci o non essere valorizzati
    select count(1) into par_conta
    from DO_ESITO_CANDIDATO
    where prgRichiestaAz = p_prgOriginale and cdnLavoratore = p_cdnLavoratore;
    if(par_conta>0) then
     select
         codEsitoDaAzienda, codEsitoDaCandidato
     into
         par_codEsitoDaAzienda, par_codEsitoDaLavoratore
     from DO_ESITO_CANDIDATO
     where prgRichiestaAz = p_prgOriginale and cdnLavoratore = p_cdnLavoratore;
    end if;

    -- inserisco il record in DO_LAV_STORIA_ROSA
    insert into DO_LAV_STORIA_ROSA
    (prgDoLavStoriaRosa, codProvincia, cdnLavoratore,
    prgRichiesta, prgAzienda, prgUnita,
    prgRosa, prgTipoRosa,
    codEsitoDaAzienda, codEsitoDaLavoratore,
    codDisponibilitaRosa, datDisponibilita)
    VALUES
    (S_DO_LAV_STORIA_ROSA.nextval, par_codProvinciaSil, p_cdnLavoratore,
     p_prgOriginale, par_prgAzienda, par_prgUnita,
     par_prgRosa, par_prgTipoRosa,
     par_codEsitoDaAzienda, par_codEsitoDaLavoratore,
     p_codDisponibilitaRosa, p_datDisponibilita);
  end if;
 END LOOP;

 exception
   when others then
      dbms_output.PUT_LINE('Errore = ' || sqlcode);

END pdAggStoriaRosaXDispo;

-- Identica alla precedente ma con alcune rettifiche sul tipo di rosa per il porting
Procedure PORT_pdAggStoriaRosaXDispo(
    p_prgOriginale DO_LAV_STORIA_ROSA.PRGRICHIESTA%TYPE,  -- codice richiesta originale
    p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%TYPE, -- codice del lavoratore
    p_codDisponibilitaRosa DO_LAV_STORIA_ROSA.CODDISPONIBILITAROSA%TYPE, -- codice disponibilita
    p_datDisponibilita DO_LAV_STORIA_ROSA.DATDISPONIBILITA%TYPE)

IS

 par_prgDoLavStoriaRosa DO_LAV_STORIA_ROSA.PRGDOLAVSTORIAROSA%TYPE;
 par_codProvinciaSil TS_GENERALE.CODPROVINCIASIL%TYPE;      -- codice provincia master
 par_prgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;     -- codice Azienda
 par_prgUnita DO_RICHIESTA_AZ.PRGUNITA%TYPE;      -- codice sede azienda
 par_prgTipoRosa DO_ROSA.PRGTIPOROSA%TYPE;      -- codice tipo rosa
 par_codEsitoDaAzienda DO_ESITO_CANDIDATO.CODESITODAAZIENDA%TYPE;
 par_codEsitoDaLavoratore DO_ESITO_CANDIDATO.CODESITODACANDIDATO%TYPE;
 par_conta number;
 par_prgRosa DO_LAV_STORIA_ROSA.PRGROSA%TYPE;

 CURSOR curRose is
     select do_rosa.PRGROSA, do_rosa.PRGTIPOROSA
     from do_rosa
       inner join do_incrocio on (do_rosa.PRGINCROCIO = do_incrocio.PRGINCROCIO)
     where
       (do_rosa.prgTipoRosa=2 or do_rosa.prgTipoRosa=3) and
       do_incrocio.PRGRICHIESTAAZ in
    (SELECT RICH2.PRGRICHIESTAAZ
     FROM DO_RICHIESTA_AZ RICH1
          INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA)
     WHERE RICH1.PRGRICHIESTAAZ = p_prgOriginale);

BEGIN
  -- Determino la provincia del master
 select codProvinciaSil into par_codProvinciaSil
 from TS_GENERALE;

 FOR rec in curRose LOOP
  par_prgRosa := rec.prgRosa;
  par_prgTipoRosa := rec.prgTipoRosa;

  -- Controllo se il record corrispondente al lavoratore esiste già per la rosa che sto esaminando
  select count(st.PRGDOLAVSTORIAROSA) into par_conta
  from DO_LAV_STORIA_ROSA st
  where
    st.CODPROVINCIA = par_codProvinciaSil
    and st.CDNLAVORATORE = p_cdnLavoratore
    and st.PRGROSA = par_prgRosa
    and st.PRGRICHIESTA = p_prgOriginale;
  if(par_conta > 0) then
   select st.PRGDOLAVSTORIAROSA into par_prgDoLavStoriaRosa
   from DO_LAV_STORIA_ROSA st
   where
     st.CODPROVINCIA = par_codProvinciaSil
     and st.CDNLAVORATORE = p_cdnLavoratore
     and st.PRGROSA = par_prgRosa
     and st.PRGRICHIESTA = p_prgOriginale;
  end if;


  if(par_prgDoLavStoriaRosa is not null) then
    -- si tratta di fare un UPDATE
    update do_lav_storia_rosa
    set codDisponibilitaRosa = p_codDisponibilitaRosa,
     datDisponibilita = p_datDisponibilita
    where
     prgDoLavStoriaRosa = par_prgDoLavStoriaRosa;
  else
    -- si tratta di fare una INSERT

    -- reperisco i valori che mi servono per l'inserimento
    select
       prgAzienda, prgUnita
    into
       par_prgAzienda,
       par_prgUnita
    from do_richiesta_az where prgRichiestaAz = p_prgOriginale;

    -- codEsitoDaAzienda e codEsitoDaCandidato potrebbero non esserci o non essere valorizzati
    select count(1) into par_conta
    from DO_ESITO_CANDIDATO
    where prgRichiestaAz = p_prgOriginale and cdnLavoratore = p_cdnLavoratore;
    if(par_conta>0) then
     select
         codEsitoDaAzienda, codEsitoDaCandidato
     into
         par_codEsitoDaAzienda, par_codEsitoDaLavoratore
     from DO_ESITO_CANDIDATO
     where prgRichiestaAz = p_prgOriginale and cdnLavoratore = p_cdnLavoratore;
    end if;

    par_prgTipoRosa := 2;
    -- inserisco il record in DO_LAV_STORIA_ROSA
    insert into DO_LAV_STORIA_ROSA
    (prgDoLavStoriaRosa, codProvincia, cdnLavoratore,
    prgRichiesta, prgAzienda, prgUnita,
    prgRosa, prgTipoRosa,
    codEsitoDaAzienda, codEsitoDaLavoratore,
    codDisponibilitaRosa, datDisponibilita)
    VALUES
    (S_DO_LAV_STORIA_ROSA.nextval, par_codProvinciaSil, p_cdnLavoratore,
     p_prgOriginale, par_prgAzienda, par_prgUnita,
     par_prgRosa, par_prgTipoRosa,
     par_codEsitoDaAzienda, par_codEsitoDaLavoratore,
     p_codDisponibilitaRosa, p_datDisponibilita);
  end if;
 END LOOP;

 exception
   when others then
      dbms_output.PUT_LINE('Errore = ' || sqlcode);

END PORT_pdAggStoriaRosaXDispo;


Procedure pdAggStoriaRosaXStato(
    p_prgRosa DO_LAV_STORIA_ROSA.PRGROSA%TYPE    -- codice della rosa
    )
IS

 par_codProvinciaSil TS_GENERALE.CODPROVINCIASIL%TYPE;      -- codice provincia master

 CURSOR curCandidati IS
     select
        r.PRGNOMINATIVO, r.CDNLAVORATORE,
        rich2.PRGRICHIESTAAZ AS PRGORIGINALE, rich2.PRGAZIENDA, rich2.PRGUNITA,
     do_rosa.PRGTIPOROSA,
     do_disponibilita.CODDISPONIBILITAROSA,
     do_disponibilita.DATDISPONIBILITA,
     do_esito_candidato.CODESITODAAZIENDA,
     do_esito_candidato.CODESITODACANDIDATO
   from do_nominativo r
   inner join do_rosa on (r.PRGROSA=do_rosa.PRGROSA)
   inner join do_incrocio on (do_rosa.PRGINCROCIO=do_incrocio.PRGINCROCIO)
   inner join do_richiesta_az rich1 on (do_incrocio.PRGRICHIESTAAZ=rich1.PRGRICHIESTAAZ)
   inner join do_richiesta_az rich2 on (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
   left outer join do_disponibilita on (rich2.PRGRICHIESTAAZ=do_disponibilita.PRGRICHIESTAAZ and do_disponibilita.CDNLAVORATORE=r.cdnLavoratore)
   left outer join do_esito_candidato on (rich2.PRGRICHIESTAAZ=do_esito_candidato.PRGRICHIESTAAZ and do_esito_candidato.CDNLAVORATORE=r.CDNLAVORATORE)
   where
       do_rosa.prgrosa=p_prgRosa and r.CODTIPOCANC is null
       and (do_disponibilita.CODDISPONIBILITAROSA like decode(do_rosa.PRGTIPOROSA,3,'A','%')
           or do_disponibilita.CODDISPONIBILITAROSA is null);


BEGIN
  -- Determino la provincia del master
 select codProvinciaSil into par_codProvinciaSil
 from TS_GENERALE;

 FOR rec in curCandidati LOOP
  INSERT INTO DO_LAV_STORIA_ROSA
  (PRGDOLAVSTORIAROSA, CODPROVINCIA, CDNLAVORATORE,
  PRGRICHIESTA, PRGAZIENDA, PRGUNITA,
  PRGROSA, PRGTIPOROSA,
  CODESITODAAZIENDA, CODESITODALAVORATORE,
  CODDISPONIBILITAROSA, DATDISPONIBILITA)
  VALUES
  (S_DO_LAV_STORIA_ROSA.nextVal, par_codProvinciaSil, rec.CDNLAVORATORE,
  rec.PRGORIGINALE, rec.PRGAZIENDA, rec.PRGUNITA,
  p_prgRosa, 3,
  rec.CODESITODAAZIENDA, rec.CODESITODACANDIDATO,
  rec.CODDISPONIBILITAROSA, rec.DATDISPONIBILITA
  );
 END LOOP;

 commit;

 exception
   when others then
      dbms_output.PUT_LINE('Errore = ' || sqlcode);


END pdAggStoriaRosaXStato;



Procedure pdAggStoriaRosaXInvio(
    p_prgRosa DO_LAV_STORIA_ROSA.PRGROSA%TYPE,     -- codice della rosa
    p_prgTipoRosa DO_LAV_STORIA_ROSA.PRGTIPOROSA%TYPE,   -- codice tipo rosa
    p_datInvio DO_LAV_STORIA_ROSA.DATINVIO%TYPE     -- data dell'invio
    )
IS



 par_prgDoLavStoriaRosa DO_LAV_STORIA_ROSA.PRGDOLAVSTORIAROSA%TYPE;
 par_prgOriginale DO_RICHIESTA_AZ.PRGRICHIESTAAZ%TYPE;   -- progressivo della richiesta originale (numStorico=0)
 par_codProvinciaSil TS_GENERALE.CODPROVINCIASIL%TYPE;      -- codice provincia master
 par_prgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;     -- codice Azienda
 par_prgUnita DO_RICHIESTA_AZ.PRGUNITA%TYPE;      -- codice sede azienda
 par_prgTipoRosa DO_ROSA.PRGTIPOROSA%TYPE;      -- codice tipo rosa
 par_codEsitoDaAzienda DO_ESITO_CANDIDATO.CODESITODAAZIENDA%TYPE;
 par_codEsitoDaLavoratore DO_ESITO_CANDIDATO.CODESITODACANDIDATO%TYPE;
 par_codDisponibilitaRosa DO_DISPONIBILITA.CODDISPONIBILITAROSA%TYPE;
 par_datDisponibilita DO_DISPONIBILITA.DATDISPONIBILITA%TYPE;
 par_conta number;

BEGIN
 -- Determino la provincia del master
 select codProvinciaSil into par_codProvinciaSil
 from TS_GENERALE;

 -- Determino il progressivo della richiesta originale
 SELECT RICH2.PRGRICHIESTAAZ into par_prgOriginale
 FROM
   DO_ROSA
   INNER JOIN DO_INCROCIO ON (DO_ROSA.PRGINCROCIO = DO_INCROCIO.PRGINCROCIO)
   INNER JOIN DO_RICHIESTA_AZ RICH1 ON (DO_INCROCIO.PRGRICHIESTAAZ = RICH1.PRGRICHIESTAAZ)
   INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA and rich2.NUMSTORICO=0)
 WHERE DO_ROSA.PRGROSA = p_prgRosa;

 if(p_datInvio is not null) then
   update DO_LAV_STORIA_ROSA sr
   set sr.DATINVIO = p_datInvio
   where
      sr.CODPROVINCIA = par_codProvinciaSil
     and sr.PRGRICHIESTA = par_prgOriginale
     and sr.PRGROSA = p_prgRosa
     and sr.PRGTIPOROSA = p_prgTipoRosa;
 end if;

 commit;

 exception
   when others then
      dbms_output.PUT_LINE('Errore = ' || sqlcode);
      rollback;


END pdAggStoriaRosaXInvio;


Procedure pdAggStoriaRosaXEsito(
    p_prgOriginale DO_LAV_STORIA_ROSA.PRGRICHIESTA%TYPE,  -- codice richiesta originale
    p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%TYPE, -- codice del lavoratore
    p_codEsitoDaAzienda DO_LAV_STORIA_ROSA.CODESITODAAZIENDA%TYPE,
    p_codEsitoDaLavoratore DO_LAV_STORIA_ROSA.CODESITODALAVORATORE%TYPE
)
IS

 par_prgDoLavStoriaRosa DO_LAV_STORIA_ROSA.PRGDOLAVSTORIAROSA%TYPE;
 par_codProvinciaSil TS_GENERALE.CODPROVINCIASIL%TYPE;      -- codice provincia master
 par_prgAzienda DO_RICHIESTA_AZ.PRGAZIENDA%TYPE;     -- codice Azienda
 par_prgUnita DO_RICHIESTA_AZ.PRGUNITA%TYPE;      -- codice sede azienda
 par_prgTipoRosa DO_ROSA.PRGTIPOROSA%TYPE;      -- codice tipo rosa
 par_codDisponibilitaRosa DO_DISPONIBILITA.CODDISPONIBILITAROSA%TYPE;
 par_datDisponibilita DO_DISPONIBILITA.DATDISPONIBILITA%TYPE;
 par_conta number;
 par_prgRosa DO_LAV_STORIA_ROSA.PRGROSA%TYPE;

 CURSOR curRose is
     select do_rosa.PRGROSA, do_rosa.PRGTIPOROSA
     from do_rosa
       inner join do_incrocio on (do_rosa.PRGINCROCIO = do_incrocio.PRGINCROCIO)
     where
       do_rosa.prgTipoRosa=3 and
       do_incrocio.PRGRICHIESTAAZ in
    (SELECT RICH2.PRGRICHIESTAAZ
     FROM DO_RICHIESTA_AZ RICH1
          INNER JOIN DO_RICHIESTA_AZ RICH2 ON (rich1.NUMANNO=rich2.NUMANNO and rich1.NUMRICHIESTA=rich2.NUMRICHIESTA)
     WHERE RICH1.PRGRICHIESTAAZ = p_prgOriginale);

BEGIN
  -- Determino la provincia del master
 select codProvinciaSil into par_codProvinciaSil
 from TS_GENERALE;

 FOR rec in curRose LOOP
  par_prgRosa := rec.prgRosa;
  par_prgTipoRosa := rec.prgTipoRosa;

  -- Controllo se il record corrispondente al lavoratore esiste già per la rosa che sto esaminando
  select count(st.PRGDOLAVSTORIAROSA) into par_conta
  from DO_LAV_STORIA_ROSA st
  where
    st.CODPROVINCIA = par_codProvinciaSil
    and st.CDNLAVORATORE = p_cdnLavoratore
    and st.PRGROSA = par_prgRosa
    and st.PRGRICHIESTA = p_prgOriginale;
  if(par_conta > 0) then
   select st.PRGDOLAVSTORIAROSA into par_prgDoLavStoriaRosa
   from DO_LAV_STORIA_ROSA st
   where
     st.CODPROVINCIA = par_codProvinciaSil
     and st.CDNLAVORATORE = p_cdnLavoratore
     and st.PRGROSA = par_prgRosa
     and st.PRGRICHIESTA = p_prgOriginale;
  end if;


  if(par_prgDoLavStoriaRosa is not null) then
    -- si tratta di fare un UPDATE
    update do_lav_storia_rosa
    set codEsitoDaAzienda = p_codEsitoDaAzienda,
     codEsitoDaLavoratore = p_codEsitoDaLavoratore
    where
     prgDoLavStoriaRosa = par_prgDoLavStoriaRosa;
  else
    -- si tratta di fare una INSERT

    -- reperisco i valori che mi servono per l'inserimento
    select
       prgAzienda, prgUnita
    into
       par_prgAzienda,
       par_prgUnita
    from do_richiesta_az where prgRichiestaAz = p_prgOriginale;

    -- codDisponibilita e datDisponibilita potrebbero non esserci o non essere valorizzati
    select count(1) into par_conta
    from DO_DISPONIBILITA
    where prgRichiestaAz = p_prgOriginale and cdnLavoratore = p_cdnLavoratore;

    if(par_conta>0) then
     select
         codDisponibilitaRosa, datDisponibilita
     into
         par_codDisponibilitaRosa, par_datDisponibilita
        from DO_DISPONIBILITA
     where prgRichiestaAz = p_prgOriginale and cdnLavoratore = p_cdnLavoratore;
    end if;



    -- inserisco il record in DO_LAV_STORIA_ROSA
    insert into DO_LAV_STORIA_ROSA
    (prgDoLavStoriaRosa, codProvincia, cdnLavoratore,
    prgRichiesta, prgAzienda, prgUnita,
    prgRosa, prgTipoRosa,
    codEsitoDaAzienda, codEsitoDaLavoratore,
    codDisponibilitaRosa, datDisponibilita)
    VALUES
    (S_DO_LAV_STORIA_ROSA.nextval, par_codProvinciaSil, p_cdnLavoratore,
     p_prgOriginale, par_prgAzienda, par_prgUnita,
     par_prgRosa, par_prgTipoRosa,
     p_codEsitoDaAzienda, p_codEsitoDaLavoratore,
     par_codDisponibilitaRosa, par_datDisponibilita);
  end if;
 END LOOP;

 exception
   when others then
      dbms_output.PUT_LINE('Errore = ' || sqlcode);

END pdAggStoriaRosaXEsito;


Function nroEsclusioniRosa(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return number IS
 p_nroEscl number;

BEGIN
 select count(1) into p_nroEscl
 from do_lav_storia_rosa strosa
 left outer join vw_do_storia_rosa vs on (strosa.CDNLAVORATORE=vs.CDNLAVORATORE)
 where strosa.CDNLAVORATORE=p_cdnLavoratore
     AND (strosa.CODTIPOCANC is not null or (strosa.CODDISPONIBILITAROSA is not null AND strosa.CODDISPONIBILITAROSA<>'A') )
      AND ((nvl(to_number(to_char(strosa.DTMCANC, 'yyyymmdd')),0)
           > nvl(to_number(to_char(vs.DtmUltimaSegn,'yyyyymmdd')),0)
   )
   OR (nvl(to_number(to_char(strosa.DATDISPONIBILITA, 'yyyymmdd')),0)
      > nvl(to_number(to_char(vs.DtmUltimaSegn,'yyyyymmdd')),0)
   ));

 dbms_output.PUT_LINE('Nro Esclusioni ' || p_nroEscl);

 return p_nroEscl;
END nroEsclusioniRosa;


Function flagStessaAz(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type,
        p_prgAzienda DO_LAV_STORIA_ROSA.PRGAZIENDA%type) return char IS
    p_nroStessaAzienda number;
    p_strAz varchar(30);

BEGIN

    select count(1) into p_nroStessaAzienda
    from do_lav_storia_rosa strosa
    where strosa.CDNLAVORATORE=p_cdnLavoratore
       --and strosa.DATINVIO is not null
    and nvl(strosa.DATINVIO, TO_DATE ('01/01/1900', 'DD/MM/YYYY'))<>TO_DATE ('01/01/1900', 'DD/MM/YYYY')
       and strosa.PRGTIPOROSA=3 and prgAzienda=p_prgAzienda;

    if(p_nroStessaAzienda>0) then
   p_strAz := 'Si';
    else
   p_strAz := 'No';
    end if;

    return(p_strAz);
END flagStessaAz;

Function candidatoRosaListeSpeciali(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return varchar
IS
    varStrListeSpec varchar2(200) := '';
    varFlgMobilita varchar2(1);
    varFlg297 varchar2(1);
    varFlgCm varchar2(1);
    varFlg40790 varchar2(1);
    checkCM number;
    p_flgabilita varchar2(1);
BEGIN
    select FLGMOBILITA, FLG297, FLG40790
    into varFlgMobilita, varFlg297, varFlg40790
    from VW_AM_LAV_SITUAZ_AMMIN
    where CDNLAVORATORE = p_cdnLavoratore;
    
    select count(tct.flgabilita) into checkCM
    from ts_config_tab tct
    where tct.cdnconfigtab = p_cdnLavoratore;
    
    if (checkCM > 0) then
      select tct.flgabilita into p_flgabilita
      from ts_config_tab tct
      where tct.cdnconfigtab = p_cdnLavoratore;
    else
      p_flgabilita := 'N';  
    end if;
        
    if(varFlgMobilita='S') then
      --varStrListeSpec := varStrListeSpec || '-Mobilita''';
   varStrListeSpec := varStrListeSpec || '-L.236/93 o L.223/91';
    end if;
    if(LENGTH(varStrListeSpec)>0) then
      varStrListeSpec := varStrListeSpec || ' <br>';
    end if;
    /*
    if(varFlg297='S') then
      --varStrListeSpec := varStrListeSpec || '-Disoccupato';
   varStrListeSpec := varStrListeSpec || '-L.407/90';
    end if;
    */
    if(varFlg40790='S') then
      --varStrListeSpec := varStrListeSpec || '-Disoccupato';
   varStrListeSpec := varStrListeSpec || '-L.407/90';
    end if;
    if(LENGTH(varStrListeSpec)>0) then
      varStrListeSpec := varStrListeSpec || ' <br>';
    end if;
    if(p_flgabilita='S') then
      --varStrListeSpec := varStrListeSpec || 'Coll. Mirato';      
       varStrListeSpec := varStrListeSpec || '-L.68/99 ';
    end if;

    --dbms_output.PUT_LINE(varStrListeSpec);

    return(varStrListeSpec);
END candidatoRosaListeSpeciali;

Function candidatoRosaListeSpecialiCC(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return varchar
IS
      varStrListeSpec varchar2(200) := '';
    varFlgMobilita varchar2(1);
    varFlg297 varchar2(1);
    varFlgCm varchar2(1);
    varFlg40790 varchar2(1);
    checkCM number;
    p_flgabilita varchar2(1);
    
BEGIN
    select FLGMOBILITA, FLG297, FLG40790
    into varFlgMobilita, varFlg297, varFlg40790
    from VW_AM_LAV_SITUAZ_AMMIN
    where CDNLAVORATORE = p_cdnLavoratore;
    
    
    select count(tct.flgabilita) into checkCM
    from ts_config_tab tct
    where tct.cdnconfigtab = p_cdnLavoratore;
    
    if (checkCM > 0) then
      select tct.flgabilita into p_flgabilita
      from ts_config_tab tct
      where tct.cdnconfigtab = p_cdnLavoratore;
    else
      p_flgabilita := 'N';  
    end if;
    
    if(varFlgMobilita='S') then
      --varStrListeSpec := varStrListeSpec || '-Mobilita''';
   varStrListeSpec := varStrListeSpec || '-L.236/93 o L.223/91';
    end if;
    if(LENGTH(varStrListeSpec)>0) then
      varStrListeSpec := varStrListeSpec || CHR(13) || CHR(10) ;
    end if;
    /*
    if(varFlg297='S') then
      --varStrListeSpec := varStrListeSpec || '-Disoccupato';
   varStrListeSpec := varStrListeSpec || '-L.407/90';
    end if;
    */
    if(varFlg40790='S') then
      --varStrListeSpec := varStrListeSpec || '-Disoccupato';
   varStrListeSpec := varStrListeSpec || '-L.407/90';
    end if;
    if(LENGTH(varStrListeSpec)>0) then
      varStrListeSpec := varStrListeSpec || CHR(13) || CHR(10) ;
    end if;
    --if(varFlgCm='S') then
     if(p_flgabilita='S') then
      --varStrListeSpec := varStrListeSpec || 'Coll. Mirato';      
       varStrListeSpec := varStrListeSpec || '-L.68/99 ';
    end if;

    --dbms_output.PUT_LINE(varStrListeSpec);

    return(varStrListeSpec);
END candidatoRosaListeSpecialiCC;

-- Conta il numero dei disoccupati di una rosa
Function numDisoccupatiRosa(p_prgRosa DO_NOMINATIVO.PRGROSA%type) return number IS
   num number;
BEGIN
   num := 0;
   BEGIN
    select count(1) into num
    from do_nominativo, VW_AM_LAV_SITUAZ_AMMIN
    where
      do_nominativo.CDNLAVORATORE=VW_AM_LAV_SITUAZ_AMMIN.CDNLAVORATORE
    and do_nominativo.PRGROSA=p_prgRosa
    and (VW_AM_LAV_SITUAZ_AMMIN.FLG297='S');

    exception
         when others then
         num:= 0;
   END;

   return num;
END numDisoccupatiRosa;

Function numDisoccupati150(p_prgRosa DO_NOMINATIVO.PRGROSA%type) return number IS
   num number;
BEGIN
   num := 0;
   BEGIN
    select count(1) into num
    from do_nominativo, VW_AM_LAV_SITUAZ_AMMIN
    where
      do_nominativo.CDNLAVORATORE=VW_AM_LAV_SITUAZ_AMMIN.CDNLAVORATORE
    and do_nominativo.PRGROSA=p_prgRosa
    and (VW_AM_LAV_SITUAZ_AMMIN.FLGDISOCC150='S');

    exception
         when others then
         num:= 0;
   END;

   return num;
END numDisoccupati150;

Function numOccupati150(p_prgRosa DO_NOMINATIVO.PRGROSA%type) return number IS
   num number;
BEGIN
   num := 0;
   BEGIN
    select count(1) into num
    from do_nominativo, VW_AM_LAV_SITUAZ_AMMIN
    where
      do_nominativo.CDNLAVORATORE=VW_AM_LAV_SITUAZ_AMMIN.CDNLAVORATORE
    and do_nominativo.PRGROSA=p_prgRosa
    and (VW_AM_LAV_SITUAZ_AMMIN.FLGOCC150='S');

    exception
         when others then
         num:= 0;
   END;

   return num;
END numOccupati150;

-- Restituisce un numero in relazione alla did di un lavoratore per l'ordinamento nella
-- visualizzazione dell'elenco candidati del matching
Function ordineDidRosa(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return varchar
IS
  num number;
  dataDid AM_DICH_DISPONIBILITA.DATDICHIARAZIONE%TYPE;
BEGIN
  begin
      select
        amdid.DATDICHIARAZIONE into dataDid
    from am_elenco_anagrafico amel, am_dich_disponibilita amdid
    where (amel.PRGELENCOANAGRAFICO=amdid.PRGELENCOANAGRAFICO)
       --and amdid.DATFINE is null
    and nvl(amdid.DATFINE,TO_DATE('2100-01-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss'))=TO_DATE('2100-01-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss')
    and amdid.CODSTATOATTO='PR'
       and amel.CDNLAVORATORE=p_cdnLavoratore;
    exception
       when no_data_found then dataDid := null;
  end;
  if(dataDid is null) then
   num := 0;
  else
   num := 1;
  end if;
  return num;
  exception
     when others then return 0;
END ordineDidRosa;

Function candidatoRosaCondizioni(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return varchar2 IS
    CURSOR curCondizioni IS
       /*select distinct(codIndispTemp)
    from am_indisp_temp
    where cdnLavoratore = p_cdnLavoratore
      and datfine is null;
    */
   select distinct(codIndispTemp)
     from am_indisp_temp
   where cdnLavoratore = p_cdnLavoratore
     and sysdate >= datinizio
     and sysdate <= nvl(datfine,sysdate);
    strCondizioni varchar2(3000) := '';
 BEGIN
   FOR rec in curCondizioni LOOP
   if(length(strCondizioni)>0) then
      strCondizioni := strCondizioni || '<br>';
   end if;
   strCondizioni := strCondizioni || rec.codIndispTemp;
  END LOOP;
  return strCondizioni;
  exception
        when others then
         return '';
END candidatoRosaCondizioni;

Function candidatoRosaCondizioniCC(p_cdnLavoratore DO_LAV_STORIA_ROSA.CDNLAVORATORE%type) return varchar2 IS
    CURSOR curCondizioni IS
       /*select distinct(codIndispTemp)
    from am_indisp_temp
    where cdnLavoratore = p_cdnLavoratore
      and datfine is null;
    */
   select distinct(codIndispTemp)
     from am_indisp_temp
   where cdnLavoratore = p_cdnLavoratore
     and sysdate >= datinizio
     and sysdate <= nvl(datfine,sysdate);
    strCondizioni varchar2(3000) := '';
 BEGIN
   FOR rec in curCondizioni LOOP
   if(length(strCondizioni)>0) then
      strCondizioni := strCondizioni || CHR(13) || CHR(10) ;
   end if;
   strCondizioni := strCondizioni || rec.codIndispTemp;
  END LOOP;
  return strCondizioni;
  exception
        when others then
         return '';
END candidatoRosaCondizioniCC;

Function mesiAnzianita(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type) return NUMBER
IS
      numMesi number;
BEGIN
    select vw_am_lav_situaz_ammin.MESIANZIANITA
    into numMesi
    from VW_AM_LAV_SITUAZ_AMMIN
    where CDNLAVORATORE = p_cdnLavoratore;

    return(numMesi);
    exception
        when others then
        return null;
END mesiAnzianita;

Function statoDid(p_cdnLavoratore AN_LAVORATORE.CDNLAVORATORE%type) return VARCHAR2
IS
      vstato varchar2(20); -- La vista usa una substring di 15 caratteri più i 3 puntini di sospensione
BEGIN
    select vw_am_lav_situaz_ammin.STATODID
    into vstato
    from VW_AM_LAV_SITUAZ_AMMIN
    where CDNLAVORATORE = p_cdnLavoratore;

    return(vStato);
    exception
        when others then
        return '';
END statoDid;

END PG_STORIA_ROSA;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_UTIL_CF_PARTIVA.sql
************************************************************************************** */



CREATE OR REPLACE PACKAGE PG_UTIL_CF_PARTIVA IS

function CONTROLLA_CF (codfis AN_AZIENDA.STRCODICEFISCALE%TYPE) return number;

function CONTROLLA_PIVA (piva in AN_AZIENDA.STRPARTITAIVA%TYPE) return number;

function CHECK_CF (codfis AN_AZIENDA.STRCODICEFISCALE%TYPE) return varchar2;

FUNCTION codice_controllo(v_str varchar2) RETURN varchar2;

END PG_UTIL_CF_PARTIVA;
/


CREATE OR REPLACE PACKAGE BODY PG_UTIL_CF_PARTIVA IS
-- Package per il controllo formale di Codice fiscale e partita IVA

FUNCTION CHECK_CF (codfis AN_AZIENDA.STRCODICEFISCALE%TYPE) return varchar2
IS
----------------------------------------------------------------------------------
-- CHECK_CF: riceve in input il codice fiscale dell'azienda da controllare
--           restituisce OK se è fornalmente corretto
--                       NO in caso contrario
----------------------------------------------------------------------------------
cf AN_AZIENDA.STRCODICEFISCALE%TYPE;
codret integer;

BEGIN
cf := rtrim(ltrim(CODFIS));
IF length(cf) = 11 THEN
  codret := CONTROLLA_PIVA (cf);
ELSIF length(cf) = 16 THEN
  codret := CONTROLLA_CF (cf);
ELSE
  codret := 1;
END IF;

IF CODRET = 0 THEN
  RETURN 'OK';
ELSE
  RETURN 'NO';
END IF;        

END;


FUNCTION CONTROLLA_CF
(codfis AN_AZIENDA.STRCODICEFISCALE%TYPE) return number
IS
----------------------------------------------------------------------------------
-- CONTROLLO FORMALE E DEL CODICE FISCALE
----------------------------------------------------------------------------------
-- CONTROLLA_CF: riceve in input il codice fiscale di 16 caratteri da controllare
--               restituisce 0 = nessun errore
--                           1 = errori
----------------------------------------------------------------------------------
TYPE RecABC is VARRAY(2) OF VARCHAR2(2);
TYPE  TabAB IS VARRAY(36) OF RecABC;
TYPE  TabCI IS VARRAY(26) OF RecABC;

FiscTot integer;
FCtrAB integer;
FCtrC  integer;
Num  integer;
i  integer;
iA  integer;
iB  integer;
iC  integer;
TROVATO  char(1);
Carattere  char(1);
car varchar(2);
coderr integer;
cf AN_AZIENDA.STRCODICEFISCALE%TYPE;


TabA TabAB:= TabAB(RecABC('A','00'),RecABC('0','00'),RecABC('B','01'),RecABC('1','01'),RecABC('C','02'),
   				 	 RecABC('2','02'),RecABC('D','03'),RecABC('3','03'),RecABC('E','04'),RecABC('4','04'),
					 RecABC('F','05'),RecABC('5','05'),RecABC('G','06'),RecABC('6','06'),RecABC('H','07'),
					 RecABC('7','07'),RecABC('I','08'),RecABC('8','08'),RecABC('J','09'),RecABC('9','09'),
					 RecABC('K','10'),RecABC('L','11'),RecABC('M','12'),RecABC('N','13'),RecABC('O','14'),
					 RecABC('P','15'),RecABC('Q','16'),RecABC('R','17'),RecABC('S','18'),RecABC('T','19'),
					 RecABC('U','20'),RecABC('V','21'),RecABC('W','22'),RecABC('X','23'),RecABC('Y','24'),
					 RecABC('Z','25'));

TabB TabAB:= TabAB(RecABC('A','01'),RecABC('0','01'),RecABC('B','00'),RecABC('1','00'),RecABC('C','05'),
	 		 	   RecABC('2','05'),RecABC('D','07'),RecABC('3','07'),RecABC('E','09'),RecABC('4','09'),
				   RecABC('F','13'),RecABC('5','13'),RecABC('G','15'),RecABC('6','15'),RecABC('H','17'),
				   RecABC('7','17'),RecABC('I','19'),RecABC('8','19'),RecABC('J','21'),RecABC('9','21'),
				   RecABC('K','02'),RecABC('L','04'),RecABC('M','18'),RecABC('N','20'),RecABC('O','11'),
				   RecABC('P','03'),RecABC('Q','06'),RecABC('R','08'),RecABC('S','12'),RecABC('T','14'),
				   RecABC('U','16'),RecABC('V','10'),RecABC('W','22'),RecABC('X','25'),RecABC('Y','24'),
				   RecABC('Z','23'));

TabC TabCI := TabCI(RecABC('A','00'),RecABC('B','01'),RecABC('C','02'),RecABC('D','03'),RecABC('E','04'),
	 	   	  		RecABC('F','05'),RecABC('G','06'),RecABC('H','07'),RecABC('I','08'),RecABC('J','09'),
					RecABC('K','10'),RecABC('L','11'),RecABC('M','12'),RecABC('N','13'),RecABC('O','14'),
					RecABC('P','15'),RecABC('Q','16'),RecABC('R','17'),RecABC('S','18'),RecABC('T','19'),
					RecABC('U','20'),RecABC('V','21'),RecABC('W','22'),RecABC('X','23'),RecABC('Y','24'),
					RecABC('Z','25'));

BEGIN

cf := UPPER(codfis);
codErr := 0;

 FCtrAB := 0;
 FCtrC := 0;
 -- Controllo l'esistenza del codice
   If Length(lTrim(rTrim(cf))) = 0 then
       codErr := 1;
       return 1;
     END if;

   -- Controllo la lunghezza del codice
   If Length(cf) <> 16 then
        codErr := 2;
        return 1;
      END if;

   -- Controllo del CHECK-DIGIT
   i := 1;
   While i <= 16 And codErr = 0 loop

      Carattere := substr(cf, i, 1);

       --Per gli elementi di posizione dispari leggo la tabella B
       If i in (1, 3, 5, 7, 9, 11, 13, 15) then
           iB := 1;
           TROVATO := 'N';
           While iB <= 36 And TROVATO ='N' loop
		   		 car := TabB (iB) (1);
               If Carattere = car then
                   TROVATO := 'Y';
				   car := TabB (iB) (2);
                   Num := to_number(lTrim(rTrim(car)));
                   FCtrAB := FCtrAB + Num;
                 END if;
               iB := iB + 1;
              END loop;

         END IF;
       --Per gli elementi di posizione pari leggo la tabella A
       If i  in ( 2, 4, 6, 8, 10, 12, 14) then
           iA := 1;
           TROVATO := 'N';
           while iA <= 36 And TROVATO = 'N' loop
		   		 car := TabA (iA) (1);
                If Carattere = car then
                   TROVATO := 'Y';
				   car := TabA (iA) (2);
                   Num := to_number(lTrim(rTrim(car)));
                   FCtrAB := FCtrAB + Num;
                 END if;
               iA := iA + 1;
             END loop;

         END if;
         --Per gli elementi di posizione 16 leggo la tabella C
        If i = 16 then
            iC := 1;
            TROVATO := 'N';
            While iC <= 26 And TROVATO = 'N' loop
				 car := TabC (iC) (1);
                 If Carattere = car then
                   TROVATO := 'Y';
                   car := TabC (iC) (2);
                   Num := to_number(lTrim(rTrim(car)));
                   FCtrC := FCtrC + Num;
                 END if;
            iC := iC + 1;
            END loop;
          END if;

       If TROVATO = 'N' then
	     codErr := 3;
		 end if;

	   i := i + 1;

     END loop;

   If codErr > 0  then
   	  return 1;
	  end if;

   FiscTot := MOD(FCtrAB, 26);
   If FiscTot <> FCtrC then
     return 1;
   	end if;

   return 0;

exception
when others then
return 1;
raise;

   END;

FUNCTION CONTROLLA_PIVA
(piva in AN_AZIENDA.STRPARTITAIVA%TYPE) return number
IS
----------------------------------------------------------------------------------
-- CONTROLLO FORMALE E DELLA PARTITA IVA
----------------------------------------------------------------------------------
-- CONTROLLA_PIVA: riceve in input il codice fiscale di 11 caratteri da controllare
--                 restituisce 0 = nessun errore
--                             1 = errori
----------------------------------------------------------------------------------

nTotEven integer;
nEven integer;
nTotOdd integer;
nOdd integer;
nTotCheck integer;
nComplem integer;
i integer;
cTotal varchar2(2);
cUnita varchar2(2);
cPICheck varchar2(2);

begin
--Inizializzazioni variabili
nTotEven := 0;
nEven := 0;
nTotOdd := 0;
nOdd := 0;
nTotCheck := 0;
cTotal := '';
cUnita := '';
cPICheck := '';
nComplem := 0;
i := 0;

if not( instr('0123456789', substr(piva, 1,1), 1,1)>0
	and instr('0123456789', substr(piva, 2,1), 1,1)>0
	and instr('0123456789', substr(piva, 3,1), 1,1)>0
	and instr('0123456789', substr(piva, 4,1), 1,1)>0
	and instr('0123456789', substr(piva, 5,1), 1,1)>0
	and instr('0123456789', substr(piva, 6,1), 1,1)>0
	and instr('0123456789', substr(piva, 7,1), 1,1)>0
	and instr('0123456789', substr(piva, 8,1), 1,1)>0
	and instr('0123456789', substr(piva, 9,1), 1,1)>0
	and instr('0123456789', substr(piva, 10,1), 1,1)>0
	and instr('0123456789', substr(piva, 11,1), 1,1)>0 ) then
  		  return 1;
  END IF;

If piva = '00000000000' then
    return 1;
  END IF;

If Length(piva) <> 11 then
    return 1;
  END IF;

i := 1;

while i <= 11 loop
      nEven := to_number(substr(pIva, i, 1) );
      nTotEven := nTotEven + nEven;
     i := i +2;
  END loop;


i := 2;
while i <= 11 loop
     nOdd := to_number(substr(pIva, i, 1)) * 2;
     If nOdd > 9 then
	 	 nOdd := nOdd - 9;
	 end if;
     nTotOdd := nTotOdd + nOdd;
     i := i +2;
  END loop;


nTotCheck := nTotEven + nTotOdd;
cTotal := cast(nTotCheck as varchar2);
cUnita := substr(lTrim(rTrim(cTotal)), 2, 1);
cPICheck := substr(pIva, 11, 1);

If cUnita = '0' then
    return 0;
Else
      nComplem := (10 - to_number(cUnita));
      If nComplem <> to_number(cPICheck) then
          return 1;
      END if;
   END if;

return 0;

exception
when others then
return 1;
raise;

end;


FUNCTION codice_controllo(v_str varchar2) RETURN varchar2
  IS
   
    TYPE caratteri_type IS TABLE OF number INDEX BY varchar2(1 char);
    TYPE controllo_type IS TABLE OF char INDEX BY BINARY_INTEGER;
  
    v_pari caratteri_type;
    v_dispari caratteri_type;
    v_controllo controllo_type;
  
    i number;
    n_pari number;
    n_dispari number;
  
  BEGIN

        v_pari('A') := 0 ;
        v_pari('B') := 1 ;
        v_pari('C') := 2 ;
        v_pari('D') := 3 ;
        v_pari('E') := 4 ;
        v_pari('F') := 5 ;
        v_pari('G') := 6 ;
        v_pari('H') := 7 ;
        v_pari('I') := 8 ;
        v_pari('J') := 9 ;
        v_pari('K') := 10 ;
        v_pari('L') := 11 ;
        v_pari('M') := 12 ;
        v_pari('N') := 13 ;
        v_pari('O') := 14 ;
        v_pari('P') := 15 ;
        v_pari('Q') := 16 ;
        v_pari('R') := 17 ;
        v_pari('S') := 18 ;
        v_pari('T') := 19 ;
        v_pari('U') := 20 ;
        v_pari('V') := 21 ;
        v_pari('W') := 22 ;
        v_pari('X') := 23 ;
        v_pari('Y') := 24 ;
        v_pari('Z') := 25 ;
        v_pari('1') := 1 ;
        v_pari('2') := 2 ;
        v_pari('3') := 3 ;
        v_pari('4') := 4 ;
        v_pari('5') := 5 ;
        v_pari('6') := 6 ;
        v_pari('7') := 7 ;
        v_pari('8') := 8 ;
        v_pari('9') := 9 ;
        v_pari('0') := 0 ;
        
      --ARRAY DISPARY 
        v_dispari('A') := 1 ;
        v_dispari('B') := 0;
        v_dispari('C') := 5;
        v_dispari('D') := 7;
        v_dispari('E') := 9;
        v_dispari('F') := 13;
        v_dispari('G') := 15;
        v_dispari('H') := 17 ;
        v_dispari('I') := 19 ;
        v_dispari('J') := 21;
        v_dispari('K') := 2;
        v_dispari('L') := 4;
        v_dispari('M') := 18;
        v_dispari('N') := 20;
        v_dispari('O') := 11;
        v_dispari('P') := 3;
        v_dispari('Q') := 6;
        v_dispari('R') := 8;
        v_dispari('S') := 12;
        v_dispari('T') := 14;
        v_dispari('U') := 16;
        v_dispari('V') := 10;
        v_dispari('W') := 22;
        v_dispari('X') := 25;
        v_dispari('Y') := 24;
        v_dispari('Z') := 23;
        v_dispari('1') := 0;
        v_dispari('2') := 5;
        v_dispari('3') := 7;
        v_dispari('4') := 9;
        v_dispari('5') := 13;
        v_dispari('6') := 15;
        v_dispari('7') := 17;
        v_dispari('8') := 19;
        v_dispari('9') := 21;
        v_dispari('0') :=  1;
      
      --VARIABILI DI CONTROLLO
        v_controllo(0) := 'A';
        v_controllo(1) := 'B';
        v_controllo(2) := 'C';
        v_controllo(3) := 'D';
        v_controllo(4) := 'E';
        v_controllo(5) := 'F';
        v_controllo(6) := 'G';
        v_controllo(7) := 'H';
        v_controllo(8) := 'I';
        v_controllo(9) := 'J';
        v_controllo(10) := 'K';
        v_controllo(11) := 'L';
        v_controllo(12) := 'M';
        v_controllo(13) := 'N';
        v_controllo(14) := 'O';
        v_controllo(15) := 'P';
        v_controllo(16) := 'Q';
        v_controllo(17) := 'R';
        v_controllo(18) := 'S';
        v_controllo(19) := 'T';
        v_controllo(20) := 'U';
        v_controllo(21) := 'V';
        v_controllo(22) := 'W';
        v_controllo(23) := 'X';
        v_controllo(24) := 'Y';
        v_controllo(25) := 'Z';
  
/* CICLO RICORSIVO PER IL CONTROLLO CORRETTEZZA VALORI  
  i := 1;
  while i < length(v_str) +1 loop
      dbms_output.put_line(substr(v_str,i,1)||'-'||v_dispari(substr(v_str,i,1)));  
    i := i +2;
  end loop;

  i := 2;
  while i < length(v_str) +1 loop
      dbms_output.put_line(substr(v_str,i,1)||'-'||v_pari(substr(v_str,i,1)));  
    i := i +2;
  end loop;
*/  
      i := 1;
      n_dispari := 0;
      while i < length(v_str) +1 loop
          n_dispari := n_dispari + v_dispari(substr(v_str,i,1));
          i := i +2;
      end loop;
    
      i := 2;
      n_pari := 0;
      while i < length(v_str) +1 loop
          n_pari := n_pari + v_pari(substr(v_str,i,1));  
        i := i +2;
      end loop;
       RETURN(v_controllo(mod(n_dispari + n_pari, 26)));  
      EXCEPTION
      WHEN OTHERS THEN      
        RETURN('CF-005');
  END codice_controllo;

END PG_UTIL_CF_PARTIVA;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_UTIL_NUMBER.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_UTIL_NUMBER IS
FUNCTION to_base (p_dec IN NUMBER, p_base IN NUMBER)  RETURN VARCHAR2;
FUNCTION to_dec (p_str IN VARCHAR2, p_from_base IN  NUMBER DEFAULT 16)   RETURN NUMBER;
FUNCTION to_hex (p_dec IN NUMBER)   RETURN VARCHAR2;
FUNCTION to_bin (p_dec IN NUMBER)   RETURN VARCHAR2;
FUNCTION to_oct (p_dec IN NUMBER)   RETURN VARCHAR2;

END PG_UTIL_NUMBER;
/

CREATE OR REPLACE PACKAGE BODY PG_UTIL_NUMBER IS

FUNCTION to_base (p_dec IN NUMBER, p_base IN NUMBER)  RETURN VARCHAR2
IS
   l_str   VARCHAR2 (255) DEFAULT NULL;
   l_num   NUMBER         DEFAULT p_dec;
   l_hex   VARCHAR2 (16)  DEFAULT '0123456789abcdef';
BEGIN
   IF (p_dec IS NULL OR p_base IS NULL)
   THEN
      RETURN NULL;
   END IF;

   IF (TRUNC (p_dec) <> p_dec OR p_dec < 0)
   THEN
      RAISE PROGRAM_ERROR;
   END IF;

   LOOP
      l_str := SUBSTR (l_hex, MOD (l_num, p_base) + 1, 1) || l_str;
      l_num := TRUNC (l_num / p_base);
      EXIT WHEN (l_num = 0);
   END LOOP;

   RETURN l_str;
END to_base;
 
FUNCTION to_dec (
   p_str         IN   VARCHAR2,
   p_from_base   IN   NUMBER DEFAULT 16
)
   RETURN NUMBER
IS
   l_num   NUMBER        DEFAULT 0;
   l_hex   VARCHAR2 (16) DEFAULT '0123456789abcdef';
BEGIN
   IF (p_str IS NULL OR p_from_base IS NULL)
   THEN
      RETURN NULL;
   END IF;

   FOR i IN 1 .. LENGTH (p_str)
   LOOP
      l_num :=
         l_num * p_from_base + INSTR (l_hex, UPPER (SUBSTR (p_str, i, 1)))
         - 1;
   END LOOP;

   RETURN l_num;
END to_dec;

FUNCTION to_hex (p_dec IN NUMBER)
   RETURN VARCHAR2
IS
BEGIN
   RETURN to_base (p_dec, 16);
END to_hex;

FUNCTION to_bin (p_dec IN NUMBER)
   RETURN VARCHAR2
IS
BEGIN
   RETURN to_base (p_dec, 2);
END to_bin;

FUNCTION to_oct (p_dec IN NUMBER)
   RETURN VARCHAR2
IS
BEGIN
   RETURN to_base (p_dec, 8);
END to_oct;

END PG_UTIL_NUMBER;
/



/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_UTILS_DID_PATTO.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_UTILS_DID_PATTO IS

FUNCTION DELETEDIDPA (prgDid am_dich_disponibilita.prgdichdisponibilita%type, cdnUt am_dich_disponibilita.cdnutins%type) RETURN NUMBER;
FUNCTION RIAPRIDIDAN (prgDid am_dich_disponibilita.prgdichdisponibilita%type, cdnLav an_lavoratore.cdnlavoratore%type, cdnUt am_dich_disponibilita.cdnutins%type) RETURN NUMBER;
FUNCTION RIAPRIPATTO (prgPatto am_patto_lavoratore.prgpattolavoratore%type, cdnUt am_patto_lavoratore.cdnutins%type, forzaRiapertura integer) RETURN NUMBER;
FUNCTION TRASFORMAPATTOANP (prgPatto am_patto_lavoratore.prgpattolavoratore%type, cdnUt am_patto_lavoratore.cdnutins%type) RETURN NUMBER;

END PG_UTILS_DID_PATTO;
/
CREATE OR REPLACE PACKAGE BODY PG_UTILS_DID_PATTO IS

FUNCTION DELETEDIDPA (prgDid am_dich_disponibilita.prgdichdisponibilita%type, cdnUt am_dich_disponibilita.cdnutins%type) RETURN NUMBER IS

BEGIN
	
	PG_LOG.doLog('D', 'AM_DICH_DISPONIBILITA', cdnUt, ' WHERE PRGDICHDISPONIBILITA = ' || prgDid);
	
	delete from am_dich_disponibilita where prgdichdisponibilita = prgDid;

	return 0;

EXCEPTION
    WHEN OTHERS THEN
      return -1;


END DELETEDIDPA;

FUNCTION RIAPRIDIDAN (prgDid am_dich_disponibilita.prgdichdisponibilita%type, cdnLav an_lavoratore.cdnlavoratore%type, cdnUt am_dich_disponibilita.cdnutins%type) RETURN NUMBER IS

	prgPattoLav am_patto_lavoratore.prgpattolavoratore%type;

BEGIN

	PG_LOG.doLog('U', 'AM_DICH_DISPONIBILITA', cdnUt, ' WHERE PRGDICHDISPONIBILITA = ' || prgDid);

	update AM_DICH_DISPONIBILITA set datfine = null, codmotivofineatto = null, codmotannullamentoatto = null, codstatoatto = 'PR',
	cdnutmod = cdnUt, dtmmod = sysdate, numklodichdisp = numklodichdisp + 1
	where PRGDICHDISPONIBILITA = prgDid;
	
	update am_documento set codstatoatto = 'PR', codmotannullamentoatto = null,
	numklodocumento = numklodocumento + 1, cdnutmod = cdnUt, dtmmod = sysdate, datfine = null
	where prgdocumento = (select doc.prgdocumento 
						  from am_documento doc inner join am_documento_coll coll on (doc.prgdocumento = coll.prgdocumento)
						  where doc.cdnlavoratore = cdnLav and doc.codtipodocumento = 'IM' and to_number(coll.strchiavetabella) = prgDid
						  and coll.cdncomponente = (select cdncomponente from ts_componente where lower(strpage) = 'dispodettagliopage')
						  );
	
	BEGIN
		prgPattoLav := null;
		
		select patto.prgpattolavoratore
		into prgPattoLav
		from am_patto_lavoratore patto
		where patto.cdnlavoratore = cdnLav and patto.prgdichdisponibilita = prgDid and patto.datfine is not null and patto.codstatoatto = 'PR'
		and patto.codmotivofineatto = 'AU';
	EXCEPTION
		WHEN OTHERS THEN prgPattoLav := null;
	END;
	
	if (prgPattoLav is not null) then
		PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnUt, ' WHERE PRGPATTOLAVORATORE = ' || prgPattoLav);
		
		update am_patto_lavoratore set datfine = null, codmotivofineatto = null,
		cdnutmod = cdnUt, dtmmod = sysdate, numklopattolavoratore = numklopattolavoratore + 1
		where prgpattolavoratore = prgPattoLav;
		
	end if;
	
	return 0;

EXCEPTION
    WHEN OTHERS THEN
      return -1;

END RIAPRIDIDAN;

FUNCTION RIAPRIPATTO (prgPatto am_patto_lavoratore.prgpattolavoratore%type, cdnUt am_patto_lavoratore.cdnutins%type, forzaRiapertura integer) RETURN NUMBER IS
	
	numPattiProtocollatiAperti integer := 0;
	numPattiSuccessiviChiusi integer := 0;
	numAzioniCollegate integer := 0;
	numPrepatti integer := 0;
	numPattiSuccessiviL14 integer := 0;
	dataStipulaPatto am_patto_lavoratore.datstipula%type;
	p_flgpatto297 am_patto_lavoratore.flgpatto297%type;
	prgDid am_dich_disponibilita.prgdichdisponibilita%type;
	dataFineDid am_dich_disponibilita.datfine%type;
	codstatoattoDid am_dich_disponibilita.codstatoatto%type;
	numklopattolav am_patto_lavoratore.numklopattolavoratore%type;
	prgDidAperta am_dich_disponibilita.prgdichdisponibilita%type;
	p_codstatooccupazragg de_stato_occupaz.codstatooccupazragg%type;
	cdnLav am_patto_lavoratore.cdnlavoratore%type;
	p_prgPattoChiuso am_patto_lavoratore.prgpattolavoratore%type;
	p_prgdocumento am_documento.prgdocumento%type;
	p_numklodocumento am_documento.numklodocumento%type;
	p_codtipopatto am_patto_lavoratore.codtipopatto%type;
	codcpiVar am_patto_lavoratore.codcpi%TYPE;
	datprotocolloVar am_patto_lavoratore.datultimoprotocollo%TYPE;
	strentecodicefiscaleVar am_patto_lavoratore.strentecodicefiscale%TYPE;
	codsedeVar am_patto_lavoratore.codsede%TYPE;
	strnotaenteVar am_patto_lavoratore.strnotaente%TYPE;
	p_doneOpenPatto boolean := false;
	retRiapertura number := 0;
	
BEGIN

	select pt.datstipula, pt.prgdichdisponibilita, pt.numklopattolavoratore, pt.flgpatto297, pt.cdnlavoratore, pt.codtipopatto, pt.codcpi, pt.datultimoprotocollo,
		pt.strentecodicefiscale, pt.codsede, pt.strnotaente
	into dataStipulaPatto, prgDid, numklopattolav, p_flgpatto297, cdnLav, p_codtipopatto, codcpiVar, datprotocolloVar,
		strentecodicefiscaleVar, codsedeVar, strnotaenteVar
	from am_patto_lavoratore pt 
	where pt.prgpattolavoratore = prgPatto;
	
	select de_stato_occupaz.codstatooccupazragg
	into p_codstatooccupazragg
	from am_stato_occupaz inner join de_stato_occupaz on (am_stato_occupaz.codstatooccupaz = de_stato_occupaz.codstatooccupaz)
	where am_stato_occupaz.cdnlavoratore = cdnLav and am_stato_occupaz.datfine is null;
	
	if (p_flgpatto297 = 'N' and p_codstatooccupazragg in ('D', 'I')) then
		return 1;
	end if;
	
	if (p_flgpatto297 = 'S' and p_codstatooccupazragg in ('A', 'O')) then
		return 1;
	end if;
	
	select count(*)
	into numPattiProtocollatiAperti
	from am_patto_lavoratore patti
	where (patti.cdnlavoratore = cdnLav) and (patti.prgpattolavoratore != prgPatto) and (patti.codstatoatto = 'PR') 
	and (patti.datfine is null);
	
	if (numPattiProtocollatiAperti > 0) then
		return 2;
	end if;
	
	select count(*)
	into numPattiSuccessiviL14
	from am_patto_lavoratore patti
	where (patti.cdnlavoratore = cdnLav) and (patti.prgpattolavoratore != prgPatto) and (patti.codstatoatto = 'PR') 
	and (patti.codtipopatto = 'L14') and (trunc(patti.datstipula) > trunc(dataStipulaPatto)) and (patti.datfine is not null);
	
	if (numPattiSuccessiviL14 > 0) then
		return 8;
	end if;
	
	select count(*)
	into numPattiSuccessiviChiusi
	from am_patto_lavoratore patti
	where (patti.cdnlavoratore = cdnLav) and (patti.prgpattolavoratore != prgPatto) and (patti.codstatoatto = 'PR') 
	and (trunc(patti.datstipula) > trunc(dataStipulaPatto)) and (patti.datfine is not null);
	
	if (numPattiSuccessiviChiusi > 1) then
		return 2;
	end if;
	
	if (numPattiSuccessiviChiusi = 1) then
		select patti.prgpattolavoratore
		into p_prgPattoChiuso
		from am_patto_lavoratore patti
		where (patti.cdnlavoratore = cdnLav) and (patti.prgpattolavoratore != prgPatto) and (patti.codstatoatto = 'PR') 
		and (trunc(patti.datstipula) > trunc(dataStipulaPatto)) and (patti.datfine is not null);
		
		select count(*)
		into numAzioniCollegate
		from am_lav_patto_scelta
		where prgpattolavoratore = p_prgPattoChiuso and codlsttab = 'OR_PER';
		
		if (numAzioniCollegate > 0) then
			return 4;
		end if;
		
		if (forzaRiapertura = 0) then
			return 5;
		else
			PG_LOG.doLog('D', 'AM_PATTO_LAVORATORE', cdnUt, ' WHERE PRGPATTOLAVORATORE = ' || p_prgPattoChiuso);
			
			delete from am_lav_patto_scelta where prgpattolavoratore = p_prgPattoChiuso;
			delete from OR_SCHEDA_SVANTAGGIO where prgpattolavoratore = p_prgPattoChiuso;
			delete from AM_PROGRAMMA_ENTE where prgpattolavoratore = p_prgPattoChiuso;
			delete from OR_SCHEDA_PARTECIPANTE where prgpattolavoratore = p_prgPattoChiuso;
			delete from am_patto_lavoratore where prgpattolavoratore = p_prgPattoChiuso;
			
			update or_percorso_concordato set prgpattodisassociatoformazione = null
			where prgpattodisassociatoformazione = p_prgPattoChiuso;
			
			BEGIN
				select doc.prgdocumento, doc.numklodocumento
				into p_prgdocumento, p_numklodocumento
				from am_documento doc
				inner join am_documento_coll coll on (coll.prgdocumento = doc.prgdocumento)
				where doc.cdnlavoratore = cdnLav and doc.codtipodocumento in ('ACLA', 'PT297')
				and to_number(coll.strchiavetabella) = p_prgPattoChiuso and doc.codstatoatto = 'PR';
				
				update am_documento set codstatoatto = 'AU', codmotannullamentoatto = 'ERR',
				numklodocumento = p_numklodocumento + 1, cdnutmod = cdnUt, dtmmod = sysdate, datfine = datinizio
				where prgdocumento = p_prgdocumento;
			
			EXCEPTION
				WHEN OTHERS THEN return 6;
			END;
			
		end if;
		
	end if;
	
	SELECT count(*)
	into numPrepatti
	FROM am_patto_lavoratore p1
	WHERE (p1.cdnlavoratore = cdnLav) and (p1.codstatoatto = 'PP') and (p1.prgpattolavoratore != prgPatto) and
		  (p1.datfine is null or trunc(p1.datstipula) >= trunc(dataStipulaPatto));
	
	
	if (numPrepatti > 0) then
		
		if (forzaRiapertura = 0) then
			return 3;
		else
			declare
				cursor curPatti is
					SELECT p1.prgpattolavoratore
					FROM am_patto_lavoratore p1
					WHERE (p1.cdnlavoratore = cdnLav) and (p1.codstatoatto = 'PP') and (p1.prgpattolavoratore != prgPatto) and
						  (p1.datfine is null or trunc(p1.datstipula) >= trunc(dataStipulaPatto));
				prgPattoDel am_patto_lavoratore.prgpattolavoratore%type;
			begin
				for prepatti IN curPatti loop
					prgPattoDel := prepatti.prgpattolavoratore;
					
					PG_LOG.doLog('D', 'AM_PATTO_LAVORATORE', cdnUt, ' WHERE PRGPATTOLAVORATORE = ' || prgPattoDel);
			
					delete from am_lav_patto_scelta where prgpattolavoratore = prgPattoDel;
					delete from OR_SCHEDA_SVANTAGGIO where prgpattolavoratore = prgPattoDel;
					delete from AM_PROGRAMMA_ENTE where prgpattolavoratore = prgPattoDel;
					delete from OR_SCHEDA_PARTECIPANTE where prgpattolavoratore = prgPattoDel;
					delete from am_patto_lavoratore where prgpattolavoratore = prgPattoDel;
					
					update or_percorso_concordato set prgpattodisassociatoformazione = null
					where prgpattodisassociatoformazione = prgPattoDel;
				
				 end loop;
			end;
			
		end if;
		
	end if;
		
	if (prgDid is not null) then
		select datfine, codstatoatto
		into dataFineDid, codstatoattoDid
		from am_dich_disponibilita
		where prgdichdisponibilita = prgDid;
		
		if (codstatoattoDid = 'PR' and dataFineDid is null) then
		
			numklopattolav := numklopattolav + 1;
		
			PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnUt, ' WHERE PRGPATTOLAVORATORE = ' || prgPatto);

			update am_patto_lavoratore set datfine = null, codmotivofineatto = null,
			cdnutmod = cdnUt, dtmmod = sysdate, numklopattolavoratore = numklopattolav
			where prgpattolavoratore = prgPatto;
			
			p_doneOpenPatto := true;
		
		
		else
			
			prgDidAperta := null;
			
			BEGIN
				
				select did.prgdichdisponibilita
				into prgDidAperta
				from am_dich_disponibilita did
				inner join am_elenco_anagrafico el on (did.prgelencoanagrafico = el.prgelencoanagrafico)
				where el.cdnlavoratore = cdnLav and did.codstatoatto = 'PR' and did.datfine is null and trunc(did.datdichiarazione) <= trunc(dataStipulaPatto);
			
			EXCEPTION
				WHEN OTHERS THEN prgDidAperta := null;
			END;
			
			if (prgDidAperta is not null) then
			
				numklopattolav := numklopattolav + 1;
				
				PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnUt, ' WHERE PRGPATTOLAVORATORE = ' || prgPatto);

				update am_patto_lavoratore set datfine = null, codmotivofineatto = null, prgdichdisponibilita = prgDidAperta,
				cdnutmod = cdnUt, dtmmod = sysdate, numklopattolavoratore = numklopattolav
				where prgpattolavoratore = prgPatto;
				
				p_doneOpenPatto := true;
				
			else
				
				return 9;
				
			end if;
			
		end if;
		
	else
		
		prgDidAperta := null;
	
		if (p_flgpatto297 = 'S') then
	
			BEGIN
							
				select did.prgdichdisponibilita
				into prgDidAperta
				from am_dich_disponibilita did
				inner join am_elenco_anagrafico el on (did.prgelencoanagrafico = el.prgelencoanagrafico)
				where el.cdnlavoratore = cdnLav and did.codstatoatto = 'PR' and did.datfine is null and trunc(did.datdichiarazione) <= trunc(dataStipulaPatto);
			
			EXCEPTION
				WHEN OTHERS THEN prgDidAperta := null;
			END;
			
		end if;
		
		numklopattolav := numklopattolav + 1;
		
		PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnUt, ' WHERE PRGPATTOLAVORATORE = ' || prgPatto);

		update am_patto_lavoratore set datfine = null, codmotivofineatto = null, prgdichdisponibilita = prgDidAperta,
		cdnutmod = cdnUt, dtmmod = sysdate, numklopattolavoratore = numklopattolav
		where prgpattolavoratore = prgPatto;
		
		p_doneOpenPatto := true;
	
	end if;
	
	retRiapertura := 0;
	if (p_doneOpenPatto) then
		-- gestione riapertura patto vecchio non legato a programmi
		if (p_codtipopatto <> 'ANP') then
			BEGIN
				
				retRiapertura := PG_UTILS_DID_PATTO.TRASFORMAPATTOANP (prgPatto, cdnUt);
				
			EXCEPTION
				WHEN OTHERS THEN
					return -1;
			END;
			
		end if;
	
	end if;
	
	return retRiapertura;

EXCEPTION
    WHEN OTHERS THEN
      return -1;

END RIAPRIPATTO;

FUNCTION TRASFORMAPATTOANP (prgPatto am_patto_lavoratore.prgpattolavoratore%type, cdnUt am_patto_lavoratore.cdnutins%type) RETURN NUMBER IS
	
	dataStipulaPatto am_patto_lavoratore.datstipula%type;
	numklopattolav am_patto_lavoratore.numklopattolavoratore%type;
	cdnLav am_patto_lavoratore.cdnlavoratore%type;
	p_codtipopatto am_patto_lavoratore.codtipopatto%type;
	p_prgcolloquio or_colloquio.prgcolloquio%type;
	prgpercorsoVar or_percorso_concordato.prgpercorso%TYPE;
	codservizioVar or_colloquio.codservizio%TYPE;
	prgspiVar ts_utente.prgspi%TYPE;
	codcpiVar am_patto_lavoratore.codcpi%TYPE;
	prgazioniVar or_percorso_concordato.prgazioni%TYPE;
	datprotocolloVar am_patto_lavoratore.datultimoprotocollo%TYPE;
	strentecodicefiscaleVar am_patto_lavoratore.strentecodicefiscale%TYPE;
	codsedeVar am_patto_lavoratore.codsede%TYPE;
	strnotaenteVar am_patto_lavoratore.strnotaente%TYPE;
	p_codregionesil ts_generale.codregionesil%TYPE;
	num_coll_prog integer :=0;
	
	cursor cursorImpegniAz is
		select codimpegno from de_azione_impegno 
		where prgazioni = (select az.prgazioni 
						   from de_azione az 
						   inner join de_azione_ragg ragg on (az.prgazioneragg = ragg.prgazioniragg) 
						   where lower(az.strdescrizione) = 'trasferimento di informazioni sul lavoro e sulla formazione' and ragg.codservizio = 'SEP');
	
	rec_Impegni cursorImpegniAz%ROWTYPE;
	
	cursor cursorImpegniAzUmb is
		select codimpegno from de_azione_impegno 
		where prgazioni = (select az.prgazioni 
						   from de_azione az 
						   inner join de_azione_ragg ragg on (az.prgazioneragg = ragg.prgazioniragg) 
						   where lower(az.strdescrizione) = 'a1.2 - erogazione informazioni sui servizi per l''impiego' and ragg.codservizio = 'SEP');
	
	rec_ImpegniUmb cursorImpegniAzUmb%ROWTYPE;
	
	cursor cursorImpegniAzTn is
		select codimpegno from de_azione_impegno 
		where prgazioni = (select prgazioni from de_azione where lower(strdescrizione) = 'orientamento per patto di servizio personalizzato');
		
	rec_ImpegniTn cursorImpegniAzTn%ROWTYPE;
	
	cursor cursorImpegniAzCal is
		select codimpegno from de_azione_impegno 
		where prgazioni = (select prgazioni from de_azione where lower(strdescrizione) = 'accoglienza, informazione e accesso ai servizi');
		
	rec_ImpegniCal cursorImpegniAzCal%ROWTYPE;
	
	cursor cursorImpegniAzVda is
		select codimpegno from de_azione_impegno 
		where prgazioni = (select az.prgazioni 
						   from de_azione az 
						   inner join de_azione_ragg ragg on (az.prgazioneragg = ragg.prgazioniragg) 
						   where lower(az.strdescrizione) = 'colloquio di primo orientamento' and ragg.codservizio = 'SEP'
						   and lower(ragg.strdescrizione) = 'orientamento');
		
	rec_ImpegniVda cursorImpegniAzVda%ROWTYPE;
	
	codimpegnoVar de_azione_impegno.codimpegno%TYPE;
	
	cursor cursorPercorsiConcordati (prgpattolavoratoreVar am_patto_lavoratore.prgpattolavoratore%TYPE, codservizioVar or_colloquio.codservizio%TYPE) is
		select perc.prgcolloquio, perc.prgpercorso, nvl(de_esito.flgstatoconcluso, 'N') flgstatoconcluso, trunc(perc.dateffettiva) dateffettiva,
		nvl(azione.flgadesionegg, 'N') flgadesionegg
		from am_patto_lavoratore patto
		inner join or_colloquio coll on (patto.cdnlavoratore = coll.cdnlavoratore)
		inner join or_percorso_concordato perc on (perc.prgcolloquio = coll.prgcolloquio)
		inner join am_lav_patto_scelta scelta on (patto.prgpattolavoratore = scelta.prgpattolavoratore and 
												  to_number(scelta.strchiavetabella) = perc.prgpercorso and
												  scelta.codlsttab = 'OR_PER')
		inner join de_azione azione on azione.prgazioni = perc.prgazioni
		inner join de_azione_ragg ragg on ragg.prgazioniragg=azione.prgazioneragg
		left join de_esito on perc.codesito = de_esito.codesito
		where patto.prgpattolavoratore = prgpattolavoratoreVar and ragg.codservizio = codservizioVar;
	
	rec_PercorsiConcordati cursorPercorsiConcordati%ROWTYPE;
	
	cursor cursorPercorsiAdesioni (prgpattolavoratoreVar am_patto_lavoratore.prgpattolavoratore%TYPE, codservizioVar or_colloquio.codservizio%TYPE) is
		select perc.prgcolloquio, perc.prgpercorso, nvl(de_esito.flgstatoconcluso, 'N') flgstatoconcluso, trunc(perc.dateffettiva) dateffettiva,
		nvl(azione.flgadesionegg, 'N') flgadesionegg
		from am_patto_lavoratore patto
		inner join or_colloquio coll on (patto.cdnlavoratore = coll.cdnlavoratore)
		inner join or_percorso_concordato perc on (perc.prgcolloquio = coll.prgcolloquio)
		inner join am_lav_patto_scelta scelta on (patto.prgpattolavoratore = scelta.prgpattolavoratore and 
												  to_number(scelta.strchiavetabella) = perc.prgpercorso and
												  scelta.codlsttab = 'OR_PER')
		inner join de_azione azione on azione.prgazioni = perc.prgazioni
		inner join de_azione_ragg ragg on ragg.prgazioniragg=azione.prgazioneragg
		left join de_esito on perc.codesito = de_esito.codesito
		where patto.prgpattolavoratore = prgpattolavoratoreVar and ragg.codservizio = codservizioVar and nvl(azione.flgadesionegg, 'N') = 'S';
		
	rec_PercorsiAdesioni cursorPercorsiAdesioni%ROWTYPE;
	
	cursor cursorPercorsiConcordatiAll (prgpattolavoratoreVar am_patto_lavoratore.prgpattolavoratore%TYPE) is
		select perc.prgcolloquio, perc.prgpercorso, nvl(de_esito.flgstatoconcluso, 'N') flgstatoconcluso, trunc(perc.dateffettiva) dateffettiva,
		nvl(azione.flgadesionegg, 'N') flgadesionegg
		from am_patto_lavoratore patto
		inner join or_colloquio coll on (patto.cdnlavoratore = coll.cdnlavoratore)
		inner join or_percorso_concordato perc on (perc.prgcolloquio = coll.prgcolloquio)
		inner join am_lav_patto_scelta scelta on (patto.prgpattolavoratore = scelta.prgpattolavoratore and 
												  to_number(scelta.strchiavetabella) = perc.prgpercorso and
												  scelta.codlsttab = 'OR_PER')
		inner join de_azione azione on azione.prgazioni = perc.prgazioni
		inner join de_azione_ragg ragg on ragg.prgazioniragg=azione.prgazioneragg
		left join de_esito on perc.codesito = de_esito.codesito
		where patto.prgpattolavoratore = prgpattolavoratoreVar;
	
	rec_PercorsiConcordatiAll cursorPercorsiConcordatiAll%ROWTYPE;
	
	cursor cursorPercorsiAdesioniAll (prgpattolavoratoreVar am_patto_lavoratore.prgpattolavoratore%TYPE) is
		select perc.prgcolloquio, perc.prgpercorso, nvl(de_esito.flgstatoconcluso, 'N') flgstatoconcluso, trunc(perc.dateffettiva) dateffettiva,
		nvl(azione.flgadesionegg, 'N') flgadesionegg
		from am_patto_lavoratore patto
		inner join or_colloquio coll on (patto.cdnlavoratore = coll.cdnlavoratore)
		inner join or_percorso_concordato perc on (perc.prgcolloquio = coll.prgcolloquio)
		inner join am_lav_patto_scelta scelta on (patto.prgpattolavoratore = scelta.prgpattolavoratore and 
												  to_number(scelta.strchiavetabella) = perc.prgpercorso and
												  scelta.codlsttab = 'OR_PER')
		inner join de_azione azione on azione.prgazioni = perc.prgazioni
		inner join de_azione_ragg ragg on ragg.prgazioniragg=azione.prgazioneragg
		left join de_esito on perc.codesito = de_esito.codesito
		where patto.prgpattolavoratore = prgpattolavoratoreVar and nvl(azione.flgadesionegg, 'N') = 'S';
		
	rec_PercorsiAdesioniAll cursorPercorsiAdesioniAll%ROWTYPE;
	
	cursor cursorPercorsiRifAdesioni (prgpercorsoad or_percorso_concordato.prgpercorso%TYPE, prgcolloquioad or_percorso_concordato.prgcolloquio%TYPE) is
		select prgpercorso, prgcolloquio
		from or_percorso_concordato
		where prgpercorsoadesione = prgpercorsoad and prgcolloquioadesione = prgcolloquioad;
	
	rec_PercorsiRifAdesioni cursorPercorsiRifAdesioni%ROWTYPE;
	
	prgpercorsoRifAdesione or_percorso_concordato.prgpercorso%TYPE;
	prgcolloquioRifAdesione or_percorso_concordato.prgcolloquio%TYPE;
	prgpercorsoCursor or_percorso_concordato.prgpercorso%TYPE;
	prgcolloquioCursor or_percorso_concordato.prgcolloquio%TYPE;
	flgadesioneggCursor de_azione.flgadesionegg%TYPE;
	flgstatoconclusoVar de_esito.flgstatoconcluso%TYPE;
	chiudiProgramma boolean := true;
	datconclusioneVar or_percorso_concordato.dateffettiva%TYPE;
	datconclusioneMax or_percorso_concordato.dateffettiva%TYPE;
	numklochiusura or_colloquio.numklocolloquio%TYPE;
	TYPE RecPercorsoAd is VARRAY(2000) OF or_percorso_concordato.prgpercorso%TYPE;
	arrayPercorsoAd RecPercorsoAd := RecPercorsoAd();
	TYPE RecColloquioAd is VARRAY(2000) OF or_percorso_concordato.prgcolloquio%TYPE;
	arrayColloquioAd RecColloquioAd := RecColloquioAd();
	contatore integer := 0;
	
BEGIN

	select pt.datstipula, pt.numklopattolavoratore, pt.cdnlavoratore, pt.codtipopatto, pt.codcpi, pt.datultimoprotocollo,
		pt.strentecodicefiscale, pt.codsede, pt.strnotaente
	into dataStipulaPatto, numklopattolav, cdnLav, p_codtipopatto, codcpiVar, datprotocolloVar,
		strentecodicefiscaleVar, codsedeVar, strnotaenteVar
	from am_patto_lavoratore pt 
	where pt.prgpattolavoratore = prgPatto;
	
	-- gestione trasformazione patto ANP
	if (p_codtipopatto <> 'ANP') then
		BEGIN
		
			numklopattolav := numklopattolav + 1;
			
			PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnUt, ' WHERE PRGPATTOLAVORATORE = ' || prgPatto);
			
			update am_patto_lavoratore
			set numklopattolavoratore = numklopattolav, cdnutmod = cdnUt, dtmmod = sysdate, codtipopatto = 'ANP'
			where prgpattolavoratore = prgPatto;
			
			select codregionesil into p_codregionesil from ts_generale where prggenerale = 1;
			
			if (p_codregionesil = '22') then
				-- PVTN
				if (p_codtipopatto = 'MGG') then
					codservizioVar := 'SGG';
				else
					if (p_codtipopatto = 'MMI') then
						codservizioVar := 'SPD';
					else
						codservizioVar := 'SSP';
					end if;
				end if;
			else
				if (p_codregionesil = '2') then
					-- VDA
					if (p_codtipopatto = 'MGG' or p_codtipopatto = 'MSR') then
						codservizioVar := p_codtipopatto;
					else
						codservizioVar := 'SEP';
					end if;
				else
					-- RER UMBRIA CALABRIA
					if (p_codtipopatto = 'MGG' or p_codtipopatto = 'ADR' or p_codtipopatto = 'FRD' or p_codtipopatto = 'FRD2018' or
						p_codtipopatto = 'POC' or p_codtipopatto = 'MGO45' or p_codtipopatto = 'MGGU' or p_codtipopatto = 'MGO30' or 
						p_codtipopatto = 'MINAT') then
						codservizioVar := p_codtipopatto;
					else
						codservizioVar := 'SEP';
					end if;
				end if;
			end if;
			
			select count(*)
			into num_coll_prog
			from or_colloquio
			where cdnlavoratore = cdnLav and codservizio = codservizioVar;
			
			if(num_coll_prog =0) then				
				begin
					select prgspi into prgspiVar from ts_utente where cdnut = cdnUt;
				exception
					WHEN OTHERS THEN
						prgspiVar := null;
				end;
				
				if (p_codregionesil = '8') then
					-- RER
					select az.prgazioni into prgazioniVar
					from de_azione az 
					inner join de_azione_ragg ragg on (az.prgazioneragg = ragg.prgazioniragg) 
					where lower(az.strdescrizione) = 'trasferimento di informazioni sul lavoro e sulla formazione' and ragg.codservizio = 'SEP';
				else
					if (p_codregionesil = '10') then
						-- UMBRIA
						select az.prgazioni into prgazioniVar
						from de_azione az 
						inner join de_azione_ragg ragg on (az.prgazioneragg = ragg.prgazioniragg) 
						where lower(az.strdescrizione) = 'a1.2 - erogazione informazioni sui servizi per l''impiego' and ragg.codservizio = 'SEP';
					else
						if (p_codregionesil = '22') then
							-- PVTN
							select prgazioni into prgazioniVar
							from de_azione where lower(strdescrizione) = 'orientamento per patto di servizio personalizzato';
						else
							if (p_codregionesil = '18') then
								-- CALABRIA
								select prgazioni into prgazioniVar
								from de_azione where lower(strdescrizione) = 'accoglienza, informazione e accesso ai servizi';
							else
								-- VDA
								select az.prgazioni into prgazioniVar
								from de_azione az 
								inner join de_azione_ragg ragg on (az.prgazioneragg = ragg.prgazioniragg) 
								where lower(az.strdescrizione) = 'colloquio di primo orientamento' and ragg.codservizio = 'SEP'
								and lower(ragg.strdescrizione) = 'orientamento';
							end if;
						end if;
					end if;
				end if;
				
				select s_or_colloquio.nextval into p_prgcolloquio from dual;
				
				insert into or_colloquio(prgcolloquio, cdnlavoratore, datcolloquio, codservizio, prgspi, codcpi,
						cdnUtIns, dtmIns, cdnUtMod, dtmMod) 
				values(p_prgcolloquio, cdnLav, trunc(dataStipulaPatto), codservizioVar, prgspiVar, codcpiVar, cdnUt, sysdate, cdnUt, sysdate);
				
				insert into or_scheda_colloquio(prgcolloquio) values(p_prgcolloquio);
				
				
				-- UMBRIA O CALABRIA OPPURE RER GESTIAMO LO SPOSTAMENTO DELLE AZIONI
				if ( ( (p_codregionesil = '10' or p_codregionesil = '18') and p_codtipopatto in ('MGG', 'MGO30', 'MGO45', 'MGGU', 'MINAT')) or 
					 (p_codregionesil = '8' and p_codtipopatto in ('POC', 'FRD', 'FRD2018'))) then
					
					chiudiProgramma := true;
					datconclusioneMax := null;
					
					if (p_codregionesil = '10' or p_codregionesil = '18') then
					
						open cursorPercorsiConcordatiAll(prgPatto);
						loop
							fetch cursorPercorsiConcordatiAll into rec_PercorsiConcordatiAll;
							exit when (cursorPercorsiConcordatiAll%notfound);
							
							prgpercorsoCursor := rec_PercorsiConcordatiAll.prgpercorso;
							prgcolloquioCursor := rec_PercorsiConcordatiAll.prgcolloquio;
							flgstatoconclusoVar := rec_PercorsiConcordatiAll.flgstatoconcluso;
							datconclusioneVar := rec_PercorsiConcordatiAll.dateffettiva;
							flgadesioneggCursor := rec_PercorsiConcordatiAll.flgadesionegg;
							
							if (flgstatoconclusoVar = 'N') then
								chiudiProgramma := false;
							else
								if (chiudiProgramma) then
									if (datconclusioneMax is null) then
										if (datconclusioneVar is not null) then
											datconclusioneMax := datconclusioneVar;
										end if;
									else
										if (datconclusioneVar is not null and datconclusioneVar > datconclusioneMax) then
											datconclusioneMax := datconclusioneVar;
										end if;
									end if;
								end if;
							end if;
							
							if (flgadesioneggCursor = 'N') then
								PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnUt, ' WHERE PRGPERCORSO = ' || prgpercorsoCursor || ' AND PRGCOLLOQUIO = ' || prgcolloquioCursor);
								
								update or_percorso_concordato
								set prgcolloquio = p_prgcolloquio, cdnutmod = cdnUt, dtmmod = sysdate
								where prgpercorso = prgpercorsoCursor and prgcolloquio = prgcolloquioCursor;
								
							end if;
							
						end loop;
						
						close cursorPercorsiConcordatiAll;
						
						open cursorPercorsiAdesioniAll(prgPatto);
						loop
							fetch cursorPercorsiAdesioniAll into rec_PercorsiAdesioni;
							exit when (cursorPercorsiAdesioniAll%notfound);
							
							prgpercorsoCursor := rec_PercorsiAdesioni.prgpercorso;
							prgcolloquioCursor := rec_PercorsiAdesioni.prgcolloquio;
							
							contatore := 0;
							
							open cursorPercorsiRifAdesioni(prgpercorsoCursor, prgcolloquioCursor);
							loop
								fetch cursorPercorsiRifAdesioni into rec_PercorsiRifAdesioni;
								exit when (cursorPercorsiRifAdesioni%notfound);
								
								prgpercorsoRifAdesione := rec_PercorsiRifAdesioni.prgpercorso;
								prgcolloquioRifAdesione := rec_PercorsiRifAdesioni.prgcolloquio;
								
								PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnUt, ' WHERE PRGPERCORSO = ' || prgpercorsoRifAdesione || ' AND PRGCOLLOQUIO = ' || prgcolloquioRifAdesione);
							
								update or_percorso_concordato
								set prgpercorsoadesione = null, prgcolloquioadesione = null, cdnutmod = cdnUt, dtmmod = sysdate
								where prgpercorso = prgpercorsoRifAdesione and prgcolloquio = prgcolloquioRifAdesione;
								
								contatore := contatore + 1;
								arrayPercorsoAd.extend;
								arrayColloquioAd.extend;
								arrayPercorsoAd(contatore) := prgpercorsoRifAdesione;
								arrayColloquioAd(contatore) := prgcolloquioRifAdesione;
								
							end loop;
							
							close cursorPercorsiRifAdesioni;
							
							PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnUt, ' WHERE PRGPERCORSO = ' || prgpercorsoCursor || ' AND PRGCOLLOQUIO = ' || prgcolloquioCursor);
							
							update or_percorso_concordato
							set prgcolloquio = p_prgcolloquio, cdnutmod = cdnUt, dtmmod = sysdate
							where prgpercorso = prgpercorsoCursor and prgcolloquio = prgcolloquioCursor;
							
							if (contatore > 0) then
								FOR i in 1 .. contatore LOOP 
									prgpercorsoRifAdesione := arrayPercorsoAd(i);
									prgcolloquioRifAdesione := arrayColloquioAd(i);
									
									PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnUt, ' WHERE PRGPERCORSO = ' || prgpercorsoRifAdesione || ' AND PRGCOLLOQUIO = ' || prgcolloquioRifAdesione);
							
									update or_percorso_concordato
									set prgpercorsoadesione = prgpercorsoCursor, prgcolloquioadesione = p_prgcolloquio, cdnutmod = cdnUt, dtmmod = sysdate
									where prgpercorso = prgpercorsoRifAdesione and prgcolloquio = prgcolloquioRifAdesione;
									
								END LOOP;
							
							end if;
							
						end loop;
						
						close cursorPercorsiAdesioniAll;
					
					else
					
						open cursorPercorsiConcordati(prgPatto, p_codtipopatto);
						loop
							fetch cursorPercorsiConcordati into rec_PercorsiConcordati;
							exit when (cursorPercorsiConcordati%notfound);
							
							prgpercorsoCursor := rec_PercorsiConcordati.prgpercorso;
							prgcolloquioCursor := rec_PercorsiConcordati.prgcolloquio;
							flgstatoconclusoVar := rec_PercorsiConcordati.flgstatoconcluso;
							datconclusioneVar := rec_PercorsiConcordati.dateffettiva;
							flgadesioneggCursor := rec_PercorsiConcordati.flgadesionegg;
							
							if (flgstatoconclusoVar = 'N') then
								chiudiProgramma := false;
							else
								if (chiudiProgramma) then
									if (datconclusioneMax is null) then
										if (datconclusioneVar is not null) then
											datconclusioneMax := datconclusioneVar;
										end if;
									else
										if (datconclusioneVar is not null and datconclusioneVar > datconclusioneMax) then
											datconclusioneMax := datconclusioneVar;
										end if;
									end if;
								end if;
							end if;
							
							if (flgadesioneggCursor = 'N') then
								PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnUt, ' WHERE PRGPERCORSO = ' || prgpercorsoCursor || ' AND PRGCOLLOQUIO = ' || prgcolloquioCursor);
								
								update or_percorso_concordato
								set prgcolloquio = p_prgcolloquio, cdnutmod = cdnUt, dtmmod = sysdate
								where prgpercorso = prgpercorsoCursor and prgcolloquio = prgcolloquioCursor;
								
							end if;
							
						end loop;
						
						close cursorPercorsiConcordati;
						
						open cursorPercorsiAdesioni(prgPatto, p_codtipopatto);
						loop
							fetch cursorPercorsiAdesioni into rec_PercorsiAdesioni;
							exit when (cursorPercorsiAdesioni%notfound);
							
							prgpercorsoCursor := rec_PercorsiAdesioni.prgpercorso;
							prgcolloquioCursor := rec_PercorsiAdesioni.prgcolloquio;
							
							contatore := 0;
							
							open cursorPercorsiRifAdesioni(prgpercorsoCursor, prgcolloquioCursor);
							loop
								fetch cursorPercorsiRifAdesioni into rec_PercorsiRifAdesioni;
								exit when (cursorPercorsiRifAdesioni%notfound);
								
								prgpercorsoRifAdesione := rec_PercorsiRifAdesioni.prgpercorso;
								prgcolloquioRifAdesione := rec_PercorsiRifAdesioni.prgcolloquio;
								
								PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnUt, ' WHERE PRGPERCORSO = ' || prgpercorsoRifAdesione || ' AND PRGCOLLOQUIO = ' || prgcolloquioRifAdesione);
							
								update or_percorso_concordato
								set prgpercorsoadesione = null, prgcolloquioadesione = null, cdnutmod = cdnUt, dtmmod = sysdate
								where prgpercorso = prgpercorsoRifAdesione and prgcolloquio = prgcolloquioRifAdesione;
								
								contatore := contatore + 1;
								arrayPercorsoAd.extend;
								arrayColloquioAd.extend;
								arrayPercorsoAd(contatore) := prgpercorsoRifAdesione;
								arrayColloquioAd(contatore) := prgcolloquioRifAdesione;
								
							end loop;
							
							close cursorPercorsiRifAdesioni;
							
							PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnUt, ' WHERE PRGPERCORSO = ' || prgpercorsoCursor || ' AND PRGCOLLOQUIO = ' || prgcolloquioCursor);
							
							update or_percorso_concordato
							set prgcolloquio = p_prgcolloquio, cdnutmod = cdnUt, dtmmod = sysdate
							where prgpercorso = prgpercorsoCursor and prgcolloquio = prgcolloquioCursor;
							
							if (contatore > 0) then
								FOR i in 1 .. contatore LOOP 
									prgpercorsoRifAdesione := arrayPercorsoAd(i);
									prgcolloquioRifAdesione := arrayColloquioAd(i);
									
									PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnUt, ' WHERE PRGPERCORSO = ' || prgpercorsoRifAdesione || ' AND PRGCOLLOQUIO = ' || prgcolloquioRifAdesione);
							
									update or_percorso_concordato
									set prgpercorsoadesione = prgpercorsoCursor, prgcolloquioadesione = p_prgcolloquio, cdnutmod = cdnUt, dtmmod = sysdate
									where prgpercorso = prgpercorsoRifAdesione and prgcolloquio = prgcolloquioRifAdesione;
									
								END LOOP;
							
							end if;
							
						end loop;
						
						close cursorPercorsiAdesioni;
						
					end if; 
					
					if (chiudiProgramma) then
						if (datconclusioneMax is null) then
							datconclusioneMax := trunc(sysdate);
						end if;
						
						select numklocolloquio into numklochiusura
						from or_colloquio where prgcolloquio = p_prgcolloquio;
						
						PG_LOG.doLog('U', 'OR_COLLOQUIO', cdnUt, ' WHERE PRGCOLLOQUIO = ' || p_prgcolloquio);
						
						update or_colloquio set datfineprogramma = datconclusioneMax, numklocolloquio = numklochiusura + 1,
							cdnutmod = cdnUt, dtmmod = sysdate
						where prgcolloquio = p_prgcolloquio;
					end if;
					
					if ( (p_codregionesil = '18' or p_codtipopatto = 'POC') and strentecodicefiscaleVar is not null) then
						insert into am_programma_ente(prgpattolavoratore, prgColloquio, strentecodicefiscale, codsede, strnotaente, cdnUtIns, dtmIns, cdnUtMod, dtmMod) 
						values(prgPatto, p_prgcolloquio, strentecodicefiscaleVar, codsedeVar, strnotaenteVar, cdnUt, sysdate, cdnUt, sysdate);	
					end if;
					
				else
					
					select s_or_percorso_concordato.nextval into prgpercorsoVar from dual;
					
					insert into or_percorso_concordato(prgPercorso, prgColloquio, datStimata, prgAzioni, codEsito, codesitorendicont,
							prgspiproposta, cdnUtIns, dtmIns, cdnUtMod, dtmMod) 
					values(prgpercorsoVar, p_prgcolloquio, trunc(dataStipulaPatto), prgazioniVar, 'PRO', 'P', prgspiVar, cdnUt, sysdate, cdnUt, sysdate);
					
					insert into am_lav_patto_scelta values (s_am_lav_patto_scelta.nextval, prgPatto, 'OR_PER', to_char(prgpercorsoVar), 
						null, null, null, null, datprotocolloVar, null);
					
					if (p_codregionesil = '8') then
						-- RER
						FOR rec_Impegni IN cursorImpegniAz LOOP
							codimpegnoVar := rec_Impegni.codimpegno;
							
							begin
							
								insert into am_lav_patto_scelta values (s_am_lav_patto_scelta.nextval, prgPatto, 'DE_IMPE', codimpegnoVar, 
								null, null, null, null, datprotocolloVar, null);
								
							exception
								WHEN OTHERS THEN
								codimpegnoVar := null;
							end;
							
						END LOOP;
					else
						if (p_codregionesil = '10') then
							-- UMBRIA
							FOR rec_ImpegniUmb IN cursorImpegniAzUmb LOOP
								codimpegnoVar := rec_ImpegniUmb.codimpegno;
								
								begin
								
									insert into am_lav_patto_scelta values (s_am_lav_patto_scelta.nextval, prgPatto, 'DE_IMPE', codimpegnoVar, 
									null, null, null, null, datprotocolloVar, null);
									
								exception
									WHEN OTHERS THEN
									codimpegnoVar := null;
								end;
								
							END LOOP;
						else
							if (p_codregionesil = '22') then
								-- PVTN
								FOR rec_ImpegniTn IN cursorImpegniAzTn LOOP
									codimpegnoVar := rec_ImpegniTn.codimpegno;
									
									begin
									
										insert into am_lav_patto_scelta values (s_am_lav_patto_scelta.nextval, prgPatto, 'DE_IMPE', codimpegnoVar, 
										null, null, null, null, datprotocolloVar, null);
										
									exception
										WHEN OTHERS THEN
										codimpegnoVar := null;
									end;
									
								END LOOP;
							else
								if (p_codregionesil = '18') then
									-- CALABRIA
									FOR rec_ImpegniCal IN cursorImpegniAzCal LOOP
										codimpegnoVar := rec_ImpegniCal.codimpegno;
										
										begin
										
											insert into am_lav_patto_scelta values (s_am_lav_patto_scelta.nextval, prgPatto, 'DE_IMPE', codimpegnoVar, 
											null, null, null, null, datprotocolloVar, null);
											
										exception
											WHEN OTHERS THEN
											codimpegnoVar := null;
										end;
										
									END LOOP;
									
									if (strentecodicefiscaleVar is not null) then
										insert into am_programma_ente(prgpattolavoratore, prgColloquio, strentecodicefiscale, codsede, strnotaente, cdnUtIns, dtmIns, cdnUtMod, dtmMod) 
										values(prgPatto, p_prgcolloquio, strentecodicefiscaleVar, codsedeVar, strnotaenteVar, cdnUt, sysdate, cdnUt, sysdate);	
									end if;
									
								else
									-- AOSTA
									FOR rec_ImpegniVda IN cursorImpegniAzVda LOOP
										codimpegnoVar := rec_ImpegniVda.codimpegno;
										
										begin
										
											insert into am_lav_patto_scelta values (s_am_lav_patto_scelta.nextval, prgPatto, 'DE_IMPE', codimpegnoVar, 
											null, null, null, null, datprotocolloVar, null);
											
										exception
											WHEN OTHERS THEN
											codimpegnoVar := null;
										end;
										
									END LOOP;
								end if;
							end if;
						end if;
					end if;
					
				end if;
			end if; --chiusura if num_coll_prog = 0
			
		EXCEPTION
			WHEN OTHERS THEN
				return -1;
		END;
		
	end if; 
	
	return 0;

EXCEPTION
    WHEN OTHERS THEN
      return -1;

END TRASFORMAPATTOANP;


END PG_UTILS_DID_PATTO;
/



/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_UTILS.sql
************************************************************************************** */


-- Eliminato perchè da problemi nella esecuzion di all.sql in quanto viene inserito all'inizio di tale file
CREATE OR REPLACE PACKAGE PG_UTILS IS

  -- Author  : Franco Vuoto
  -- Purpose : Funzioni di utilità generale

VERSION CONSTANT VARCHAR2 (200) :=  'SIL.PG_UTILS         Version: 1.0  Date: 17/11/03 15:57    Modtime: 17/11/03 15:57';

FUNCTION VER RETURN VARCHAR2;
PRAGMA RESTRICT_REFERENCES (VER, WNDS, WNPS, RNDS);

Secondavolta BOOLEAN;


FUNCTION NUMERO_IN_LETTERE(NUMERO NUMBER)    RETURN VARCHAR2;

FUNCTION TROVA_TIPO_MANSIONE (Pmansione VARCHAR2) RETURN VARCHAR2;


FUNCTION TRUNC_DESC(PAR_STR VARCHAR2, MAXL NUMBER, CODA VARCHAR2)    RETURN VARCHAR2;
FUNCTION TRUNC_DESC_OTTIMIZZATA(PAR_STR VARCHAR2, MAXL NUMBER, CODA VARCHAR2)    RETURN VARCHAR2;

FUNCTION concatena(cdnLav an_lavoratore.CDNLAVORATORE%TYPE ,prgMan pr_mansione.PRGMANSIONE%TYPE, ordine number) return varchar2;

FUNCTION CONCATENA_COMUNI(MANSIONE NUMBER, DESCMANSIONE VARCHAR2) RETURN VARCHAR2;

FUNCTION CONCATENA_PROVINCE(MANSIONE NUMBER, DESCMANSIONE VARCHAR2) RETURN VARCHAR2;

FUNCTION CONCATENA_REGIONI(MANSIONE NUMBER, DESCMANSIONE VARCHAR2) RETURN VARCHAR2;

FUNCTION CONCATENA_STATI(MANSIONE NUMBER, DESCMANSIONE VARCHAR2) RETURN VARCHAR2;

-- funzione utilizzata per fare la quote di alcuni caratteri per poter passare la strina via xml
-- analoga al metodo della classe utils nell'applicativo
FUNCTION QUOTE(strParStringa VARCHAR2) RETURN VARCHAR2;

END PG_UTILS;
/
CREATE OR REPLACE PACKAGE BODY PG_UTILS IS

FUNCTION VER RETURN VARCHAR2 IS
BEGIN
	RETURN VERSION;
END;



FUNCTION NUMERO_IN_LETTERE(NUMERO  NUMBER) RETURN VARCHAR2 IS
 tempstr      VARCHAR2(2000);
 suffisso    VARCHAR2(1000);
 newstr       VARCHAR2(1000);
 numstr       NUMBER;
 NumeroInLettere VARCHAR2(1000);
 VALORE_TMP   VARCHAR(1000);
 newnum       NUMBER;
 newresto     NUMBER;
 VARCASE      NUMBER;
 FLG_ELIDERE  NUMBER;

 BEGIN

	 numstr:=NUMERO;

     IF NOT Secondavolta THEN
         Secondavolta := TRUE;
		 IF (numstr=0) THEN
	   	    NumeroInLettere:='ZERO';
		    RETURN NumeroInLettere;
		 END IF;
     END IF;

	 IF(numstr > 1000000000) THEN
	    NumeroInLettere:='';
	    RETURN NumeroInLettere;
	 END IF;

     IF(numstr>=1000000000) THEN
	     newnum := TRUNC(numstr/ 1000000000);
         newresto := numstr - newnum * 1000000000;

		 IF (newnum = 1) THEN
	        suffisso := 'UNMILIARDO';
	     ELSE
	        suffisso := 'MILIARDI';
	     END IF;

         IF (newnum > 1) THEN
		 	    tempstr := NUMERO_IN_LETTERE(newnum)||suffisso;
		 ELSE
			    tempstr := suffisso;
		 END IF;

		 VALORE_TMP:=NUMERO_IN_LETTERE(newresto);
         tempstr := tempstr || VALORE_TMP;
     ELSE
		         IF(numstr>=1000000) THEN
			     newnum := TRUNC(numstr/ 1000000);
		         newresto := numstr - newnum * 1000000;

				 IF (newnum = 1) THEN
			        suffisso := 'UNMILIONE';
			     ELSE
			        suffisso := 'MILIONI';
			     END IF;

		         IF (newnum > 1) THEN
				 	    tempstr := NUMERO_IN_LETTERE(newnum)||suffisso;
				 ELSE
					    tempstr := suffisso;
				 END IF;

				 tempstr := tempstr || NUMERO_IN_LETTERE(newresto);

		         ELSE
					         IF(numstr>=1000) THEN
						     newnum := TRUNC(numstr/ 1000);
					         newresto := numstr - (newnum * 1000);

								 IF (newnum = 1) THEN
							        suffisso := 'MILLE';
							     ELSE
							        suffisso := 'MILA';
							     END IF;

						         IF (newnum > 1) THEN
								 	    tempstr := NUMERO_IN_LETTERE(newnum)||suffisso;
								 ELSE
									    tempstr := suffisso;
								 END IF;

								 VALORE_TMP:=NUMERO_IN_LETTERE(newresto);

								 tempstr := tempstr || VALORE_TMP;
							     ELSE

											  IF(numstr>=100) THEN
												     newnum := TRUNC(numstr/ 100);
											         newresto := numstr - newnum * 100;
													 suffisso := 'CENTO';

											  IF (newnum > 1) THEN
											 	    tempstr := NUMERO_IN_LETTERE(newnum)||suffisso;
											  ELSE
												    tempstr := suffisso;
											  END IF;

												VALORE_TMP:=NUMERO_IN_LETTERE(newresto);
												tempstr := tempstr || VALORE_TMP;
											  ELSE
											        FLG_ELIDERE := 0;
													IF (numstr >= 20) THEN
												    VARCASE :=TRUNC(numstr/ 10);
													FLG_ELIDERE:=1;
													IF(VARCASE=2) THEN
														tempstr := tempstr || 'VENTI';
													END IF;
													IF(VARCASE=3) THEN
														tempstr := tempstr || 'TRENTA';
													END IF;
													IF(VARCASE=4) THEN
														tempstr := tempstr || 'QUARANTA';
													END IF;
													IF(VARCASE=5) THEN
														tempstr := tempstr || 'CINQUANTA';
													END IF;
													IF(VARCASE=6) THEN
														tempstr := tempstr || 'SESSANTA';
													END IF;
													IF(VARCASE=7) THEN
														tempstr := tempstr || 'SETTANTA';
													END IF;
													IF(VARCASE=8) THEN
														tempstr := tempstr || 'OTTANTA';
													END IF;
													IF(VARCASE=9) THEN
														tempstr := tempstr || 'NOVANTA';
													END IF;

													numstr := TRUNC((numstr - TRUNC(numstr/10) * 10));
												   END IF;

												   IF (numstr > 0) THEN
												   VARCASE:=numstr;
												    IF(VARCASE=1) THEN
													    IF flg_elidere = 1 THEN tempstr := SUBSTR(tempstr,1,LENGTH(tempstr)-1); END IF;
														tempstr := tempstr || 'UNO';
													END IF;
												    IF(VARCASE=2) THEN
														tempstr := tempstr || 'DUE';
													END IF;
													IF(VARCASE=3) THEN
														tempstr := tempstr || 'TRE';
													END IF;
													IF(VARCASE=4) THEN
														tempstr := tempstr || 'QUATTRO';
													END IF;
													IF(VARCASE=5) THEN
														tempstr := tempstr || 'CINQUE';
													END IF;
													IF(VARCASE=6) THEN
														tempstr := tempstr || 'SEI';
													END IF;
													IF(VARCASE=7) THEN
														tempstr := tempstr || 'SETTE';
													END IF;
													IF(VARCASE=8) THEN
													    IF flg_elidere = 1 THEN tempstr := SUBSTR(tempstr,1,LENGTH(tempstr)-1); END IF;
														tempstr := tempstr || 'OTTO';
													END IF;
													IF(VARCASE=9) THEN
														tempstr := tempstr || 'NOVE';
													END IF;

													IF(VARCASE=10) THEN
														tempstr := tempstr || 'DIECI';
													END IF;
												    IF(VARCASE=11) THEN
														tempstr := tempstr || 'UNDICI';
													END IF;
													IF(VARCASE=12) THEN
														tempstr := tempstr || 'DODICI';
													END IF;
													IF(VARCASE=13) THEN
														tempstr := tempstr || 'TREDICI';
													END IF;
													IF(VARCASE=14) THEN
														tempstr := tempstr || 'QUATTORDICI';
													END IF;
													IF(VARCASE=15) THEN
														tempstr := tempstr || 'QUINDICI';
													END IF;
													IF(VARCASE=16) THEN
														tempstr := tempstr || 'SEDICI';
													END IF;
													IF(VARCASE=17) THEN
														tempstr := tempstr || 'DICIASETTE';
													END IF;
													IF(VARCASE=18) THEN
														tempstr := tempstr || 'DICIOTTO';
													END IF;
													IF(VARCASE=19) THEN
														tempstr := tempstr || 'DICIANNOVE';
													END IF;
							                       END IF;
      										  END IF;
									END IF;
		         END IF;
     END IF;

    NumeroInLettere := tempstr;
	RETURN NumeroInLettere;

 END;



FUNCTION TROVA_TIPO_MANSIONE(Pmansione VARCHAR2) RETURN VARCHAR2 is
 	 codMansioneTipo      VARCHAR2(2000);
	 res				  VARCHAR2(2000);
BEGIN
	 if Pmansione is null OR length(Pmansione) < 2 then
	 	RETURN null;
	 end if;
	 
	 if length(Pmansione) = 7 then
	 	codMansioneTipo := substr(Pmansione, 0, 5) || '00';
	 else 
	 	codMansioneTipo := substr(Pmansione, 0, 2) || '0000';
	 end if;
	 
	 select de_mansione.STRDESCRIZIONE into res
	 from de_mansione
	 where de_mansione.CODMANSIONE = codMansioneTipo;
  
RETURN res;

END;



-- Se la string @PAR_STR è piu' lunga di @MAXL caratteri,
-- viene troncata al @MAXL carattere ed appesa la stringa
-- @CODA.

FUNCTION TRUNC_DESC(PAR_STR VARCHAR2, MAXL NUMBER, CODA VARCHAR2)
RETURN VARCHAR2 is
 BUFFER VARCHAR2(4000);
BEGIN

  BUFFER :=   PAR_STR;
  IF (LENGTH(buffer)>MAXL) THEN
    BUFFER:= SUBSTR(BUFFER, 1, MAXL) || CODA;
  END IF;

RETURN buffer;


END;


-- concatena la stringa CODA a PAR_STR. Se la string risultante è piu' lunga di @MAXL caratteri,
-- viene troncata al @MAXL carattere

FUNCTION TRUNC_DESC_OTTIMIZZATA(PAR_STR VARCHAR2, MAXL NUMBER, CODA VARCHAR2)
RETURN VARCHAR2 is
 BUFFER VARCHAR2(4000);
BEGIN

  BUFFER := CODA || PAR_STR;
  IF (LENGTH(buffer)>MAXL) THEN
    BUFFER:= SUBSTR(BUFFER, 1, MAXL);
  END IF;

RETURN buffer;


END;


-- questa funzione viene utilizzata all' interno della view vw_am_rpt_vincoli_compatto.
-- serve a compattare i vincoli quali i comuni, le regioni in una sola stringa in modo che nel report vengano
-- visualizzati in sequenza e non in una moltitudine di righe
FUNCTION concatena(cdnLav an_lavoratore.CDNLAVORATORE%TYPE ,prgMan pr_mansione.PRGMANSIONE%TYPE , ordine number)
return varchar2 is str varchar2(4000);
begin
declare
	 fieldTemp varchar2(4000);
	 -- ordine = 5 comuni
	 cursor c5(cdn number, prg number) is
	 select distinct dec_.STRDENOMINAZIONE as cdn
	 FROM am_lav_patto_scelta ps_,
            pr_mansione pr_,
            de_mansione de_,
            am_patto_lavoratore amp,
            pr_dis_comune dis_,
            de_comune dec_
            WHERE ( (pr_.prgmansione = ps_.strchiavetabella)
            AND (ps_.codlsttab = 'PR_MAN')
            AND (ps_.prgpattolavoratore = amp.prgPattoLavoratore)
            AND (amp.datfine is null)
            AND (de_.codmansione = pr_.codmansione)
            AND (pr_.prgmansione = dis_.prgmansione)
            AND (dec_.codcom = dis_.codcom)
			and (amp.CDNLAVORATORE=cdn) and (pr_.PRGMANSIONE=prg)
            );
	 -- ordine = 6 province
	 cursor c6(cdn number, prg number) is
	 select distinct dec_.STRDENOMINAZIONE as cdn
	 FROM am_lav_patto_scelta ps_,
            pr_mansione pr_,
            de_mansione de_,
            am_patto_lavoratore amp,
            pr_dis_provincia dis_,
            de_provincia dec_
            WHERE ( (pr_.prgmansione = ps_.strchiavetabella)
            AND (ps_.codlsttab = 'PR_MAN')
            AND (ps_.prgpattolavoratore = amp.prgPattoLavoratore)
            AND (amp.datfine is null)
            AND (de_.codmansione = pr_.codmansione)
            AND (pr_.prgmansione = dis_.prgmansione)
            AND (dec_.codprovincia = dis_.codprovincia)
			and (amp.CDNLAVORATORE=cdn) and (pr_.PRGMANSIONE=prg)
            );
	 -- ordine = 7 regioni
	 cursor c7(cdn number, prg number) is
	 select distinct dec_.STRDENOMINAZIONE as cdn
	 FROM am_lav_patto_scelta ps_,pr_mansione pr_,
            de_mansione de_,
            am_patto_lavoratore amp,
            pr_dis_regione dis_,
            de_regione dec_
            WHERE ( (pr_.prgmansione = ps_.strchiavetabella)
            AND (ps_.codlsttab = 'PR_MAN')
            AND (ps_.prgpattolavoratore = amp.prgPattoLavoratore)
            AND (amp.datfine is null)
            AND (de_.codmansione = pr_.codmansione)
            AND (pr_.prgmansione = dis_.prgmansione)
            AND (dec_.codregione = dis_.codregione)
			and (amp.CDNLAVORATORE=cdn) and (pr_.PRGMANSIONE=prg)
            );
	  -- ordine = 8 stati
	  cursor c8(cdn number, prg number) is
	  select distinct dec_.STRDENOMINAZIONE as cdn
	  FROM am_lav_patto_scelta ps_,
            pr_mansione pr_,
            de_mansione de_,
            am_patto_lavoratore amp,
            pr_dis_stato dis_,
            de_comune dec_
            WHERE ( (pr_.prgmansione = ps_.strchiavetabella)
            AND (ps_.codlsttab = 'PR_MAN')
            AND (ps_.prgpattolavoratore = amp.prgPattoLavoratore)
            AND (amp.datfine is null)
            AND (de_.codmansione = pr_.codmansione)
            AND (pr_.prgmansione = dis_.prgmansione)
            AND (dec_.codcom = dis_.codcom)
			and (amp.CDNLAVORATORE=cdn) and (pr_.PRGMANSIONE=prg)
            );

begin
str:='';
if ordine = 5 then
	for c5_rec in c5(cdnLav, prgMan) loop
		fieldTemp:=c5_rec.cdn;
		str:=str||', '||fieldTemp;
	end loop;
elsif ordine = 6 then
	for c6_rec in c6(cdnLav, prgMan) loop
		fieldTemp:=c6_rec.cdn;
		str:=str||', '||fieldTemp;
	end loop;
elsif ordine = 7 then
	for c7_rec in c7(cdnLav, prgMan) loop
		fieldTemp:=c7_rec.cdn;
		str:=str||', '||fieldTemp;
	end loop;
elsif ordine = 8 then
	for c8_rec in c8(cdnLav, prgMan) loop
		fieldTemp:=c8_rec.cdn;
		str:=str||', '||fieldTemp;
	end loop;
end if;
if length(str)>0 then str:= substr(str,2); end if;
if str='' then str:=null; end if;
end;
return str;

end;


FUNCTION CONCATENA_COMUNI(MANSIONE NUMBER, DESCMANSIONE VARCHAR2)
 RETURN VARCHAR2
 AS
 m_result VARCHAR2 (32000);
 TYPE COMUNERECTYP IS RECORD (
    PRGDISCOMUNE PR_DIS_COMUNE.PRGDISCOMUNE%TYPE,
	STRDENOMINAZIONE DE_COMUNE.STRDENOMINAZIONE%TYPE
	);
 RIGA COMUNERECTYP;
 cursor C1 is
	SELECT COM.PRGDISCOMUNE, DE_COM.STRDENOMINAZIONE
    FROM PR_DIS_COMUNE COM,
	 	 DE_COMUNE DE_COM
 	WHERE
   		 COM.PRGMANSIONE=MANSIONE
   		 AND COM.CODCOM = DE_COM.CODCOM;
BEGIN
 OPEN C1;
 LOOP
   FETCH C1 INTO RIGA ;
   EXIT WHEN C1%NOTFOUND;
   m_result := m_result || '<TR>';
   m_result := m_result || '<TD>';
   m_result := m_result || '<A href="javascript://" onclick="ComuneDetail(';
   m_result := m_result || TO_CHAR (RIGA.PRGDISCOMUNE);
   m_result := m_result || '); return false;"><IMG name="image" border="0"  src="../../img/detail.gif" alt="Selezionare un dettaglio"/></A>';
   m_result := m_result || '</TD>' ;
   m_result := m_result || '<TD>';
   m_result := m_result || RIGA.STRDENOMINAZIONE;
   m_result := m_result || '</TD>';
   m_result := m_result || '<TD align="right">';
   m_result := m_result || '<A href="javascript://" onclick="ComuneDelete(';
   m_result := m_result || TO_CHAR (RIGA.PRGDISCOMUNE) || ',' || CHR (39) || REPLACE (RIGA.STRDENOMINAZIONE,CHR(39),CHR(96)) || CHR (39) || ',' || CHR (39) || REPLACE (DESCMANSIONE,CHR(39),CHR(96)) || CHR(39);
   m_result := m_result || '); return false;"><IMG name="image" border="0" src="../../img/del.gif" alt="Cancellare una riga"/></A>';
   m_result := m_result || '<TD>';
   m_result := m_result || '</TR>';
 END LOOP;
 CLOSE C1;
 m_result := '<TABLE>' || m_result || '</TABLE>' ;
 m_result := SUBSTR(m_result, 0, length(m_result));
 RETURN m_result;
END;


FUNCTION CONCATENA_PROVINCE(MANSIONE NUMBER, DESCMANSIONE VARCHAR2)
 RETURN VARCHAR2
 AS
 m_result VARCHAR2 (32000);
 TYPE PROVINCIARECTYP IS RECORD (
    PRGDISPROVINCIA PR_DIS_PROVINCIA.PRGDISPROVINCIA%TYPE,
	STRDENOMINAZIONE DE_PROVINCIA.STRDENOMINAZIONE%TYPE
	);
 RIGA PROVINCIARECTYP;
 cursor C1 is
	SELECT PRO.PRGDISPROVINCIA, DE_PRO.STRDENOMINAZIONE
    FROM PR_DIS_PROVINCIA PRO,
	 	 DE_PROVINCIA DE_PRO
 	WHERE
   		 PRO.PRGMANSIONE=MANSIONE
   		 AND PRO.CODPROVINCIA = DE_PRO.CODPROVINCIA;
BEGIN
 OPEN C1;
 LOOP
   FETCH C1 INTO RIGA;
   EXIT WHEN C1%NOTFOUND;
   m_result := m_result || '<TR>';
   m_result := m_result || '<TD></TD>';
   m_result := m_result || '<TD>';
   m_result := m_result || RIGA.STRDENOMINAZIONE;
   m_result := m_result || '</TD>' ;
   m_result := m_result || '<TD align="right">' ;
   m_result := m_result || '<A href="javascript://" onclick="ProvinciaDelete(';
   m_result := m_result || TO_CHAR (RIGA.PRGDISPROVINCIA) || ',' || CHR (39) || REPLACE (RIGA.STRDENOMINAZIONE,CHR(39),CHR(96)) || CHR (39) || ',' || CHR (39) || REPLACE (DESCMANSIONE,CHR(39),CHR(96)) || CHR(39);
   m_result := m_result || '); return false;"><IMG name="image" border="0" src="../../img/del.gif" alt="Cancellare una riga"/></A>';
   m_result := m_result || '<TD>' ;
   m_result := m_result || '</TR>' ;
 END LOOP;
 CLOSE C1;
 m_result := '<TABLE>' || m_result || '</TABLE>' ;
 m_result := SUBSTR(m_result, 0, length(m_result));
 RETURN m_result;
END;

FUNCTION CONCATENA_REGIONI(MANSIONE NUMBER, DESCMANSIONE VARCHAR2)
 RETURN VARCHAR2
 AS
 m_result VARCHAR2 (32000);
 TYPE REGIONERECTYP IS RECORD (
    PRGDISREGIONE PR_DIS_REGIONE.PRGDISREGIONE%TYPE,
	STRDENOMINAZIONE DE_REGIONE.STRDENOMINAZIONE%TYPE
	);
 RIGA REGIONERECTYP;
 cursor C1 is
	SELECT REG.PRGDISREGIONE, DE_REG.STRDENOMINAZIONE
    FROM PR_DIS_REGIONE REG,
	 	 DE_REGIONE DE_REG
 	WHERE
   		 REG.PRGMANSIONE=MANSIONE
   		 AND REG.CODREGIONE = DE_REG.CODREGIONE;
BEGIN
 OPEN C1;
 LOOP
   FETCH C1 INTO RIGA;
   EXIT WHEN C1%NOTFOUND;
   m_result := m_result || '<TR>';
   m_result := m_result || '<TD></TD>' ;
   m_result := m_result || '<TD>';
   m_result := m_result || RIGA.STRDENOMINAZIONE;
   m_result := m_result || '</TD>';
   m_result := m_result || '<TD align="right">';
   m_result := m_result ||  '<A href="javascript://" onclick="RegioneDelete(';
   m_result := m_result ||  TO_CHAR (RIGA.PRGDISREGIONE) || ',' || CHR (39) || REPLACE (RIGA.STRDENOMINAZIONE,CHR(39),CHR(96)) || CHR (39) || ',' || CHR (39) || REPLACE (DESCMANSIONE,CHR(39),CHR(96)) || CHR(39);
   m_result := m_result ||  '); return false;"><IMG name="image" border="0" src="../../img/del.gif" alt="Cancellare una riga"/></A>';
   m_result := m_result || '<TD>' ;
   m_result := m_result || '</TR>' ;
 END LOOP;
 CLOSE C1;
 m_result := '<TABLE>' || m_result || '</TABLE>' ;
 m_result := SUBSTR(m_result, 0, length(m_result));
 RETURN m_result;
END;


FUNCTION CONCATENA_STATI(MANSIONE NUMBER, DESCMANSIONE VARCHAR2)
 RETURN VARCHAR2
 AS
 m_result VARCHAR2 (32000);
 TYPE STATORECTYP IS RECORD (
    PRGDISSTATO PR_DIS_STATO.PRGDISSTATO%TYPE,
	STRDENOMINAZIONE DE_COMUNE.STRDENOMINAZIONE%TYPE
	);
 RIGA STATORECTYP;
 cursor C1 is
	SELECT STA.PRGDISSTATO, DE_STA.STRDENOMINAZIONE
    FROM PR_DIS_STATO STA,
	 	 DE_COMUNE DE_STA
 	WHERE
   		 STA.PRGMANSIONE=MANSIONE
   		 AND STA.CODCOM = DE_STA.CODCOM;
BEGIN
 OPEN C1;
 LOOP
   FETCH C1 INTO RIGA;
   EXIT WHEN C1%NOTFOUND;
   m_result := m_result || '<TR>';
   m_result := m_result || '<TD></TD>';
   m_result := m_result || '<TD>';
   m_result := m_result || RIGA.STRDENOMINAZIONE;
   m_result := m_result || '</TD>';
   m_result := m_result || '<TD align="right">' ;
   m_result := m_result || '<A href="javascript://" onclick="StatoDelete(';
   m_result := m_result || TO_CHAR (RIGA.PRGDISSTATO) || ',' || CHR (39) || REPLACE (RIGA.STRDENOMINAZIONE,CHR(39),CHR(96)) || CHR (39) || ',' || CHR (39) || REPLACE (DESCMANSIONE,CHR(39),CHR(96)) || CHR(39);
   m_result := m_result || '); return false;"><IMG name="image" border="0" src="../../img/del.gif" alt="Cancellare una riga"/></A>'||  chr(10);
   m_result := m_result || '<TD>' ;
   m_result := m_result || '</TR>' ;
 END LOOP;
 CLOSE C1;
 m_result := '<TABLE>' || m_result || '</TABLE>' ;
 m_result := SUBSTR(m_result, 0, length(m_result));
 RETURN m_result;
END;

-- funzione utilizzata per fare la quote di alcuni caratteri per poter passare la strina via xml
-- analoga al metodo della classe utils nell'applicativo
FUNCTION QUOTE(strParStringa VARCHAR2)
RETURN VARCHAR2
AS
 -- variabili
  strVarStringa varchar2(1000);
begin
 		 strVarStringa := strParStringa;

         if strParStringa is not null then


             strVarStringa := replace( strVarStringa, '&'  , '&amp;'  );
             strVarStringa := replace( strVarStringa, '\''', '&quot;' );
             strVarStringa := replace( strVarStringa, '<'  , '&lt;'   );
             strVarStringa := replace( strVarStringa, '>'  , '&gt;'   );
             strVarStringa := replace( strVarStringa, '''' , '&apos;' );
			 strVarStringa := replace( strVarStringa, '"'  , '&apos;'  );


		end if;
        return strVarStringa;
end;

END PG_UTILS;
/




/* *************************************************************************************
**** CONTENUTO DEL FILE ./Database/db_src/Packages/PG_VOUCHER.sql
************************************************************************************** */


CREATE OR REPLACE PACKAGE PG_VOUCHER IS

	
FUNCTION assegnazioneAllaData (
	prgColloquioVar in or_percorso_concordato.prgcolloquio%type, 
	prgPercorsoVar in or_percorso_concordato.prgPercorso%type, 
	codiceAttivazioneVar in varchar2,
	cdnParUtenteVar in or_vch_voucher.CDNUTASS%TYPE,
	datAssegnazioneVar in or_vch_voucher.datAssegnazione%TYPE) RETURN NUMBER;

	
FUNCTION annulla (
	prgColloquioVar in or_percorso_concordato.prgcolloquio%type, 
	prgPercorsoVar in or_percorso_concordato.prgPercorso%type, 
	cdnParUtenteVar in or_vch_voucher.CDNUTANN%TYPE,
	codVchMotivoAnnVar in or_vch_voucher.CODVCHMOTIVOANNULLAMENTO%TYPE) RETURN NUMBER;
	
	
FUNCTION proroga(
	prgVoucherVar in or_vch_voucher.prgvoucher%type, 
	ggProrogaAttivazione in number,
	ggProrogaChiusura in number,
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE,
	skipCheckProroga in number) RETURN NUMBER;

FUNCTION calcolaDoteProcessoSottrarre (
	prgpattolavoratoreVar in am_patto_lavoratore.prgpattolavoratore%type) RETURN NUMBER;
	
FUNCTION calcolaDoteRisultatoSottrarre (
	prgpattolavoratoreVar in am_patto_lavoratore.prgpattolavoratore%type) RETURN NUMBER;
	

PROCEDURE calcolaResiduoDoti (
	doteAProcesso in am_patto_lavoratore.decDoteProcessoAssegnato%type,
	doteARisultato in am_patto_lavoratore.decDoteRisultatoAssegnato%type,
	prgpattolavoratoreVar in am_patto_lavoratore.prgpattolavoratore%type,
	residuoAProcesso out am_patto_lavoratore.decDoteProcessoResidua%type,
	residuoARisultato out am_patto_lavoratore.decDoteRisultatoResidua%type,
	errCodeOut out varchar2,
	messaggioErr out varchar2);
	
	
PROCEDURE attivazioneAllaData (
	cfEnte in or_vch_voucher.strcfenteaccreditato%type,
	sedeEnte in or_vch_voucher.codsede%type,
	codiceFiscaleLav in an_lavoratore.strcodicefiscale%type,
	codiceAttivazione in or_vch_voucher.codattivazione%type,
	cdnParUtenteVar in or_vch_voucher.CDNUTATT%TYPE,
	datAttivazioneVar in or_vch_voucher.datAttivazione%TYPE,
	errCodeOut out number,
	messaggioErr out varchar2);
	

FUNCTION aggiornaModalitaDurata (
	prgVoucherVar in or_vch_voucher.prgvoucher%type,
	prgModalitaVar in or_vch_modalita.prgmodmodalita%type,
	durataEffettivaVar in or_vch_modalita.numdurataeffettiva%type,
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE) RETURN NUMBER;
	

FUNCTION cancellaModalitaDurata (
	prgVoucherVar in or_vch_voucher.prgvoucher%type,
	prgModalitaVar in or_vch_modalita.prgmodmodalita%type,
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE) RETURN NUMBER;
	

FUNCTION chiusuraTDA (
	prgVoucherVar in or_vch_voucher.prgvoucher%type,
	dataChiusuraVar in varchar2,
	tipoRisultatoRaggiuntoVar in varchar2, 
	descRisultatoVar in varchar2,
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE) RETURN NUMBER;
	

FUNCTION aggiornaPagamentoTDA (
	prgVoucherVar in or_vch_voucher.prgvoucher%type,
	codVchStatoPagamentoVar in varchar2,
	decPagatoVar in or_vch_voucher.decpagato%type, 
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE) RETURN NUMBER;


FUNCTION riapriTDA (
	prgVoucherVar in or_vch_voucher.prgvoucher%type,
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE) RETURN NUMBER;
	

END PG_VOUCHER;
/

CREATE OR REPLACE PACKAGE BODY PG_VOUCHER IS



FUNCTION assegnazioneAllaData (
	prgColloquioVar in or_percorso_concordato.prgcolloquio%type, 
	prgPercorsoVar in or_percorso_concordato.prgPercorso%type, 
	codiceAttivazioneVar in varchar2,
	cdnParUtenteVar in or_vch_voucher.CDNUTASS%TYPE,
	datAssegnazioneVar in or_vch_voucher.datAssegnazione%TYPE) RETURN NUMBER IS

	prgVoucherKey or_vch_voucher.prgvoucher%type;
	codTipoServizioVar DE_VCH_TIPOSERVIZIO.CODTIPOSERVIZIO%TYPE;
	decDoteResidua am_patto_lavoratore.decDoteRisultatoResidua%type;
	decValTotale or_vch_voucher.decvaltot%type;
	ggErogVoucher vch_modello_voucher.numngmaxerogvch%type;
	ggAttVoucher vch_modello_voucher.numngmaxattvch%type;
	flagCMVoucher vch_modello_voucher.flgcm%type;
	flagCMVch  vch_modello_voucher.flgcm%type;
	codSelezMod vch_modello_voucher.codselezmodalita%type;
	codCpiVar am_patto_lavoratore.codcpi%type;
	decDoteResiduaCpi vch_budget_cpi.decTotResiduo%type;
	numklopattoVar am_patto_lavoratore.numklopattolavoratore%type;
	numklobudgetcpiVar vch_budget_cpi.numklobudget%type;
	prgModelloVoucher vch_modello_voucher.prgmodvoucher%type;
	prgpattolavoratoreVar am_patto_lavoratore.prgpattolavoratore%type;
	codEsitoAzVar or_percorso_concordato.codesito%type;
	dataMassimaErogazioneVCH date;
	p_numannobudget vch_budget_cpi.numannobudget%type;
	numVoucherAssociati integer := 0;
	numCodiceVchVar AM_VCH_CODICE_ATTIVAZIONE.NUMCODICEVCH%type;
	numkloCodiceVchVar AM_VCH_CODICE_ATTIVAZIONE.NUMKLOVCHCODICE%type;
	isCodiceAttivazioneGenerato boolean := false;
	codProvinciaSilVar ts_generale.codprovinciasil%type;
	p_codiceAttivazione or_vch_voucher.codattivazione%type;

BEGIN
	
	select count(*)
	into numVoucherAssociati
	from or_vch_voucher
	where prgpercorso = prgPercorsoVar and prgcolloquio = prgColloquioVar;
	
	if (numVoucherAssociati > 0) then
		return 40;
	end if;
	
	select AZ.CODTIPOSERVIZIO, PERC.codEsito
	into codTipoServizioVar, codEsitoAzVar
	from OR_PERCORSO_CONCORDATO PERC
	inner join DE_AZIONE AZ on (PERC.PRGAZIONI = AZ.PRGAZIONI)
	where PERC.PRGPERCORSO = prgPercorsoVar AND PERC.PRGCOLLOQUIO = prgColloquioVar;
	
	if (codEsitoAzVar <> 'PRO') then
		return 30;
	end if;
	
	select patto_scelta.prgpattolavoratore
	into prgpattolavoratoreVar
	from am_lav_patto_scelta patto_scelta
	where to_number(patto_scelta.strchiavetabella) = prgPercorsoVar and patto_scelta.codlsttab = 'OR_PER';
	
	select modello.prgmodvoucher, modello.decvaltot, modello.numngmaxerogvch, modello.codselezmodalita, modello.numngmaxattvch, modello.flgcm
	into prgModelloVoucher, decValTotale, ggErogVoucher, codSelezMod, ggAttVoucher, flagCMVoucher
	from or_percorso_concordato perc
	inner join vch_modello_voucher modello on (perc.prgazioni = modello.prgazioni)
	where perc.prgpercorso = prgPercorsoVar AND perc.prgcolloquio = prgColloquioVar and modello.flgAttivo = 'S';
	
	flagCMVch := nvl(flagCMVoucher, 'N');
	
	dataMassimaErogazioneVCH := trunc(datAssegnazioneVar) + ggErogVoucher;
	
	begin
		
		select (case
				when codTipoServizioVar = 'SP' then nvl(pt.decDoteProcessoResidua, 0)
				else nvl(pt.decDoteRisultatoResidua, 0)
			   end), pt.codcpi, nvl(budget.decTotResiduo, 0), pt.numklopattolavoratore, budget.numklobudget
		into decDoteResidua, codCpiVar, decDoteResiduaCpi, numklopattoVar, numklobudgetcpiVar
		from am_patto_lavoratore pt
		inner join vch_budget_cpi budget on (pt.codcpi = budget.codcpi)
		where pt.prgpattolavoratore = prgpattolavoratoreVar and budget.numannobudget = to_number(to_char(dataMassimaErogazioneVCH, 'yyyy'));
		
	exception
		when NO_DATA_FOUND then 
		return 20;
	end;
	
	if(flagCMVch = 'N') then
	
		if ((decDoteResidua - decValTotale) < 0) then
			return 10;
		end if;
	
		if ((decDoteResiduaCpi - decValTotale) < 0) then
			return 20;
		end if;
		
	end if;
	
	if (codiceAttivazioneVar is null or codiceAttivazioneVar = '''') then
		select codProvinciaSil
		into codProvinciaSilVar
		from ts_generale;
		
		SELECT NUMCODICEVCH + 1, NUMKLOVCHCODICE
		INTO numCodiceVchVar, numkloCodiceVchVar
		FROM AM_VCH_CODICE_ATTIVAZIONE
		WHERE NUMANNOCODVCH = TO_NUMBER(TO_CHAR(SYSDATE, 'yyyy'));
		
		p_codiceAttivazione := codProvinciaSilVar || to_char(sysdate, 'yyyy') || to_char(numCodiceVchVar);
		
		isCodiceAttivazioneGenerato := true;
	else
		p_codiceAttivazione := codiceAttivazioneVar;
	end if;
	
	select s_or_vch_voucher.nextval
	into prgVoucherKey
	from dual;
	
	insert into or_vch_voucher (PRGVOUCHER, PRGCOLLOQUIO, PRGPERCORSO, CODSTATOVOUCHER, CDNUTASS, DTMUTASS, CODATTIVAZIONE, 
								DATASSEGNAZIONE, DATMAXATTIVAZIONE, 
								DATMAXEROGAZIONE, DECVALTOT, NUMANNOBUDGET, CODSELEZMODALITA, FLGCM,
								CDNUTINS, DTMINS, CDNUTMOD, DTMMOD)
	values (prgVoucherKey, prgColloquioVar, prgPercorsoVar, 'ASS', cdnParUtenteVar, sysdate, p_codiceAttivazione, 
								trunc(datAssegnazioneVar), trunc(datAssegnazioneVar) + ggAttVoucher,
								dataMassimaErogazioneVCH, decValTotale, to_number(to_char(dataMassimaErogazioneVCH, 'yyyy')), codSelezMod, 
								flagCMVoucher, cdnParUtenteVar, sysdate, cdnParUtenteVar, sysdate);
	
	
	insert into or_vch_modalita (PRGMODMODALITA, PRGMODVOUCHER, DECVALUNITARIO, DECVALTOTALE, CODTIPOLOGIADURATA, CODVCHMODEROG,
							     NUMDURATAMAX, NUMDURATAMIN, CDNUTINS, DTMINS, CDNUTMOD, DTMMOD, CODMONOTIPRIMBORSO, NUMPERCPARCOMPLET)
	select s_or_vch_modalita.nextval, prgVoucherKey, modello.decvalunitario, modello.decvaltotale, modello.codtipologiadurata, modello.codvchmoderog,
		   modello.numduratamax, modello.numduratamin, cdnParUtenteVar, sysdate, cdnParUtenteVar, sysdate, modello.CODMONOTIPRIMBORSO, modello.NUMPERCPARCOMPLET
	from vch_modello_modalita modello
	where modello.prgmodvoucher = prgModelloVoucher;
	
	if(flagCMVch = 'N') then
		PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnParUtenteVar, ' WHERE PRGPATTOLAVORATORE = ' || prgpattolavoratoreVar);


		update am_patto_lavoratore
			set decDoteProcessoResidua = 
			case
				when codTipoServizioVar = 'SP' then decDoteProcessoResidua - decValTotale
				else decDoteProcessoResidua
			end,
			decDoteRisultatoResidua = 
			case
				when codTipoServizioVar = 'SR' then decDoteRisultatoResidua - decValTotale
				else decDoteRisultatoResidua
			end,
			numklopattolavoratore = numklopattoVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where prgpattolavoratore = prgpattolavoratoreVar;
	end if;
	
	p_numannobudget := to_number(to_char(dataMassimaErogazioneVCH, 'yyyy'));
	
	PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || p_numannobudget);
	
	update vch_budget_cpi
		set decTotImpegnato = decTotImpegnato + decValTotale,
		decTotResiduo = decTotResiduo - decValTotale, 
		numklobudget = numklobudgetcpiVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
	where codcpi = codCpiVar and numannobudget = p_numannobudget;
	
	if (isCodiceAttivazioneGenerato) then
		UPDATE AM_VCH_CODICE_ATTIVAZIONE 
		 SET NUMCODICEVCH  = numCodiceVchVar ,
			 NUMKLOVCHCODICE = numkloCodiceVchVar + 1  
		WHERE NUMANNOCODVCH = TO_NUMBER(TO_CHAR(SYSDATE, 'yyyy'));
	end if;
	
	return 0;

EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;



FUNCTION annulla (
	prgColloquioVar in or_percorso_concordato.prgcolloquio%type, 
	prgPercorsoVar in or_percorso_concordato.prgPercorso%type, 
	cdnParUtenteVar in or_vch_voucher.CDNUTANN%TYPE,
	codVchMotivoAnnVar in or_vch_voucher.CODVCHMOTIVOANNULLAMENTO%TYPE) RETURN NUMBER IS

	prgVoucherKey or_vch_voucher.prgvoucher%type;
	flagCMVoucher vch_modello_voucher.flgcm%type;
	flagCMVch  vch_modello_voucher.flgcm%type;
	codTipoServizioVar DE_VCH_TIPOSERVIZIO.CODTIPOSERVIZIO%TYPE;
	decValTotale or_vch_voucher.decvaltot%type;
	codCpiVar am_patto_lavoratore.codcpi%type;
	numklopattoVar am_patto_lavoratore.numklopattolavoratore%type;
	numklobudgetcpiVar vch_budget_cpi.numklobudget%type;
	p_numklovoucher or_vch_voucher.numklovoucher%type;
	p_numannobudget or_vch_voucher.numannobudget%type;
	prgpattolavoratoreVar am_patto_lavoratore.prgpattolavoratore%type;
	p_codstatovoucher or_vch_voucher.codstatovoucher%type;

BEGIN
	
	select prgvoucher, decvaltot, numklovoucher, numannobudget, codstatovoucher, flgcm
	into prgVoucherKey, decValTotale, p_numklovoucher, p_numannobudget, p_codstatovoucher, flagCMVoucher
	from or_vch_voucher
	where prgpercorso = prgPercorsoVar and prgcolloquio = prgColloquioVar;
	
	if (p_codstatovoucher not in ('ASS', 'ATT')) then
		return 10;
	end if;
	
	flagCMVch := nvl(flagCMVoucher , 'N');
	
	select patto_scelta.prgpattolavoratore
	into prgpattolavoratoreVar
	from am_lav_patto_scelta patto_scelta
	where to_number(patto_scelta.strchiavetabella) = prgPercorsoVar and patto_scelta.codlsttab = 'OR_PER';
	
	select AZ.CODTIPOSERVIZIO
	into codTipoServizioVar
	from OR_PERCORSO_CONCORDATO PERC
	inner join DE_AZIONE AZ on (PERC.PRGAZIONI = AZ.PRGAZIONI)
	where PERC.PRGPERCORSO = prgPercorsoVar AND PERC.PRGCOLLOQUIO = prgColloquioVar;
	
	select pt.codcpi, pt.numklopattolavoratore, budget.numklobudget
	into codCpiVar, numklopattoVar, numklobudgetcpiVar
	from am_patto_lavoratore pt
	inner join vch_budget_cpi budget on (pt.codcpi = budget.codcpi)
	where pt.prgpattolavoratore = prgpattolavoratoreVar and budget.numannobudget = p_numannobudget;
	
	PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherKey);
	
	update or_vch_voucher
		set CODSTATOVOUCHER = 'ANN', CDNUTANN = cdnParUtenteVar, DTMUTANN = sysdate, CODVCHMOTIVOANNULLAMENTO = codVchMotivoAnnVar,
		cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numklovoucher + 1
	where prgvoucher = prgVoucherKey;
	
	PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnParUtenteVar, ' WHERE prgpercorso = ' || prgPercorsoVar || ' AND  prgcolloquio = ' || prgColloquioVar);
	
	update or_percorso_concordato
	set codesito = 'NA', codesitorendicont = 'A', cdnutmod = cdnParUtenteVar, dtmmod = sysdate
	where prgpercorso = prgPercorsoVar AND prgcolloquio = prgColloquioVar;
	
	
	if(flagCMVch = 'N') then
		PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnParUtenteVar, ' WHERE PRGPATTOLAVORATORE = ' || prgpattolavoratoreVar);

		update am_patto_lavoratore
			set decDoteProcessoResidua = 
			case
				when codTipoServizioVar = 'SP' then decDoteProcessoResidua + decValTotale
				else decDoteProcessoResidua
			end,
			decDoteRisultatoResidua = 
			case
				when codTipoServizioVar = 'SR' then decDoteRisultatoResidua + decValTotale
				else decDoteRisultatoResidua
			end,
			numklopattolavoratore = numklopattoVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where prgpattolavoratore = prgpattolavoratoreVar;
	end if;
	
	PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || p_numannobudget);
	
	update vch_budget_cpi
		set decTotImpegnato = decTotImpegnato - decValTotale,
		decTotResiduo = decTotResiduo + decValTotale, 
		numklobudget = numklobudgetcpiVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
	where codcpi = codCpiVar and numannobudget = p_numannobudget;
	
	return 0;

EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;

FUNCTION proroga(
	prgVoucherVar in or_vch_voucher.prgvoucher%type, 
	ggProrogaAttivazione in number,
	ggProrogaChiusura in number,
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE,
	skipCheckProroga in number) RETURN NUMBER IS
	
	prgVoucherKey or_vch_voucher.prgvoucher%type;
	prgPercorsoVar or_percorso_concordato.prgPercorso%type;
	prgColloquioVar or_percorso_concordato.prgPercorso%type;
	p_numklovoucher or_vch_voucher.numklovoucher%type;
	p_numannobudget or_vch_voucher.numannobudget%type;
	p_datmaxattivazione or_vch_voucher.datmaxattivazione%type;
	p_datmaxerogazione  or_vch_voucher.datmaxerogazione%type;
	decValTotale or_vch_voucher.decvaltot%type;
	numklobudgetcpiAnnoOldVar vch_budget_cpi.numklobudget%type;
	numklobudgetcpiAnnoNewVar vch_budget_cpi.numklobudget%type;
	p_datmaxattivazioneNew or_vch_voucher.datmaxattivazione%type;
	p_datmaxerogazioneNew or_vch_voucher.datmaxerogazione%type;
	p_decTotImpegnatoAnnoOld vch_budget_cpi.decTotImpegnato%type;
	p_decTotImpegnatoAnnoNew vch_budget_cpi.decTotImpegnato%type;
	p_decTotResiduoAnnoNew vch_budget_cpi.decTotResiduo%type;
	p_decTotResiduoAnnoOld vch_budget_cpi.decTotResiduo%type;
	p_codstatovoucher or_vch_voucher.codstatovoucher%type;
	prgpattolavoratoreVar am_patto_lavoratore.prgpattolavoratore%type;
	codCpiVar am_patto_lavoratore.codcpi%type;
	annoOld number;
	annoNew number;
	prorogaNumAttVar number;
	prorogaNumChiVar number;
	updateProrogaAtt boolean;
	updateProrogaChi boolean;
 
BEGIN

	updateProrogaAtt := true;
	updateProrogaChi := true;
	
	
	select prgvoucher, numklovoucher, numannobudget, datmaxattivazione, datmaxerogazione, decvaltot, prgpercorso, prgcolloquio, codstatovoucher
	into prgVoucherKey, p_numklovoucher, p_numannobudget, p_datmaxattivazione, p_datmaxerogazione, decValTotale, prgPercorsoVar, prgColloquioVar, p_codstatovoucher
	from or_vch_voucher
	where prgvoucher = prgVoucherVar;
	
	if (p_codstatovoucher in ('ANN', 'CHI')) then
		return 20;
	end if;
	
	select patto_scelta.prgpattolavoratore
	into prgpattolavoratoreVar
	from am_lav_patto_scelta patto_scelta
	where to_number(patto_scelta.strchiavetabella) = prgPercorsoVar and patto_scelta.codlsttab = 'OR_PER';
	

	if (ggProrogaAttivazione > 0 and ggProrogaChiusura > 0)  then
		return 40;
	end if;
	
	select nvl(numggproratt, 0) numggproratt
	into prorogaNumAttVar
	from or_vch_voucher 
	where prgvoucher = prgVoucherVar;
	
	if(skipCheckProroga = 1 and prorogaNumAttVar > 0 and ggProrogaAttivazione > 0) then
		return 30;
	end if;
	
	if(prorogaNumAttVar > 0 ) then
		updateProrogaAtt := false;
	end if;
	
	select nvl(numggprorchi, 0) numggprorchi
	into prorogaNumChiVar
	from or_vch_voucher 
	where prgvoucher = prgVoucherVar;	
	
	if(skipCheckProroga = 1 and prorogaNumChiVar > 0 and ggProrogaChiusura > 0) then
		return 31;
	end if;
	
	if(prorogaNumChiVar > 0 ) then
		updateProrogaChi := false;
	end if;

	select prgvoucher, numklovoucher, numannobudget, datmaxattivazione, datmaxerogazione, decvaltot, prgpercorso, prgcolloquio, codstatovoucher
	into prgVoucherKey, p_numklovoucher, p_numannobudget, p_datmaxattivazione, p_datmaxerogazione, decValTotale, prgPercorsoVar, prgColloquioVar, p_codstatovoucher
	from or_vch_voucher
	where prgvoucher = prgVoucherVar;
	
	p_datmaxattivazioneNew := trunc(p_datmaxattivazione) + ggProrogaAttivazione;
	
	if(ggProrogaAttivazione > 0) then
		p_datmaxerogazioneNew := trunc(p_datmaxerogazione) + ggProrogaAttivazione;
	else  
		p_datmaxerogazioneNew := trunc(p_datmaxerogazione) + ggProrogaChiusura;
	end if;
	
	
	annoOld := to_number(to_char(p_datmaxerogazione, 'yyyy'));
	annoNew := to_number(to_char(p_datmaxerogazioneNew, 'yyyy'));
	
	if (annoNew = annoOld) then
	
		PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherKey);
		
		if(skipCheckProroga = 1 and updateProrogaAtt and updateProrogaChi) then
			update or_vch_voucher
			set datmaxattivazione = p_datmaxattivazioneNew, datmaxerogazione = p_datmaxerogazioneNew,
			cdnutproratt = cdnParUtenteVar, dtmproratt = sysdate, numggproratt = ggProrogaAttivazione,
			cdnutprorchi = cdnParUtenteVar, dtmprorchi = sysdate, numggprorchi = ggProrogaChiusura,
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numklovoucher + 1
			where prgvoucher = prgVoucherKey;
		elsif(skipCheckProroga = 1 and updateProrogaAtt) then
			update or_vch_voucher
			set datmaxattivazione = p_datmaxattivazioneNew, datmaxerogazione = p_datmaxerogazioneNew,
			cdnutproratt = cdnParUtenteVar, dtmproratt = sysdate, numggproratt = ggProrogaAttivazione,
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numklovoucher + 1
			where prgvoucher = prgVoucherKey;
		elsif(skipCheckProroga = 1 and updateProrogaChi)	then
			update or_vch_voucher
			set datmaxattivazione = p_datmaxattivazioneNew, datmaxerogazione = p_datmaxerogazioneNew,
			cdnutprorchi = cdnParUtenteVar, dtmprorchi = sysdate, numggprorchi = ggProrogaChiusura,
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numklovoucher + 1
			where prgvoucher = prgVoucherKey;
    else
    	update or_vch_voucher
			set datmaxattivazione = p_datmaxattivazioneNew, datmaxerogazione = p_datmaxerogazioneNew,
 			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numklovoucher + 1
			where prgvoucher = prgVoucherKey;
		end if;
	 
	else
		
		select pt.codcpi
		into codCpiVar
		from am_patto_lavoratore pt
		where pt.prgpattolavoratore = prgpattolavoratoreVar;
		
		select decTotImpegnato, decTotResiduo, numklobudget
		into p_decTotImpegnatoAnnoNew, p_decTotResiduoAnnoNew, numklobudgetcpiAnnoNewVar
		from vch_budget_cpi
		where codcpi = codCpiVar and numannobudget = annoNew;
		
		if ((p_decTotResiduoAnnoNew - decValTotale) < 0) then
			return 10;
		end if;
		
		select decTotImpegnato, decTotResiduo, numklobudget
		into p_decTotImpegnatoAnnoOld, p_decTotResiduoAnnoOld, numklobudgetcpiAnnoOldVar
		from vch_budget_cpi
		where codcpi = codCpiVar and numannobudget = annoOld;
		
		PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || annoOld);
		
		update vch_budget_cpi
			set decTotImpegnato = p_decTotImpegnatoAnnoOld - decValTotale,
			decTotResiduo = p_decTotResiduoAnnoOld + decValTotale, 
			numklobudget = numklobudgetcpiAnnoOldVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where codcpi = codCpiVar and numannobudget = annoOld;
		
		PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || annoNew);
		
		update vch_budget_cpi
			set decTotImpegnato = p_decTotImpegnatoAnnoNew + decValTotale,
			decTotResiduo = p_decTotResiduoAnnoNew - decValTotale, 
			numklobudget = numklobudgetcpiAnnoNewVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where codcpi = codCpiVar and numannobudget = annoNew;
		
		PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherKey);
		
		if(skipCheckProroga = 1 and updateProrogaAtt and updateProrogaChi) then
			update or_vch_voucher
			set datmaxattivazione = p_datmaxattivazioneNew, datmaxerogazione = p_datmaxerogazioneNew,numannobudget = annoNew,
			cdnutproratt = cdnParUtenteVar, dtmproratt = sysdate, numggproratt = ggProrogaAttivazione,
			cdnutprorchi = cdnParUtenteVar, dtmprorchi = sysdate, numggprorchi = ggProrogaChiusura,
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numklovoucher + 1
			where prgvoucher = prgVoucherKey;
		elsif(skipCheckProroga = 1 and updateProrogaAtt) then
			update or_vch_voucher
			set datmaxattivazione = p_datmaxattivazioneNew, datmaxerogazione = p_datmaxerogazioneNew,numannobudget = annoNew,
			cdnutproratt = cdnParUtenteVar, dtmproratt = sysdate, numggproratt = ggProrogaAttivazione,
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numklovoucher + 1
			where prgvoucher = prgVoucherKey;
		elsif(skipCheckProroga = 1 and updateProrogaChi)	then
			update or_vch_voucher
			set datmaxattivazione = p_datmaxattivazioneNew, datmaxerogazione = p_datmaxerogazioneNew,numannobudget = annoNew,
			cdnutprorchi = cdnParUtenteVar, dtmprorchi = sysdate, numggprorchi = ggProrogaChiusura,
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numklovoucher + 1
			where prgvoucher = prgVoucherKey;
    else 
    	update or_vch_voucher
			set datmaxattivazione = p_datmaxattivazioneNew, datmaxerogazione = p_datmaxerogazioneNew,numannobudget = annoNew,
 			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numklovoucher + 1
			where prgvoucher = prgVoucherKey;
		end if;
	
	end if;
	 
	return 0;

EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;


FUNCTION calcolaDoteProcessoSottrarre (
	prgpattolavoratoreVar in am_patto_lavoratore.prgpattolavoratore%type) RETURN NUMBER IS
	
	decImpegnato or_vch_voucher.decvaltot%type;
	decSpeso or_vch_voucher.decspesaeffettiva%type;
	decSPagato or_vch_voucher.decpagato%type;

BEGIN

	select nvl(sum(nvl(vch.decvaltot, 0)), 0)
	into decImpegnato
	from or_vch_voucher vch
	inner join or_percorso_concordato perc on (vch.prgpercorso = perc.prgpercorso and vch.prgcolloquio = perc.prgcolloquio)
	inner join de_azione az on (perc.prgazioni = az.prgazioni)
	where vch.prgpercorso in (
		select to_number(strchiavetabella)
        from am_lav_patto_scelta
        WHERE prgpattolavoratore = prgpattolavoratoreVar and codlsttab = 'OR_PER')
	and vch.codstatovoucher in ('ASS', 'ATT') and az.codtiposervizio = 'SP'
	and nvl(vch.flgcm, 'N') = 'N';
	
	select nvl(sum(nvl(vch.decspesaeffettiva, 0)), 0)
	into decSpeso
	from or_vch_voucher vch
	inner join or_percorso_concordato perc on (vch.prgpercorso = perc.prgpercorso and vch.prgcolloquio = perc.prgcolloquio)
	inner join de_azione az on (perc.prgazioni = az.prgazioni)
	where vch.prgpercorso in (
		select to_number(strchiavetabella)
        from am_lav_patto_scelta
        WHERE prgpattolavoratore = prgpattolavoratoreVar and codlsttab = 'OR_PER')
	and vch.codstatovoucher in ('CHI') and az.codtiposervizio = 'SP' and vch.CODVCHSTATOPAGAMENTO = 'INA'
	and nvl(vch.flgcm, 'N') = 'N';
	
	select nvl(sum(nvl(vch.decpagato, 0)), 0)
	into decSPagato
	from or_vch_voucher vch
	inner join or_percorso_concordato perc on (vch.prgpercorso = perc.prgpercorso and vch.prgcolloquio = perc.prgcolloquio)
	inner join de_azione az on (perc.prgazioni = az.prgazioni)
	where vch.prgpercorso in (
		select to_number(strchiavetabella)
        from am_lav_patto_scelta
        WHERE prgpattolavoratore = prgpattolavoratoreVar and codlsttab = 'OR_PER')
	and vch.codstatovoucher in ('CHI') and az.codtiposervizio = 'SP' and vch.CODVCHSTATOPAGAMENTO <> 'INA'
	and nvl(vch.flgcm, 'N') = 'N';

	return decImpegnato + decSpeso + decSPagato;

EXCEPTION
	WHEN OTHERS THEN
		return -1;

END;


FUNCTION calcolaDoteRisultatoSottrarre (
	prgpattolavoratoreVar in am_patto_lavoratore.prgpattolavoratore%type) RETURN NUMBER IS
	
	decImpegnato or_vch_voucher.decvaltot%type;
	decSpeso or_vch_voucher.decspesaeffettiva%type;
	decSPagato or_vch_voucher.decpagato%type;

BEGIN
	
	select nvl(sum(nvl(vch.decvaltot, 0)), 0)
	into decImpegnato
	from or_vch_voucher vch
	inner join or_percorso_concordato perc on (vch.prgpercorso = perc.prgpercorso and vch.prgcolloquio = perc.prgcolloquio)
	inner join de_azione az on (perc.prgazioni = az.prgazioni)
	where vch.prgpercorso in (
		select to_number(strchiavetabella)
        from am_lav_patto_scelta
        WHERE prgpattolavoratore = prgpattolavoratoreVar and codlsttab = 'OR_PER')
	and vch.codstatovoucher in ('ASS', 'ATT') and az.codtiposervizio = 'SR'
	and nvl(vch.flgcm, 'N') = 'N';
	
	select nvl(sum(nvl(vch.decspesaeffettiva, 0)), 0)
	into decSpeso
	from or_vch_voucher vch
	inner join or_percorso_concordato perc on (vch.prgpercorso = perc.prgpercorso and vch.prgcolloquio = perc.prgcolloquio)
	inner join de_azione az on (perc.prgazioni = az.prgazioni)
	where vch.prgpercorso in (
		select to_number(strchiavetabella)
        from am_lav_patto_scelta
        WHERE prgpattolavoratore = prgpattolavoratoreVar and codlsttab = 'OR_PER')
	and vch.codstatovoucher in ('CHI') and az.codtiposervizio = 'SR' and vch.CODVCHSTATOPAGAMENTO = 'INA'
	and nvl(vch.flgcm, 'N') = 'N';
	
	select nvl(sum(nvl(vch.decpagato, 0)), 0)
	into decSPagato
	from or_vch_voucher vch
	inner join or_percorso_concordato perc on (vch.prgpercorso = perc.prgpercorso and vch.prgcolloquio = perc.prgcolloquio)
	inner join de_azione az on (perc.prgazioni = az.prgazioni)
	where vch.prgpercorso in (
		select to_number(strchiavetabella)
        from am_lav_patto_scelta
        WHERE prgpattolavoratore = prgpattolavoratoreVar and codlsttab = 'OR_PER')
	and vch.codstatovoucher in ('CHI') and az.codtiposervizio = 'SR' and vch.CODVCHSTATOPAGAMENTO <> 'INA'
	and nvl(vch.flgcm, 'N') = 'N';

	return decImpegnato + decSpeso + decSPagato;

EXCEPTION
	WHEN OTHERS THEN
		return -1;

END;


PROCEDURE calcolaResiduoDoti (
	doteAProcesso in am_patto_lavoratore.decDoteProcessoAssegnato%type,
	doteARisultato in am_patto_lavoratore.decDoteRisultatoAssegnato%type,
	prgpattolavoratoreVar in am_patto_lavoratore.prgpattolavoratore%type,
	residuoAProcesso out am_patto_lavoratore.decDoteProcessoResidua%type,
	residuoARisultato out am_patto_lavoratore.decDoteRisultatoResidua%type,
	errCodeOut out varchar2,
	messaggioErr out varchar2) IS
	
	decImpegnatoSpesoProcesso or_vch_voucher.decvaltot%type;
	decImpegnatoSpesoRisultato or_vch_voucher.decvaltot%type;
	
BEGIN

	decImpegnatoSpesoProcesso := calcolaDoteProcessoSottrarre(prgpattolavoratoreVar);
	decImpegnatoSpesoRisultato := calcolaDoteRisultatoSottrarre(prgpattolavoratoreVar);
	
	if (decImpegnatoSpesoProcesso >= 0 and decImpegnatoSpesoRisultato >= 0) then
		residuoAProcesso := doteAProcesso - decImpegnatoSpesoProcesso;
		residuoARisultato := doteARisultato - decImpegnatoSpesoRisultato;
		errCodeOut := '00';
		messaggioErr := 'OK';
	else
		errCodeOut := '10';
		messaggioErr := 'Errore durante il calcolo residuo doti';
	end if;
		
EXCEPTION
	WHEN OTHERS THEN
		errCodeOut := '99';
		messaggioErr := 'Errore durante il calcolo residuo doti';
END;



PROCEDURE attivazioneAllaData (
	cfEnte in or_vch_voucher.strcfenteaccreditato%type,
	sedeEnte in or_vch_voucher.codsede%type,
	codiceFiscaleLav in an_lavoratore.strcodicefiscale%type,
	codiceAttivazione in or_vch_voucher.codattivazione%type,
	cdnParUtenteVar in or_vch_voucher.CDNUTATT%TYPE,
	datAttivazioneVar in or_vch_voucher.datAttivazione%TYPE,
	errCodeOut out number,
	messaggioErr out varchar2) IS
	
	numVoucher integer := 0;
	numVoucherLavoratore integer := 0;
	numVoucherNonAttivabili integer := 0;
	prgVoucherKey or_vch_voucher.prgvoucher%type;
	p_numklovoucher or_vch_voucher.numklovoucher%type;
	numVoucherNonAttivabiliEnte integer := 0;
	p_datmaxattivazione or_vch_voucher.datmaxattivazione%type;
	p_datassegnazione or_vch_voucher.datassegnazione%type;
	risProroga number;
	
	-- qui
	p_prgpercorso or_vch_voucher.prgpercorso%type;
	p_prgcolloquio or_vch_voucher.prgcolloquio%type;
	
	CURSOR voucherAttivabili IS
         --SELECT prgvoucher, datassegnazione, numklovoucher
		 SELECT prgvoucher, datassegnazione, numklovoucher, prgpercorso, prgcolloquio
         FROM or_vch_voucher
         WHERE codattivazione = codiceAttivazione and codstatovoucher = 'ASS';
	
BEGIN

	select count(*) into numVoucher
    from or_vch_voucher
    where codattivazione = codiceAttivazione and codstatovoucher <> 'ANN';
	
	if (numVoucher = 0) then
		errCodeOut := 10;
		messaggioErr := 'Codice di attivazione inesistente';
	else
		select count(*) into numVoucherLavoratore
		from or_vch_voucher
		inner join or_percorso_concordato per on (or_vch_voucher.prgpercorso = per.prgpercorso and or_vch_voucher.prgcolloquio = per.prgcolloquio)
		inner join or_colloquio coll on (per.prgcolloquio = coll.prgcolloquio)
		inner join an_lavoratore lav on (coll.cdnlavoratore = lav.cdnlavoratore)
		where upper(lav.strcodicefiscale) = upper(codiceFiscaleLav) and or_vch_voucher.codattivazione = codiceAttivazione and or_vch_voucher.codstatovoucher <> 'ANN';
	
		if (numVoucherLavoratore = 0) then
			errCodeOut := 20;
			messaggioErr := 'Il codice di attivazione non esiste per questo lavoratore';
		else
			select count(*) into numVoucherNonAttivabili
			from or_vch_voucher
			where codattivazione = codiceAttivazione and codstatovoucher not in ('ASS', 'ANN');
			
			if (numVoucherNonAttivabili > 0) then
				errCodeOut := 50;
				messaggioErr := 'voucher non e'' piu'' attivabile';
			else
			
				select max(datmaxattivazione)
				into p_datmaxattivazione
				from or_vch_voucher
				where codattivazione = codiceAttivazione and codstatovoucher = 'ASS';
				
				if (trunc(p_datmaxattivazione) < trunc(datAttivazioneVar)) then
					errCodeOut := 40;
					messaggioErr := 'il codice di attivazione non e'' piu'' utilizzabile, sono superati i termini per l''attivazione';
				else
					
					select count(*) into numVoucherNonAttivabiliEnte
					from or_vch_voucher
					inner join or_percorso_concordato per on (or_vch_voucher.prgpercorso = per.prgpercorso and or_vch_voucher.prgcolloquio = per.prgcolloquio)
					where or_vch_voucher.codattivazione = codiceAttivazione and or_vch_voucher.codstatovoucher = 'ASS' and not exists 
						(select 1 from vch_ente_accreditato ente where ente.prgazioni = per.prgazioni 
																 and upper(ente.strcodicefiscale) = upper(cfEnte) and upper(ente.codsede) = upper(sedeEnte));
				
					if (numVoucherNonAttivabiliEnte > 0) then
						errCodeOut := 60;
						messaggioErr := 'L''Ente non puo'' erogare tutti i servizi previsti dal codice attivazione fornito';
					else
				
						FOR voucher IN voucherAttivabili 
						LOOP
							prgVoucherKey := voucher.prgvoucher;
							p_datassegnazione := voucher.datassegnazione;
							p_numklovoucher := voucher.numklovoucher;
							
							-- qui
							p_prgpercorso  := voucher.prgpercorso;
							p_prgcolloquio  := voucher.prgcolloquio;
							
							PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherKey);
							
							update or_vch_voucher
								set CODSTATOVOUCHER = 'ATT', DATATTIVAZIONE = trunc(datAttivazioneVar), STRCFENTEACCREDITATO = upper(cfEnte), CODSEDE = upper(sedeEnte),
								CDNUTATT = cdnParUtenteVar, DTMUTATT = sysdate, 
								cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numklovoucher + 1
							where prgvoucher = prgVoucherKey;
							
							if ((trunc(datAttivazioneVar) - trunc(p_datassegnazione)) > 0) then
								risProroga := proroga(prgVoucherKey, 0, (trunc(datAttivazioneVar) - trunc(p_datassegnazione)), cdnParUtenteVar, 0);
								
								if (risProroga != 0) then
									errCodeOut := 90;
									messaggioErr := 'Errore durante la procedura di attivazione voucher durante la proroga della data massima erogazione';
									return;
								end if;
								
							end if;
							
							/* qui */
							PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnParUtenteVar, ' WHERE prgpercorso = ' || p_prgpercorso || ' AND  prgcolloquio = ' || p_prgcolloquio);
							update or_percorso_concordato 
							set codesito = 'AVV', datavvioazione = trunc(datAttivazioneVar), 
							dateffettiva = (SELECT DATMAXEROGAZIONE FROM  OR_VCH_VOUCHER vou WHERE vou.PRGVOUCHER = prgVoucherKey), 
							cdnutmod = cdnParUtenteVar, dtmmod = sysdate, codEsitoRendicont = 'P'
							where prgpercorso = p_prgpercorso and prgcolloquio = p_prgcolloquio;
						
						END LOOP;
						
						errCodeOut := 0;
						messaggioErr := 'OK';
					end if;
				end if;
			end if;
		end if;
	end if;
		
EXCEPTION
	WHEN OTHERS THEN
		errCodeOut := sqlcode;
		messaggioErr := 'Errore durante la procedura di attivazione voucher';
END;


FUNCTION aggiornaModalitaDurata (
	prgVoucherVar in or_vch_voucher.prgvoucher%type,
	prgModalitaVar in or_vch_modalita.prgmodmodalita%type,
	durataEffettivaVar in or_vch_modalita.numdurataeffettiva%type,
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE) RETURN NUMBER IS
	
	codtiposervizioVar de_azione.codtiposervizio%type;
	p_durataMin or_vch_modalita.numduratamin%type;
	p_durataMax or_vch_modalita.numduratamax%type;
	p_numkloMod or_vch_modalita.numklovchmodalita%type;
	p_percMinima or_vch_modalita.numpercparcomplet%type;
	p_durataRimborsabile or_vch_modalita.numduratamax%type;
	p_tipoRimborso or_vch_modalita.codmonotiprimborso%type;
	p_spesaEffettiva or_vch_modalita.decspesaeffettiva%type;
	p_decValTotale or_vch_modalita.decvaltotale%type;
	p_decValUnitario or_vch_modalita.decvalunitario%type;
	p_spesaTotale or_vch_modalita.decspesaeffettiva%type;
	p_numkloVoucher or_vch_voucher.numklovoucher%type;
	p_decValTotImpegnato or_vch_voucher.decvaltot%type;
	p_codstatovoucher or_vch_voucher.codstatovoucher%type;
	
BEGIN
	
	select az.codtiposervizio, vch.numklovoucher, vch.decvaltot, vch.codstatovoucher
	into codtiposervizioVar, p_numkloVoucher, p_decValTotImpegnato, p_codstatovoucher
	from or_vch_voucher vch
	inner join or_percorso_concordato perc on (vch.prgpercorso = perc.prgpercorso and vch.prgcolloquio = perc.prgcolloquio)
	inner join de_azione az on (perc.prgazioni = az.prgazioni)
	where vch.prgvoucher = prgVoucherVar;
	
	if (p_codstatovoucher <> 'ATT') then
		return 20;
	end if;
	
	select numduratamin, numduratamax, numklovchmodalita, numpercparcomplet, codmonotiprimborso, decvaltotale, decvalunitario
	into p_durataMin, p_durataMax, p_numkloMod, p_percMinima, p_tipoRimborso, p_decValTotale, p_decValUnitario
	from or_vch_modalita
	where prgmodmodalita = prgModalitaVar;
	
	if(codtiposervizioVar is null) then
		return 30;
	end if;
	
	if (codtiposervizioVar = 'SR') then
		
		PG_LOG.doLog('U', 'OR_VCH_MODALITA', cdnParUtenteVar, ' WHERE prgmodmodalita = ' || prgModalitaVar);
		
		update or_vch_modalita
			set numdurataeffettiva = durataEffettivaVar,
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovchmodalita = p_numkloMod + 1
		where prgmodmodalita = prgModalitaVar;
	
	else
		
		if (durataEffettivaVar < ((p_durataMin * p_percMinima)/100)) then
			
			PG_LOG.doLog('U', 'OR_VCH_MODALITA', cdnParUtenteVar, ' WHERE prgmodmodalita = ' || prgModalitaVar);
			
			update or_vch_modalita
				set numdurataeffettiva = durataEffettivaVar, decspesaeffettiva = 0,
				cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovchmodalita = p_numkloMod + 1
			where prgmodmodalita = prgModalitaVar;
		
		else
		
			if (durataEffettivaVar > p_durataMax) then
				p_durataRimborsabile := p_durataMax;
			else
				p_durataRimborsabile := durataEffettivaVar;
			end if;
		
			if (p_tipoRimborso = 'T') then
				p_spesaEffettiva := p_decValTotale;
			else
				p_spesaEffettiva := p_durataRimborsabile * p_decValUnitario;
			end if;
			
			PG_LOG.doLog('U', 'OR_VCH_MODALITA', cdnParUtenteVar, ' WHERE prgmodmodalita = ' || prgModalitaVar);
		
			update or_vch_modalita
				set numdurataeffettiva = durataEffettivaVar, decspesaeffettiva = p_spesaEffettiva,
				cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovchmodalita = p_numkloMod + 1
			where prgmodmodalita = prgModalitaVar;
		
		end if;
		
		select sum(nvl(decspesaeffettiva, 0))
		into p_spesaTotale
		from or_vch_modalita
		where prgmodvoucher = prgVoucherVar;
		
		if (p_spesaTotale <= p_decValTotImpegnato) then
			
			PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherVar);
		
			update or_vch_voucher
				set decspesaeffettiva = p_spesaTotale,
				cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numkloVoucher + 1
			where prgvoucher = prgVoucherVar;
		else
			return 10;
		end if;
		
	end if;

	return 0;

EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;


FUNCTION cancellaModalitaDurata (
	prgVoucherVar in or_vch_voucher.prgvoucher%type,
	prgModalitaVar in or_vch_modalita.prgmodmodalita%type,
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE) RETURN NUMBER IS
	
	codtiposervizioVar de_azione.codtiposervizio%type;
	p_numkloMod or_vch_modalita.numklovchmodalita%type;
	p_spesaTotale or_vch_modalita.decspesaeffettiva%type;
	p_numkloVoucher or_vch_voucher.numklovoucher%type;
	p_codstatovoucher or_vch_voucher.codstatovoucher%type;
	
BEGIN
	
	select az.codtiposervizio, vch.numklovoucher, vch.codstatovoucher
	into codtiposervizioVar, p_numkloVoucher, p_codstatovoucher
	from or_vch_voucher vch
	inner join or_percorso_concordato perc on (vch.prgpercorso = perc.prgpercorso and vch.prgcolloquio = perc.prgcolloquio)
	inner join de_azione az on (perc.prgazioni = az.prgazioni)
	where vch.prgvoucher = prgVoucherVar;
	
	if (p_codstatovoucher <> 'ATT') then
		return 20;
	end if;
	
	select numklovchmodalita
	into p_numkloMod
	from or_vch_modalita
	where prgmodmodalita = prgModalitaVar;
	
	if (codtiposervizioVar = 'SR') then
		
		PG_LOG.doLog('U', 'OR_VCH_MODALITA', cdnParUtenteVar, ' WHERE prgmodmodalita = ' || prgModalitaVar);
		
		update or_vch_modalita
			set numdurataeffettiva = null,
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovchmodalita = p_numkloMod + 1
		where prgmodmodalita = prgModalitaVar;
	
	else
		PG_LOG.doLog('U', 'OR_VCH_MODALITA', cdnParUtenteVar, ' WHERE prgmodmodalita = ' || prgModalitaVar);
		
		update or_vch_modalita
			set numdurataeffettiva = null, decspesaeffettiva = null,
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovchmodalita = p_numkloMod + 1
		where prgmodmodalita = prgModalitaVar;
		
		select sum(nvl(decspesaeffettiva, 0))
		into p_spesaTotale
		from or_vch_modalita
		where prgmodvoucher = prgVoucherVar;
		
		PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherVar);
		
		update or_vch_voucher
			set decspesaeffettiva = p_spesaTotale,
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numkloVoucher + 1
		where prgvoucher = prgVoucherVar;
		
	end if;

	return 0;

EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;


FUNCTION chiusuraTDA (
	prgVoucherVar in or_vch_voucher.prgvoucher%type,
	dataChiusuraVar in varchar2,
	tipoRisultatoRaggiuntoVar in varchar2,
	descRisultatoVar in varchar2,
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE) RETURN NUMBER IS
	
	num_p_spesaTotale integer := 0;
	numEventi integer := 0;
	numAttivita integer := 0;
	numModalitaInserite integer := 0;
	numModalitaPreviste integer := 0;
	p_noteObiettivi or_vch_voucher.strnoteobiettivi%type;
	p_numkloVoucher or_vch_voucher.numklovoucher%type;
	p_codSelezModalita or_vch_voucher.codselezmodalita%type;
	p_codTipoServizio de_azione.codtiposervizio%type;
	prgPercorsoVar or_percorso_concordato.prgPercorso%type;
	prgColloquioVar or_percorso_concordato.prgPercorso%type;
	p_decvaltot or_vch_voucher.decvaltot%type;
	p_numduratatotaleeff or_percorso_concordato.numygdurataeff%type;
	p_numduratatotaletipologia or_vch_modalita.numdurataeffettiva%type;
	p_numduratacurr or_vch_modalita.numdurataeffettiva%type;
	p_tipologiaduratacurr or_vch_modalita.codtipologiadurata%type;
	p_tipologiadurataprec or_vch_modalita.codtipologiadurata%type;
	p_tipologiaduratafinale or_percorso_concordato.codtipologiadurata%type;
	p_contatoretipodurata integer;
	tipologiamodalitadiverse boolean;
	p_codesito or_percorso_concordato.codEsito%type;
	p_codesitorendicont or_percorso_concordato.codEsitoRendicont%type;
	p_spesaTotale or_vch_voucher.decspesaeffettiva%type;
	p_datafineeffettiva or_percorso_concordato.datEffettiva%type;
	p_numannobudget or_vch_voucher.numannobudget%type;
	p_numannochiusura or_vch_voucher.numannobudget%type;
	prgpattolavoratoreVar am_patto_lavoratore.prgpattolavoratore%type;
	p_decDoteProcessoResidua am_patto_lavoratore.decDoteProcessoResidua%type;
	p_decDoteRisultatoResidua am_patto_lavoratore.decDoteRisultatoResidua%type;
	numklopattoVar am_patto_lavoratore.numklopattolavoratore%type;
	codCpiVar am_patto_lavoratore.codcpi%type;
	p_decTotResiduoCpi vch_budget_cpi.decTotResiduo%type;
	numklobudgetcpiVar vch_budget_cpi.numklobudget%type;
	p_numklobudgetcpiannoprec vch_budget_cpi.numklobudget%type;
	p_codvchprofiling am_patto_lavoratore.codvchprofiling%type;
	p_codstatovoucher or_vch_voucher.codstatovoucher%type;
	p_codmansione1 or_vch_voucher.codmansione1%type;
	p_codmansione2 or_vch_voucher.codmansione2%type;
	p_descAzioneTda de_azione.strdescrizione%type;
	flagCMVoucher vch_modello_voucher.flgcm%type;
	flagCMVch  vch_modello_voucher.flgcm%type;
	
	CURSOR curModalitaVoucher IS
         SELECT numdurataeffettiva, codtipologiadurata
         FROM or_vch_modalita
         WHERE prgmodvoucher = prgVoucherVar and numdurataeffettiva is not null;
	
BEGIN
	
	select vch.numklovoucher, vch.strnoteobiettivi, vch.codselezmodalita, az.codtiposervizio, vch.prgpercorso, 
		vch.prgcolloquio, nvl(vch.decspesaeffettiva,0), vch.numannobudget, vch.decvaltot, vch.codstatovoucher, 
		vch.codmansione1, vch.codmansione2, az.strdescrizione, vch.flgcm
	into p_numkloVoucher, p_noteObiettivi, p_codSelezModalita, p_codTipoServizio, prgPercorsoVar, 
		prgColloquioVar, p_spesaTotale, p_numannobudget, p_decvaltot, p_codstatovoucher, 
		p_codmansione1, p_codmansione2, p_descAzioneTda, flagCMVoucher
	from or_vch_voucher vch
	inner join or_percorso_concordato perc on (vch.prgpercorso = perc.prgpercorso and vch.prgcolloquio = perc.prgcolloquio)
	inner join de_azione az on (perc.prgazioni = az.prgazioni)
	where vch.prgvoucher = prgVoucherVar;
	
	if (p_codstatovoucher <> 'ATT') then
		return 50;
	end if;
	
	flagCMVch := nvl(flagCMVoucher, 'N');
	
	select patto_scelta.prgpattolavoratore
	into prgpattolavoratoreVar
	from am_lav_patto_scelta patto_scelta
	where to_number(patto_scelta.strchiavetabella) = prgPercorsoVar and patto_scelta.codlsttab = 'OR_PER';
	
	select pt.decDoteProcessoResidua, pt.decDoteRisultatoResidua, pt.numklopattolavoratore, pt.codcpi, budget.numklobudget, pt.codvchprofiling
	into p_decDoteProcessoResidua, p_decDoteRisultatoResidua, numklopattoVar, codCpiVar, numklobudgetcpiVar, p_codvchprofiling
	from am_patto_lavoratore pt
	inner join vch_budget_cpi budget on (pt.codcpi = budget.codcpi)
	where pt.prgpattolavoratore = prgpattolavoratoreVar and budget.numannobudget = p_numannobudget;
	
	if (p_noteObiettivi is null or p_noteObiettivi = '''') then
		return 10;
	end if;

	select count(*) into numEventi
    from or_vch_evento
    where prgvoucher = prgVoucherVar;
	
	if (numEventi = 0) then
		return 10;
	end if;
	
	select count(*) into numAttivita
    from or_vch_attivita
    where prgvoucher = prgVoucherVar;
	
	if (numAttivita = 0) then
		return 10;
	end if;
	
	select count(*) into numModalitaInserite
	from or_vch_modalita
	where prgmodvoucher = prgVoucherVar and numdurataeffettiva is not null;
	
	if (numModalitaInserite = 0) then
		return 20;
	end if;
	
	if (p_codSelezModalita = 'S' and numModalitaInserite > 1) then
		return 30;
	end if;
	
	if (p_codSelezModalita = 'T') then
		select count(*) into numModalitaPreviste
		from or_vch_modalita
		where prgmodvoucher = prgVoucherVar;
		
		if (numModalitaInserite < numModalitaPreviste) then
			return 40;
		end if;
	end if;
	
	if ( (upper(p_descAzioneTda) like '2CE%') and (p_codmansione1 is null or p_codmansione1 = '''') and (p_codmansione2 is null or p_codmansione2 = '''') ) then
		return 60;
	end if;
	
	p_numkloVoucher := p_numkloVoucher + 1;
	
	if (p_codTipoServizio = 'SP') then
		PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherVar);
		
		update or_vch_voucher
		set codstatovoucher = 'CHI', cdnutconc = cdnParUtenteVar, dtmutconc = sysdate,
		datfineerogazione = to_date(dataChiusuraVar, 'dd/mm/yyyy'), CODVCHSTATOPAGAMENTO = 'INA',
		cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numkloVoucher
		where prgvoucher = prgVoucherVar;
	else
		-- in base al profiling e al tipoRisultatoRaggiuntoVar calcolo la decspesaeffettiva
		if (tipoRisultatoRaggiuntoVar is null or tipoRisultatoRaggiuntoVar = '''' or tipoRisultatoRaggiuntoVar = 'ZRNC') then
			p_spesaTotale := 0;
			
			PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherVar);
			
			update or_vch_voucher
			set codstatovoucher = 'CHI', cdnutconc = cdnParUtenteVar, dtmutconc = sysdate, CODVCHSTATOPAGAMENTO = 'INA',
			decspesaeffettiva = p_spesaTotale, datfineerogazione = to_date(dataChiusuraVar, 'dd/mm/yyyy'),
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numkloVoucher, strdesrisultato = descRisultatoVar
			where prgvoucher = prgVoucherVar;
			
		else
		--	select deccosto
		--	into p_spesaTotale
		--	from vch_costi_risultato
		--	where codvchrisultato = tipoRisultatoRaggiuntoVar and codvchprofiling = p_codvchprofiling;
			
			
			--select ris.strdescrizione as difficolta, p.codvchprofiling, p.strdescrizione as profiling, 
			--cr.deccosto, cr.datinizioval, cr.datfineval 
			
			--BORRIELLO: MODIFICA CALCOLO COSTO TDA SR - MARZO 2019
			select count(cr.deccosto)
			into num_p_spesaTotale
			from vch_costi_risultato cr
			inner join de_vch_risultato ris on (cr.codvchrisultato=ris.codvchtiporisultato) 
			inner join de_vch_profiling p on (cr.codvchprofiling=p.codvchprofiling) 
			where  to_date(dataChiusuraVar, 'dd/mm/yyyy') BETWEEN trunc(cr.datinizioval) and trunc(cr.datfineval )
			and cr.codvchrisultato = tipoRisultatoRaggiuntoVar and cr.codvchprofiling = p_codvchprofiling;
			
			if (num_p_spesaTotale = 0) then
				return 80;
			end if;
			
			select cr.deccosto
			into p_spesaTotale
			from vch_costi_risultato cr
			inner join de_vch_risultato ris on (cr.codvchrisultato=ris.codvchtiporisultato) 
			inner join de_vch_profiling p on (cr.codvchprofiling=p.codvchprofiling) 
			where  to_date(dataChiusuraVar, 'dd/mm/yyyy') BETWEEN trunc(cr.datinizioval) and trunc(cr.datfineval )
			and cr.codvchrisultato = tipoRisultatoRaggiuntoVar and cr.codvchprofiling = p_codvchprofiling;
			
			PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherVar);
			
			update or_vch_voucher
			set codstatovoucher = 'CHI', cdnutconc = cdnParUtenteVar, dtmutconc = sysdate, CODVCHSTATOPAGAMENTO = 'INA',
			decspesaeffettiva = p_spesaTotale, datfineerogazione = to_date(dataChiusuraVar, 'dd/mm/yyyy'),
			cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numkloVoucher, 
			codvchtiporisultato = tipoRisultatoRaggiuntoVar, strdesrisultato = descRisultatoVar
			where prgvoucher = prgVoucherVar;
			
		end if;
		
	end if;
	
	p_numduratatotaleeff := 0;
	p_numduratatotaletipologia := 0;
	p_contatoretipodurata := 0;
	tipologiamodalitadiverse := false;
	
	FOR voucher IN curModalitaVoucher 
	LOOP
		p_numduratacurr := voucher.numdurataeffettiva;
		p_tipologiaduratacurr := voucher.codtipologiadurata;
		p_contatoretipodurata := p_contatoretipodurata + 1;
		
		if (p_contatoretipodurata = 1) then
			p_tipologiaduratafinale := p_tipologiaduratacurr;
			p_tipologiadurataprec := p_tipologiaduratacurr;
			p_numduratatotaletipologia := p_numduratatotaletipologia + p_numduratacurr;
		else
			if (p_tipologiadurataprec = p_tipologiaduratacurr) then
				p_numduratatotaletipologia := p_numduratatotaletipologia + p_numduratacurr;
			else
				tipologiamodalitadiverse := true;
			end if;
			p_tipologiadurataprec := p_tipologiaduratacurr;
		end if;
		
		if (p_tipologiaduratacurr = 'G') then
			p_numduratatotaleeff := p_numduratatotaleeff + p_numduratacurr;
		else
			if (p_tipologiaduratacurr = 'M') then
				p_numduratatotaleeff := p_numduratatotaleeff + (p_numduratacurr * 30);
			else
				p_numduratatotaleeff := p_numduratatotaleeff + (p_numduratacurr / 8);
			end if;
		end if;
	END LOOP;
	
	if (not tipologiamodalitadiverse) then
		p_numduratatotaleeff := p_numduratatotaletipologia;
	else
		p_tipologiaduratafinale := 'G';
	end if;
	
	p_numduratatotaleeff := round(p_numduratatotaleeff);
	p_datafineeffettiva := to_date(dataChiusuraVar, 'dd/mm/yyyy');
	
	if (p_codTipoServizio = 'SR') then
		p_codesito := 'FC';
		p_codesitorendicont := 'E';
	else
		if (p_spesaTotale > 0) then
			p_codesito := 'FC';
			p_codesitorendicont := 'E';
		else
			if (p_numduratatotaleeff > 0 and p_spesaTotale = 0) then
				p_codesito := 'INT';
				p_codesitorendicont := 'ENR';
			else
				if (p_numduratatotaleeff = 0) then
					p_codesito := 'RIF';
					p_codesitorendicont := 'A';
					p_datafineeffettiva := null;
				end if;
			end if;
		end if;
	end if;
	
	PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnParUtenteVar, ' WHERE prgpercorso = ' || prgPercorsoVar || ' AND  prgcolloquio = ' || prgColloquioVar);
	
	update or_percorso_concordato 
	set codEsito = p_codesito, codEsitoRendicont = p_codesitorendicont, 
	datEffettiva = p_datafineeffettiva, 
	numygdurataeff = p_numduratatotaleeff, codtipologiadurata = p_tipologiaduratafinale,
	cdnutmod = cdnParUtenteVar, dtmmod = sysdate
	where prgpercorso = prgPercorsoVar and prgcolloquio = prgColloquioVar;
	
	if (p_codTipoServizio = 'SP') then
		p_decDoteProcessoResidua := p_decDoteProcessoResidua + p_decvaltot - p_spesaTotale;
	else
		p_decDoteRisultatoResidua := p_decDoteRisultatoResidua + p_decvaltot - p_spesaTotale;
	end if;
	
	if(flagCMVch = 'N') then
		PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnParUtenteVar, ' WHERE PRGPATTOLAVORATORE = ' || prgpattolavoratoreVar);

		update am_patto_lavoratore
			set decDoteProcessoResidua = p_decDoteProcessoResidua, decDoteRisultatoResidua = p_decDoteRisultatoResidua,
			numklopattolavoratore = numklopattoVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where prgpattolavoratore = prgpattolavoratoreVar;
	end if;
	
	p_numannochiusura := to_number(to_char(to_date(dataChiusuraVar, 'dd/mm/yyyy'), 'yyyy'));
	
	if (p_numannochiusura = p_numannobudget) then
		PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || p_numannobudget);
	
		update vch_budget_cpi
			set decTotImpegnato = decTotImpegnato - p_decvaltot, decTotSpeso = decTotSpeso + p_spesaTotale,
			decTotResiduo = decTotResiduo + p_decvaltot - p_spesaTotale, 
			numklobudget = numklobudgetcpiVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where codcpi = codCpiVar and numannobudget = p_numannobudget;
	else
		select budget.decTotResiduo, budget.numklobudget
		into p_decTotResiduoCpi, p_numklobudgetcpiannoprec
		from vch_budget_cpi budget
		where budget.codcpi = codCpiVar and budget.numannobudget = p_numannochiusura;
		
		if ((p_decTotResiduoCpi - p_spesaTotale >= 0)) then
			PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || p_numannobudget);
		
			update vch_budget_cpi
				set decTotImpegnato = decTotImpegnato - p_decvaltot,
				decTotResiduo = decTotResiduo + p_decvaltot, 
				numklobudget = numklobudgetcpiVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
			where codcpi = codCpiVar and numannobudget = p_numannobudget;
			
			PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || p_numannochiusura);
			
			update vch_budget_cpi
				set decTotSpeso = decTotSpeso + p_spesaTotale,
				decTotResiduo = decTotResiduo - p_spesaTotale, 
				numklobudget = p_numklobudgetcpiannoprec + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
			where codcpi = codCpiVar and numannobudget = p_numannochiusura;
			
			p_numkloVoucher := p_numkloVoucher + 1;
			
			PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherVar);
			
			update or_vch_voucher
			set numannobudget = p_numannochiusura, numklovoucher = p_numkloVoucher
			where prgvoucher = prgVoucherVar;
		else
			PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || p_numannobudget);
		
			update vch_budget_cpi
				set decTotImpegnato = decTotImpegnato - p_decvaltot, decTotSpeso = decTotSpeso + p_spesaTotale,
				decTotResiduo = decTotResiduo + p_decvaltot - p_spesaTotale, 
				numklobudget = numklobudgetcpiVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
			where codcpi = codCpiVar and numannobudget = p_numannobudget;
		end if;
	end if;
	
	return 0;
	
EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;


FUNCTION aggiornaPagamentoTDA (
	prgVoucherVar in or_vch_voucher.prgvoucher%type,
	codVchStatoPagamentoVar in varchar2,
	decPagatoVar in or_vch_voucher.decpagato%type, 
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE) RETURN NUMBER IS
	
	p_numkloVoucher or_vch_voucher.numklovoucher%type;
	prgPercorsoVar or_percorso_concordato.prgPercorso%type;
	prgColloquioVar or_percorso_concordato.prgPercorso%type;
	p_codstatovoucher or_vch_voucher.codstatovoucher%type;
	p_codTipoServizio de_azione.codtiposervizio%type;
	p_decSpeso or_vch_voucher.decspesaeffettiva%type;
	p_decPagatoOld or_vch_voucher.decpagato%type;
	p_numannobudget or_vch_voucher.numannobudget%type;
	prgpattolavoratoreVar am_patto_lavoratore.prgpattolavoratore%type;
	p_decDoteProcessoResidua am_patto_lavoratore.decDoteProcessoResidua%type;
	p_decDoteRisultatoResidua am_patto_lavoratore.decDoteRisultatoResidua%type;
	numklopattoVar am_patto_lavoratore.numklopattolavoratore%type;
	codCpiVar am_patto_lavoratore.codcpi%type;
	numklobudgetcpiVar vch_budget_cpi.numklobudget%type;
	p_decTotResiduo vch_budget_cpi.decTotResiduo%type;
	p_decTotSpeso vch_budget_cpi.decTotSpeso%type;
	p_codVchStatoPagamentoPrec or_vch_voucher.codvchstatopagamento%type;
	
BEGIN

	select vch.numklovoucher, vch.prgpercorso, vch.prgcolloquio, vch.codstatovoucher, vch.decspesaeffettiva, vch.numannobudget, vch.codvchstatopagamento,
		az.codtiposervizio, nvl(vch.decpagato, 0)
	into p_numkloVoucher, prgPercorsoVar, prgColloquioVar, p_codstatovoucher, p_decSpeso, p_numannobudget, p_codVchStatoPagamentoPrec,
		p_codTipoServizio, p_decPagatoOld
	from or_vch_voucher vch
	inner join or_percorso_concordato perc on (vch.prgpercorso = perc.prgpercorso and vch.prgcolloquio = perc.prgcolloquio)
	inner join de_azione az on (perc.prgazioni = az.prgazioni)
	where vch.prgvoucher = prgVoucherVar;
	
	if (p_codstatovoucher <> 'CHI') then
		return 10;
	end if;
	
	if (codVchStatoPagamentoVar is null or codVchStatoPagamentoVar = '''') then
		return 20;
	end if;
	
	if (codVchStatoPagamentoVar = 'PAG' and decPagatoVar is null) then
		return 30;
	end if;
	
	if ( (p_codVchStatoPagamentoPrec = 'PAG' or p_codVchStatoPagamentoPrec = 'NPAG') and (codVchStatoPagamentoVar = 'INA') ) then
		return 70;
	end if;
	
	if ( (codVchStatoPagamentoVar = 'NPAG' or codVchStatoPagamentoVar = 'INA') and (decPagatoVar is not null) ) then
		return 40;
	end if;
	
	if (codVchStatoPagamentoVar = 'PAG' and decPagatoVar > p_decSpeso) then
		return 50;
	end if;
	
	p_numkloVoucher := p_numkloVoucher + 1;
	
	PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherVar);
	
	update or_vch_voucher
	set CODVCHSTATOPAGAMENTO = codVchStatoPagamentoVar, DECPAGATO = decPagatoVar,
	cdnutmod = cdnParUtenteVar, dtmmod = sysdate, numklovoucher = p_numkloVoucher
	where prgvoucher = prgVoucherVar;
	
	select patto_scelta.prgpattolavoratore
	into prgpattolavoratoreVar
	from am_lav_patto_scelta patto_scelta
	where to_number(patto_scelta.strchiavetabella) = prgPercorsoVar and patto_scelta.codlsttab = 'OR_PER';
	
	select pt.decDoteProcessoResidua, pt.decDoteRisultatoResidua, pt.numklopattolavoratore, pt.codcpi, budget.numklobudget, budget.decTotSpeso, budget.decTotResiduo
	into p_decDoteProcessoResidua, p_decDoteRisultatoResidua, numklopattoVar, codCpiVar, numklobudgetcpiVar, p_decTotSpeso, p_decTotResiduo
	from am_patto_lavoratore pt
	inner join vch_budget_cpi budget on (pt.codcpi = budget.codcpi)
	where pt.prgpattolavoratore = prgpattolavoratoreVar and budget.numannobudget = p_numannobudget;
	
	if ( (p_codVchStatoPagamentoPrec = 'INA') and (codVchStatoPagamentoVar = 'PAG' or codVchStatoPagamentoVar = 'NPAG') ) then
		p_decTotSpeso := p_decTotSpeso - p_decSpeso - p_decPagatoOld + nvl(decPagatoVar, 0);
		p_decTotResiduo := p_decTotResiduo + p_decSpeso + p_decPagatoOld - nvl(decPagatoVar, 0);
	else
		p_decTotSpeso := p_decTotSpeso - p_decPagatoOld + nvl(decPagatoVar, 0);
		p_decTotResiduo := p_decTotResiduo + p_decPagatoOld - nvl(decPagatoVar, 0);
	end if;
	
	if (p_codTipoServizio = 'SP') then
		if ( (p_codVchStatoPagamentoPrec = 'INA') and (codVchStatoPagamentoVar = 'PAG' or codVchStatoPagamentoVar = 'NPAG') ) then
			p_decDoteProcessoResidua := p_decDoteProcessoResidua + p_decSpeso + p_decPagatoOld - nvl(decPagatoVar, 0);
		else
			p_decDoteProcessoResidua := p_decDoteProcessoResidua + p_decPagatoOld - nvl(decPagatoVar, 0);
		end if;
		
		if (p_decDoteProcessoResidua < 0 or p_decTotResiduo < 0) then
			return 60;
		end if;
		
		PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnParUtenteVar, ' WHERE PRGPATTOLAVORATORE = ' || prgpattolavoratoreVar);
		
		update am_patto_lavoratore
			set decDoteProcessoResidua = p_decDoteProcessoResidua,
			numklopattolavoratore = numklopattoVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where prgpattolavoratore = prgpattolavoratoreVar;
		
	else
		if ( (p_codVchStatoPagamentoPrec = 'INA') and (codVchStatoPagamentoVar = 'PAG' or codVchStatoPagamentoVar = 'NPAG') ) then
			p_decDoteRisultatoResidua := p_decDoteRisultatoResidua + p_decSpeso + p_decPagatoOld - nvl(decPagatoVar, 0);
		else
			p_decDoteRisultatoResidua := p_decDoteRisultatoResidua + p_decPagatoOld - nvl(decPagatoVar, 0);
		end if;
		
		if (p_decDoteRisultatoResidua < 0 or p_decTotResiduo < 0) then
			return 60;
		end if;
		
		PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnParUtenteVar, ' WHERE PRGPATTOLAVORATORE = ' || prgpattolavoratoreVar);
		
		update am_patto_lavoratore
			set decDoteRisultatoResidua = p_decDoteRisultatoResidua,
			numklopattolavoratore = numklopattoVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where prgpattolavoratore = prgpattolavoratoreVar;
		
	end if;
	
	PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || p_numannobudget);
	
	update vch_budget_cpi
		set decTotSpeso = p_decTotSpeso,
		decTotResiduo = p_decTotResiduo, 
		numklobudget = numklobudgetcpiVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
	where codcpi = codCpiVar and numannobudget = p_numannobudget;
	
	return 0;

EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;


FUNCTION riapriTDA (
	prgVoucherVar in or_vch_voucher.prgvoucher%type,
	cdnParUtenteVar in or_vch_voucher.cdnutins%TYPE) RETURN NUMBER IS
	
	p_numkloVoucher or_vch_voucher.numklovoucher%type;
	prgPercorsoVar or_percorso_concordato.prgPercorso%type;
	prgColloquioVar or_percorso_concordato.prgPercorso%type;
	p_codstatovoucher or_vch_voucher.codstatovoucher%type;
	p_codTipoServizio de_azione.codtiposervizio%type;
	p_decSpeso or_vch_voucher.decspesaeffettiva%type;
	p_numannobudget or_vch_voucher.numannobudget%type;
	p_numannobudgetSucc or_vch_voucher.numannobudget%type;
	prgpattolavoratoreVar am_patto_lavoratore.prgpattolavoratore%type;
	p_decDoteProcessoResidua am_patto_lavoratore.decDoteProcessoResidua%type;
	p_decDoteRisultatoResidua am_patto_lavoratore.decDoteRisultatoResidua%type;
	numklopattoVar am_patto_lavoratore.numklopattolavoratore%type;
	codCpiVar am_patto_lavoratore.codcpi%type;
	numklobudgetcpiVar vch_budget_cpi.numklobudget%type;
	p_decTotResiduo vch_budget_cpi.decTotResiduo%type;
	p_decTotSpeso vch_budget_cpi.decTotSpeso%type;
	p_decTotResiduoSucc vch_budget_cpi.decTotResiduo%type;
	p_decTotImpegnatoSucc vch_budget_cpi.decTotImpegnato%type;
	numklobudgetcpiSuccVar vch_budget_cpi.numklobudget%type;
	codVchStatoPagamentoVar or_vch_voucher.codVchStatoPagamento%type;
	p_decvaltot or_vch_voucher.decvaltot%type;
	p_decTotImpegnato vch_budget_cpi.decTotImpegnato%type;
	p_datmaxerogazione  or_vch_voucher.datmaxerogazione%type;
	annoMaxErogazione number;
	
BEGIN
	
	select vch.numklovoucher, vch.prgpercorso, vch.prgcolloquio, vch.codstatovoucher, nvl(vch.decspesaeffettiva, 0), vch.numannobudget, az.codtiposervizio, 
		vch.codVchStatoPagamento, nvl(vch.decvaltot, 0), vch.datmaxerogazione
	into p_numkloVoucher, prgPercorsoVar, prgColloquioVar, p_codstatovoucher, p_decSpeso, p_numannobudget, p_codTipoServizio, 
		codVchStatoPagamentoVar, p_decvaltot, p_datmaxerogazione
	from or_vch_voucher vch
	inner join or_percorso_concordato perc on (vch.prgpercorso = perc.prgpercorso and vch.prgcolloquio = perc.prgcolloquio)
	inner join de_azione az on (perc.prgazioni = az.prgazioni)
	where vch.prgvoucher = prgVoucherVar;
	
	if (p_codstatovoucher <> 'CHI') then
		return 10;
	end if;
	
	if (codVchStatoPagamentoVar is null or codVchStatoPagamentoVar <> 'INA') then
		return 10;
	end if;
	
	p_numkloVoucher := p_numkloVoucher + 1;
	
	PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherVar);
	
	update or_vch_voucher
	set CODVCHSTATOPAGAMENTO = null, datfineerogazione = null, codstatovoucher = 'ATT',
	codvchtiporisultato = null, strdesrisultato = null,
	decspesaeffettiva = (case
							when p_codTipoServizio = 'SR' then null
							else decspesaeffettiva
						 end),
	cdnutmod = cdnParUtenteVar, dtmmod = sysdate, cdnutconc = null, dtmutconc = null,
	numklovoucher = p_numkloVoucher
	where prgvoucher = prgVoucherVar;
	
	PG_LOG.doLog('U', 'OR_PERCORSO_CONCORDATO', cdnParUtenteVar, ' WHERE prgpercorso = ' || prgPercorsoVar || ' AND  prgcolloquio = ' || prgColloquioVar);
	
	/*
	update or_percorso_concordato 
	set codEsito = 'PRO', codEsitoRendicont = 'P', datEffettiva = null, 
	numygdurataeff = null, codtipologiadurata = null,
	cdnutmod = cdnParUtenteVar, dtmmod = sysdate
	where prgpercorso = prgPercorsoVar and prgcolloquio = prgColloquioVar;
	*/
	
	update or_percorso_concordato 
	set codEsito = 'AVV', codEsitoRendicont = 'P', datavvioazione = (SELECT DATATTIVAZIONE FROM OR_VCH_VOUCHER vou WHERE vou.PRGVOUCHER = prgVoucherVar), 
	datEffettiva = (SELECT DATMAXEROGAZIONE FROM OR_VCH_VOUCHER vou WHERE vou.PRGVOUCHER = prgVoucherVar), 
	numygdurataeff = null, codtipologiadurata = null,
	cdnutmod = cdnParUtenteVar, dtmmod = sysdate
	where prgpercorso = prgPercorsoVar and prgcolloquio = prgColloquioVar;
	
	select patto_scelta.prgpattolavoratore
	into prgpattolavoratoreVar
	from am_lav_patto_scelta patto_scelta
	where to_number(patto_scelta.strchiavetabella) = prgPercorsoVar and patto_scelta.codlsttab = 'OR_PER';
	
	select pt.decDoteProcessoResidua, pt.decDoteRisultatoResidua, pt.numklopattolavoratore, pt.codcpi 
	into p_decDoteProcessoResidua, p_decDoteRisultatoResidua, numklopattoVar, codCpiVar
	from am_patto_lavoratore pt
	where pt.prgpattolavoratore = prgpattolavoratoreVar;
	
	if (p_codTipoServizio = 'SP') then
		p_decDoteProcessoResidua := p_decDoteProcessoResidua - p_decvaltot + p_decSpeso;
		
		if (p_decDoteProcessoResidua < 0) then
			return 20;
		end if;
		
		PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnParUtenteVar, ' WHERE PRGPATTOLAVORATORE = ' || prgpattolavoratoreVar);
		
		update am_patto_lavoratore
			set decDoteProcessoResidua = p_decDoteProcessoResidua,
			numklopattolavoratore = numklopattoVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where prgpattolavoratore = prgpattolavoratoreVar;
		
	else
		p_decDoteRisultatoResidua := p_decDoteRisultatoResidua - p_decvaltot + p_decSpeso;
		
		if (p_decDoteRisultatoResidua < 0) then
			return 20;
		end if;
		
		PG_LOG.doLog('U', 'AM_PATTO_LAVORATORE', cdnParUtenteVar, ' WHERE PRGPATTOLAVORATORE = ' || prgpattolavoratoreVar);
		
		update am_patto_lavoratore
			set decDoteRisultatoResidua = p_decDoteRisultatoResidua,
			numklopattolavoratore = numklopattoVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where prgpattolavoratore = prgpattolavoratoreVar;
		
	end if;
	
	annoMaxErogazione := to_number(to_char(p_datmaxerogazione, 'yyyy'));
	
	select budget.numklobudget, budget.decTotSpeso, budget.decTotResiduo, budget.decTotImpegnato
	into numklobudgetcpiVar, p_decTotSpeso, p_decTotResiduo, p_decTotImpegnato
	from vch_budget_cpi budget
	where budget.codcpi =  codCpiVar and budget.numannobudget = p_numannobudget;
	
	if (p_numannobudget = annoMaxErogazione) then
		
		p_decTotImpegnato := p_decTotImpegnato + p_decvaltot;
		p_decTotSpeso := p_decTotSpeso - p_decSpeso;
		p_decTotResiduo := p_decTotResiduo - p_decvaltot + p_decSpeso;
		
		if (p_decTotResiduo < 0) then
			return 20;
		end if;
		
		PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || p_numannobudget);
		
		update vch_budget_cpi
			set decTotSpeso = p_decTotSpeso,
			decTotResiduo = p_decTotResiduo, 
			decTotImpegnato = p_decTotImpegnato,
			numklobudget = numklobudgetcpiVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where codcpi = codCpiVar and numannobudget = p_numannobudget;
		
	else
		-- Libero lo speso in p_numannobudget (anno budget nel voucher)
		p_decTotSpeso := p_decTotSpeso - p_decSpeso;
		p_decTotResiduo := p_decTotResiduo + p_decSpeso;
		
		PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || p_numannobudget);
		
		update vch_budget_cpi
			set decTotSpeso = p_decTotSpeso,
			decTotResiduo = p_decTotResiduo,
			numklobudget = numklobudgetcpiVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where codcpi = codCpiVar and numannobudget = p_numannobudget;
		
		-- Carico la spesa impegnata nel budget relativo anno data max erogazione
		
		p_numannobudgetSucc := annoMaxErogazione;
		
		select budget.numklobudget, budget.decTotResiduo, budget.decTotImpegnato
		into numklobudgetcpiSuccVar, p_decTotResiduoSucc, p_decTotImpegnatoSucc
		from vch_budget_cpi budget
		where budget.codcpi =  codCpiVar and budget.numannobudget = p_numannobudgetSucc;
		
		p_decTotImpegnatoSucc := p_decTotImpegnatoSucc + p_decvaltot;
		p_decTotResiduoSucc := p_decTotResiduoSucc - p_decvaltot;
		
		if (p_decTotResiduoSucc < 0) then
			return 20;
		end if;
		
		PG_LOG.doLog('U', 'VCH_BUDGET_CPI', cdnParUtenteVar, ' WHERE codcpi = ' || codCpiVar || ' AND  numannobudget = ' || p_numannobudgetSucc);
		
		update vch_budget_cpi
			set decTotResiduo = p_decTotResiduoSucc, decTotImpegnato = p_decTotImpegnatoSucc,
			numklobudget = numklobudgetcpiSuccVar + 1, cdnutmod = cdnParUtenteVar, dtmmod = sysdate
		where codcpi = codCpiVar and numannobudget = p_numannobudgetSucc;
		
		-- aggiorno anno budget
		p_numkloVoucher := p_numkloVoucher + 1;
		
		PG_LOG.doLog('U', 'OR_VCH_VOUCHER', cdnParUtenteVar, ' WHERE prgvoucher = ' || prgVoucherVar);
		
		update or_vch_voucher
		set numannobudget = p_numannobudgetSucc, numklovoucher = p_numkloVoucher
		where prgvoucher = prgVoucherVar;
		
	end if;
	
	return 0;

EXCEPTION
	WHEN OTHERS THEN
		return sqlcode;

END;

		
END PG_VOUCHER;
/

