/* Generated by Together */

package com.engiweb.framework.dbaccess.sql;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

import com.engiweb.framework.dbaccess.sql.result.DataResult;
import com.engiweb.framework.error.EMFErrorSeverity;
import com.engiweb.framework.error.EMFInternalError;

/**
 * Questa Classe Rappresenta un generico comando SQL nello standard SQL92
 * 
 * @author Andrea Zoppello - andrea.zoppello@engiweb.com
 * @version 1.0
 */
public abstract class SQLCommand {

	static org.apache.log4j.Logger _logger = org.apache.log4j.Logger.getLogger(SQLCommand.class.getName());
	protected DataConnection _dataConnection = null;
	protected Statement _stmt = null;
	protected String _commandString = null;
	protected List _inputParameter;

	protected boolean _closed = false;

	/**
	 * Costruttore
	 * 
	 * @param <B>DataConnection
	 *            </B> dataConnection - la connessione al db
	 * @param <B>String
	 *            </B> commandString - La stringa contenente il comando sql
	 */
	public SQLCommand(DataConnection dataConnection, String commandString) {
		_dataConnection = dataConnection;
		_commandString = commandString;
	} // public SQLCommand(DataConnection dataConnection, String
		// commandString)

	public DataConnection getDataConnection() {
		return _dataConnection;
	} // public DataConnection getDataConnection()

	/**
	 * Questo metodo server per eseguire il comnado senza parametri
	 * 
	 * @return un oggetto di tipo <B>DataResult</B> contente il risultato dell'esecuzione del comando
	 * @throws <B>EMFInternalError
	 *             </B> - Se si verifica qualche problema durante l'esecuzione del comando
	 */
	public abstract DataResult execute() throws EMFInternalError;

	/**
	 * Questo metodo serve per eseguire il comando con dei parametri di input
	 * 
	 * @param <B>List
	 *            </B> inputParameters - una lista di <B>DataField</B> object
	 * @return un oggetto di tipo <B>DataResult</B> contente il risultato dell'esecuzione del comando
	 * @throws <B>EMFInternalError
	 *             </B> - Se si verifica qualche problema durante l'esecuzione del comando
	 */
	public abstract DataResult execute(List inputParameters) throws EMFInternalError;

	/**
	 * Questo metodo permette di chiudere l'oggetto SQLCommand
	 * 
	 * @throws <B>EMFInternalError
	 *             </B> - Se qualche errore si verifica
	 */
	public void close() throws EMFInternalError {
		closeInternal();
	} // public void close() throws EMFInternalError

	protected void closeInternal() throws EMFInternalError {
		try {
			if ((_stmt != null) && (!_closed)) {
				_stmt.close();
				_closed = true;
			}
			return;
		} // try
		catch (SQLException sqle) {
			it.eng.sil.util.TraceWrapper.fatal(_logger, "SQLCommand::closeInternal:", sqle);

			throw new EMFInternalError(EMFErrorSeverity.ERROR, "SQLCommand :: close() :: " + sqle.getMessage());
		} // catch (SQLException sqle)
	} // protected void closeInternal() throws EMFInternalError

	protected Connection getInternalConnection() {
		return _dataConnection.getInternalConnection();
	} // protected Connection getInternalConnection()

	/**
	 * Questo metodo verifica che il lo stato dell'oggetto comando.
	 * 
	 * @throws <B>EMFInternalError
	 *             </B> - Se l'istanza comando risulta chiusa.
	 */
	public void validate() throws EMFInternalError {
		if (_closed)
			throw new EMFInternalError(EMFErrorSeverity.ERROR,
					"SQLCommand :: validate() :: Cannot Use SQL Command The Command is already closed");
		return;
	} // public void validate() throws EMFInternalError

	/*
	 * protected void finalize() { try { // // Close Connection Object // close(); // // Metti a NULL Tutti Gli Oggetti
	 * // _dataConnection = null; _stmt = null; _commandString = null; _inputParameter = null; _tracer = null; return; }
	 * catch (Exception e) { _logger.info( " Exception in finalize : " + e.getMessage()); } } //protected void
	 * finalize()
	 */
} // end Class SQLCommand
