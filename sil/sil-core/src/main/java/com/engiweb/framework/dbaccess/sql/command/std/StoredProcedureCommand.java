/* Generated by Together */

package com.engiweb.framework.dbaccess.sql.command.std;

import java.sql.CallableStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import com.engiweb.framework.dbaccess.Utils;
import com.engiweb.framework.dbaccess.sql.DataConnection;
import com.engiweb.framework.dbaccess.sql.DataField;
import com.engiweb.framework.dbaccess.sql.SQLCommand;
import com.engiweb.framework.dbaccess.sql.result.DataResult;
import com.engiweb.framework.dbaccess.sql.result.DataResultFactory;
import com.engiweb.framework.dbaccess.sql.result.DataResultInterface;
import com.engiweb.framework.dbaccess.sql.result.DefaultDataResultFactory;
import com.engiweb.framework.dbaccess.sql.result.InformationDataResult;
import com.engiweb.framework.dbaccess.sql.result.std.CompositeDataResult;
import com.engiweb.framework.error.EMFInternalError;
import com.jamonapi.Monitor;
import com.jamonapi.MonitorFactory;

/**
 * Questa Classe rappresenta un comando SQL di CALL
 * 
 * @author Andrea Zoppello - andrea.zoppello@engiweb.com
 * @version 1.0
 */
public class StoredProcedureCommand extends SQLCommand {

	static org.apache.log4j.Logger _logger = org.apache.log4j.Logger.getLogger(StoredProcedureCommand.class.getName());
	protected List outputParametersPositions = null;
	protected List inputParametersPositions = null;

	/**
	 * Costruttore
	 * 
	 * @param <B>DataConnection
	 *            </B> dataConnection - l'oggetto dataConnection legato al comando
	 * @param <B>String
	 *            </B> commandString - La Stringa rappresentante il comando
	 */
	public StoredProcedureCommand(DataConnection dataConnection, String commandString) {
		super(dataConnection, commandString);
	} // public StoredProcedureCommand(DataConnection dataConnection, String
		// commandString)

	/**
	 * Questo metodo server per eseguire il comnado senza parametri
	 * 
	 * @return un oggetto di tipo <B>DataResult</B> contente il risultato dell'esecuzione del comando
	 * @throws <B>EMFInternalError
	 *             </B> - Se si verifica qualche problema durante l'esecuzione del comando
	 */
	public DataResult execute() throws EMFInternalError {
		return execute(true);
	} // public DataResult execute() throws EMFInternalError

	public DataResult execute(boolean scroll) throws EMFInternalError {
		Monitor monitor = MonitorFactory.start("model.data-access.stored-procedure." + _commandString.toLowerCase());
		try {
			//
			// Stored Procedure Senza Parametri di input e di output
			//
			this.closeInternal();
			if (scroll)
				_stmt = getInternalConnection().prepareCall(_commandString, ResultSet.TYPE_SCROLL_INSENSITIVE,
						ResultSet.CONCUR_READ_ONLY);
			else
				_stmt = getInternalConnection().prepareCall(_commandString, ResultSet.TYPE_FORWARD_ONLY,
						ResultSet.CONCUR_READ_ONLY);
			((CallableStatement) _stmt).executeUpdate();
			DataResultFactory dataResultFactory = new DefaultDataResultFactory();
			DataResultInterface internalDataResult = dataResultFactory.createInformationDataResult(this, null,
					InformationDataResult.CORRECT_EXECUTION, -1,
					" CORRECT EXECUTION : STORED PROCEDURE COMMAND " + _commandString + "EXECUTE CORRECTLY");
			return new DataResult(internalDataResult, DataResultInterface.INFORMATION_DATA_RESULT);
		} // try
		catch (SQLException sqle) {
			it.eng.sil.util.TraceWrapper.fatal(_logger, "StoredProcedureCommand::execute:", sqle);

			String method = "StoredProcedureCommand :: execute() :: ";
			throw Utils.generateInternalError(sqle, method);
		} // catch (SQLException sqle) try
		finally {
			monitor.stop();
		} // finally
	} // public DataResult execute(boolean scroll) throws EMFInternalError

	/**
	 * Questo metodo serve per eseguire il comando con dei parametri di input
	 * 
	 * @param <B>List
	 *            </B> inputParameters - una lista di <B>DataField</B> object
	 * @return un oggetto di tipo <B>DataResult</B> contente il risultato dell'esecuzione del comando
	 * @throws <B>EMFInternalError
	 *             </B> - Se si verifica qualche problema durante l'esecuzione del comando
	 */
	public DataResult execute(List parameters) throws EMFInternalError {
		return execute(parameters, true);
	} // public DataResult execute(List parameters) throws EMFInternalError

	public DataResult execute(List parameters, boolean scroll) throws EMFInternalError {
		Monitor monitor = MonitorFactory.start("model.data-access.stored-procedure." + _commandString.toLowerCase());
		try {
			this.closeInternal();
			if (scroll)
				_stmt = getInternalConnection().prepareCall(_commandString, ResultSet.TYPE_SCROLL_INSENSITIVE,
						ResultSet.CONCUR_READ_ONLY);
			else
				_stmt = getInternalConnection().prepareCall(_commandString, ResultSet.TYPE_FORWARD_ONLY,
						ResultSet.CONCUR_READ_ONLY);
			//
			// Registro i Parametri di Input
			//
			DataField parameter = null;
			if (inputParametersPositions != null) {
				Iterator inputParametersIterator = inputParametersPositions.iterator();
				while (inputParametersIterator.hasNext()) {
					int position = ((Integer) inputParametersIterator.next()).intValue();
					parameter = (DataField) parameters.get(position);
					((CallableStatement) _stmt).setObject(position + 1, parameter.getObjectValue(),
							parameter.getSqlType());
				} // while (inputParametersIterator.hasNext())
			} // if (inputParametersPositions != null)
				//
				// Registro i parametri di output
				//
			if (outputParametersPositions != null) {
				Iterator outputParametersIterator = outputParametersPositions.iterator();
				while (outputParametersIterator.hasNext()) {
					int position = ((Integer) outputParametersIterator.next()).intValue();
					parameter = (DataField) parameters.get(position);
					// Modifica Monica del 27/01/2004 - inizio
					if (parameter.getTypeName() != null) {
						// se è stato passato il typeNameal DataField significa
						// che il metodo registerOutParameter
						// da invocare necessita di tale informazione per
						// gestire parametri di output del tipo
						// STRUCT, DISTINCT, JAVA_OBJECT o REF
						((CallableStatement) _stmt).registerOutParameter(position + 1, parameter.getSqlType(),
								parameter.getTypeName());
					} // if(parameter.getTypeName()!= null)
					else {
						((CallableStatement) _stmt).registerOutParameter(position + 1, parameter.getSqlType());
					} // else
						// Modifica Monica del 27/01/2004 - fine
				} // while (outputParametersIterator.hasNext())
			} // if (outputParametersPositions != null)
			((CallableStatement) _stmt).executeUpdate();
			DataResultFactory dataResultFactory = new DefaultDataResultFactory();
			DataResultInterface globalStoredProcedureDataResult = null;
			if (outputParametersPositions == null)
				// Non ci sono parametri di ritorno
				return null;
			else {
				if (outputParametersPositions.size() == 1) {
					//
					// La store procedure ha solo il valore di ritorno ma non
					// parametri di output registrati nella firma
					//
					int position = ((Integer) outputParametersPositions.get(0)).intValue();
					Object returnedObject = ((CallableStatement) _stmt).getObject(position + 1);
					parameter = (DataField) parameters.get(position);
					// if (parameter.getSqlType() == Types.REF) {
					if (returnedObject instanceof ResultSet) {
						ResultSet resultSet = (ResultSet) returnedObject;
						if (resultSet.getType() == ResultSet.TYPE_FORWARD_ONLY)
							_logger.debug("StoredProcedureCommand::execute: tipo resultSet TYPE_FORWARD_ONLY");

						else if (resultSet.getType() == ResultSet.TYPE_SCROLL_INSENSITIVE)
							_logger.debug("StoredProcedureCommand::execute: tipo resultSet TYPE_SCROLL_INSENSITIVE");

						else if (resultSet.getType() == ResultSet.TYPE_SCROLL_SENSITIVE)
							_logger.debug("StoredProcedureCommand::execute: tipo resultSet TYPE_SCROLL_SENSITIVE");

						else
							_logger.debug(
									"StoredProcedureCommand::execute: tipo resultSet [" + resultSet.getType() + "]");

						if (resultSet.getType() == ResultSet.TYPE_FORWARD_ONLY)
							globalStoredProcedureDataResult = dataResultFactory.createScrollableDataResult(this,
									parameters, resultSet, false);
						else
							globalStoredProcedureDataResult = dataResultFactory.createScrollableDataResult(this,
									parameters, resultSet, true);
						return new DataResult(globalStoredProcedureDataResult,
								DataResultInterface.SCROLLABLE_DATA_RESULT);
					} // if (returnedObject instanceof ResultSet)
					else {
						globalStoredProcedureDataResult = dataResultFactory.createPunctualDataResult(this, parameters,
								_dataConnection.createDataField(parameter.getName(), parameter.getSqlType(),
										returnedObject));
					} // if (returnedObject instanceof ResultSet) else
					return new DataResult(globalStoredProcedureDataResult, DataResultInterface.PUNCTUAL_DATA_RESULT);
				} // if (outputParametersPositions.size() == 1)
				else {
					globalStoredProcedureDataResult = dataResultFactory.createCompositeDataResult(this, parameters);
					Iterator outputPositionsIterator = outputParametersPositions.iterator();
					int position;
					Object returnedObject = null;
					DataResultInterface partialDataResult = null;
					while (outputPositionsIterator.hasNext()) {
						position = ((Integer) outputPositionsIterator.next()).intValue();
						returnedObject = ((CallableStatement) _stmt).getObject(position + 1);
						parameter = (DataField) parameters.get(position);
						// if (parameter.getSqlType() == Types.REF) {
						if (returnedObject instanceof ResultSet) {
							ResultSet resultSet = (ResultSet) returnedObject;
							if (resultSet.getType() == ResultSet.TYPE_FORWARD_ONLY)
								_logger.debug("StoredProcedureCommand::execute: tipo resultSet TYPE_FORWARD_ONLY");

							else if (resultSet.getType() == ResultSet.TYPE_SCROLL_INSENSITIVE)
								_logger.debug(
										"StoredProcedureCommand::execute: tipo resultSet TYPE_SCROLL_INSENSITIVE");

							else if (resultSet.getType() == ResultSet.TYPE_SCROLL_SENSITIVE)
								_logger.debug("StoredProcedureCommand::execute: tipo resultSet TYPE_SCROLL_SENSITIVE");

							else
								_logger.debug("StoredProcedureCommand::execute: tipo resultSet [" + resultSet.getType()
										+ "]");

							if (resultSet.getType() == ResultSet.TYPE_FORWARD_ONLY)
								partialDataResult = dataResultFactory.createScrollableDataResult(this, parameters,
										resultSet, false);
							else
								partialDataResult = dataResultFactory.createScrollableDataResult(this, parameters,
										resultSet, true);
						} // if (returnedObject instanceof ResultSet)
						else {
							partialDataResult = dataResultFactory.createPunctualDataResult(this, parameters,
									_dataConnection.createDataField(parameter.getName(), parameter.getSqlType(),
											returnedObject));
						} // if (returnedObject instanceof ResultSet) else
						((CompositeDataResult) globalStoredProcedureDataResult).add(partialDataResult);
					} // while (outputPositionsIterator.hasNext())
					return new DataResult(globalStoredProcedureDataResult, DataResultInterface.COMPOSITE_DATA_RESULT);
				} // if (outputParametersPositions.size() == 1) else
			} // if (outputParametersPositions == null)
		} // try
		catch (SQLException sqle) {
			it.eng.sil.util.TraceWrapper.fatal(_logger, "StoredProcedureCommand::execute:", sqle);

			String method = "StoredProcedureCommand :: execute(parameters) :: ";
			throw Utils.generateInternalError(sqle, method);
		} // catch (SQLException sqle) try
		finally {
			monitor.stop();
		} // finally
	} // public DataResult execute(List parameters, boolean scroll) throws
		// EMFInternalError

	/**
	 * Questo metodo serve per informare il comando che tra i parametri passati in un'esecuzione con parametri, il
	 * parametro della posizione specificata è un parametro di input
	 * 
	 * @param int
	 *            position - la posizione del parametro di input
	 */
	public void setAsInputParameters(int position) {
		if (this.inputParametersPositions == null)
			inputParametersPositions = new ArrayList();
		inputParametersPositions.add(new Integer(position));
	} // public void setAsInputParameters(int position)

	/**
	 * Questo metodo serve per informare il comando che tra i parametri passati in un'esecuzione con parametri, il
	 * parametro della posizione specificata è un parametro di output
	 * 
	 * @param int
	 *            position - la posizione del parametro di output
	 */
	public void setAsOutputParameters(int position) {
		if (this.outputParametersPositions == null)
			outputParametersPositions = new ArrayList();
		outputParametersPositions.add(new Integer(position));
	} // public void setAsOutputParameters(int position)
} // public class StoredProcedureCommand extends SQLCommand
